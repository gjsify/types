
/*
 * Type Definitions for node-gtk (https://github.com/romgrk/node-gtk)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/gjsify/ts-for-gir
 */

import './node-gcr-3-import.d.ts';
    
/**
 * Gcr-3
 */

import type Gio from '@girs/node-gio-2.0';
import type GObject from '@girs/node-gobject-2.0';
import type GLib from '@girs/node-glib-2.0';
import type Gck from '@girs/node-gck-1';

export namespace Gcr {

/**
 * The status of a built certificate chain. Will be set to
 * %GCR_CERTIFICATE_CHAIN_UNKNOWN for certificate chains that have not been
 * built.
 */
enum CertificateChainStatus {
    /**
     * The certificate chain's status is unknown.
     * When a chain is not yet built it has this status. If a chain is modified after
     * being built, it has this status.
     */
    UNKNOWN,
    /**
     * A full chain could not be loaded. The
     * chain does not end with a self-signed certificate, a trusted anchor, or a
     * pinned certificate.
     */
    INCOMPLETE,
    /**
     * The certificate chain contains a revoked
     * or otherwise explicitly distrusted certificate. The entire chain should
     * be distrusted.
     */
    DISTRUSTED,
    /**
     * The chain ends with a self-signed
     * certificate. No trust anchor was found.
     */
    SELFSIGNED,
    /**
     * The chain represents a pinned certificate. A
     * pinned certificate is an exception which trusts a given certificate
     * explicitly for a purpose and communication with a certain peer.
     */
    PINNED,
    /**
     * The chain ends with an anchored
     * certificate. The anchored certificate is not necessarily self-signed.
     */
    ANCHORED,
}
/**
 * The format of a certificate request. Currently only PKCS#10 is supported.
 */
enum CertificateRequestFormat {
    /**
     * certificate request is in PKCS#10 format
     */
    CERTIFICATE_REQUEST_PKCS10,
}
/**
 * Values responding to error codes for parsing and serializing data.
 */
enum DataError {
    /**
     * Failed to parse or serialize the data
     */
    FAILURE,
    /**
     * The data was unrecognized or unsupported
     */
    UNRECOGNIZED,
    /**
     * The operation was cancelled
     */
    CANCELLED,
    /**
     * The data was encrypted or locked and could not be unlocked.
     */
    LOCKED,
}
/**
 * The various format identifiers.
 */
enum DataFormat {
    /**
     * Represents all the formats, when enabling or disabling
     */
    ALL,
    /**
     * Not a valid format
     */
    INVALID,
    /**
     * DER encoded private key
     */
    DER_PRIVATE_KEY,
    /**
     * DER encoded RSA private key
     */
    DER_PRIVATE_KEY_RSA,
    /**
     * DER encoded DSA private key
     */
    DER_PRIVATE_KEY_DSA,
    /**
     * DER encoded EC private key
     */
    DER_PRIVATE_KEY_EC,
    /**
     * DER encoded SubjectPublicKeyInfo
     */
    DER_SUBJECT_PUBLIC_KEY,
    /**
     * DER encoded X.509 certificate
     */
    DER_CERTIFICATE_X509,
    /**
     * DER encoded PKCS#7 container file which can contain certificates
     */
    DER_PKCS7,
    /**
     * DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8,
    /**
     * Unencrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_PLAIN,
    /**
     * Encrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_ENCRYPTED,
    /**
     * DER encoded PKCS#10 certificate request file
     */
    DER_PKCS10,
    /**
     * DER encoded SPKAC as generated by HTML5 keygen element
     */
    DER_SPKAC,
    /**
     * OpenSSL style SPKAC data
     */
    BASE64_SPKAC,
    /**
     * DER encoded PKCS#12 file which can contain certificates and/or keys
     */
    DER_PKCS12,
    /**
     * OpenSSH v1 or v2 public key
     */
    OPENSSH_PUBLIC,
    /**
     * OpenPGP key packet(s)
     */
    OPENPGP_PACKET,
    /**
     * OpenPGP public or private key armor encoded data
     */
    OPENPGP_ARMOR,
    /**
     * An OpenSSL style PEM file with unspecified contents
     */
    PEM,
    /**
     * An OpenSSL style PEM file with a private RSA key
     */
    PEM_PRIVATE_KEY_RSA,
    /**
     * An OpenSSL style PEM file with a private DSA key
     */
    PEM_PRIVATE_KEY_DSA,
    /**
     * An OpenSSL style PEM file with an X.509 certificate
     */
    PEM_CERTIFICATE_X509,
    /**
     * An OpenSSL style PEM file containing PKCS#7
     */
    PEM_PKCS7,
    /**
     * Unencrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_PLAIN,
    /**
     * Encrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_ENCRYPTED,
    /**
     * An OpenSSL style PEM file containing PKCS#12
     */
    PEM_PKCS12,
    /**
     * An OpenSSL style PEM file with a private key
     */
    PEM_PRIVATE_KEY,
    /**
     * An OpenSSL style PEM file containing PKCS#10
     */
    PEM_PKCS10,
    /**
     * An OpenSSL style PEM file with a private EC key
     */
    PEM_PRIVATE_KEY_EC,
    /**
     * An OpenSSL style PEM file containing a SubjectPublicKeyInfo
     */
    PEM_PUBLIC_KEY,
}
/**
 * Various replies returned by [method`Prompt`.confirm] and friends.
 */
enum PromptReply {
    /**
     * the prompt was cancelled
     */
    CANCEL,
    /**
     * the user replied with 'ok'
     */
    CONTINUE,
}
/**
 * No error returned by the #GcrSystemPrompt is suitable for display or
 * to the user.
 * 
 * If the system prompter can only show one prompt at a time, and there is
 * already a prompt being displayed, and the timeout waiting to open the
 * prompt expires, then %GCR_SYSTEM_PROMPT_IN_PROGRESS is returned.
 */
enum SystemPromptError {
    /**
     * another prompt is already in progress
     */
    SYSTEM_PROMPT_IN_PROGRESS,
}
/**
 * The mode for the system prompter. Most system prompters can only show
 * one prompt at a time and would use the %GCR_SYSTEM_PROMPTER_SINGLE mode.
 */
enum SystemPrompterMode {
    /**
     * only one prompt shown at a time
     */
    SINGLE,
    /**
     * more than one prompt shown at a time
     */
    MULTIPLE,
}
/**
 * Flags to be used with the gcr_certificate_chain_build() operation.
 * @bitfield 
 */
enum CertificateChainFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * If this flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11.
     */
    NO_LOOKUPS,
}
enum ColumnFlags {
    NONE,
    HIDDEN,
    SORTABLE,
}
const ICON_CERTIFICATE: string | null
const ICON_GNUPG: string | null
const ICON_HOME_DIRECTORY: string | null
const ICON_KEY: string | null
const ICON_KEY_PAIR: string | null
const ICON_PASSWORD: string | null
const ICON_SMART_CARD: string | null
/**
 * The major version number of the Gcr library.
 */
const MAJOR_VERSION: number
/**
 * The micro version number of the Gcr library.
 */
const MICRO_VERSION: number
/**
 * The minor version number of the Gcr library.
 */
const MINOR_VERSION: number
/**
 * The purpose used to verify the client certificate in a TLS connection.
 */
const PURPOSE_CLIENT_AUTH: string | null
/**
 * The purpose used to verify certificate used for the signature on signed code.
 */
const PURPOSE_CODE_SIGNING: string | null
/**
 * The purpose used to verify certificates that are used in email communication
 * such as S/MIME.
 */
const PURPOSE_EMAIL: string | null
/**
 * The purpose used to verify the server certificate in a TLS connection. This
 * is the most common purpose in use.
 */
const PURPOSE_SERVER_AUTH: string | null
/**
 * The current secret exchange protocol. Key agreement is done using DH with the
 * 1536 bit IKE parameter group. Keys are derived using SHA256 with HKDF. The
 * transport encryption is done with 128 bit AES.
 */
const SECRET_EXCHANGE_PROTOCOL_1: string | null
const UNLOCK_OPTION_ALWAYS: string | null
const UNLOCK_OPTION_IDLE: string | null
const UNLOCK_OPTION_SESSION: string | null
const UNLOCK_OPTION_TIMEOUT: string | null
/**
 * Compare one certificate against another. If the certificates are equal
 * then zero is returned. If one certificate is %NULL or not a certificate,
 * then a non-zero value is returned.
 * 
 * The return value is useful in a stable sort, but has no user logical
 * meaning.
 * @param first the certificate to compare
 * @param other the certificate to compare against
 * @returns zero if the certificates match, non-zero otherwise.
 */
function certificateCompare(first: Comparable | null, other: Comparable | null): number
function dataErrorGetDomain(): GLib.Quark
/**
 * Create a key fingerprint for a certificate, public key or private key.
 * Note that this is not a fingerprint of certificate data, which you would
 * use gcr_certificate_get_fingerprint() for.
 * @param attrs attributes for key or certificate
 * @param checksumType the type of fingerprint to create
 * @returns the          fingerprint or %NULL if the input was invalid.
 */
function fingerprintFromAttributes(attrs: Gck.Attributes, checksumType: GLib.ChecksumType): Uint8Array | null
/**
 * Create a key fingerprint for a DER encoded subjectPublicKeyInfo. The
 * fingerprint is created so that it will be identical for a key and its
 * corresponding certificate.
 * 
 * Note that in the case of certificates this is not a fingerprint of the
 * actual certificate data, but rather of the public key contained in a
 * certificate.
 * @param keyInfo DER encoded subjectPublicKeyInfo structure
 * @param checksumType the type of fingerprint to create
 * @returns the          fingerprint or %NULL if the input was invalid.
 */
function fingerprintFromSubjectPublicKeyInfo(keyInfo: Uint8Array, checksumType: GLib.ChecksumType): Uint8Array | null
/**
 * Get an appropriate icon for the token
 * @param tokenInfo the token info
 * @returns the icon
 */
function iconForToken(tokenInfo: Gck.TokenInfo): Gio.Icon
/**
 * Create a set of importers which can import this parsed item.
 * The parsed item is represented by the state of the GcrParser at the
 * time of calling this method.
 * @param parsed a parser with a parsed item to import
 * @returns a list of importers          which can import the parsed item, which should be freed with          g_object_unref(), or %NULL if no types of importers can be created
 */
function importerCreateForParsed(parsed: Parsed): Importer[]
/**
 * Queues an additional item to be imported in all compattible importers
 * in the set. The parsed item is represented by the state of the #GcrParser
 * at the time of calling this method.
 * 
 * If the parsed item is incompatible with an importer, then that the item
 * will not be queued on that importer.
 * @param importers a set of importers
 * @param parsed a parsed item
 * @returns a new set of importers          that queued the item, which should be freed with gck_list_unref_free()
 */
function importerQueueAndFilterForParsed(importers: Importer[], parsed: Parsed): Importer[]
/**
 * Register an importer to handle parsed items that match the given attributes.
 * 
 * If `attrs` are a floating reference, then it is consumed.
 * @param importerType the GType of the importer being registered
 * @param attrs the attributes that this importer is compatible with
 */
function importerRegister(importerType: GObject.GType, attrs: Gck.Attributes): void
/**
 * Register built-in PKCS#11 and GnuPG importers.
 */
function importerRegisterWellKnown(): void
/**
 * Disconnect the mock prompter
 */
function mockPrompterDisconnect(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects any prompt, and closes the prompt when it gets it.
 */
function mockPrompterExpectClose(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects a confirmation prompt, and then cancels that prompt.
 */
function mockPrompterExpectConfirmCancel(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects a password prompt, and then cancels that prompt.
 */
function mockPrompterExpectPasswordCancel(): void
/**
 * Get the delay in milliseconds before the mock prompter completes
 * an expected prompt.
 * @returns the delay
 */
function mockPrompterGetDelayMsec(): number
/**
 * Check if the mock prompter is expecting a response. This will be %TRUE
 * when one of the <literal>gcr_mock_prompter_expect_xxx<!-- -->()</literal>
 * functions have been used to queue an expected prompt, but that prompt
 * response has not be 'used' yet.
 * @returns whether expecting a prompt
 */
function mockPrompterIsExpecting(): boolean
/**
 * Check if the mock prompter is showing any prompts.
 * @returns whether prompting
 */
function mockPrompterIsPrompting(): boolean
/**
 * Set the delay in milliseconds before the mock prompter completes
 * an expected prompt.
 * @param delayMsec prompt response delay in milliseconds
 */
function mockPrompterSetDelayMsec(delayMsec: number): void
/**
 * Start the mock prompter. This is often used from the
 * <literal>setup<!-- -->()</literal> function of tests.
 * 
 * Starts the mock prompter in an additional thread. Use the returned DBus bus
 * name with gcr_system_prompt_open_for_prompter() to connect to this prompter.
 * @returns the bus name that the mock prompter is listening on
 */
function mockPrompterStart(): string | null
/**
 * Stop the mock prompter. This is often used from the
 * <literal>teardown<!-- -->()</literal> function of tests.
 */
function mockPrompterStop(): void
/**
 * Unreferences a parsed item which was referenced with gcr_parsed_ref()
 * @param parsed a parsed item
 */
function parsedUnref(parsed: any | null): void
/**
 * Add a #GckModule to the list of PKCS#11 modules that are used by the
 * GCR library.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param module a #GckModule
 */
function pkcs11AddModule(module: Gck.Module): void
/**
 * Initialize a PKCS#11 module and add it to the modules that are
 * used by the GCR library. Note that is an error to initialize the same
 * PKCS#11 module twice.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param modulePath the full file path of the PKCS#11 module
 * @param unused unused
 * @returns whether the module was sucessfully added.
 */
function pkcs11AddModuleFromFile(modulePath: string | null, unused: any | null): boolean
/**
 * List all the PKCS#11 modules that are used by the GCR library.
 * Each module is a [class`Gck`.Module] object.
 * 
 * An empty list of modules will be returned if [func`pkcs1`1_set_modules],
 * or [func`pkcs1`1_initialize] has not yet run.
 * 
 * When done with the list, free it with gck_list_unref_free().
 * @returns a newly allocated list          of #GckModule objects
 */
function pkcs11GetModules(): Gck.Module[]
/**
 * List all the PKCS#11 slots that are used by the GCR library for lookup
 * of trust assertions. Each slot is a [class`Gck`.Slot] object.
 * 
 * This will return an empty list if the [func`pkcs1`1_initialize] function has
 * not yet been called.
 * @returns a list of #GckSlot          objects to use for lookup of trust, or the empty list if not          initialized or no appropriate trust stores could be found.
 */
function pkcs11GetTrustLookupSlots(): Gck.Slot[]
/**
 * Get the PKCS#11 URIs that are used to identify which slots to use for
 * lookup trust assertions.
 * @returns the uri which identifies trust storage slot
 */
function pkcs11GetTrustLookupUris(): string[] | null
/**
 * Selects an appropriate PKCS#11 slot to store trust assertions. The slot
 * to use is normally configured automatically by the system.
 * 
 * This will only return a valid result after the [func`pkcs1`1_initialize]
 * method has been called.
 * 
 * When done with the #GckSlot, use g_object_unref() to release it.
 * @returns the #GckSlot to use for trust          assertions, or null if not initialized or no appropriate          trust store could be found.
 */
function pkcs11GetTrustStoreSlot(): Gck.Slot | null
/**
 * Get the PKCS#11 URI that is used to identify which slot to use for
 * storing trust storage.
 * @returns the uri which identifies trust storage slot
 */
function pkcs11GetTrustStoreUri(): string | null
/**
 * Asynchronously initialize the registered PKCS#11 modules.
 * @param cancellable optional cancellable used to cancel the operation
 * @returns whether the operation was successful or not.
 */
function pkcs11Initialize(cancellable: Gio.Cancellable | null): boolean
/**
 * Asynchronously initialize the registered PKCS#11 modules.
 * @param cancellable optional cancellable used to cancel the operation
 * @param callback callback which will be called when the operation completes
 */
function pkcs11InitializeAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Complete the asynchronous operation to initialize the registered PKCS#11
 * modules.
 * @param result the asynchronous result
 * @returns whether the operation was successful or not.
 */
function pkcs11InitializeFinish(result: Gio.AsyncResult): boolean
/**
 * Set the list of PKCS#11 modules that are used by the GCR library.
 * Each module in the list is a [class`Gck`.Module] object.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param modules a list of PKCS#11 modules
 */
function pkcs11SetModules(modules: Gck.Module[]): void
/**
 * Set the PKCS#11 URIs that are used to identify which slots to use for
 * lookup of trust assertions.
 * 
 * It is not normally necessary to call this function. The relevant
 * PKCS#11 slots are automatically configured by the GCR library.
 * @param pkcs11Uris the uris which identifies trust lookup slots
 */
function pkcs11SetTrustLookupUris(pkcs11Uris: string | null): void
/**
 * Set the PKCS#11 URI that is used to identify which slot to use for
 * storing trust assertions.
 * 
 * It is not normally necessary to call this function. The relevant
 * PKCS#11 slot is automatically configured by the GCR library.
 * @param pkcs11Uri the uri which identifies trust storage slot
 */
function pkcs11SetTrustStoreUri(pkcs11Uri: string | null): void
/**
 * Add a pinned `certificate` for connections to `peer` for `purpose`. A pinned
 * certificate overrides all other certificate verification and should be
 * used with care.
 * 
 * If the same pinned certificate already exists, then this operation
 * does not add another, and succeeds without error.
 * 
 * This call may block, see gcr_trust_add_pinned_certificate_async() for the
 * non-blocking version.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @returns %TRUE if the pinned certificate is recorded successfully
 */
function trustAddPinnedCertificate(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Add a pinned certificate for communication with `peer` for `purpose`. A pinned
 * certificate overrides all other certificate verification and should be used
 * with care.
 * 
 * If the same pinned certificate already exists, then this operation
 * does not add another, and succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_add_pinned_certificate_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trustAddPinnedCertificateAsync(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_add_pinned_certificate_async().
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the pinned certificate is recorded successfully
 */
function trustAddPinnedCertificateFinish(result: Gio.AsyncResult): boolean
/**
 * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
 * anchor is used to verify the signatures on other certificates when verifying
 * a certificate chain. Also known as a trusted certificate authority.
 * 
 * This call may block, see [func`Gcr`.trust_is_certificate_anchored_async] for
 * the non-blocking version.
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param cancellable a #GCancellable
 * @returns %TRUE if the certificate is a trust anchor
 */
function trustIsCertificateAnchored(certificate: Certificate, purpose: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
 * anchor is used to verify the signatures on other certificates when verifying
 * a certificate chain. Also known as a trusted certificate authority.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_is_certificate_anchored_finish() to get the result of the operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trustIsCertificateAnchoredAsync(certificate: Certificate, purpose: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_is_certificate_anchored_async().
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the certificate is a trust anchor
 */
function trustIsCertificateAnchoredFinish(result: Gio.AsyncResult): boolean
/**
 * Check if `certificate` is pinned for `purpose` to communicate with `peer`.
 * A pinned certificate overrides all other certificate verification.
 * 
 * This call may block, see gcr_trust_is_certificate_pinned_async() for the
 * non-blocking version.
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param peer the peer for this pinned
 * @param cancellable a #GCancellable
 * @returns %TRUE if the certificate is pinned for the host and purpose
 */
function trustIsCertificatePinned(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Check if `certificate` is pinned for `purpose` to communicate with `peer`. A
 * pinned certificate overrides all other certificate verification.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_is_certificate_pinned_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param peer the peer for this pinned
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trustIsCertificatePinnedAsync(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_is_certificate_pinned_async().
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the certificate is pinned.
 */
function trustIsCertificatePinnedFinish(result: Gio.AsyncResult): boolean
/**
 * Remove a pinned certificate for communication with `peer` for `purpose`.
 * 
 * If the same pinned certificate does not exist, or was already removed,
 * then this operation succeeds without error.
 * 
 * This call may block, see gcr_trust_remove_pinned_certificate_async() for the
 * non-blocking version.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @returns %TRUE if the pinned certificate no longer exists
 */
function trustRemovePinnedCertificate(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Remove a pinned certificate for communication with `peer` for `purpose`.
 * 
 * If the same pinned certificate does not exist, or was already removed,
 * then this operation succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_remove_pinned_certificate_finish() to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trustRemovePinnedCertificateAsync(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_remove_pinned_certificate_async().
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the pinned certificate no longer exists
 */
function trustRemovePinnedCertificateFinish(result: Gio.AsyncResult): boolean
/**
 * A function which is called by [class`FilterCollection]` in order to determine
 * whether an object should show through the filter or not.
 * @callback 
 * @param object object to filter
 * @returns %TRUE if an object should be included in the filtered collection
 */
interface FilterCollectionFunc {
    (object: GObject.Object): boolean
}
module Certificate {

    // Constructor properties interface

    interface ConstructorProperties extends Comparable.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface Certificate extends Comparable {

    // Own properties of Gcr-3.Gcr.Certificate

    /**
     * A readable description for this certificate
     */
    readonly description: string | null
    /**
     * The expiry date of the certificate
     */
    readonly expiry: GLib.Date
    /**
     * An icon representing the certificate
     */
    readonly icon: Gio.Icon
    /**
     * Common name part of the certificate issuer
     */
    readonly issuer: string | null
    /**
     * A readable label for this certificate.
     */
    readonly label: string | null
    /**
     * GLib markup to describe the certificate
     */
    readonly markup: string | null
    /**
     * Common name part of the certificate subject
     */
    readonly subject: string | null
    __gtype__: number

    // Owm methods of Gcr-3.Gcr.Certificate

    /**
     * Get the basic constraints for the certificate if present. If %FALSE is
     * returned then no basic constraints are present and the `is_ca` and
     * `path_len` arguments are not changed.
     * @returns whether basic constraints are present or not
     */
    getBasicConstraints(): [ /* returnType */ boolean, /* isCa */ boolean, /* pathLen */ number ]
    // Has conflict: getDerData(): Uint8Array
    /**
     * Get the expiry date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     * @returns An allocated expiry date of this certificate.
     */
    getExpiryDate(): GLib.Date
    /**
     * Calculate the fingerprint for this certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @param type the type of algorithm for the fingerprint.
     * @returns the raw binary fingerprint
     */
    getFingerprint(type: GLib.ChecksumType): Uint8Array
    /**
     * Calculate the fingerprint for this certificate, and return it
     * as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @param type the type of algorithm for the fingerprint.
     * @returns an allocated hex string which contains the fingerprint.
     */
    getFingerprintHex(type: GLib.ChecksumType): string | null
    /**
     * Get the issued date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     * @returns An allocated issued date of this certificate.
     */
    getIssuedDate(): GLib.Date
    /**
     * Get the common name of the issuer of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated issuer CN, or %NULL if no issuer CN present.
     */
    getIssuerCn(): string | null
    /**
     * Get the full issuer DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated issuer DN of the certificate.
     */
    getIssuerDn(): string | null
    /**
     * Get a name to represent the issuer of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     * @returns the allocated issuer name, or %NULL if no issuer name
     */
    getIssuerName(): string | null
    /**
     * Get a part of the DN of the issuer of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @param part a DN type string or OID.
     * @returns the allocated part of the issuer DN, or %NULL if no          such part is present
     */
    getIssuerPart(part: string | null): string | null
    /**
     * Get the raw DER data for the issuer DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     * @returns allocated memory containing          the raw issuer
     */
    getIssuerRaw(): Uint8Array
    /**
     * Get the key size in bits of the public key represented
     * by this certificate.
     * @returns The key size of the certificate.
     */
    getKeySize(): number
    /**
     * Calculate a GMarkup string for displaying this certificate.
     * @returns the markup string
     */
    getMarkupText(): string | null
    /**
     * Get the raw binary serial number of the certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @returns the raw binary serial number.
     */
    getSerialNumber(): Uint8Array
    /**
     * Get the serial number of the certificate as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @returns an allocated string containing the serial number as hex.
     */
    getSerialNumberHex(): string | null
    /**
     * Get the common name of the subject of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated subject CN, or %NULL if no subject CN present.
     */
    getSubjectCn(): string | null
    /**
     * Get the full subject DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated subject DN of the certificate.
     */
    getSubjectDn(): string | null
    /**
     * Get a name to represent the subject of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     * @returns the allocated subject name, or %NULL if no subject name
     */
    getSubjectName(): string | null
    /**
     * Get a part of the DN of the subject of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @param part a DN type string or OID.
     * @returns the allocated part of the subject DN, or %NULL if no          such part is present.
     */
    getSubjectPart(part: string | null): string | null
    /**
     * Get the raw DER data for the subject DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     * @returns allocated memory containing          the raw subject
     */
    getSubjectRaw(): Uint8Array
    /**
     * Check if `issuer` could be the issuer of this certificate. This is done by
     * comparing the relevant subject and issuer fields. No signature check is
     * done. Proper verification of certificates must be done via a crypto
     * library.
     * @param issuer a possible issuer #GcrCertificate
     * @returns whether @issuer could be the issuer of the certificate.
     */
    isIssuer(issuer: Certificate): boolean
    /**
     * Implementers of the #GcrCertificate mixin should call this function to notify
     * when the certificate has changed to emit notifications on the various
     * properties.
     */
    mixinEmitNotify(): void

    // Own virtual methods of Gcr-3.Gcr.Certificate

    /**
     * Gets the raw DER data for an X.509 certificate.
     * @virtual 
     * @returns raw DER data of the X.509 certificate
     */
    getDerData(): Uint8Array

    // Class property signals of Gcr-3.Gcr.Certificate

    connect(sigName: "notify::description", callback: (...args: any[]) => void): number
    on(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry", callback: (...args: any[]) => void): number
    on(sigName: "notify::expiry", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::expiry", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::expiry", ...args: any[]): void
    connect(sigName: "notify::icon", callback: (...args: any[]) => void): number
    on(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::issuer", callback: (...args: any[]) => void): number
    on(sigName: "notify::issuer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::issuer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::issuer", ...args: any[]): void
    connect(sigName: "notify::label", callback: (...args: any[]) => void): number
    on(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::markup", callback: (...args: any[]) => void): number
    on(sigName: "notify::markup", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::markup", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::markup", ...args: any[]): void
    connect(sigName: "notify::subject", callback: (...args: any[]) => void): number
    on(sigName: "notify::subject", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::subject", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::subject", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface that represents an X.509 certificate.
 * 
 * Objects can implement this interface to make a certificate usable with the
 * GCR library.
 * 
 * Various methods are available to parse out relevant bits of the certificate.
 * However no verification of the validity of a certificate is done here. Use
 * your favorite crypto library to do this.
 * 
 * You can use [class`SimpleCertificate]` to simply load a certificate for which
 * you already have the raw certificate data.
 * 
 * The #GcrCertificate interface has several properties that must be implemented.
 * You can use a mixin to implement these properties if desired. See the
 * gcr_certificate_mixin_class_init() and gcr_certificate_mixin_get_property()
 * functions.
 * 
 * All certificates are comparable. If implementing a #GcrCertificate, you can
 * use GCR_CERTIFICATE_MIXIN_IMPLEMENT_COMPARABLE() to implement the #GcrComparable
 * interface.
 * @interface 
 */
class Certificate extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Certificate

    static name: string

    // Constructors of Gcr-3.Gcr.Certificate

    constructor(config?: Certificate.ConstructorProperties) 
    _init(config?: Certificate.ConstructorProperties): void
    /**
     * Compare one certificate against another. If the certificates are equal
     * then zero is returned. If one certificate is %NULL or not a certificate,
     * then a non-zero value is returned.
     * 
     * The return value is useful in a stable sort, but has no user logical
     * meaning.
     * @param first the certificate to compare
     * @param other the certificate to compare against
     * @returns zero if the certificates match, non-zero otherwise.
     */
    static compare(first: Comparable | null, other: Comparable | null): number
}

module Collection {

    // Signal callback interfaces

    /**
     * Signal callback interface for `added`
     */
    interface AddedSignalCallback {
        (object: GObject.Object): void
    }

    /**
     * Signal callback interface for `removed`
     */
    interface RemovedSignalCallback {
        (object: GObject.Object): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Collection {

    // Own properties of Gcr-3.Gcr.Collection

    __gtype__: number

    // Owm methods of Gcr-3.Gcr.Collection

    // Has conflict: contains(object: GObject.Object): boolean
    /**
     * Emit the #GcrCollection::added signal for the given object. This function
     * is used by implementors of this interface.
     * @param object The object that was added
     */
    emitAdded(object: GObject.Object): void
    /**
     * Emit the #GcrCollection::removed signal for the given object. This function
     * is used by implementors of this interface.
     * @param object The object that was removed
     */
    emitRemoved(object: GObject.Object): void
    // Has conflict: getLength(): number
    // Has conflict: getObjects(): GObject.Object[]

    // Own virtual methods of Gcr-3.Gcr.Collection

    added(object: GObject.Object): void
    /**
     * Check whether the collection contains an object or not.
     * @virtual 
     * @param object object to check
     * @returns whether the collection contains this object
     */
    contains(object: GObject.Object): boolean
    /**
     * Get the number of objects in this collection.
     * @virtual 
     * @returns The number of objects.
     */
    getLength(): number
    /**
     * Get a list of the objects in this collection.
     * @virtual 
     * @returns a list of the objects          in this collection, which should be freed with g_list_free()
     */
    getObjects(): GObject.Object[]
    removed(object: GObject.Object): void

    // Own signals of Gcr-3.Gcr.Collection

    connect(sigName: "added", callback: Collection.AddedSignalCallback): number
    on(sigName: "added", callback: Collection.AddedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "added", callback: Collection.AddedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "added", callback: Collection.AddedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "added", ...args: any[]): void
    connect(sigName: "removed", callback: Collection.RemovedSignalCallback): number
    on(sigName: "removed", callback: Collection.RemovedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: Collection.RemovedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: Collection.RemovedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "removed", ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.Collection

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GcrCollection is used to group a set of objects.
 * 
 * This is an abstract interface which can be used to determine which objects
 * show up in a selector or other user interface element.
 * 
 * Use [ctor`SimpleCollection`.new] to create a concrete implementation of this
 * interface which you can add objects to.
 * @interface 
 */
class Collection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Collection

    static name: string

    // Constructors of Gcr-3.Gcr.Collection

    constructor(config?: Collection.ConstructorProperties) 
    _init(config?: Collection.ConstructorProperties): void
}

module Comparable {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Comparable {

    // Own properties of Gcr-3.Gcr.Comparable

    __gtype__: number

    // Owm methods of Gcr-3.Gcr.Comparable

    // Has conflict: compare(other: Comparable | null): number

    // Own virtual methods of Gcr-3.Gcr.Comparable

    /**
     * Compare whether two objects represent the same thing. The return value can
     * also be used to sort the objects.
     * @virtual 
     * @param other Another comparable object
     * @returns Zero if the two objects represent the same thing, non-zero if not.
     */
    compare(other: Comparable | null): number

    // Class property signals of Gcr-3.Gcr.Comparable

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface for comparing objects
 * @interface 
 */
class Comparable extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Comparable

    static name: string

    // Constructors of Gcr-3.Gcr.Comparable

    constructor(config?: Comparable.ConstructorProperties) 
    _init(config?: Comparable.ConstructorProperties): void
}

module ImportInteraction {

    // Constructor properties interface

    interface ConstructorProperties extends Gio.TlsInteraction.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface ImportInteraction extends Gio.TlsInteraction {

    // Own properties of Gcr-3.Gcr.ImportInteraction

    __gtype__: number

    // Owm methods of Gcr-3.Gcr.ImportInteraction

    // Has conflict: supplement(builder: Gck.Builder, cancellable: Gio.Cancellable | null): Gio.TlsInteractionResult
    // Has conflict: supplementAsync(builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    // Has conflict: supplementFinish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    // Has conflict: supplementPrep(builder: Gck.Builder): void

    // Own virtual methods of Gcr-3.Gcr.ImportInteraction

    /**
     * Supplement attributes before import. This means prompting the user for
     * things like labels and the like. The needed attributes will have been passed
     * to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes. If the user or
     * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
     */
    supplement(builder: Gck.Builder, cancellable: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Asynchronously supplement attributes before import. This means prompting the
     * user for things like labels and the like. The needed attributes will have
     * been passed to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes.
     * @virtual 
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @param callback called when the operation completes
     */
    supplementAsync(builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete operation to asynchronously supplement attributes before import.
     * 
     * If the user or cancellable cancels the operation the error should be set
     * with %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the asynchronous result
     * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
     */
    supplementFinish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /**
     * Prepare for supplementing the given attributes before import. This means
     * prompting the user for things like labels and the like. The attributes
     * will contain attributes for values that the importer needs, either empty
     * or prefilled with suggested values.
     * 
     * This method does not prompt the user, but rather just prepares the
     * interaction that these are the attributes that are needed.
     * @virtual 
     * @param builder attributes to supplement
     */
    supplementPrep(builder: Gck.Builder): void

    // Class property signals of Gcr-3.Gcr.ImportInteraction

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This is an interface implemented by a caller performing an import. It allows
 * the importer to ask the caller for further information about the import.
 * 
 * It must be implemented on a derived class of [class`Gio`.TlsInteraction]
 * @interface 
 */
class ImportInteraction extends GObject.Object {

    // Own properties of Gcr-3.Gcr.ImportInteraction

    static name: string

    // Constructors of Gcr-3.Gcr.ImportInteraction

    constructor(config?: ImportInteraction.ConstructorProperties) 
    _init(config?: ImportInteraction.ConstructorProperties): void
}

module Importer {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.Importer

        /**
         * The interaction for the importer.
         */
        interaction?: Gio.TlsInteraction | null
    }

}

interface Importer {

    // Own properties of Gcr-3.Gcr.Importer

    /**
     * The icon for the importer.
     */
    readonly icon: Gio.Icon
    /**
     * The interaction for the importer.
     */
    interaction: Gio.TlsInteraction
    /**
     * The label for the importer.
     */
    readonly label: string | null
    /**
     * The URI of the location imported to.
     */
    readonly uri: string | null
    __gtype__: number

    // Owm methods of Gcr-3.Gcr.Importer

    /**
     * Get the interaction used to prompt the user when needed by this
     * importer.
     * @returns the interaction or %NULL
     */
    getInteraction(): Gio.TlsInteraction | null
    /**
     * Import the queued items in the importer. This call will block
     * until the operation completes.
     * @param cancellable a #GCancellable, or %NULL
     * @returns whether the items were imported successfully or not
     */
    import(cancellable: Gio.Cancellable | null): boolean
    // Has conflict: importAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    // Has conflict: importFinish(result: Gio.AsyncResult): boolean
    // Has conflict: queueForParsed(parsed: Parsed): boolean
    /**
     * Set the interaction used to prompt the user when needed by this
     * importer.
     * @param interaction the interaction used by the importer
     */
    setInteraction(interaction: Gio.TlsInteraction): void

    // Own virtual methods of Gcr-3.Gcr.Importer

    /**
     * Import the queued items in the importer. This function returns immediately
     * and completes asynchronously.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @param callback called when the operation completes
     */
    importAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an asynchronous operation to import queued items.
     * @virtual 
     * @param result an asynchronous result
     * @returns whether the import succeeded or failed
     */
    importFinish(result: Gio.AsyncResult): boolean
    importSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Queues an additional item to be imported. The parsed item is represented
     * by the state of the [class`Parser]` at the time of calling this method.
     * 
     * If the parsed item is incompatible with the importer, then this will
     * fail and the item will not be queued.
     * @virtual 
     * @param parsed a parsed item to import
     * @returns whether the item was queued or not
     */
    queueForParsed(parsed: Parsed): boolean

    // Class property signals of Gcr-3.Gcr.Importer

    connect(sigName: "notify::icon", callback: (...args: any[]) => void): number
    on(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (...args: any[]) => void): number
    on(sigName: "notify::interaction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::interaction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::interaction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::label", callback: (...args: any[]) => void): number
    on(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::uri", callback: (...args: any[]) => void): number
    on(sigName: "notify::uri", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::uri", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::uri", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::uri", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface which allows importing of certificates and keys. Each importer
 * is registered with a set of PKCS#11 attributes to match stuff that it can
 * import.
 * 
 * An importer gets passed a [class`Parser]` and accesses the currently parsed
 * item. To create a set of importers that can import the currently parsed
 * item in a parser, use [func`Importer`.create_for_parsed]. The list of
 * importers returned has the parsed item queued for import.
 * 
 * To queue additional items with a importer use
 * [method`Importer`.queue_for_parsed].  In addition you can try and queue an
 * additional item with a set of importers using the
 * [func`Importer`.queue_and_filter_for_parsed].
 * 
 * To start the import, use [method`Importer`.import] or its async variants.
 * @interface 
 */
class Importer extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Importer

    static name: string

    // Constructors of Gcr-3.Gcr.Importer

    constructor(config?: Importer.ConstructorProperties) 
    _init(config?: Importer.ConstructorProperties): void
    /**
     * Create a set of importers which can import this parsed item.
     * The parsed item is represented by the state of the GcrParser at the
     * time of calling this method.
     * @param parsed a parser with a parsed item to import
     * @returns a list of importers          which can import the parsed item, which should be freed with          g_object_unref(), or %NULL if no types of importers can be created
     */
    static createForParsed(parsed: Parsed): Importer[]
    /**
     * Queues an additional item to be imported in all compattible importers
     * in the set. The parsed item is represented by the state of the #GcrParser
     * at the time of calling this method.
     * 
     * If the parsed item is incompatible with an importer, then that the item
     * will not be queued on that importer.
     * @param importers a set of importers
     * @param parsed a parsed item
     * @returns a new set of importers          that queued the item, which should be freed with gck_list_unref_free()
     */
    static queueAndFilterForParsed(importers: Importer[], parsed: Parsed): Importer[]
    /**
     * Register an importer to handle parsed items that match the given attributes.
     * 
     * If `attrs` are a floating reference, then it is consumed.
     * @param importerType the GType of the importer being registered
     * @param attrs the attributes that this importer is compatible with
     */
    static register(importerType: GObject.GType, attrs: Gck.Attributes): void
    /**
     * Register built-in PKCS#11 and GnuPG importers.
     */
    static registerWellKnown(): void
}

module Prompt {

    // Signal callback interfaces

    /**
     * Signal callback interface for `prompt-close`
     */
    interface PromptCloseSignalCallback {
        (): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.Prompt

        /**
         * The string handle of the caller's window.
         * 
         * The caller window indicates to the prompt which window is prompting the
         * user. The prompt may choose to ignore this information or use it in whatever
         * way it sees fit.
         * 
         * In X11, this will be a stringified version of the XWindow handle; in
         * Wayland this is the result of an export using the XDG foreign
         * protocol.
         */
        callerWindow?: string | null
        /**
         * The label for the cancel button in the prompt.
         */
        cancelLabel?: string | null
        /**
         * Whether the additional choice is chosen or not.
         * 
         * The additional choice would have been setup using #GcrPrompt:choice-label.
         */
        choiceChosen?: boolean | null
        /**
         * The label for the additional choice.
         * 
         * If this is a non-%NULL value then an additional boolean choice will be
         * displayed by the prompt allowing the user to select or deselect it.
         * 
         * If %NULL, then no additional choice is displayed.
         * 
         * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
         */
        choiceLabel?: string | null
        /**
         * The label for the continue button in the prompt.
         */
        continueLabel?: string | null
        /**
         * The detailed description of the prompt.
         * 
         * A prompt implementation may choose not to display this detailed description.
         * The prompt message should contain relevant information.
         */
        description?: string | null
        /**
         * The prompt message for the user.
         * 
         * A prompt implementation should always display this message.
         */
        message?: string | null
        /**
         * Whether the prompt will prompt for a new password.
         * 
         * This will cause the prompt implementation to ask the user to confirm the
         * password and/or display other relevant user interface for creating a new
         * password.
         */
        passwordNew?: boolean | null
        /**
         * The title of the prompt.
         * 
         * A prompt implementation may choose not to display the prompt title. The
         * #GcrPrompt:message should contain relevant information.
         */
        title?: string | null
        /**
         * A prompt warning displayed on the prompt, or %NULL for no warning.
         * 
         * This is a warning like "The password is incorrect." usually displayed to the
         * user about a previous 'unsuccessful' prompt.
         */
        warning?: string | null
    }

}

interface Prompt {

    // Own properties of Gcr-3.Gcr.Prompt

    /**
     * The string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * 
     * In X11, this will be a stringified version of the XWindow handle; in
     * Wayland this is the result of an export using the XDG foreign
     * protocol.
     */
    callerWindow: string | null
    /**
     * The label for the cancel button in the prompt.
     */
    cancelLabel: string | null
    /**
     * Whether the additional choice is chosen or not.
     * 
     * The additional choice would have been setup using #GcrPrompt:choice-label.
     */
    choiceChosen: boolean
    /**
     * The label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * If %NULL, then no additional choice is displayed.
     * 
     * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
     */
    choiceLabel: string | null
    /**
     * The label for the continue button in the prompt.
     */
    continueLabel: string | null
    /**
     * The detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    description: string | null
    /**
     * The prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    message: string | null
    /**
     * Whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    passwordNew: boolean
    /**
     * Indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    readonly passwordStrength: number
    /**
     * The title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * #GcrPrompt:message should contain relevant information.
     */
    title: string | null
    /**
     * A prompt warning displayed on the prompt, or %NULL for no warning.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     */
    warning: string | null
    __gtype__: number

    // Owm methods of Gcr-3.Gcr.Prompt

    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the reply from the prompt
     */
    confirm(cancellable: Gio.Cancellable | null): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    confirmAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param result asynchronous result passed to callback
     * @returns the reply from the prompt
     */
    confirmFinish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a `gtk_dialog_run()`. The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the reply from the prompt
     */
    confirmRun(cancellable: Gio.Cancellable | null): PromptReply
    /**
     * Get the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * @returns a newly allocated string containing the string          handle of the window.
     */
    getCallerWindow(): string | null
    /**
     * Get the label for the cancel button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     * @returns a newly allocated string containing the label
     */
    getCancelLabel(): string | null
    /**
     * Get whether the additional choice was chosen or not.
     * 
     * The additional choice would have been setup using
     * gcr_prompt_set_choice_label().
     * @returns whether chosen
     */
    getChoiceChosen(): boolean
    /**
     * Get the label for the additional choice.
     * 
     * This will be %NULL if no additional choice is being displayed.
     * @returns a newly allocated string containing the additional          choice or %NULL
     */
    getChoiceLabel(): string | null
    /**
     * Get the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     * @returns a newly allocated string containing the label
     */
    getContinueLabel(): string | null
    /**
     * Get the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     * @returns a newly allocated string containing the detailed          description of the prompt
     */
    getDescription(): string | null
    /**
     * Gets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     * @returns a newly allocated string containing the detailed          description of the prompt
     */
    getMessage(): string | null
    /**
     * Get whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     * @returns whether in new password mode or not
     */
    getPasswordNew(): boolean
    /**
     * Get indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     * @returns zero if the password is empty, greater than zero if not
     */
    getPasswordStrength(): number
    /**
     * Gets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     * @returns a newly allocated string containing the prompt          title.
     */
    getTitle(): string | null
    /**
     * Get a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     * @returns a newly allocated string containing the prompt          warning, or %NULL if no warning
     */
    getWarning(): string | null
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the password owned by the prompt, or %NULL
     */
    password(cancellable: Gio.Cancellable | null): string | null
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    passwordAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param result asynchronous result passed to callback
     * @returns the password owned by the prompt, or %NULL
     */
    passwordFinish(result: Gio.AsyncResult): string | null
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a gtk_dialog_run(). The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the password owned by the prompt, or %NULL
     */
    passwordRun(cancellable: Gio.Cancellable | null): string | null
    /**
     * Reset the contents and properties of the prompt.
     */
    reset(): void
    /**
     * Set the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * @param windowId the window id
     */
    setCallerWindow(windowId: string | null): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     * @param cancelLabel the label
     */
    setCancelLabel(cancelLabel: string | null): void
    /**
     * Set whether the additional choice is chosen or not.
     * 
     * The additional choice should be set up using gcr_prompt_set_choice_label().
     * @param chosen whether chosen
     */
    setChoiceChosen(chosen: boolean): void
    /**
     * Set the label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * The initial value of the choice can be set with the
     * gcr_prompt_set_choice_label() method.
     * 
     * If this is %NULL, then no additional choice is being displayed.
     * @param choiceLabel the additional choice or %NULL
     */
    setChoiceLabel(choiceLabel: string | null): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     * @param continueLabel the label
     */
    setContinueLabel(continueLabel: string | null): void
    /**
     * Set the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * Use gcr_prompt_set_message() to set a general message containing relevant
     * information.
     * @param description the detailed description
     */
    setDescription(description: string | null): void
    /**
     * Sets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     * @param message the prompt message
     */
    setMessage(message: string | null): void
    /**
     * Set whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     * @param newPassword whether in new password mode or not
     */
    setPasswordNew(newPassword: boolean): void
    /**
     * Sets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     * @param title the prompt title
     */
    setTitle(title: string | null): void
    /**
     * Set a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     * @param warning the warning or %NULL
     */
    setWarning(warning: string | null): void

    // Own virtual methods of Gcr-3.Gcr.Prompt

    promptClose(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     * @virtual 
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    promptConfirmAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @virtual 
     * @param result asynchronous result passed to callback
     * @returns the reply from the prompt
     */
    promptConfirmFinish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     * @virtual 
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    promptPasswordAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @virtual 
     * @param result asynchronous result passed to callback
     * @returns the password owned by the prompt, or %NULL
     */
    promptPasswordFinish(result: Gio.AsyncResult): string | null

    // Own signals of Gcr-3.Gcr.Prompt

    connect(sigName: "prompt-close", callback: Prompt.PromptCloseSignalCallback): number
    on(sigName: "prompt-close", callback: Prompt.PromptCloseSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "prompt-close", callback: Prompt.PromptCloseSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "prompt-close", callback: Prompt.PromptCloseSignalCallback): NodeJS.EventEmitter
    emit(sigName: "prompt-close", ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.Prompt

    connect(sigName: "notify::caller-window", callback: (...args: any[]) => void): number
    on(sigName: "notify::caller-window", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::caller-window", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::caller-window", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::caller-window", ...args: any[]): void
    connect(sigName: "notify::cancel-label", callback: (...args: any[]) => void): number
    on(sigName: "notify::cancel-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cancel-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cancel-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cancel-label", ...args: any[]): void
    connect(sigName: "notify::choice-chosen", callback: (...args: any[]) => void): number
    on(sigName: "notify::choice-chosen", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::choice-chosen", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::choice-chosen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::choice-chosen", ...args: any[]): void
    connect(sigName: "notify::choice-label", callback: (...args: any[]) => void): number
    on(sigName: "notify::choice-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::choice-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::choice-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::choice-label", ...args: any[]): void
    connect(sigName: "notify::continue-label", callback: (...args: any[]) => void): number
    on(sigName: "notify::continue-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::continue-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::continue-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::continue-label", ...args: any[]): void
    connect(sigName: "notify::description", callback: (...args: any[]) => void): number
    on(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::message", callback: (...args: any[]) => void): number
    on(sigName: "notify::message", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::message", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::message", ...args: any[]): void
    connect(sigName: "notify::password-new", callback: (...args: any[]) => void): number
    on(sigName: "notify::password-new", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::password-new", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::password-new", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::password-new", ...args: any[]): void
    connect(sigName: "notify::password-strength", callback: (...args: any[]) => void): number
    on(sigName: "notify::password-strength", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::password-strength", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::password-strength", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::password-strength", ...args: any[]): void
    connect(sigName: "notify::title", callback: (...args: any[]) => void): number
    on(sigName: "notify::title", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::title", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::title", ...args: any[]): void
    connect(sigName: "notify::warning", callback: (...args: any[]) => void): number
    on(sigName: "notify::warning", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::warning", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::warning", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::warning", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A prompt displayed to the user. It is an interface with various
 * implementations.
 * 
 * Various properties are set on the prompt, and then the prompt is displayed
 * the various prompt methods like [method`Prompt`.password_run].
 * 
 * A `GcrPrompt` may be used to display multiple related prompts. Most
 * implementions do not hide the window between display of multiple related
 * prompts, and the #GcrPrompt must be closed or destroyed in order to make
 * it go away. This allows the user to see that the prompts are related.
 * 
 * Use `GcrPromptDialog` (part of gcr-ui) to create an in-process GTK+ dialog
 * prompt. Use [class`SystemPrompt]` to create a system prompt in a prompter
 * process.
 * 
 * The prompt implementation will always display the [property`Prompt:`message]
 * property, but may choose not to display the [property`Prompt:`description] or
 * [property`Prompt:`title] properties.
 * @interface 
 */
class Prompt extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Prompt

    static name: string

    // Constructors of Gcr-3.Gcr.Prompt

    constructor(config?: Prompt.ConstructorProperties) 
    _init(config?: Prompt.ConstructorProperties): void
}

module CertificateChain {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface CertificateChain {

    // Own properties of Gcr-3.Gcr.CertificateChain

    /**
     * The length of the certificate chain.
     */
    readonly length: number
    __gtype__: number

    // Own fields of Gcr-3.Gcr.CertificateChain

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.CertificateChain

    /**
     * Add `certificate` to the chain. The order of certificates in the chain are
     * important. The first certificate should be the endpoint certificate, and
     * then come the signers (certificate authorities) each in turn. If a root
     * certificate authority is present, it should come last.
     * 
     * Adding a certificate an already built chain (see
     * gcr_certificate_chain_build()) resets the type of the certificate chain
     * to %GCR_CERTIFICATE_CHAIN_UNKNOWN
     * @param certificate a #GcrCertificate to add to the chain
     */
    add(certificate: Certificate): void
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This operation will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * This call will block, see gcr_certificate_chain_build_async() for the
     * asynchronous version.
     * @param purpose the purpose the certificate chain will be used for
     * @param peer the peer the certificate chain will be used with, or %NULL
     * @param flags chain completion flags
     * @param cancellable a #GCancellable or %NULL
     * @returns whether the operation completed successfully
     */
    build(purpose: string | null, peer: string | null, flags: CertificateChainFlags, cancellable: Gio.Cancellable | null): boolean
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * gcr_certificate_chain_build_finish() to get the result of the operation.
     * @param purpose the purpose the certificate chain will be used for
     * @param peer the peer the certificate chain will be used with, or %NULL
     * @param flags chain completion flags
     * @param cancellable a #GCancellable or %NULL
     * @param callback this will be called when the operation completes.
     */
    buildAsync(purpose: string | null, peer: string | null, flags: CertificateChainFlags, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_certificate_chain_build_async().
     * @param result the #GAsyncResult passed to the callback
     * @returns whether the operation succeeded
     */
    buildFinish(result: Gio.AsyncResult): boolean
    /**
     * If the certificate chain has been built and is of status
     * %GCR_CERTIFICATE_CHAIN_ANCHORED, then this will return the anchor
     * certificate that was found. This is not necessarily a root certificate
     * authority. If an intermediate certificate authority in the chain was
     * found to be anchored, then that certificate will be returned.
     * 
     * If an anchor is returned it does not mean that the certificate chain has
     * been verified, but merely that an anchor has been found.
     * @returns the anchor certificate, or %NULL if not anchored.
     */
    getAnchor(): Certificate
    /**
     * Get a certificate in the chain. It is an error to call this function
     * with an invalid index.
     * @param index index of the certificate to get
     * @returns the certificate
     */
    getCertificate(index: number): Certificate
    /**
     * Get the endpoint certificate in the chain. This is always the first
     * certificate in the chain. The endpoint certificate cannot be anchored.
     * @returns the endpoint certificate, or %NULL if the chain          is empty
     */
    getEndpoint(): Certificate
    /**
     * Get the length of the certificate chain.
     * @returns the length of the certificate chain
     */
    getLength(): number
    /**
     * Get the status of a certificate chain. If the certificate chain has not
     * been built, then the status will be %GCR_CERTIFICATE_CHAIN_UNKNOWN.
     * 
     * A status of %GCR_CERTIFICATE_CHAIN_ANCHORED does not mean that the
     * certificate chain has been verified, but merely that an anchor has been
     * found.
     * @returns the status of the certificate chain.
     */
    getStatus(): CertificateChainStatus

    // Class property signals of Gcr-3.Gcr.CertificateChain

    connect(sigName: "notify::length", callback: (...args: any[]) => void): number
    on(sigName: "notify::length", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::length", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::length", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Represents a chain of certificates, normally used to
 * validate the trust in a certificate. An X.509 certificate chain has one
 * endpoint certificate (the one for which trust is being verified) and then
 * in turn the certificate that issued each previous certificate in the chain.
 * 
 * This functionality is for building of certificate chains not for validating
 * them. Use your favorite crypto library to validate trust in a certificate
 * chain once its built.
 * 
 * The order of certificates in the chain should be first the endpoint
 * certificates and then the signing certificates.
 * 
 * Create a new certificate chain with [ctor`CertificateChain`.new] and then
 * add the certificates with [method`CertificateChain`.add].
 * 
 * You can then use [method`CertificateChain`.build] to build the remainder of
 * the chain. This will lookup missing certificates in PKCS#11 modules and
 * also check that each certificate in the chain is the signer of the previous
 * one. If a trust anchor, pinned certificate, or self-signed certificate is
 * found, then the chain is considered built. Any extra certificates are
 * removed from the chain.
 * 
 * Once the certificate chain has been built, you can access its status
 * through [method`CertificateChain`.get_status]. The status signifies whether
 * the chain is anchored on a trust root, self-signed, incomplete etc. See
 * [enum`CertificateChainStatus]` for information on the various statuses.
 * 
 * It's important to understand that the building of a certificate chain is
 * merely the first step towards verifying trust in a certificate.
 * @class 
 */
class CertificateChain extends GObject.Object {

    // Own properties of Gcr-3.Gcr.CertificateChain

    static name: string

    // Constructors of Gcr-3.Gcr.CertificateChain

    constructor(config?: CertificateChain.ConstructorProperties) 
    /**
     * Create a new #GcrCertificateChain.
     * @constructor 
     * @returns a newly allocated certificate chain
     */
    constructor() 
    /**
     * Create a new #GcrCertificateChain.
     * @constructor 
     * @returns a newly allocated certificate chain
     */
    static new(): CertificateChain
    _init(config?: CertificateChain.ConstructorProperties): void
}

module CertificateRequest {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.CertificateRequest

        /**
         * The private key that this certificate request is for.
         */
        privateKey?: Gck.Object | null
    }

}

interface CertificateRequest {

    // Own properties of Gcr-3.Gcr.CertificateRequest

    /**
     * The private key that this certificate request is for.
     */
    readonly privateKey: Gck.Object
    __gtype__: number

    // Owm methods of Gcr-3.Gcr.CertificateRequest

    /**
     * Complete and sign a certificate request, so that it can be encoded
     * and sent to a certificate authority.
     * 
     * This call may block as it signs the request using the private key.
     * @param cancellable a cancellation object
     * @returns whether certificate request was successfully completed or not
     */
    complete(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously complete and sign a certificate request, so that it can
     * be encoded and sent to a certificate authority.
     * 
     * This call will return immediately and complete later.
     * @param cancellable a cancellation object
     * @param callback called when the operation completes
     */
    completeAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finish an asynchronous operation to complete and sign a certificate
     * request.
     * @param result result of the asynchronous operation
     * @returns whether certificate request was successfully completed or not
     */
    completeFinish(result: Gio.AsyncResult): boolean
    /**
     * Encode the certificate request. It must have been completed with
     * [method`CertificateRequest`.complete] or
     * [method`CertificateRequest`.complete_async].
     * 
     * If `textual` is %FALSE, the output is a DER encoded certificate request.
     * 
     * If `textual` is %TRUE, the output is encoded as text. For PKCS#10 requests
     * this is done using the OpenSSL style PEM encoding.
     * @param textual whether to encode output as text
     * @returns the encoded certificate request
     */
    encode(textual: boolean): Uint8Array
    /**
     * Get the format of this certificate request.
     * @returns the format
     */
    getFormat(): CertificateRequestFormat
    /**
     * Get the private key this certificate request is for.
     * @returns the private key,
     */
    getPrivateKey(): Gck.Object
    /**
     * Set the common name encoded in the certificate request.
     * @param cn common name to set on the request
     */
    setCn(cn: string | null): void

    // Class property signals of Gcr-3.Gcr.CertificateRequest

    connect(sigName: "notify::private-key", callback: (...args: any[]) => void): number
    on(sigName: "notify::private-key", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::private-key", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::private-key", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::private-key", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An object that allows creation of certificate requests. A certificate
 * request is sent to a certificate authority to request an X.509 certificate.
 * 
 * Use [func`CertificateRequest`.prepare] to create a blank certificate
 * request for a given private key. Set the common name on the certificate
 * request with [method`CertificateRequest`.set_cn], and then sign the request
 * with [method`CertificateRequest`.complete_async].
 * @class 
 */
class CertificateRequest extends GObject.Object {

    // Own properties of Gcr-3.Gcr.CertificateRequest

    static name: string

    // Constructors of Gcr-3.Gcr.CertificateRequest

    constructor(config?: CertificateRequest.ConstructorProperties) 
    _init(config?: CertificateRequest.ConstructorProperties): void
    /**
     * Check whether [class`CertificateRequest]` is capable of creating a request
     * for the given `private_key`.
     * @param privateKey a private key
     * @param cancellable cancellation object
     * @returns whether a request can be created
     */
    static capable(privateKey: Gck.Object, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously check whether [class`CertificateRequest]` is capable of
     * creating a request for the given `private_key`.
     * @param privateKey a private key
     * @param cancellable cancellation object
     * @param callback will be called when the operation completes
     */
    static capableAsync(privateKey: Gck.Object, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Get the result for asynchronously check whether [class`CertificateRequest]` is
     * capable of creating a request for the given `private_key`.
     * @param result asynchronous result
     * @returns whether a request can be created
     */
    static capableFinish(result: Gio.AsyncResult): boolean
    /**
     * Create a new certificate request, in the given format for the private key.
     * @param format the format for the certificate request
     * @param privateKey the private key the the certificate is being requested for
     * @returns a new #GcrCertificate request
     */
    static prepare(format: CertificateRequestFormat, privateKey: Gck.Object): CertificateRequest
}

module FilterCollection {

    // Constructor properties interface

    interface ConstructorProperties extends Collection.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.FilterCollection

        underlying?: Collection | null
    }

}

interface FilterCollection extends Collection {

    // Own properties of Gcr-3.Gcr.FilterCollection

    readonly underlying: Collection
    __gtype__: number

    // Own fields of Gcr-3.Gcr.FilterCollection

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.FilterCollection

    /**
     * Get the collection that is being filtered by this filter collection.
     * @returns the underlying collection
     */
    getUnderlying(): Collection
    /**
     * Refilter all objects in the underlying collection. Call this function if
     * the filter callback function changes its filtering criteria.
     */
    refilter(): void
    /**
     * Set the callback used to filter the objects in the underlying collection.
     * The callback should return %TRUE if an object should appear in the
     * filtered collection.
     * 
     * If a %NULL callback is set, then all underlynig objects will appear in the
     * filtered collection.
     * 
     * This will refilter the collection.
     * @param callback function to call for each object
     */
    setCallback(callback: FilterCollectionFunc | null): void

    // Class property signals of Gcr-3.Gcr.FilterCollection

    connect(sigName: "notify::underlying", callback: (...args: any[]) => void): number
    on(sigName: "notify::underlying", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::underlying", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::underlying", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::underlying", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A collection which filters a [iface`Collection]`.
 * 
 * An implementation of [iface`Collection]` which filters objects from another
 * underlying collection. Use [ctor`FilterCollection`.new_with_callback]
 * to create a new filter collection.
 * 
 * The callback will determine the criteria for whether an object shows through
 * the filter or not.
 * @class 
 */
class FilterCollection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.FilterCollection

    static name: string

    // Constructors of Gcr-3.Gcr.FilterCollection

    constructor(config?: FilterCollection.ConstructorProperties) 
    /**
     * Create a new #GcrFilterCollection.
     * 
     * The callback should return %TRUE if an object should appear in the
     * filtered collection.
     * 
     * If a %NULL callback is set, then all underlynig objects will appear in the
     * filtered collection.
     * @constructor 
     * @param underlying the underlying collection
     * @param callback function to call for each object
     * @returns a newly allocated          filtered collection, which should be freed with g_object_unref()
     */
    static newWithCallback(underlying: Collection, callback: FilterCollectionFunc | null): FilterCollection
    _init(config?: FilterCollection.ConstructorProperties): void
}

module Parser {

    // Signal callback interfaces

    /**
     * Signal callback interface for `authenticate`
     */
    interface AuthenticateSignalCallback {
        (count: number): boolean
    }

    /**
     * Signal callback interface for `parsed`
     */
    interface ParsedSignalCallback {
        (): void
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

interface Parser {

    // Own properties of Gcr-3.Gcr.Parser

    /**
     * Get the attributes that make up the currently parsed item. This is
     * generally only valid during a #GcrParser::parsed signal.
     */
    readonly parsedAttributes: Gck.Attributes
    /**
     * The description of the type of the currently parsed item. This is generally
     * only valid during a #GcrParser::parsed signal.
     */
    readonly parsedDescription: string | null
    /**
     * The label of the currently parsed item. This is generally
     * only valid during a #GcrParser::parsed signal.
     */
    readonly parsedLabel: string | null
    __gtype__: number

    // Own fields of Gcr-3.Gcr.Parser

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.Parser

    /**
     * Add a password to the set of passwords to try when parsing locked or encrypted
     * items. This is usually called from the #GcrParser::authenticate signal.
     * @param password a password to try
     */
    addPassword(password: string | null): void
    /**
     * Disable parsing of the given format. Use %GCR_FORMAT_ALL to disable all the formats.
     * @param format The format identifier
     */
    formatDisable(format: DataFormat): void
    /**
     * Enable parsing of the given format. Use %GCR_FORMAT_ALL to enable all the formats.
     * @param format The format identifier
     */
    formatEnable(format: DataFormat): void
    /**
     * Check whether the given format is supported by the parser.
     * @param format The format identifier
     * @returns Whether the format is supported.
     */
    formatSupported(format: DataFormat): boolean
    /**
     * Get the filename of the parser item.
     * @returns the filename set on the parser, or %NULL
     */
    getFilename(): string | null
    /**
     * Get the currently parsed item
     * @returns the currently parsed item
     */
    getParsed(): Parsed
    /**
     * Get the attributes which make up the currently parsed item. This is generally
     * only valid during the #GcrParser::parsed signal.
     * @returns the attributes for the current item,          which are owned by the parser and should not be freed
     */
    getParsedAttributes(): Gck.Attributes | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the #GcrParser::parsed signal.
     * @returns the raw data          block of the currently parsed item; the value is owned by the parser          and should not be freed
     */
    getParsedBlock(): Uint8Array | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the #GcrParser::parsed signal.
     * @returns the raw data block of the currently parsed item
     */
    getParsedBytes(): any
    /**
     * Get a description for the type of the currently parsed item. This is generally
     * only valid during the #GcrParser::parsed signal.
     * @returns the description for the current item; this is owned by          the parser and should not be freed
     */
    getParsedDescription(): string | null
    /**
     * Get the format of the raw data block that represents this parsed object.
     * This corresponds with the data returned from gcr_parser_get_parsed_block().
     * 
     * This is only valid during the #GcrParser::parsed signal.
     * @returns the data format of the currently parsed item
     */
    getParsedFormat(): DataFormat
    /**
     * Get the label of the currently parsed item. This is generally only valid
     * during the #GcrParser::parsed signal.
     * @returns the label of the currently parsed item. The value is          owned by the parser and should not be freed.
     */
    getParsedLabel(): string | null
    /**
     * Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * @param data the data to parse
     * @returns Whether the data was parsed successfully or not.
     */
    parseBytes(data: any): boolean
    /**
     * Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * 
     * A copy of the data will be made. Use gcr_parser_parse_bytes() to avoid this.
     * @param data the data to parse
     * @returns Whether the data was parsed successfully or not.
     */
    parseData(data: Uint8Array): boolean
    /**
     * Parse items from the data in a #GInputStream. This function may block while
     * reading from the input stream. Use gcr_parser_parse_stream_async() for
     * a non-blocking variant.
     * 
     * The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * @param input The input stream
     * @param cancellable An optional cancellation object
     * @returns Whether the parsing completed successfully or not.
     */
    parseStream(input: Gio.InputStream, cancellable: Gio.Cancellable | null): boolean
    /**
     * Parse items from the data in a #GInputStream. This function completes
     * asyncronously and doesn't block.
     * 
     * The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * @param input The input stream
     * @param cancellable An optional cancellation object
     * @param callback Called when the operation result is ready.
     */
    parseStreamAsync(input: Gio.InputStream, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to parse a stream.
     * @param result The operation result
     * @returns Whether the parsing completed successfully or not.
     */
    parseStreamFinish(result: Gio.AsyncResult): boolean
    /**
     * Sets the filename of the parser item.
     * @param filename a string of the filename of the parser item
     */
    setFilename(filename: string | null): void

    // Own virtual methods of Gcr-3.Gcr.Parser

    authenticate(count: number): boolean
    parsed(): void

    // Own signals of Gcr-3.Gcr.Parser

    connect(sigName: "authenticate", callback: Parser.AuthenticateSignalCallback): number
    on(sigName: "authenticate", callback: Parser.AuthenticateSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "authenticate", callback: Parser.AuthenticateSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "authenticate", callback: Parser.AuthenticateSignalCallback): NodeJS.EventEmitter
    emit(sigName: "authenticate", ...args: any[]): void
    connect(sigName: "parsed", callback: Parser.ParsedSignalCallback): number
    on(sigName: "parsed", callback: Parser.ParsedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parsed", callback: Parser.ParsedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parsed", callback: Parser.ParsedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "parsed", ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.Parser

    connect(sigName: "notify::parsed-attributes", callback: (...args: any[]) => void): number
    on(sigName: "notify::parsed-attributes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::parsed-attributes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::parsed-attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::parsed-attributes", ...args: any[]): void
    connect(sigName: "notify::parsed-description", callback: (...args: any[]) => void): number
    on(sigName: "notify::parsed-description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::parsed-description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::parsed-description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::parsed-description", ...args: any[]): void
    connect(sigName: "notify::parsed-label", callback: (...args: any[]) => void): number
    on(sigName: "notify::parsed-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::parsed-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::parsed-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::parsed-label", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A parser for parsing various types of files or data.
 * 
 * A `GcrParser` can parse various certificate and key files such as OpenSSL
 * PEM files, DER encoded certifictes, PKCS#8 keys and so on. Each various
 * format is identified by a value in the [enum`DataFormat]` enumeration.
 * 
 * In order to parse data, a new parser is created with gcr_parser_new() and
 * then the [signal`Parser:`:authenticate] and [signal`Parser:`:parsed] signals
 * should be connected to. Data is then fed to the parser via
 * [method`Parser`.parse_data] or [method`Parser`.parse_stream].
 * 
 * During the [signal`Parser:`:parsed] signal the attributes that make up the
 * currently parsed item can be retrieved using the
 * [method`Parser`.get_parsed_attributes] function.
 * @class 
 */
class Parser extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Parser

    static name: string

    // Constructors of Gcr-3.Gcr.Parser

    constructor(config?: Parser.ConstructorProperties) 
    /**
     * Create a new #GcrParser
     * @constructor 
     * @returns a newly allocated #GcrParser
     */
    constructor() 
    /**
     * Create a new #GcrParser
     * @constructor 
     * @returns a newly allocated #GcrParser
     */
    static new(): Parser
    _init(config?: Parser.ConstructorProperties): void
}

module Pkcs11Certificate {

    // Constructor properties interface

    interface ConstructorProperties extends Certificate.ConstructorProperties, Comparable.ConstructorProperties, Gck.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.Pkcs11Certificate

        /**
         * Automatically loaded attributes for this certificate.
         */
        attributes?: Gck.Attributes | null
    }

}

interface Pkcs11Certificate extends Certificate, Comparable {

    // Own properties of Gcr-3.Gcr.Pkcs11Certificate

    /**
     * Automatically loaded attributes for this certificate.
     */
    readonly attributes: Gck.Attributes
    __gtype__: number

    // Own fields of Gcr-3.Gcr.Pkcs11Certificate

    parent: Gck.Object & GObject.Object

    // Owm methods of Gcr-3.Gcr.Pkcs11Certificate

    /**
     * Access the automatically loaded attributes for this certificate.
     * @returns the certificate attributes
     */
    getAttributes(): Gck.Attributes

    // Conflicting methods

    /**
     * Get the data for the specified attribute from the object. For convenience
     * the returned data has a null terminator.
     * 
     * This call may block for an indefinite period.
     * @param attrType The attribute to get data for.
     * @param cancellable A #GCancellable or %NULL
     * @returns the resulting PKCS#11          attribute data, or %NULL if an error occurred
     */
    getData(attrType: number, cancellable: Gio.Cancellable | null): Uint8Array

    // Overloads of getData

    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    getData(key: string | null): any | null
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    getData(key: string | null): any | null

    // Class property signals of Gcr-3.Gcr.Pkcs11Certificate

    connect(sigName: "notify::attributes", callback: (...args: any[]) => void): number
    on(sigName: "notify::attributes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::attributes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::attributes", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::handle", callback: (...args: any[]) => void): number
    on(sigName: "notify::handle", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::handle", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::handle", ...args: any[]): void
    connect(sigName: "notify::module", callback: (...args: any[]) => void): number
    on(sigName: "notify::module", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::module", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::module", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::module", ...args: any[]): void
    connect(sigName: "notify::session", callback: (...args: any[]) => void): number
    on(sigName: "notify::session", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session", ...args: any[]): void
    connect(sigName: "notify::description", callback: (...args: any[]) => void): number
    on(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry", callback: (...args: any[]) => void): number
    on(sigName: "notify::expiry", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::expiry", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::expiry", ...args: any[]): void
    connect(sigName: "notify::icon", callback: (...args: any[]) => void): number
    on(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::issuer", callback: (...args: any[]) => void): number
    on(sigName: "notify::issuer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::issuer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::issuer", ...args: any[]): void
    connect(sigName: "notify::label", callback: (...args: any[]) => void): number
    on(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::markup", callback: (...args: any[]) => void): number
    on(sigName: "notify::markup", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::markup", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::markup", ...args: any[]): void
    connect(sigName: "notify::subject", callback: (...args: any[]) => void): number
    on(sigName: "notify::subject", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::subject", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::subject", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A certificate loaded from a PKCS#11 storage.
 * It is also a valid [class`Gck`.Object] and can be used as such.
 * 
 * Use gcr_pkcs11_certificate_lookup_issuer() to lookup the issuer of a given
 * certificate in the PKCS#11 store.
 * 
 * Various common PKCS#11 certificate attributes are automatically loaded and
 * are available via gcr_pkcs11_certificate_get_attributes().
 * @class 
 */
class Pkcs11Certificate extends Gck.Object {

    // Own properties of Gcr-3.Gcr.Pkcs11Certificate

    static name: string

    // Constructors of Gcr-3.Gcr.Pkcs11Certificate

    constructor(config?: Pkcs11Certificate.ConstructorProperties) 
    _init(config?: Pkcs11Certificate.ConstructorProperties): void
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * This call may block, see gcr_pkcs11_certificate_lookup_issuer() for the
     * non-blocking version.
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     * @param certificate a #GcrCertificate
     * @param cancellable a #GCancellable
     * @returns a new #GcrPkcs11Certificate, or %NULL
     */
    static lookupIssuer(certificate: Certificate, cancellable: Gio.Cancellable | null): Certificate
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * When the operation is finished, callback will be called. You can then call
     * gcr_pkcs11_certificate_lookup_issuer_finish() to get the result of the
     * operation.
     * @param certificate a #GcrCertificate
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    static lookupIssuerAsync(certificate: Certificate, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_pkcs11_certificate_lookup_issuer_async().
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     * @param result the #GAsyncResult passed to the callback
     * @returns a new #GcrPkcs11Certificate, or %NULL
     */
    static lookupIssuerFinish(result: Gio.AsyncResult): Certificate
}

module SecretExchange {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.SecretExchange

        /**
         * The protocol being used for the exchange.
         * 
         * Will be %NULL if no protocol was specified when creating this object,
         * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
         * have not been called successfully.
         */
        protocol?: string | null
    }

}

interface SecretExchange {

    // Own properties of Gcr-3.Gcr.SecretExchange

    /**
     * The protocol being used for the exchange.
     * 
     * Will be %NULL if no protocol was specified when creating this object,
     * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
     * have not been called successfully.
     */
    readonly protocol: string | null
    __gtype__: number

    // Owm methods of Gcr-3.Gcr.SecretExchange

    /**
     * Begin the secret exchange. The resulting string should be sent to the other
     * side of the exchange. The other side should use [method`SecretExchange`.receive]
     * to process the string.
     * @returns A newly allocated string to be sent to the other     side of the secret exchange
     */
    begin(): string | null
    /**
     * Will return %NULL if no protocol was specified, and either
     * [method`SecretExchange`.begin] or [method`SecretExchange`.receive] have not
     * been called successfully.
     * @returns the protocol or %NULL
     */
    getProtocol(): string | null
    /**
     * Returns the last secret received. If no secret has yet been received this
     * will return %NULL. The string is owned by the #GcrSecretExchange object
     * and will be valid until the next time that gcr_secret_exchange_receive()
     * is called on this object, or the object is destroyed.
     * 
     * Depending on the secret passed into the other side of the secret exchange,
     * the result may be a binary string. It does however have a null terminator,
     * so if you're certain that it is does not contain arbitrary binary data,
     * it can be used as a string.
     * @returns the last secret received
     */
    getSecret(): string[]
    /**
     * Receive a string from the other side of secret exchange. This string will
     * have been created by [method`SecretExchange`.begin] or
     * [method`SecretExchange`.send].
     * 
     * After this call completes successfully the value returned from
     * gcr_secret_exchange_get_secret() will have changed.
     * @param exchange the string received
     * @returns whether the string was successfully parsed and received
     */
    receive(exchange: string | null): boolean
    /**
     * Send a reply to the other side of the secret exchange, optionally sending a
     * secret.
     * 
     * [method`SecretExchange`.receive] must have been successfully called at least
     * once on this object. In other words this object must have received data
     * from the other side of the secret exchange, before we can send a secret.
     * @param secret optionally, a secret to send to the other side
     * @param secretLen length of `secret,` or -1 if null terminated
     * @returns a newly allocated string to be sent to the other     side of the secret exchange
     */
    send(secret: string | null, secretLen: number): string | null

    // Own virtual methods of Gcr-3.Gcr.SecretExchange

    deriveTransportKey(peer: number, nPeer: number): boolean
    generateExchangeKey(scheme: string | null, publicKey: number, nPublicKey: number): boolean

    // Class property signals of Gcr-3.Gcr.SecretExchange

    connect(sigName: "notify::protocol", callback: (...args: any[]) => void): number
    on(sigName: "notify::protocol", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::protocol", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::protocol", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::protocol", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Allows exchange of secrets between two processes on the same system without
 * exposing those secrets to things like loggers, non-pageable memory etc.
 * 
 * This does not protect against active attacks like MITM attacks.
 * 
 * Each side creates a secret exchange object, and one of the sides calls
 * [method`SecretExchange`.begin]. This creates a string, which should be passed
 * to the other side. Each side passes the strings it receives into
 * [method`SecretExchange`.receive].
 * 
 * In order to send a reply (either with or without a secret) use
 * [method`SecretExchange`.send]. A side must have successfully called
 * [method`SecretExchange`.receive] before it can use
 * [method`SecretExchange`.send].
 * 
 * The secret exchange objects can be used for multiple iterations of the
 * conversation, or for just one request/reply. The only limitation being that
 * the initial request cannot contain a secret.
 * 
 * Caveat: Information about the approximate length (rounded up to the nearest
 * 16 bytes) may be leaked. If this is considered inacceptable, do not use
 * [class`SecretExchange]`.
 * @class 
 */
class SecretExchange extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SecretExchange

    static name: string

    // Constructors of Gcr-3.Gcr.SecretExchange

    constructor(config?: SecretExchange.ConstructorProperties) 
    /**
     * Create a new secret exchange object.
     * 
     * Specify a protocol of %NULL to allow any protocol. This is especially
     * relevant on the side of the exchange that does not call
     * [method`SecretExchange`.begin], that is the originator. Currently the only
     * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
     * @constructor 
     * @param protocol the exchange protocol to use
     * @returns A new #GcrSecretExchange object
     */
    constructor(protocol: string | null) 
    /**
     * Create a new secret exchange object.
     * 
     * Specify a protocol of %NULL to allow any protocol. This is especially
     * relevant on the side of the exchange that does not call
     * [method`SecretExchange`.begin], that is the originator. Currently the only
     * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
     * @constructor 
     * @param protocol the exchange protocol to use
     * @returns A new #GcrSecretExchange object
     */
    static new(protocol: string | null): SecretExchange
    _init(config?: SecretExchange.ConstructorProperties): void
}

module SimpleCertificate {

    // Constructor properties interface

    interface ConstructorProperties extends Certificate.ConstructorProperties, Comparable.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface SimpleCertificate extends Certificate, Comparable {

    // Own properties of Gcr-3.Gcr.SimpleCertificate

    __gtype__: number

    // Own fields of Gcr-3.Gcr.SimpleCertificate

    parent: GObject.Object

    // Class property signals of Gcr-3.Gcr.SimpleCertificate

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::description", callback: (...args: any[]) => void): number
    on(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry", callback: (...args: any[]) => void): number
    on(sigName: "notify::expiry", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::expiry", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::expiry", ...args: any[]): void
    connect(sigName: "notify::icon", callback: (...args: any[]) => void): number
    on(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::icon", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::issuer", callback: (...args: any[]) => void): number
    on(sigName: "notify::issuer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::issuer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::issuer", ...args: any[]): void
    connect(sigName: "notify::label", callback: (...args: any[]) => void): number
    on(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::markup", callback: (...args: any[]) => void): number
    on(sigName: "notify::markup", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::markup", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::markup", ...args: any[]): void
    connect(sigName: "notify::subject", callback: (...args: any[]) => void): number
    on(sigName: "notify::subject", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::subject", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::subject", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An implementation of [iface`Certificate]` which loads a certificate from DER
 * data already located in memory.
 * 
 * To create an object, use the [ctor`SimpleCertificate`.new] or
 * [ctor`SimpleCertificate`.new_static] functions.
 * @class 
 */
class SimpleCertificate extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SimpleCertificate

    static name: string

    // Constructors of Gcr-3.Gcr.SimpleCertificate

    constructor(config?: SimpleCertificate.ConstructorProperties) 
    /**
     * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
     * copied so you can dispose of it after this function returns.
     * @constructor 
     * @param data the raw DER certificate data
     * @returns a new #GcrSimpleCertificate
     */
    constructor(data: Uint8Array) 
    /**
     * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
     * copied so you can dispose of it after this function returns.
     * @constructor 
     * @param data the raw DER certificate data
     * @returns a new #GcrSimpleCertificate
     */
    static new(data: Uint8Array): SimpleCertificate
    _init(config?: SimpleCertificate.ConstructorProperties): void
}

module SimpleCollection {

    // Constructor properties interface

    interface ConstructorProperties extends Collection.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface SimpleCollection extends Collection {

    // Own properties of Gcr-3.Gcr.SimpleCollection

    __gtype__: number

    // Own fields of Gcr-3.Gcr.SimpleCollection

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.SimpleCollection

    /**
     * Add an object to this collection
     * @param object The object to add
     */
    add(object: GObject.Object): void
    /**
     * Remove an object from the collection.
     * @param object The object to remove from the collection
     */
    remove(object: GObject.Object): void

    // Class property signals of Gcr-3.Gcr.SimpleCollection

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A simple implementation of [iface`Collection]`, which you can add and remove
 * objects from.
 * 
 * You can use [method`SimpleCollection`.add] to add objects, and
 * [method`SimpleCollection`.remove] to remove them again.
 * @class 
 */
class SimpleCollection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SimpleCollection

    static name: string

    // Constructors of Gcr-3.Gcr.SimpleCollection

    constructor(config?: SimpleCollection.ConstructorProperties) 
    /**
     * Create a new #GcrSimpleCollection.
     * @constructor 
     * @returns a newly allocated     collection, which should be freed with g_object_unref()
     */
    constructor() 
    /**
     * Create a new #GcrSimpleCollection.
     * @constructor 
     * @returns a newly allocated     collection, which should be freed with g_object_unref()
     */
    static new(): SimpleCollection
    _init(config?: SimpleCollection.ConstructorProperties): void
}

module SshAskpass {

    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.SshAskpass

        /**
         * The interaction used to prompt for passwords.
         */
        interaction?: Gio.TlsInteraction | null
    }

}

interface SshAskpass {

    // Own properties of Gcr-3.Gcr.SshAskpass

    /**
     * The interaction used to prompt for passwords.
     */
    readonly interaction: Gio.TlsInteraction
    __gtype__: number

    // Owm methods of Gcr-3.Gcr.SshAskpass

    /**
     * Get the interaction associated with this object.
     * @returns the interaction
     */
    getInteraction(): Gio.TlsInteraction

    // Class property signals of Gcr-3.Gcr.SshAskpass

    connect(sigName: "notify::interaction", callback: (...args: any[]) => void): number
    on(sigName: "notify::interaction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::interaction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::interaction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * When used as the setup function while spawning an ssh command like ssh-add
 * or ssh, this allows callbacks for passwords on the provided interaction.
 * @class 
 */
class SshAskpass extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SshAskpass

    static name: string

    // Constructors of Gcr-3.Gcr.SshAskpass

    constructor(config?: SshAskpass.ConstructorProperties) 
    /**
     * Create a new GcrSshAskpass object which can be used to spawn an
     * ssh command and prompt for any necessary passwords.
     * 
     * Use the gcr_ssh_askpass_child_setup() function as a callback with
     * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
     * @constructor 
     * @param interaction the interaction to use for prompting paswords
     * @returns A new #GcrSshAskpass object
     */
    constructor(interaction: Gio.TlsInteraction) 
    /**
     * Create a new GcrSshAskpass object which can be used to spawn an
     * ssh command and prompt for any necessary passwords.
     * 
     * Use the gcr_ssh_askpass_child_setup() function as a callback with
     * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
     * @constructor 
     * @param interaction the interaction to use for prompting paswords
     * @returns A new #GcrSshAskpass object
     */
    static new(interaction: Gio.TlsInteraction): SshAskpass
    _init(config?: SshAskpass.ConstructorProperties): void
    /**
     * Use this function as a callback setup function passed to g_spawn_sync(),
     * g_spawn_async(), g_spawn_async_with_pipes().
     * @param askpass a #GcrSshAskpass object
     */
    static childSetup(askpass: any | null): void
}

module SystemPrompt {

    // Constructor properties interface

    interface ConstructorProperties extends Prompt.ConstructorProperties, Gio.AsyncInitable.ConstructorProperties, Gio.Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.SystemPrompt

        /**
         * The DBus bus name of the prompter to use for prompting, or %NULL
         * for the default prompter.
         */
        busName?: string | null
        /**
         * The #GcrSecretExchange to use when transferring passwords. A default
         * secret exchange will be used if this is not set.
         */
        secretExchange?: SecretExchange | null
        /**
         * The timeout in seconds to wait when opening the prompt.
         */
        timeoutSeconds?: number | null
    }

}

interface SystemPrompt extends Prompt, Gio.AsyncInitable, Gio.Initable {

    // Own properties of Gcr-3.Gcr.SystemPrompt

    /**
     * The DBus bus name of the prompter to use for prompting, or %NULL
     * for the default prompter.
     */
    readonly busName: string | null
    /**
     * The #GcrSecretExchange to use when transferring passwords. A default
     * secret exchange will be used if this is not set.
     */
    secretExchange: SecretExchange
    /**
     * The timeout in seconds to wait when opening the prompt.
     */
    readonly timeoutSeconds: number
    __gtype__: number

    // Own fields of Gcr-3.Gcr.SystemPrompt

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.SystemPrompt

    /**
     * Close this prompt. After calling this function, no further prompts will
     * succeed on this object. The prompt object is not unreferenced by this
     * function, and you must unreference it once done.
     * 
     * This call may block, use the gcr_system_prompt_close_async() to perform
     * this action indefinitely.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     * @param cancellable an optional cancellation object
     * @returns whether close was cleanly completed
     */
    close(cancellable: Gio.Cancellable | null): boolean

    // Overloads of close

    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    /**
     * Close this prompt asynchronously. After calling this function, no further
     * methods may be called on this object. The prompt object is not unreferenced
     * by this function, and you must unreference it once done.
     * 
     * This call returns immediately and completes asynchronously.
     * @param cancellable an optional cancellation object
     * @param callback called when the operation completes
     */
    closeAsync(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete operation to close this prompt.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     * @param result asynchronous operation result
     * @returns whether close was cleanly completed
     */
    closeFinish(result: Gio.AsyncResult): boolean
    /**
     * Get the current [class`SecretExchange]` used to transfer secrets in this prompt.
     * @returns the secret exchange
     */
    getSecretExchange(): SecretExchange

    // Class property signals of Gcr-3.Gcr.SystemPrompt

    connect(sigName: "notify::bus-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::bus-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bus-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bus-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bus-name", ...args: any[]): void
    connect(sigName: "notify::secret-exchange", callback: (...args: any[]) => void): number
    on(sigName: "notify::secret-exchange", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::secret-exchange", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::secret-exchange", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::secret-exchange", ...args: any[]): void
    connect(sigName: "notify::timeout-seconds", callback: (...args: any[]) => void): number
    on(sigName: "notify::timeout-seconds", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::timeout-seconds", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::timeout-seconds", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::timeout-seconds", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::caller-window", callback: (...args: any[]) => void): number
    on(sigName: "notify::caller-window", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::caller-window", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::caller-window", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::caller-window", ...args: any[]): void
    connect(sigName: "notify::cancel-label", callback: (...args: any[]) => void): number
    on(sigName: "notify::cancel-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cancel-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cancel-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cancel-label", ...args: any[]): void
    connect(sigName: "notify::choice-chosen", callback: (...args: any[]) => void): number
    on(sigName: "notify::choice-chosen", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::choice-chosen", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::choice-chosen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::choice-chosen", ...args: any[]): void
    connect(sigName: "notify::choice-label", callback: (...args: any[]) => void): number
    on(sigName: "notify::choice-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::choice-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::choice-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::choice-label", ...args: any[]): void
    connect(sigName: "notify::continue-label", callback: (...args: any[]) => void): number
    on(sigName: "notify::continue-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::continue-label", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::continue-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::continue-label", ...args: any[]): void
    connect(sigName: "notify::description", callback: (...args: any[]) => void): number
    on(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::message", callback: (...args: any[]) => void): number
    on(sigName: "notify::message", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::message", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::message", ...args: any[]): void
    connect(sigName: "notify::password-new", callback: (...args: any[]) => void): number
    on(sigName: "notify::password-new", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::password-new", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::password-new", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::password-new", ...args: any[]): void
    connect(sigName: "notify::password-strength", callback: (...args: any[]) => void): number
    on(sigName: "notify::password-strength", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::password-strength", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::password-strength", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::password-strength", ...args: any[]): void
    connect(sigName: "notify::title", callback: (...args: any[]) => void): number
    on(sigName: "notify::title", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::title", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::title", ...args: any[]): void
    connect(sigName: "notify::warning", callback: (...args: any[]) => void): number
    on(sigName: "notify::warning", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::warning", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::warning", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::warning", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A [iface`Prompt]` implementation which calls to the system prompter to
 * display prompts in a system modal fashion.
 * 
 * Since the system prompter usually only displays one prompt at a time, you
 * may have to wait for the prompt to be displayed. Use [func`SystemPrompt`.open]
 * or a related function to open a prompt. Since this can take a long time, you
 * should always check that the prompt is still needed after it is opened. A
 * previous prompt may have already provided the information needed and you
 * may no longer need to prompt.
 * 
 * Use [method`SystemPrompt`.close] to close the prompt when you're done with it.
 * @class 
 */
class SystemPrompt extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SystemPrompt

    static name: string

    // Constructors of Gcr-3.Gcr.SystemPrompt

    constructor(config?: SystemPrompt.ConstructorProperties) 
    _init(config?: SystemPrompt.ConstructorProperties): void
    static errorGetDomain(): GLib.Quark
    /**
     * Opens a system prompt with the default prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param timeoutSeconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @returns the prompt, or %NULL if          prompt could not be opened
     */
    static open(timeoutSeconds: number, cancellable: Gio.Cancellable | null): SystemPrompt
    /**
     * Asynchronously open a system prompt with the default system prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param timeoutSeconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    static openAsync(timeoutSeconds: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to asynchronously open a system prompt.
     * @param result the asynchronous result
     * @returns the prompt, or %NULL if          prompt could not be opened
     */
    static openFinish(result: Gio.AsyncResult): SystemPrompt
    /**
     * Opens a system prompt. If prompter_name is %NULL, then the default
     * system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param prompterName the prompter dbus name
     * @param timeoutSeconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @returns the prompt, or %NULL if          prompt could not be opened
     */
    static openForPrompter(prompterName: string | null, timeoutSeconds: number, cancellable: Gio.Cancellable | null): SystemPrompt
    /**
     * Opens a system prompt asynchronously. If prompter_name is %NULL, then the
     * default system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param prompterName the prompter D-Bus name
     * @param timeoutSeconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    static openForPrompterAsync(prompterName: string | null, timeoutSeconds: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

module SystemPrompter {

    // Signal callback interfaces

    /**
     * Signal callback interface for `new-prompt`
     */
    interface NewPromptSignalCallback {
        (): Prompt
    }


    // Constructor properties interface

    interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-3.Gcr.SystemPrompter

        /**
         * The #GType for prompts created by this prompter. This must be a
         * #GcrPrompt implementation.
         */
        promptType?: GObject.GType | null
    }

}

interface SystemPrompter {

    // Own properties of Gcr-3.Gcr.SystemPrompter

    /**
     * The #GType for prompts created by this prompter. This must be a
     * #GcrPrompt implementation.
     */
    readonly promptType: GObject.GType
    /**
     * Whether the prompter is prompting or not.
     */
    readonly prompting: boolean
    __gtype__: number

    // Own fields of Gcr-3.Gcr.SystemPrompter

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.SystemPrompter

    /**
     * Get the mode for this prompter.
     * 
     * Most system prompters only display one prompt at a time and therefore
     * return %GCR_SYSTEM_PROMPTER_SINGLE.
     * @returns the prompter mode
     */
    getMode(): SystemPrompterMode
    /**
     * Get the #GType for prompts created by this prompter.
     * 
     * The returned #GType will be a #GcrPrompt implementation.
     * @returns the prompt #GType
     */
    getPromptType(): GObject.GType
    /**
     * Get whether prompting or not.
     * @returns whether prompting or not
     */
    getPrompting(): boolean
    /**
     * Register this system prompter on the DBus `connection`.
     * 
     * This makes the prompter available for clients to call. The prompter will
     * remain registered until gcr_system_prompter_unregister() is called, or the
     * prompter is unreferenced.
     * @param connection a DBus connection
     */
    register(connection: Gio.DBusConnection): void
    /**
     * Unregister this system prompter on the DBus `connection`.
     * 
     * The prompter must have previously been registered with gcr_system_prompter_register().
     * 
     * If `wait` is set then this function will wait until all prompts have been closed
     * or cancelled. This is usually only used by tests.
     * @param wait whether to wait for closing prompts
     */
    unregister(wait: boolean): void

    // Own signals of Gcr-3.Gcr.SystemPrompter

    connect(sigName: "new-prompt", callback: SystemPrompter.NewPromptSignalCallback): number
    on(sigName: "new-prompt", callback: SystemPrompter.NewPromptSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-prompt", callback: SystemPrompter.NewPromptSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-prompt", callback: SystemPrompter.NewPromptSignalCallback): NodeJS.EventEmitter
    emit(sigName: "new-prompt", ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.SystemPrompter

    connect(sigName: "notify::prompt-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::prompt-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::prompt-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::prompt-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::prompt-type", ...args: any[]): void
    connect(sigName: "notify::prompting", callback: (...args: any[]) => void): number
    on(sigName: "notify::prompting", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::prompting", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::prompting", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::prompting", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A prompter used by implementations of system prompts.
 * 
 * This is a D-Bus service which is rarely implemented. Use [class`SystemPrompt]`
 * to display system prompts.
 * 
 * The system prompter service responds to D-Bus requests to create system
 * prompts and creates #GcrPrompt type objects to display those prompts.
 * 
 * Pass the GType of the implementation of [iface`Prompt]` to
 * [ctor`SystemPrompter`.new].
 * @class 
 */
class SystemPrompter extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SystemPrompter

    static name: string

    // Constructors of Gcr-3.Gcr.SystemPrompter

    constructor(config?: SystemPrompter.ConstructorProperties) 
    /**
     * Create a new system prompter service. This prompter won't do anything unless
     * you connect to its signals and show appropriate prompts.
     * 
     * If `prompt_type` is zero, then the new-prompt signal must be handled and
     * return a valid prompt object implementing the #GcrPrompt interface.
     * 
     * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
     * interface.
     * @constructor 
     * @param mode the mode for the prompt
     * @param promptType the gobject type for prompts created by this prompter
     * @returns a new prompter service
     */
    constructor(mode: SystemPrompterMode, promptType: GObject.GType) 
    /**
     * Create a new system prompter service. This prompter won't do anything unless
     * you connect to its signals and show appropriate prompts.
     * 
     * If `prompt_type` is zero, then the new-prompt signal must be handled and
     * return a valid prompt object implementing the #GcrPrompt interface.
     * 
     * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
     * interface.
     * @constructor 
     * @param mode the mode for the prompt
     * @param promptType the gobject type for prompts created by this prompter
     * @returns a new prompter service
     */
    static new(mode: SystemPrompterMode, promptType: GObject.GType): SystemPrompter
    _init(config?: SystemPrompter.ConstructorProperties): void
}

module UnionCollection {

    // Constructor properties interface

    interface ConstructorProperties extends Collection.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

interface UnionCollection extends Collection {

    // Own properties of Gcr-3.Gcr.UnionCollection

    __gtype__: number

    // Own fields of Gcr-3.Gcr.UnionCollection

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.UnionCollection

    /**
     * Add objects from this collection to the union
     * @param collection The collection whose objects to add
     */
    add(collection: Collection): void
    /**
     * Get the collections that have been added to this union.
     * @returns collections          added to the union
     */
    elements(): Collection[]
    /**
     * Check whether the collection is present in the union.
     * @param collection the collection to check
     * @returns whether present or not
     */
    have(collection: Collection): boolean
    /**
     * Remove an object from the collection.
     * @param collection The collection whose objects to remove
     */
    remove(collection: Collection): void
    /**
     * Return the number of collections in this union. This does not reflect
     * the number of objects in the combined collection.
     * @returns number of collections inlcuded
     */
    size(): number
    /**
     * Add objects from this collection to the union. Do not add an additional
     * reference to the collection.
     * @param collection The collection whose objects to add
     */
    take(collection: Collection): void

    // Class property signals of Gcr-3.Gcr.UnionCollection

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An implementation of #GcrCollection, which combines the objects in
 * other [iface`Collection]`s. Use [method`UnionCollection`.add] to add and
 * [method`UnionCollection`.remove] to remove them.
 * @class 
 */
class UnionCollection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.UnionCollection

    static name: string

    // Constructors of Gcr-3.Gcr.UnionCollection

    constructor(config?: UnionCollection.ConstructorProperties) 
    /**
     * Create a new #GcrUnionCollection.
     * @constructor 
     * @returns a newly allocated          collection, which should be freed with g_object_unref()
     */
    constructor() 
    /**
     * Create a new #GcrUnionCollection.
     * @constructor 
     * @returns a newly allocated          collection, which should be freed with g_object_unref()
     */
    static new(): UnionCollection
    _init(config?: UnionCollection.ConstructorProperties): void
}

interface CertificateChainClass {

    // Own fields of Gcr-3.Gcr.CertificateChainClass

    /**
     * The parent class
     * @field 
     */
    parentClass: GObject.ObjectClass
}

/**
 * The class for #GcrCertificateChain.
 * @record 
 */
abstract class CertificateChainClass {

    // Own properties of Gcr-3.Gcr.CertificateChainClass

    static name: string
}

interface CertificateChainPrivate {
}

class CertificateChainPrivate {

    // Own properties of Gcr-3.Gcr.CertificateChainPrivate

    static name: string
}

interface CertificateIface {

    // Own fields of Gcr-3.Gcr.CertificateIface

    /**
     * the parent interface type
     * @field 
     */
    parent: GObject.TypeInterface
    getDerData: (self: Certificate) => Uint8Array
}

/**
 * The interface that implementors of #GcrCertificate must implement.
 * @record 
 */
abstract class CertificateIface {

    // Own properties of Gcr-3.Gcr.CertificateIface

    static name: string
}

interface CertificateRequestClass {

    // Own fields of Gcr-3.Gcr.CertificateRequestClass

    parentClass: GObject.ObjectClass
}

abstract class CertificateRequestClass {

    // Own properties of Gcr-3.Gcr.CertificateRequestClass

    static name: string
}

interface CollectionIface {

    // Own fields of Gcr-3.Gcr.CollectionIface

    parent: GObject.TypeInterface
    added: (self: Collection, object: GObject.Object) => void
    removed: (self: Collection, object: GObject.Object) => void
    getLength: (self: Collection) => number
    getObjects: (self: Collection) => GObject.Object[]
    contains: (self: Collection, object: GObject.Object) => boolean
}

abstract class CollectionIface {

    // Own properties of Gcr-3.Gcr.CollectionIface

    static name: string
}

interface Column {

    // Own fields of Gcr-3.Gcr.Column

    propertyName: string | null
    propertyType: GObject.GType
    columnType: GObject.GType
    label: string | null
    flags: ColumnFlags
    transformer: GObject.ValueTransform
    userData: any
}

class Column {

    // Own properties of Gcr-3.Gcr.Column

    static name: string
}

interface ComparableIface {

    // Own fields of Gcr-3.Gcr.ComparableIface

    /**
     * type interface
     * @field 
     */
    parent: GObject.TypeInterface
    compare: (self: Comparable, other: Comparable | null) => number
}

/**
 * The interface to implement for [iface`Comparable]`
 * @record 
 */
abstract class ComparableIface {

    // Own properties of Gcr-3.Gcr.ComparableIface

    static name: string
}

interface FilterCollectionClass {

    // Own fields of Gcr-3.Gcr.FilterCollectionClass

    /**
     * the parent class
     * @field 
     */
    parentClass: GObject.ObjectClass
}

/**
 * The class struct for [class`FilterCollection]`.
 * @record 
 */
abstract class FilterCollectionClass {

    // Own properties of Gcr-3.Gcr.FilterCollectionClass

    static name: string
}

interface FilterCollectionPrivate {
}

class FilterCollectionPrivate {

    // Own properties of Gcr-3.Gcr.FilterCollectionPrivate

    static name: string
}

interface ImportInteractionIface {

    // Own fields of Gcr-3.Gcr.ImportInteractionIface

    /**
     * parent interface
     * @field 
     */
    parent: GObject.TypeInterface
    supplementPrep: (interaction: ImportInteraction, builder: Gck.Builder) => void
    supplement: (interaction: ImportInteraction, builder: Gck.Builder, cancellable: Gio.Cancellable | null) => Gio.TlsInteractionResult
    supplementAsync: (interaction: ImportInteraction, builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    supplementFinish: (interaction: ImportInteraction, result: Gio.AsyncResult) => Gio.TlsInteractionResult
}

/**
 * Interface implemented by implementations of [iface`ImportInteraction]`.
 * @record 
 */
abstract class ImportInteractionIface {

    // Own properties of Gcr-3.Gcr.ImportInteractionIface

    static name: string
}

interface ImporterIface {

    // Own fields of Gcr-3.Gcr.ImporterIface

    /**
     * parent interface
     * @field 
     */
    parent: GObject.TypeInterface
    queueForParsed: (importer: Importer, parsed: Parsed) => boolean
    importSync: (importer: Importer, cancellable: Gio.Cancellable | null) => boolean
    importAsync: (importer: Importer, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    importFinish: (importer: Importer, result: Gio.AsyncResult) => boolean
}

/**
 * Interface implemented for a #GcrImporter.
 * @record 
 */
abstract class ImporterIface {

    // Own properties of Gcr-3.Gcr.ImporterIface

    static name: string
}

interface Parsed {

    // Owm methods of Gcr-3.Gcr.Parsed

    /**
     * Get the attributes which make up the parsed item.
     * @returns the attributes for the item; these          are owned by the parsed item and should not be freed
     */
    getAttributes(): Gck.Attributes | null
    /**
     * Get the raw data block for the parsed item.
     * @returns the raw data of the parsed item, or %NULL
     */
    getBytes(): any
    /**
     * Get the raw data block for the parsed item.
     * @returns the raw data of          the parsed item, or %NULL
     */
    getData(): Uint8Array | null
    /**
     * Get the descirption for a parsed item.
     * @returns the description
     */
    getDescription(): string | null
    /**
     * Get the filename of the parsed item.
     * @returns the filename of          the parsed item, or %NULL
     */
    getFilename(): string | null
    /**
     * Get the format of the parsed item.
     * @returns the data format of the item
     */
    getFormat(): DataFormat
    /**
     * Get the label for the parsed item.
     * @returns the label for the item
     */
    getLabel(): string | null
    /**
     * Add a reference to a parsed item. An item may not be shared across threads
     * until it has been referenced at least once.
     * @returns the parsed item
     */
    ref(): Parsed
}

/**
 * A parsed item parsed by a #GcrParser.
 * @record 
 */
class Parsed {

    // Own properties of Gcr-3.Gcr.Parsed

    static name: string

    // Constructors of Gcr-3.Gcr.Parsed

    /**
     * Unreferences a parsed item which was referenced with gcr_parsed_ref()
     * @param parsed a parsed item
     */
    static unref(parsed: any | null): void
}

interface ParserClass {

    // Own fields of Gcr-3.Gcr.ParserClass

    /**
     * The parent class
     * @field 
     */
    parentClass: GObject.ObjectClass
    authenticate: (self: Parser, count: number) => boolean
    parsed: (self: Parser) => void
}

/**
 * The class for #GcrParser
 * @record 
 */
abstract class ParserClass {

    // Own properties of Gcr-3.Gcr.ParserClass

    static name: string
}

interface ParserPrivate {
}

class ParserPrivate {

    // Own properties of Gcr-3.Gcr.ParserPrivate

    static name: string
}

interface Pkcs11CertificateClass {
}

abstract class Pkcs11CertificateClass {

    // Own properties of Gcr-3.Gcr.Pkcs11CertificateClass

    static name: string
}

interface Pkcs11CertificatePrivate {
}

class Pkcs11CertificatePrivate {

    // Own properties of Gcr-3.Gcr.Pkcs11CertificatePrivate

    static name: string
}

interface PromptIface {

    // Own fields of Gcr-3.Gcr.PromptIface

    /**
     * parent interface
     * @field 
     */
    parentIface: GObject.TypeInterface
    promptPasswordAsync: (prompt: Prompt, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    promptPasswordFinish: (prompt: Prompt, result: Gio.AsyncResult) => string | null
    promptConfirmAsync: (prompt: Prompt, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    promptConfirmFinish: (prompt: Prompt, result: Gio.AsyncResult) => PromptReply
    promptClose: (prompt: Prompt) => void
}

/**
 * The interface for implementing [class`Prompt]`.
 * @record 
 */
abstract class PromptIface {

    // Own properties of Gcr-3.Gcr.PromptIface

    static name: string
}

interface SecretExchangeClass {

    // Own fields of Gcr-3.Gcr.SecretExchangeClass

    generateExchangeKey: (exchange: SecretExchange, scheme: string | null, publicKey: number, nPublicKey: number) => boolean
    deriveTransportKey: (exchange: SecretExchange, peer: number, nPeer: number) => boolean
}

abstract class SecretExchangeClass {

    // Own properties of Gcr-3.Gcr.SecretExchangeClass

    static name: string
}

interface SecretExchangePrivate {
}

class SecretExchangePrivate {

    // Own properties of Gcr-3.Gcr.SecretExchangePrivate

    static name: string
}

interface SimpleCertificateClass {

    // Own fields of Gcr-3.Gcr.SimpleCertificateClass

    parentClass: GObject.ObjectClass
}

abstract class SimpleCertificateClass {

    // Own properties of Gcr-3.Gcr.SimpleCertificateClass

    static name: string
}

interface SimpleCertificatePrivate {
}

class SimpleCertificatePrivate {

    // Own properties of Gcr-3.Gcr.SimpleCertificatePrivate

    static name: string
}

interface SimpleCollectionClass {

    // Own fields of Gcr-3.Gcr.SimpleCollectionClass

    parentClass: GObject.ObjectClass
}

abstract class SimpleCollectionClass {

    // Own properties of Gcr-3.Gcr.SimpleCollectionClass

    static name: string
}

interface SimpleCollectionPrivate {
}

class SimpleCollectionPrivate {

    // Own properties of Gcr-3.Gcr.SimpleCollectionPrivate

    static name: string
}

interface SshAskpassClass {

    // Own fields of Gcr-3.Gcr.SshAskpassClass

    parentClass: GObject.ObjectClass
}

abstract class SshAskpassClass {

    // Own properties of Gcr-3.Gcr.SshAskpassClass

    static name: string
}

interface SystemPromptClass {

    // Own fields of Gcr-3.Gcr.SystemPromptClass

    parentClass: GObject.ObjectClass
}

abstract class SystemPromptClass {

    // Own properties of Gcr-3.Gcr.SystemPromptClass

    static name: string
}

interface SystemPromptPrivate {
}

class SystemPromptPrivate {

    // Own properties of Gcr-3.Gcr.SystemPromptPrivate

    static name: string
}

interface SystemPrompterClass {

    // Own fields of Gcr-3.Gcr.SystemPrompterClass

    /**
     * parent class
     * @field 
     */
    parentClass: GObject.ObjectClass
}

/**
 * The class for #GcrSystemPrompter.
 * @record 
 */
abstract class SystemPrompterClass {

    // Own properties of Gcr-3.Gcr.SystemPrompterClass

    static name: string
}

interface SystemPrompterPrivate {
}

class SystemPrompterPrivate {

    // Own properties of Gcr-3.Gcr.SystemPrompterPrivate

    static name: string
}

interface UnionCollectionClass {

    // Own fields of Gcr-3.Gcr.UnionCollectionClass

    parentClass: GObject.ObjectClass
}

abstract class UnionCollectionClass {

    // Own properties of Gcr-3.Gcr.UnionCollectionClass

    static name: string
}

interface UnionCollectionPrivate {
}

class UnionCollectionPrivate {

    // Own properties of Gcr-3.Gcr.UnionCollectionPrivate

    static name: string
}

}

export default Gcr;
// END