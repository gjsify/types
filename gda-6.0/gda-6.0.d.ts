/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

import '@girs/gjs';

// Module dependencies
import type libxml2 from '@girs/libxml2-2.0';
import type Gio from '@girs/gio-2.0';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type GModule from '@girs/gmodule-2.0';

export namespace Gda {
    /**
     * Gda-6.0
     */

    export namespace BatchError {
        export const $gtype: GObject.GType<BatchError>;
    }

    enum BatchError {
        BATCH_CONFLICTING_PARAMETER_ERROR,
    }

    export namespace ConfigError {
        export const $gtype: GObject.GType<ConfigError>;
    }

    enum ConfigError {
        DSN_NOT_FOUND_ERROR,
        PERMISSION_ERROR,
        PROVIDER_NOT_FOUND_ERROR,
        PROVIDER_CREATION_ERROR,
    }

    export namespace ConnectionError {
        export const $gtype: GObject.GType<ConnectionError>;
    }

    enum ConnectionError {
        DSN_NOT_FOUND_ERROR,
        PROVIDER_NOT_FOUND_ERROR,
        PROVIDER_ERROR,
        NO_CNC_SPEC_ERROR,
        NO_PROVIDER_SPEC_ERROR,
        OPEN_ERROR,
        ALREADY_OPENED_ERROR,
        STATEMENT_TYPE_ERROR,
        CANT_LOCK_ERROR,
        TASK_NOT_FOUND_ERROR,
        CLOSED_ERROR,
        META_DATA_CONTEXT_ERROR,
        NO_MAIN_CONTEXT_ERROR,
    }

    export namespace ConnectionEventCode {
        export const $gtype: GObject.GType<ConnectionEventCode>;
    }

    enum ConnectionEventCode {
        CONSTRAINT_VIOLATION,
        RESTRICT_VIOLATION,
        NOT_NULL_VIOLATION,
        FOREIGN_KEY_VIOLATION,
        UNIQUE_VIOLATION,
        CHECK_VIOLATION,
        INSUFFICIENT_PRIVILEGES,
        UNDEFINED_COLUMN,
        UNDEFINED_FUNCTION,
        UNDEFINED_TABLE,
        DUPLICATE_COLUMN,
        DUPLICATE_DATABASE,
        DUPLICATE_FUNCTION,
        DUPLICATE_SCHEMA,
        DUPLICATE_TABLE,
        DUPLICATE_ALIAS,
        DUPLICATE_OBJECT,
        SYNTAX_ERROR,
        UNKNOWN,
    }

    export namespace ConnectionEventType {
        export const $gtype: GObject.GType<ConnectionEventType>;
    }

    enum ConnectionEventType {
        NOTICE,
        WARNING,
        ERROR,
        COMMAND,
    }
    /**
     * Used in gda_connection_supports_feature() and gda_server_provider_supports_feature() to test if a connection
     * or a database provider supports some specific feature.
     */

    /**
     * Used in gda_connection_supports_feature() and gda_server_provider_supports_feature() to test if a connection
     * or a database provider supports some specific feature.
     */
    export namespace ConnectionFeature {
        export const $gtype: GObject.GType<ConnectionFeature>;
    }

    enum ConnectionFeature {
        /**
         * test for aggregates support
         */
        AGGREGATES,
        /**
         * test for BLOBS (binary large objects) support
         */
        BLOBS,
        /**
         * test for indexes support
         */
        INDEXES,
        /**
         * test for tables inheritance support
         */
        INHERITANCE,
        /**
         * test for namespaces support
         */
        NAMESPACES,
        /**
         * test for functions support
         */
        PROCEDURES,
        /**
         * test for sequences support
         */
        SEQUENCES,
        /**
         * test for SQL language (even specific to the database) support
         */
        SQL,
        /**
         * test for transactions support
         */
        TRANSACTIONS,
        /**
         * test for savepoints within transactions support
         */
        SAVEPOINTS,
        /**
         * test if savepoints can be removed
         */
        SAVEPOINTS_REMOVE,
        /**
         * test for triggers support
         */
        TRIGGERS,
        /**
         * test for updatable cursors support
         */
        UPDATABLE_CURSOR,
        /**
         * test for users support
         */
        USERS,
        /**
         * test for views support
         */
        VIEWS,
        /**
         * test for READ COMMITTED transaction isolation level
         */
        TRANSACTION_ISOLATION_READ_COMMITTED,
        /**
         * test for READ UNCOMMITTED transaction isolation level
         */
        TRANSACTION_ISOLATION_READ_UNCOMMITTED,
        /**
         * test for REPEATABLE READ transaction isolation level
         */
        TRANSACTION_ISOLATION_REPEATABLE_READ,
        /**
         * test for SERIALIZABLE transaction isolation level
         */
        TRANSACTION_ISOLATION_SERIALIZABLE,
        /**
         * test for distributed transactions support
         */
        XA_TRANSACTIONS,
        /**
         * not used
         */
        LAST,
    }
    /**
     * Used with gda_connection_get_meta_store_data() to describe what meta data to extract from
     * a connection's associated #GdaMetaStore.
     */

    /**
     * Used with gda_connection_get_meta_store_data() to describe what meta data to extract from
     * a connection's associated #GdaMetaStore.
     */
    export namespace ConnectionMetaType {
        export const $gtype: GObject.GType<ConnectionMetaType>;
    }

    enum ConnectionMetaType {
        /**
         * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_NAMESPACES">namespaces</link> (or schemas for PostgreSQL)
         */
        NAMESPACES,
        /**
         * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_TYPES">database types</link>
         */
        TYPES,
        /**
         * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_TABLES">tables</link>
         */
        TABLES,
        /**
         * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_VIEWS">views</link>
         */
        VIEWS,
        /**
         * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_FIELDS">table's or view's fields</link>
         */
        FIELDS,
        /**
         * lists the <link linkend="GdaConnectionMetaTypeGDA_CONNECTION_META_INDEXES">table's indexes</link>
         */
        INDEXES,
    }
    /**
     * Indicates the current status of a connection. The possible status and the transitions between those status
     * are indicated in the diagram below:
     *  <mediaobject>
     *    <imageobject role="html">
     *      <imagedata fileref="connection-status.png" format="PNG" contentwidth="50mm"/>
     *    </imageobject>
     *    <textobject>
     *      <phrase>GdaConnection's status and transitions between different status</phrase>
     *    </textobject>
     *  </mediaobject>
     */

    /**
     * Indicates the current status of a connection. The possible status and the transitions between those status
     * are indicated in the diagram below:
     *  <mediaobject>
     *    <imageobject role="html">
     *      <imagedata fileref="connection-status.png" format="PNG" contentwidth="50mm"/>
     *    </imageobject>
     *    <textobject>
     *      <phrase>GdaConnection's status and transitions between different status</phrase>
     *    </textobject>
     *  </mediaobject>
     */
    export namespace ConnectionStatus {
        export const $gtype: GObject.GType<ConnectionStatus>;
    }

    enum ConnectionStatus {
        /**
         * the connection is closed (default status upon creation)
         */
        CLOSED,
        /**
         * the connection is currently being opened
         */
        OPENING,
        /**
         * the connection is opened but not currently used
         */
        IDLE,
        /**
         * the connection is opened and currently being used
         */
        BUSY,
    }

    export namespace DataComparatorError {
        export const $gtype: GObject.GType<DataComparatorError>;
    }

    enum DataComparatorError {
        MISSING_DATA_MODEL_ERROR,
        COLUMN_TYPES_MISMATCH_ERROR,
        MODEL_ACCESS_ERROR,
        USER_CANCELLED_ERROR,
    }
    class DataModelError extends GLib.Error {
        static $gtype: GObject.GType<DataModelError>;

        // Static fields

        static ROW_OUT_OF_RANGE_ERROR: number;
        static COLUMN_OUT_OF_RANGE_ERROR: number;
        static VALUES_LIST_ERROR: number;
        static VALUE_TYPE_ERROR: number;
        static ROW_NOT_FOUND_ERROR: number;
        static ACCESS_ERROR: number;
        static FEATURE_NON_SUPPORTED_ERROR: number;
        static FILE_EXIST_ERROR: number;
        static XML_FORMAT_ERROR: number;
        static TRUNCATED_ERROR: number;
        static INVALID: number;
        static OTHER_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    export namespace DataModelHint {
        export const $gtype: GObject.GType<DataModelHint>;
    }

    enum DataModelHint {
        START_BATCH_UPDATE,
        END_BATCH_UPDATE,
        REFRESH,
    }
    /**
     * Format to use when exporting a data model, see gda_data_model_export_to_string() and gda_data_model_export_to_file()
     */

    /**
     * Format to use when exporting a data model, see gda_data_model_export_to_string() and gda_data_model_export_to_file()
     */
    export namespace DataModelIOFormat {
        export const $gtype: GObject.GType<DataModelIOFormat>;
    }

    enum DataModelIOFormat {
        /**
         * data is exported as an XML structure
         */
        DATA_ARRAY_XML,
        /**
         * data is exported as CSV
         */
        TEXT_SEPARATED,
        /**
         * data is exported as a human readable table
         */
        TEXT_TABLE,
    }

    export namespace DataModelIterError {
        export const $gtype: GObject.GType<DataModelIterError>;
    }

    enum DataModelIterError {
        DATA_MODEL_ITER_COLUMN_OUT_OF_RANGE_ERROR,
    }
    /**
     * Possible operations for the data fields.
     */

    /**
     * Possible operations for the data fields.
     */
    export namespace DataPivotAggregate {
        export const $gtype: GObject.GType<DataPivotAggregate>;
    }

    enum DataPivotAggregate {
        AVG,
        COUNT,
        MAX,
        MIN,
        SUM,
    }
    /**
     * Possible #GdaDataPivot related errors.
     */

    /**
     * Possible #GdaDataPivot related errors.
     */
    export namespace DataPivotError {
        export const $gtype: GObject.GType<DataPivotError>;
    }

    enum DataPivotError {
        INTERNAL_ERROR,
        SOURCE_MODEL_ERROR,
        FIELD_FORMAT_ERROR,
        USAGE_ERROR,
        OVERFLOW_ERROR,
    }
    /**
     * Define types of field to be used when defining a #GdaDataPivot analysis.
     */

    /**
     * Define types of field to be used when defining a #GdaDataPivot analysis.
     */
    export namespace DataPivotFieldType {
        export const $gtype: GObject.GType<DataPivotFieldType>;
    }

    enum DataPivotFieldType {
        ROW,
        COLUMN,
    }

    export namespace DataProxyError {
        export const $gtype: GObject.GType<DataProxyError>;
    }

    enum DataProxyError {
        COMMIT_ERROR,
        COMMIT_CANCELLED,
        READ_ONLY_VALUE,
        READ_ONLY_ROW,
        FILTER_ERROR,
    }
    /**
     * Defines what criteria gda_data_select_compute_modification_statements_ext() uses
     * to uniquely identify a single row in a table when creating modification statements.
     */

    /**
     * Defines what criteria gda_data_select_compute_modification_statements_ext() uses
     * to uniquely identify a single row in a table when creating modification statements.
     */
    export namespace DataSelectConditionType {
        export const $gtype: GObject.GType<DataSelectConditionType>;
    }

    enum DataSelectConditionType {
        /**
         * only primary key fields are used
         */
        PK,
        /**
         * all the columns of the tables are used
         */
        ALL_COLUMNS,
    }

    export namespace DataSelectError {
        export const $gtype: GObject.GType<DataSelectError>;
    }

    enum DataSelectError {
        MODIFICATION_STATEMENT_ERROR,
        MISSING_MODIFICATION_STATEMENT_ERROR,
        CONNECTION_ERROR,
        ACCESS_ERROR,
        SQL_ERROR,
        SAFETY_LOCKED_ERROR,
    }
    /**
     * These error are primary for developers to troubleshoot the problem rather than for user.
     */

    /**
     * These error are primary for developers to troubleshoot the problem rather than for user.
     */
    export namespace DbCatalogError {
        export const $gtype: GObject.GType<DbCatalogError>;
    }

    enum DbCatalogError {
        /**
         * Context is %NULL. Should not be %NULL for normal operation.
         */
        CONTEXT_NULL,
        /**
         * #xmlDocPtr is %NULL.
         */
        DOC_NULL,
        /**
         * Sets if xml check fails. Xml file structure doesn't match with DTD
         * file
         */
        INVALID_XML,
        /**
         * Sets if the used schema is invalid.
         */
        INVALID_SCHEMA,
        /**
         * Sets if server operation is %NULL.
         */
        SERVER_OPERATION,
        /**
         * Sets if xml file is not readable
         */
        FILE_READ,
        /**
         * Sets if an error with context during parsing an xml file
         */
        PARSE_CONTEXT,
        /**
         * Sets if parsing reports an error
         */
        PARSE,
        /**
         * If set, error with parse chunk algorithm.
         */
        PARSE_CHUNK,
        /**
         * Connection is not open.
         */
        CONNECTION_CLOSED,
    }
    /**
     * Values used to describe the source of the error.
     */

    /**
     * Values used to describe the source of the error.
     */
    export namespace DbColumnError {
        export const $gtype: GObject.GType<DbColumnError>;
    }

    enum DbColumnError {
        /**
         * Set if wrong column type was given in the xml file.
         */
        TYPE,
        /**
         * Wrong operation requested
         */
        WRONG_OPERATION,
    }
    /**
     * Specify numeric value for the actions, e.g. "ON DELETE" and "ON UPDATE"
     */

    /**
     * Specify numeric value for the actions, e.g. "ON DELETE" and "ON UPDATE"
     */
    export namespace DbFkeyReferenceAction {
        export const $gtype: GObject.GType<DbFkeyReferenceAction>;
    }

    enum DbFkeyReferenceAction {
        /**
         * Action is not specified.
         */
        NO_ACTION,
        /**
         * Action value is set to %NULL
         */
        SET_NULL,
        /**
         * Value is set to "RESTRICT"
         */
        RESTRICT,
        /**
         * Value is set to default behavior
         */
        SET_DEFAULT,
        /**
         * Value is set to cascade
         */
        CASCADE,
    }

    export namespace DbIndexError {
        export const $gtype: GObject.GType<DbIndexError>;
    }

    enum DbIndexError {
        CONNECTION_NOT_OPENED,
        SERVER_OPERATION,
    }
    /**
     * Enum values to specify the sorting
     */

    /**
     * Enum values to specify the sorting
     */
    export namespace DbIndexSortOrder {
        export const $gtype: GObject.GType<DbIndexSortOrder>;
    }

    enum DbIndexSortOrder {
        /**
         * ascending sorting
         */
        ASC,
        /**
         * descending sorting
         */
        DESC,
    }

    export namespace DbTableError {
        export const $gtype: GObject.GType<DbTableError>;
    }

    enum DbTableError {
        /**
         * Table doesn't contain columns
         */
        COLUMN_EMPTY,
        /**
         * Closed connection was passed as parameter
         */
        CONNECTION_NOT_OPENED,
        /**
         * Error related to #GdaServerOperation
         */
        SERVER_OPERATION,
    }

    export namespace DbViewRefAction {
        export const $gtype: GObject.GType<DbViewRefAction>;
    }

    enum DbViewRefAction {
        RESTRICT,
        CASCADE,
    }
    class DdlModifiableError extends GLib.Error {
        static $gtype: GObject.GType<DdlModifiableError>;

        // Static fields

        static NOT_IMPLEMENTED: number;
        static CONNECTION_NOT_OPENED: number;
        static MISSED_DATA: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    export namespace DiffType {
        export const $gtype: GObject.GType<DiffType>;
    }

    enum DiffType {
        ADD_ROW,
        REMOVE_ROW,
        MODIFY_ROW,
    }

    export namespace ForeignKeyMatch {
        export const $gtype: GObject.GType<ForeignKeyMatch>;
    }

    enum ForeignKeyMatch {
        NONE,
        FULL,
        PARTIAL,
    }

    export namespace ForeignKeyRule {
        export const $gtype: GObject.GType<ForeignKeyRule>;
    }

    enum ForeignKeyRule {
        NONE,
        CASCADE,
        SET_NULL,
        SET_DEFAULT,
        RESTRICT,
        NO_ACTION,
    }

    export namespace HolderError {
        export const $gtype: GObject.GType<HolderError>;
    }

    enum HolderError {
        STRING_CONVERSION_ERROR,
        VALUE_TYPE_ERROR,
        VALUE_NULL_ERROR,
        VALUE_CHANGE_ERROR,
    }
    /**
     * Type of database object which can be handled as a #GdaMetaDbObject
     */

    /**
     * Type of database object which can be handled as a #GdaMetaDbObject
     */
    export namespace MetaDbObjectType {
        export const $gtype: GObject.GType<MetaDbObjectType>;
    }

    enum MetaDbObjectType {
        /**
         * unknown type
         */
        UNKNOWN,
        /**
         * represents a table
         */
        TABLE,
        /**
         * represents a view
         */
        VIEW,
    }
    /**
     * Defines the filtering policy of a foreign key when invoked on an UPDATE
     * or DELETE operation.
     */

    /**
     * Defines the filtering policy of a foreign key when invoked on an UPDATE
     * or DELETE operation.
     */
    export namespace MetaForeignKeyPolicy {
        export const $gtype: GObject.GType<MetaForeignKeyPolicy>;
    }

    enum MetaForeignKeyPolicy {
        /**
         * unspecified policy
         */
        UNKNOWN,
        /**
         * not enforced policy
         */
        NONE,
        /**
         * return an error, no action taken
         */
        NO_ACTION,
        /**
         * same as `GDA_META_FOREIGN_KEY_NO_ACTION,` not deferrable
         */
        RESTRICT,
        /**
         * policy is to delete any rows referencing the deleted row, or update the value of the referencing column to the new value of the referenced column, respectively
         */
        CASCADE,
        /**
         * policy is to set the referencing column to NULL
         */
        SET_NULL,
        /**
         * policy is to set the referencing column to its default value
         */
        SET_DEFAULT,
    }
    /**
     * Types of sorting
     */

    /**
     * Types of sorting
     */
    export namespace MetaSortType {
        export const $gtype: GObject.GType<MetaSortType>;
    }

    enum MetaSortType {
        /**
         * sort alphabetically
         */
        ALHAPETICAL,
        /**
         * sort by dependencies
         */
        DEPENDENCIES,
    }

    export namespace MetaStoreChangeType {
        export const $gtype: GObject.GType<MetaStoreChangeType>;
    }

    enum MetaStoreChangeType {
        ADD,
        REMOVE,
        MODIFY,
    }

    export namespace MetaStoreError {
        export const $gtype: GObject.GType<MetaStoreError>;
    }

    enum MetaStoreError {
        INCORRECT_SCHEMA_ERROR,
        UNSUPPORTED_PROVIDER_ERROR,
        INTERNAL_ERROR,
        META_CONTEXT_ERROR,
        MODIFY_CONTENTS_ERROR,
        EXTRACT_SQL_ERROR,
        ATTRIBUTE_NOT_FOUND_ERROR,
        ATTRIBUTE_ERROR,
        SCHEMA_OBJECT_NOT_FOUND_ERROR,
        SCHEMA_OBJECT_CONFLICT_ERROR,
        SCHEMA_OBJECT_DESCR_ERROR,
        TRANSACTION_ALREADY_STARTED_ERROR,
    }

    export namespace MetaStructError {
        export const $gtype: GObject.GType<MetaStructError>;
    }

    enum MetaStructError {
        UNKNOWN_OBJECT_ERROR,
        DUPLICATE_OBJECT_ERROR,
        INCOHERENCE_ERROR,
        XML_ERROR,
    }
    class ProviderMetaError extends GLib.Error {
        static $gtype: GObject.GType<ProviderMetaError>;

        // Static fields

        static NO_CONNECTION_ERROR: number;
        static QUERY_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    export namespace ServerOperationError {
        export const $gtype: GObject.GType<ServerOperationError>;
    }

    enum ServerOperationError {
        OBJECT_NAME_ERROR,
        INCORRECT_VALUE_ERROR,
        XML_ERROR,
    }

    export namespace ServerOperationNodeStatus {
        export const $gtype: GObject.GType<ServerOperationNodeStatus>;
    }

    enum ServerOperationNodeStatus {
        OPTIONAL,
        REQUIRED,
        UNKNOWN,
    }

    export namespace ServerOperationNodeType {
        export const $gtype: GObject.GType<ServerOperationNodeType>;
    }

    enum ServerOperationNodeType {
        PARAMLIST,
        DATA_MODEL,
        PARAM,
        SEQUENCE,
        SEQUENCE_ITEM,
        DATA_MODEL_COLUMN,
        UNKNOWN,
    }

    export namespace ServerOperationType {
        export const $gtype: GObject.GType<ServerOperationType>;
    }

    enum ServerOperationType {
        CREATE_DB,
        DROP_DB,
        CREATE_TABLE,
        DROP_TABLE,
        RENAME_TABLE,
        ADD_COLUMN,
        DROP_COLUMN,
        RENAME_COLUMN,
        CREATE_INDEX,
        DROP_INDEX,
        RENAME_INDEX,
        CREATE_VIEW,
        DROP_VIEW,
        COMMENT_TABLE,
        COMMENT_COLUMN,
        CREATE_USER,
        ALTER_USER,
        DROP_USER,
        LAST,
    }

    export namespace ServerProviderError {
        export const $gtype: GObject.GType<ServerProviderError>;
    }

    enum ServerProviderError {
        METHOD_NON_IMPLEMENTED_ERROR,
        PREPARE_STMT_ERROR,
        EMPTY_STMT_ERROR,
        MISSING_PARAM_ERROR,
        STATEMENT_EXEC_ERROR,
        OPERATION_ERROR,
        INTERNAL_ERROR,
        BUSY_ERROR,
        NON_SUPPORTED_ERROR,
        SERVER_VERSION_ERROR,
        DATA_ERROR,
        DEFAULT_VALUE_HANDLING_ERROR,
        MISUSE_ERROR,
        FILE_NOT_FOUND_ERROR,
    }
    /**
     * Represents the different types of sets of virtual functions which can be implemented for each provider
     */

    /**
     * Represents the different types of sets of virtual functions which can be implemented for each provider
     */
    export namespace ServerProviderFunctionsType {
        export const $gtype: GObject.GType<ServerProviderFunctionsType>;
    }

    enum ServerProviderFunctionsType {
        BASE,
        META,
        XA,
        MAX,
    }

    export namespace ServerProviderMetaType {
        export const $gtype: GObject.GType<ServerProviderMetaType>;
    }

    enum ServerProviderMetaType {
        _INFO,
        _BTYPES,
        _UDT,
        UDT,
        _UDT_COLS,
        UDT_COLS,
        _ENUMS,
        ENUMS,
        _DOMAINS,
        DOMAINS,
        _CONSTRAINTS_DOM,
        CONSTRAINTS_DOM,
        _EL_TYPES,
        EL_TYPES,
        _COLLATIONS,
        COLLATIONS,
        _CHARACTER_SETS,
        CHARACTER_SETS,
        _SCHEMATA,
        SCHEMATA,
        _TABLES_VIEWS,
        TABLES_VIEWS,
        _COLUMNS,
        COLUMNS,
        _VIEW_COLS,
        VIEW_COLS,
        _CONSTRAINTS_TAB,
        CONSTRAINTS_TAB,
        _CONSTRAINTS_REF,
        CONSTRAINTS_REF,
        _KEY_COLUMNS,
        KEY_COLUMNS,
        _CHECK_COLUMNS,
        CHECK_COLUMNS,
        _TRIGGERS,
        TRIGGERS,
        _ROUTINES,
        ROUTINES,
        _ROUTINE_COL,
        ROUTINE_COL,
        _ROUTINE_PAR,
        ROUTINE_PAR,
        _INDEXES_TAB,
        INDEXES_TAB,
        _INDEX_COLS,
        INDEX_COLS,
    }

    export namespace SetError {
        export const $gtype: GObject.GType<SetError>;
    }

    enum SetError {
        XML_SPEC_ERROR,
        HOLDER_NOT_FOUND_ERROR,
        INVALID_ERROR,
        READ_ONLY_ERROR,
        IMPLEMENTATION_ERROR,
    }
    /**
     * Type of part.
     */

    /**
     * Type of part.
     */
    export namespace SqlAnyPartType {
        export const $gtype: GObject.GType<SqlAnyPartType>;
    }

    enum SqlAnyPartType {
        /**
         * structure is a #GdaSqlStatementSelect
         */
        STMT_SELECT,
        /**
         * structure is a #GdaSqlStatementInsert
         */
        STMT_INSERT,
        /**
         * structure is a #GdaSqlStatementUpdate
         */
        STMT_UPDATE,
        /**
         * structure is a #GdaSqlStatementDelete
         */
        STMT_DELETE,
        /**
         * structure is a #GdaSqlStatementCompound
         */
        STMT_COMPOUND,
        /**
         * structure is a #GdaSqlStatementTransaction
         */
        STMT_BEGIN,
        /**
         * structure is a #GdaSqlStatementTransaction
         */
        STMT_ROLLBACK,
        /**
         * structure is a #GdaSqlStatementTransaction
         */
        STMT_COMMIT,
        /**
         * structure is a #GdaSqlStatementTransaction
         */
        STMT_SAVEPOINT,
        /**
         * structure is a #GdaSqlStatementTransaction
         */
        STMT_ROLLBACK_SAVEPOINT,
        /**
         * structure is a #GdaSqlStatementTransaction
         */
        STMT_DELETE_SAVEPOINT,
        /**
         * structure is a #GdaSqlStatementUnknown
         */
        STMT_UNKNOWN,
        /**
         * structure is a #GdaSqlExpr
         */
        EXPR,
        /**
         * structure is a #GdaSqlField
         */
        SQL_FIELD,
        /**
         * structure is a #GdaSqlTable
         */
        SQL_TABLE,
        /**
         * structure is a #GdaSqlFunction
         */
        SQL_FUNCTION,
        /**
         * structure is a #GdaSqlOperation
         */
        SQL_OPERATION,
        /**
         * structure is a #GdaSqlCase
         */
        SQL_CASE,
        /**
         * structure is a #GdaSqlSelectField
         */
        SQL_SELECT_FIELD,
        /**
         * structure is a #GdaSqlSelectTarget
         */
        SQL_SELECT_TARGET,
        /**
         * structure is a #GdaSqlSelectJoin
         */
        SQL_SELECT_JOIN,
        /**
         * structure is a #GdaSqlSelectFrom
         */
        SQL_SELECT_FROM,
        /**
         * structure is a #GdaSqlSelectOrder
         */
        SQL_SELECT_ORDER,
    }

    export namespace SqlBuilderError {
        export const $gtype: GObject.GType<SqlBuilderError>;
    }

    enum SqlBuilderError {
        WRONG_TYPE_ERROR,
        MISUSE_ERROR,
    }
    class SqlError extends GLib.Error {
        static $gtype: GObject.GType<SqlError>;

        // Static fields

        static STRUCTURE_CONTENTS_ERROR: number;
        static MALFORMED_IDENTIFIER_ERROR: number;
        static MISSING_IDENTIFIER_ERROR: number;
        static VALIDATION_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    export namespace SqlOperatorType {
        export const $gtype: GObject.GType<SqlOperatorType>;
    }

    enum SqlOperatorType {
        AND,
        OR,
        EQ,
        IS,
        LIKE,
        BETWEEN,
        GT,
        LT,
        GEQ,
        LEQ,
        DIFF,
        REGEXP,
        REGEXP_CI,
        NOT_REGEXP,
        NOT_REGEXP_CI,
        SIMILAR,
        ISNULL,
        ISNOTNULL,
        NOT,
        IN,
        NOTIN,
        CONCAT,
        PLUS,
        MINUS,
        STAR,
        DIV,
        REM,
        BITAND,
        BITOR,
        BITNOT,
        ILIKE,
        NOTLIKE,
        NOTILIKE,
    }

    export namespace SqlParserError {
        export const $gtype: GObject.GType<SqlParserError>;
    }

    enum SqlParserError {
        SYNTAX_ERROR,
        OVERFLOW_ERROR,
        EMPTY_SQL_ERROR,
    }

    export namespace SqlParserFlavour {
        export const $gtype: GObject.GType<SqlParserFlavour>;
    }

    enum SqlParserFlavour {
        STANDARD,
        SQLITE,
        MYSQL,
        ORACLE,
        POSTGRESQL,
    }

    export namespace SqlParserMode {
        export const $gtype: GObject.GType<SqlParserMode>;
    }

    enum SqlParserMode {
        PARSE,
        DELIMIT,
    }

    export namespace SqlSelectJoinType {
        export const $gtype: GObject.GType<SqlSelectJoinType>;
    }

    enum SqlSelectJoinType {
        CROSS,
        NATURAL,
        INNER,
        LEFT,
        RIGHT,
        FULL,
    }

    export namespace SqlStatementCompoundType {
        export const $gtype: GObject.GType<SqlStatementCompoundType>;
    }

    enum SqlStatementCompoundType {
        UNION,
        UNION_ALL,
        INTERSECT,
        INTERSECT_ALL,
        EXCEPT,
        EXCEPT_ALL,
    }
    /**
     * Known types of statements
     */

    /**
     * Known types of statements
     */
    export namespace SqlStatementType {
        export const $gtype: GObject.GType<SqlStatementType>;
    }

    enum SqlStatementType {
        /**
         * a SELECT statement
         */
        SELECT,
        /**
         * an INSERT statement
         */
        INSERT,
        /**
         * an UPDATE statement
         */
        UPDATE,
        /**
         * a DELETE statement
         */
        DELETE,
        /**
         * a compound statement: multiple SELECT statements grouped together using an operator
         */
        COMPOUND,
        /**
         * start of transaction statement
         */
        BEGIN,
        /**
         * transaction abort statement
         */
        ROLLBACK,
        /**
         * transaction commit statement
         */
        COMMIT,
        /**
         * new savepoint definition statement
         */
        SAVEPOINT,
        /**
         * return to savepoint statement
         */
        ROLLBACK_SAVEPOINT,
        /**
         * savepoint deletion statement
         */
        DELETE_SAVEPOINT,
        /**
         * unknown statement, only identifies variables
         */
        UNKNOWN,
        /**
         * not used
         */
        NONE,
    }

    export namespace StatementError {
        export const $gtype: GObject.GType<StatementError>;
    }

    enum StatementError {
        PARSE_ERROR,
        SYNTAX_ERROR,
        NO_CNC_ERROR,
        CNC_CLOSED_ERROR,
        EXEC_ERROR,
        PARAM_TYPE_ERROR,
        PARAM_ERROR,
    }
    /**
     * Describes transactions' isolation level
     */

    /**
     * Describes transactions' isolation level
     */
    export namespace TransactionIsolation {
        export const $gtype: GObject.GType<TransactionIsolation>;
    }

    enum TransactionIsolation {
        /**
         * isolation level defined by the server
         */
        SERVER_DEFAULT,
        READ_COMMITTED,
        READ_UNCOMMITTED,
        REPEATABLE_READ,
        SERIALIZABLE,
    }

    export namespace TransactionStatusEventType {
        export const $gtype: GObject.GType<TransactionStatusEventType>;
    }

    enum TransactionStatusEventType {
        SAVEPOINT,
        SQL,
        SUB_TRANSACTION,
    }

    export namespace TransactionStatusState {
        export const $gtype: GObject.GType<TransactionStatusState>;
    }

    enum TransactionStatusState {
        OK,
        FAILED,
    }

    export namespace TreeError {
        export const $gtype: GObject.GType<TreeError>;
    }

    enum TreeError {
        TREE_UNKNOWN_ERROR,
    }

    export namespace TreeManagerError {
        export const $gtype: GObject.GType<TreeManagerError>;
    }

    enum TreeManagerError {
        TREE_MANAGER_UNKNOWN_ERROR,
    }

    export namespace TreeNodeError {
        export const $gtype: GObject.GType<TreeNodeError>;
    }

    enum TreeNodeError {
        TREE_NODE_UNKNOWN_ERROR,
    }
    class WorkerError extends GLib.Error {
        static $gtype: GObject.GType<WorkerError>;

        // Static fields

        static INTER_THREAD_ERROR: number;
        static JOB_NOT_FOUND_ERROR: number;
        static JOB_QUEUED_ERROR: number;
        static JOB_BEING_PROCESSED_ERROR: number;
        static JOB_PROCESSED_ERROR: number;
        static JOB_CANCELLED_ERROR: number;
        static THREAD_KILLED: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    export namespace XaTransactionError {
        export const $gtype: GObject.GType<XaTransactionError>;
    }

    enum XaTransactionError {
        ALREADY_REGISTERED_ERROR,
        DTP_NOT_SUPPORTED_ERROR,
        CONNECTION_BRANCH_LENGTH_ERROR,
    }

    export namespace XaType {
        export const $gtype: GObject.GType<XaType>;
    }

    enum XaType {
        START,
        END,
        PREPARE,
        COMMIT,
        ROLLBACK,
        RECOVER,
    }
    /**
     * The corresponding attribute specifies if the object it refers to is auto incremented (value has a G_TYPE_BOOLEAN type).
     */
    const ATTRIBUTE_AUTO_INCREMENT: string;
    /**
     * The corresponding attribute is the description of the object it refers to (value has a G_TYPE_STRING type).
     */
    const ATTRIBUTE_DESCRIPTION: string;
    /**
     * The corresponding attribute specifies if the object it refers to has its value to default (value has a G_TYPE_BOOLEAN type).
     */
    const ATTRIBUTE_IS_DEFAULT: string;
    /**
     * The corresponding attribute is the name of the object it refers to (value has a G_TYPE_STRING type).
     */
    const ATTRIBUTE_NAME: string;
    /**
     * The corresponding attribute is the number of significant digits of the object it refers to (value has a G_TYPE_INT type).
     */
    const ATTRIBUTE_NUMERIC_PRECISION: string;
    /**
     * The corresponding attribute is the number of significant digits to the right of the decimal point of the object it refers to (value has a G_TYPE_INT type).
     */
    const ATTRIBUTE_NUMERIC_SCALE: string;
    /**
     * This attribute, if %TRUE specifies that a tree node may or may not have any children nodes (value has a G_TYPE_BOOLEAN type).
     */
    const ATTRIBUTE_TREE_NODE_UNKNOWN_CHILDREN: string;
    const EXTRA_AUTO_INCREMENT: string;
    const SQLSTATE_GENERAL_ERROR: string;
    const SQLSTATE_NO_ERROR: string;
    const TIMEZONE_INVALID: number;
    /**
     * Does the opposite of gda_text_to_alphanum(), in the same string
     * @param text a string
     * @returns @text if conversion succeeded or %NULL if an error occurred
     */
    function alphanum_to_text(text: string): string | null;
    function column_attributes_from_string(str: string): ColumnAttributes;
    function column_attributes_items(result_length1: number): ColumnAttributes;
    function column_attributes_to_string(self: ColumnAttributes | null): string;
    /**
     * Creates an array of strings (terminated by a %NULL) corresponding to possible completions.
     * If no completion is available, then the returned array contains just one NULL entry, and
     * if it was not possible to try to compute a completions list, then %NULL is returned.
     * @param cnc a #GdaConnection object
     * @param sql a partial SQL statement which is the context of the completion proposal, may also start with a "." for       Gda's tools which use internal commands
     * @param start starting position within @sql of the "token" to complete (starts at 0)
     * @param end ending position within @sql of the "token" to complete
     * @returns a new array of strings, or %NULL (use g_strfreev() to free the returned array)
     */
    function completion_list_get(cnc: Connection, sql: string, start: number, end: number): string[] | null;
    /**
     * Creates an INSERT, an UPDATE and a DELETE statement from a SELECT statement
     * using the database metadata available in `cnc'`s meta store. Each statements are computed only if
     * the corresponding place to store the created statement is not %NULL.
     * @param cnc a #GdaConnection
     * @param select_stmt a SELECT #GdaStatement (compound statements not handled)
     * @param require_pk TRUE if the created statement have to use a primary key
     * @returns %TRUE if no error occurred
     */
    function compute_dml_statements(
        cnc: Connection,
        select_stmt: Statement,
        require_pk: boolean,
    ): [boolean, Statement | null, Statement | null, Statement | null];
    /**
     * Computes a SELECT statement which selects all the rows the `update_stmt` would update. Beware
     * however that this #GdaSqlStatement does not select anything (ie it would be rendered as "SELECT FROM ... WHERE ...")
     * and before being usable, one needs to add some fields to actually select.
     * @param update_stmt an UPDATE statement
     * @returns a new #GdaStatement if no error occurred, or %NULL otherwise
     */
    function compute_select_statement_from_update(update_stmt: Statement): SqlStatement | null;
    /**
     * Computes a #GdaSqlExpr expression which can be used in the WHERE clause of an UPDATE
     * or DELETE statement when a row from the result of the `stsel` statement has to be modified.
     * @param stsel a #GdaSqlSelectStatement
     * @param mtable a #GdaMetaTable
     * @param require_pk set to TRUE if a primary key ir required
     * @returns a new #GdaSqlExpr, or %NULL if an error occurred.
     */
    function compute_unique_table_row_condition(
        stsel: SqlStatementSelect,
        mtable: MetaTable,
        require_pk: boolean,
    ): SqlExpr | null;
    /**
     * Computes a #GdaSqlExpr expression which can be used in the WHERE clause of an UPDATE
     * or DELETE statement when a row from the result of the `stsel` statement has to be modified.
     *
     * If `require_pk` is %TRUE then this function will return a non %NULL #GdaSqlExpr only if it can
     * use a primary key of `mtable`. If `require_pk` is %FALSE, then it will try to use a primary key of `mtable,`
     * and if none is available, it will use all the columns of `mtable` to compute a condition statement.
     * @param cnc a #GdaConnection, or %NULL
     * @param stsel a #GdaSqlSelectStatement
     * @param mtable a #GdaMetaTable
     * @param require_pk set to %TRUE if a primary key is required
     * @returns a new #GdaSqlExpr, or %NULL if an error occurred.
     */
    function compute_unique_table_row_condition_with_cnc(
        cnc: Connection | null,
        stsel: SqlStatementSelect,
        mtable: MetaTable,
        require_pk: boolean,
    ): SqlExpr | null;
    /**
     * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
     * data handler will be adapted to use the current locale information (for example dates will be formatted
     * taking into account the locale).
     *
     * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
     * @param for_type a #GType type
     * @returns a #GdaDataHandler which must be destroyed using g_object_unref()
     */
    function data_handler_get_default(for_type: GObject.GType): DataHandler;
    function data_model_error_quark(): GLib.Quark;
    function date_time_copy(ts: GLib.DateTime): GLib.DateTime;
    function ddl_modifiable_error_quark(): GLib.Quark;
    /**
     * Escapes `string` to make it understandable by a DBMS. The escape method is very common and replaces any
     * occurrence of "'" with "''" and "\" with "\\"
     * @param string string to escape
     * @returns a new string
     */
    function default_escape_string(string: string): string | null;
    /**
     * Do the reverse of gda_default_escape_string(): transforms any "''" into "'", any
     * "\\" into "\" and any "\'" into "'".
     * @param string string to unescape
     * @returns a new unescaped string, or %NULL in an error was found in @string
     */
    function default_unescape_string(string: string): string | null;
    /**
     * Extract the DSN, username and password from `string`. in `string,` the various parts are strings
     * which are expected to be encoded using an RFC 1738 compliant encoding. If they are specified,
     * the returned username and password strings are correctly decoded.
     *
     * `out_username` and `out_password` may be set to %NULL depending on `string'`s format.
     * @param string a string in the "[&lt;username&gt;[:&lt;password&gt;]@]&lt;DSN&gt;" form
     * @param out_dsn a place to store the new string containing the &lt;DSN&gt; part
     * @param out_username a place to store the new string containing the &lt;username&gt; part
     * @param out_password a place to store the new string containing the &lt;password&gt; part
     */
    function dsn_split(string: string, out_dsn: string, out_username: string, out_password: string): void;
    function foreign_key_match_from_string(str: string): ForeignKeyMatch;
    function foreign_key_match_items(result_length1: number): ForeignKeyMatch;
    function foreign_key_match_to_string(self: ForeignKeyMatch | null): string;
    function foreign_key_rule_from_string(str: string): ForeignKeyRule;
    function foreign_key_rule_items(result_length1: number): ForeignKeyRule;
    function foreign_key_rule_to_string(self: ForeignKeyRule | null): string;
    /**
     * Converts a named type to ts GType type (also see the gda_g_type_to_string() function).
     *
     * This function is a wrapper around the g_type_from_name() function, but also recognizes
     * some type synonyms such as:
     * <itemizedlist>
     *   <listitem><para>"int" for G_TYPE_INT</para></listitem>
     *   <listitem><para>"uint" for G_TYPE_UINT</para></listitem>
     *   <listitem><para>"int64" for G_TYPE_INT64</para></listitem>
     *   <listitem><para>"uint64" for G_TYPE_UINT64</para></listitem>
     *   <listitem><para>"char" for G_TYPE_CHAR</para></listitem>
     *   <listitem><para>"uchar" for G_TYPE_UCHAR</para></listitem>
     *   <listitem><para>"short" for GDA_TYPE_SHORT</para></listitem>
     *   <listitem><para>"ushort" for GDA_TYPE_USHORT</para></listitem>
     *   <listitem><para>"string" for G_TYPE_STRING</para></listitem>
     *   <listitem><para>"date" for G_TYPE_DATE</para></listitem>
     *   <listitem><para>"time" for GDA_TYPE_TIME</para></listitem>
     *   <listitem><para>"timestamp" for G_TYPE_DATE_TIME</para></listitem>
     *   <listitem><para>"boolean" for G_TYPE_BOOLEAN</para></listitem>
     *   <listitem><para>"blob" for GDA_TYPE_BLOB</para></listitem>
     *   <listitem><para>"binary" for GDA_TYPE_BINARY</para></listitem>
     *   <listitem><para>"null" for GDA_TYPE_NULL</para></listitem>
     * </itemizedlist>
     * @param str the name of a #GType, as returned by gda_g_type_to_string().
     * @returns the #GType represented by the given @str, or #G_TYPE_INVALID if not found
     */
    function g_type_from_string(str: string): GObject.GType;
    /**
     * Converts a GType to its string representation (use gda_g_type_from_string() for the
     * operation in the other direction).
     *
     * This function wraps g_type_name() but for common types it provides an easier to
     * understand and remember name. For Example the G_TYPE_STRING is converted to "string"
     * whereas g_type_name() converts it to "gchararray".
     * @param type Type to convert from.
     * @returns the GDA's string representing the given #GType or the name returned by #g_type_name.
     */
    function g_type_to_string(type: GObject.GType): string;
    /**
     * Does the same as strcmp(`id1`, `id2`), but handles the case where id1 and/or id2 are enclosed in double quotes.
     * can also be used in hash tables as a #GEqualFunc.
     * @param id1 an identifier string
     * @param id2 an identifier string
     * @returns %TRUE if @id1 and @id2 are equal.
     */
    function identifier_equal(id1: string, id2: string): boolean;
    /**
     * computes a hash string from `id,` to be used in hash tables as a #GHashFunc
     * @param id an identifier string
     * @returns a new hash
     */
    function identifier_hash(id: string): number;
    /**
     * Disables GDA logs.
     */
    function log_disable(): void;
    /**
     * Enables GDA logs.
     */
    function log_enable(): void;
    function log_is_enabled(): boolean;
    /**
     * This function is similar to gda_parse_iso8601_date() (with `first` being `G_DATE_YEAR,` `second` being `G_DATE_MONTH,`
     * `third` being `G_DATE_DAY` and `sep` being '-') but allows one to specify the expected date format.
     * @param gdate a pointer to a #GDate structure which will be filled
     * @param value a string to be parsed
     * @param first a #GDateDMY specifying which of year, month or day appears first (in the first bytes) in @value
     * @param second a #GDateDMY specifying which of year, month or day appears second (in the first bytes) in @value
     * @param third a #GDateDMY specifying which of year, month or day appears third (in the first bytes) in @value
     * @param sep spcifies the expected separator character bewteen year, month and day (for example '-')
     * @returns %TRUE if @value has been sucessfuly parsed as a valid date (see g_date_valid()).
     */
    function parse_formatted_date(
        gdate: GLib.Date,
        value: string,
        first: GLib.DateDMY | null,
        second: GLib.DateDMY | null,
        third: GLib.DateDMY | null,
        sep: number,
    ): boolean;
    function parse_formatted_time(value: string, sep: number): Time;
    /**
     * This function is similar to g_date_time_new_from_iso8601() (with `first` being `G_DATE_YEAR,` `second` being `G_DATE_MONTH,`
     * `third` being `G_DATE_DAY` and `sep` being '-') but allows one to specify the expected date format.
     * @param value a string to be parsed
     * @param first a #GDateDMY specifying which of year, month or day appears first (in the first bytes) in @value
     * @param second a #GDateDMY specifying which of year, month or day appears second (in the first bytes) in @value
     * @param third a #GDateDMY specifying which of year, month or day appears third (in the first bytes) in @value
     * @param sep specifies the expected separator character between year, month and day (for example '-')
     * @returns a new #GDateTime if @value has been successfully parsed as a valid date (see g_date_valid()).
     */
    function parse_formatted_timestamp(
        value: string,
        first: GLib.DateDMY | null,
        second: GLib.DateDMY | null,
        third: GLib.DateDMY | null,
        sep: number,
    ): GLib.DateTime | null;
    /**
     * Extracts date parts from `value,` and sets `gdate'`s contents
     *
     * Accepted date format is "YYYY-MM-DD" (more or less than 4 digits for years and
     * less than 2 digits for month and day are accepted). Years must be in the 1-65535 range,
     * a limitation imposed by #GDate.
     * @param gdate a pointer to a #GDate structure which will be filled
     * @param value a string
     * @returns %TRUE if @value has been sucessfuly parsed as a valid date (see g_date_valid()).
     */
    function parse_iso8601_date(gdate: GLib.Date, value: string): boolean;
    /**
     * Extracts time parts from `value,` and sets `timegda'`s contents
     *
     * Accepted date format is "HH:MM:SS[.ms][TZ]" where TZ is +hour or -hour.
     * If no time zone is given UTC is used.
     * @param value a string
     * @returns a new parsed #GdaTime
     */
    function parse_iso8601_time(value: string): Time;
    function provider_meta_error_quark(): GLib.Quark;
    /**
     * Modifies `sqlst` to take into account any parameter which might be %NULL: if `sqlst` contains the
     * equivalent of "xxx = &lt;parameter definition&gt;" and if that parameter is in `params` and
     * its value is of type GDA_TYPE_NUL, then that part is replaced with "xxx IS NULL". It also
     * handles the "xxx IS NOT NULL" transformation.
     *
     * If `out_modified` is not %NULL, then it will be set to %TRUE if `sqlst` has been modified
     * by this function, and to %FALSE otherwise.
     *
     * This function is used by provider's implementations to make sure one can use parameters with
     * NULL values in statements without having to rewrite statements, as database usually don't
     * consider that "xxx = NULL" is the same as "xxx IS NULL" when using parameters.
     * @param sqlst a #GdaSqlStatement
     * @param params a #GdaSet to be used as parameters when executing @stmt
     * @returns the modified @sqlst statement, or %NULL if an error occurred
     */
    function rewrite_sql_statement_for_null_parameters(
        sqlst: SqlStatement,
        params: Set,
    ): [SqlStatement | null, boolean];
    /**
     * Modifies `stmt` to take into account any parameter which might be %NULL: if `stmt` contains the
     * equivalent of "xxx = &lt;parameter definition&gt;" and if that parameter is in `params` and
     * its value is of type GDA_TYPE_NUL, then that part is replaced with "xxx IS NULL". It also
     * handles the "xxx IS NOT NULL" transformation.
     *
     * For example the following SELECT:
     * <programlisting>SELECT * FROM data WHERE id = ##id::int::null AND name = ##name::string</programlisting>
     * in case the "id" parameter is set to NULL, is converted to:
     * <programlisting>SELECT * FROM data WHERE id IS NULL AND name = ##name::string</programlisting>
     *
     * if `out_stmt` is not %NULL, then it will contain:
     * <itemizedlist>
     *   <listitem><para>the modified statement if some modifications were required and no error occured (the function returns %TRUE)</para></listitem>
     *   <listitem><para>%NULL if no modification to `stmt` were required and no erro occurred (the function returns %FALSE)</para></listitem>
     *   <listitem><para>%NULL if an error occured (the function returns %TRUE)</para></listitem>
     * </itemizedlist>
     *
     * This function is used by provider's implementations to make sure one can use parameters with
     * NULL values in statements without having to rewrite statements, as database usually don't
     * consider that "xxx = NULL" is the same as "xxx IS NULL" when using parameters.
     * @param stmt a #GdaStatement
     * @param params a #GdaSet to be used as parameters when executing @stmt
     * @returns %TRUE if @stmt needs to be transformed to handle NULL parameters, and %FALSE otherwise
     */
    function rewrite_statement_for_null_parameters(stmt: Statement, params: Set): [boolean, Statement | null];
    /**
     * Decodes `string` using the RFC 1738 recommendations: the
     * <constant>&lt;&gt;&quot;#%{}|\^~[]&apos;`;/?:`=`&amp;</constant> and space characters are replaced by
     * <constant>&quot;%%ab&quot;</constant> where
     * <constant>ab</constant> is the hexadecimal number corresponding to the character.
     *
     * `string` should respect the RFC 1738 encoding. If this is not the case (for example if there
     * is a "%2z" because 2z is not an hexadecimal value), then the part with the problem
     * is not decoded, and the function returns FALSE.
     *
     * `string` is decoded in place, no new string gets created.
     * @param string a string to decode
     * @returns %TRUE if no error occurred.
     */
    function rfc1738_decode(string: string): boolean;
    /**
     * Encodes `string` using the RFC 1738 recommendations: the
     * <constant>&lt;&gt;&quot;#%{}|\^~[]&apos;`;/?:`=`&amp;</constant> and space characters are replaced by
     * <constant>&quot;%%ab&quot;</constant> where
     * <constant>ab</constant> is the hexadecimal number corresponding to the character.
     * @param string a string to encode
     * @returns a new string or %NULL
     */
    function rfc1738_encode(string: string): string | null;
    /**
     * Creates a new #GdaStatement, selecting the same data as `stmt,` but which always returns an
     * empty (no row) data model. This is use dy database providers' implementations.
     * @param stmt a SELECT #GdaStatement
     * @returns a new #GdaStatement
     */
    function select_alter_select_for_empty(stmt: Statement): Statement;
    function server_operation_create_table_arg_get_fkey_ref_field_get_type(): GObject.GType;
    function sql_error_quark(): GLib.Quark;
    /**
     * Add double quotes around the `str` identifier. This function is normally used only by database provider's
     * implementation. Any double quote character is replaced by two double quote characters.
     *
     * For other uses, see gda_sql_identifier_quote().
     * @param str an SQL identifier
     */
    function sql_identifier_force_quotes(str: string): string;
    /**
     * Prepares `str` to be compared:
     * <itemizedlist>
     * <listitem><para>if surrounded by double quotes or single quotes, then just remove the quotes</para></listitem>
     * <listitem><para>otherwise convert to lower case</para></listitem>
     * </itemizedlist>
     *
     * The quoted string:
     * <itemizedlist>
     *   <listitem><para>must start and finish with the same single or double quotes character</para></listitem>
     *   <listitem><para>can contain the delimiter character (the single or double quotes) in the string if every instance
     *     of it is preceeded with a backslash character or with the delimiter character itself</para></listitem>
     * </itemizedlist>
     *
     * This function is normally used only by database provider's implementation.
     *
     * WARNING: `str` must NOT be a composed identifier (&lt;part1&gt;."&lt;part2&gt;" for example)
     * WARNING: you may have to <code>#include &lt;sql-parser/gda-sql-parser.h&gt;</code>
     * @param str a quoted string
     * @returns @str
     */
    function sql_identifier_prepare_for_compare(str: string): string;
    /**
     * Use this function for any SQL identifier to make sure that:
     * <itemizedlist>
     *   <listitem>
     *     <para>it is correctly formatted
     *           to be used with `cnc` (if `cnc` is %NULL, then some default SQL quoting rules will be applied,
     *           similar to PostgreSQL's way) if `for_meta_store` is %FALSE;
     *     </para>
     *   </listitem>
     *   <listitem>
     *     <para>it is correctly formatted to be used with the #GdaMetaStore's object associated to `cnc`
     *           is `for_meta_store` is %TRUE.
     *     </para>
     *   </listitem>
     * </itemizedlist>
     *
     * The `force_quotes` allow some control of how to interpret `id:` if %FALSE, then `id` will be left
     * unchanged most of the time (except for example if it's a reserved keyword), otherwise
     * if `force_quotes` is %TRUE, then the returned string will most probably have quotes around it
     * to request that the database keep the case sensitiveness (but again, this may vary depending
     * on the database being accessed through `cnc)`.
     *
     * For example, the following table gives the result of this function depending on the arguments
     * when `cnc` is %NULL (and `prov` is also %NULL):
     * <table frame="all">
     *  <tgroup cols="6" colsep="1" rowsep="1" align="justify">
     *    <thead>
     *      <row>
     *        <entry>id</entry>
     *        <entry>for_meta_store=%FALSE, force_quotes=%FALSE</entry>
     *        <entry>for_meta_store=%TRUE, force_quotes=%FALSE</entry>
     *        <entry>for_meta_store=%FALSE, force_quotes=%TRUE</entry>
     *        <entry>for_meta_store=%TRUE, force_quotes=%TRUE</entry>
     *        <entry>remark</entry>
     *      </row>
     *    </thead>
     *    <tbody>
     *      <row>
     *        <entry>"double word"</entry>
     *        <entry>"double word"</entry>
     *        <entry>"double word"</entry>
     *        <entry>"double word"</entry>
     *        <entry>"double word"</entry>
     *        <entry>non allowed character in SQL identifier</entry>
     *      </row>
     *      <row>
     *        <entry>"CapitalTest"</entry>
     *        <entry>"CapitalTest"</entry>
     *        <entry>"CapitalTest"</entry>
     *        <entry>"CapitalTest"</entry>
     *        <entry>"CapitalTest"</entry>
     *        <entry>Mixed case SQL identifier, already quoted</entry>
     *      </row>
     *      <row>
     *        <entry>CapitalTest</entry>
     *        <entry>CapitalTest</entry>
     *        <entry>capitaltest</entry>
     *        <entry>"CapitalTest"</entry>
     *        <entry>"CapitalTest"</entry>
     *        <entry>Mixed case SQL identifier, non quoted</entry>
     *      </row>
     *      <row>
     *        <entry>"mytable"</entry>
     *        <entry>"mytable"</entry>
     *        <entry>mytable</entry>
     *        <entry>"mytable"</entry>
     *        <entry>mytable</entry>
     *        <entry>All lowser case, quoted</entry>
     *      </row>
     *      <row>
     *        <entry>mytable</entry>
     *        <entry>mytable</entry>
     *        <entry>mytable</entry>
     *        <entry>"mytable"</entry>
     *        <entry>mytable</entry>
     *        <entry>All lowser case</entry>
     *      </row>
     *      <row>
     *        <entry>MYTABLE</entry>
     *        <entry>MYTABLE</entry>
     *        <entry>mytable</entry>
     *        <entry>"MYTABLE"</entry>
     *        <entry>"MYTABLE"</entry>
     *        <entry>All upper case</entry>
     *      </row>
     *      <row>
     *        <entry>"MYTABLE"</entry>
     *        <entry>"MYTABLE"</entry>
     *        <entry>"MYTABLE"</entry>
     *        <entry>"MYTABLE"</entry>
     *        <entry>"MYTABLE"</entry>
     *        <entry>All upper case, quoted</entry>
     *      </row>
     *      <row>
     *        <entry>desc</entry>
     *        <entry>"desc"</entry>
     *        <entry>"desc"</entry>
     *        <entry>"desc"</entry>
     *        <entry>"desc"</entry>
     *        <entry>SQL reserved keyword</entry>
     *      </row>
     *      <row>
     *        <entry>5ive</entry>
     *        <entry>"5ive"</entry>
     *        <entry>"5ive"</entry>
     *        <entry>"5ive"</entry>
     *        <entry>"5ive"</entry>
     *        <entry>SQL identifier starting with a digit</entry>
     *      </row>
     *    </tbody>
     *  </tgroup>
     * </table>
     *
     * Here are a few examples of when and how to use this function:
     * <itemizedlist>
     *   <listitem>
     *     <para>
     *       When creating a table, the user has entered the table name, this function can be used to
     *       create a valid SQL identifier from the user provided table name:
     *       <programlisting>
     * gchar *user_sqlid=...
     * gchar *valid_sqlid = gda_sql_identifier_quote (user_sqlid, cnc, NULL, FALSE, FALSE);
     * gchar *sql = g_strdup_printf ("CREATE TABLE %s ...", valid_sqlid);
     * g_free (valid_sqlid);
     *       </programlisting>
     *       Note that this is an illustration and creating a table should be sone using a #GdaServerOperation
     *       object.
     *     </para>
     *   </listitem>
     *   <listitem>
     *     <para>
     *      When updating the meta data associated to a table which has been created with the code
     *      above:
     *      <programlisting>
     * GValue table_name_value = { 0 };
     * gchar* column_names[] = { (gchar*)"table_name" };
     * GValue* column_values[] = { &table_name_value };
     * GdaMetaContext mcontext = { (gchar*)"_tables", 1, column_names, column_values };
     * g_value_init (&amp;table_name_value, G_TYPE_STRING);
     * g_value_take_string (&amp;table_name_value, gda_sql_identifier_quote (user_sqlid, cnc, NULL, TRUE, FALSE);
     * gda_connection_update_meta_store (cnc, &amp;mcontext, NULL);
     * g_value_reset (&amp;table_name_value);
     *       </programlisting>
     *     </para>
     *   </listitem>
     *   <listitem>
     *     <para>
     *      When using a #GdaMetaStruct object to fetch information about a table (which has been created with
     *      the code above):
     *      <programlisting>
     * GValue table_name_value = { 0 };
     * g_value_init (&amp;table_name_value, G_TYPE_STRING);
     * g_value_take_string (&amp;table_name_value, gda_sql_identifier_quote (user_sqlid, cnc, NULL, TRUE, FALSE);
     * GdaMetaDbObject *dbo;
     * dbo = gda_meta_struct_complement (mstruct, GDA_META_DB_TABLE, NULL, NULL, &amp;table_name_value, NULL);
     * g_value_reset (&amp;table_name_value);
     *       </programlisting>
     *     </para>
     *   </listitem>
     * </itemizedlist>
     *
     *
     * Note that `id` must not be a composed SQL identifier (such as "mytable.mycolumn" which should be
     * treated as the "mytable" and "mycolumn" SQL identifiers). If unsure, use gda_sql_identifier_split().
     *
     * Also note that if `cnc` is %NULL, then it's possible to pass an non %NULL `prov` to have a result specific
     * to `prov`.
     *
     * For more information, see the <link linkend="gen:sql_identifiers">SQL identifiers and abstraction</link> and
     * <link linkend="information_schema:sql_identifiers">SQL identifiers in meta data</link> sections.
     * @param id an SQL identifier
     * @param cnc a #GdaConnection object, or %NULL
     * @param prov a #GdaServerProvider object, or %NULL @for_meta_store set to %TRUE if the returned string will be used in a #GdaMetaStore
     * @param meta_store_convention
     * @param force_quotes set to %TRUE to force the returned string to be quoted
     * @returns the representation of @id ready to be used in SQL statement, as a new string,          or %NULL if @id is in a wrong format
     */
    function sql_identifier_quote(
        id: string,
        cnc: Connection | null,
        prov: ServerProvider | null,
        meta_store_convention: boolean,
        force_quotes: boolean,
    ): string | null;
    /**
     * Splits `id` into an array of it sub parts. `id'`s format has to be "&lt;part&gt;[.&lt;part&gt;[...]]" where
     * each part is either a text surrounded by double quotes which can contain upper and lower cases or
     * an SQL identifier in lower case.
     *
     * For example the <![CDATA["test.\"ATable\""]]> string will result in the array: <![CDATA[{"test", "\"ATable\"", NULL}]]>
     * @param id an SQL identifier
     * @returns a new %NULL-terminated array of strings, or NULL (use g_strfreev() to free the returned array)
     */
    function sql_identifier_split(id: string): string[] | null;
    /**
     * Returns #GdaSqlOperatorType that correspond with the string `op`.
     * @param op a #GdaSqlOperation structure
     * @returns #GdaSqlOperatorType
     */
    function sql_operation_operator_from_string(op: string): SqlOperatorType;
    /**
     * Returns a constant string representing a operator name. You don't need to free
     * the returned string.
     * @param op a #GdaSqlOperation structure
     * @returns a string with the operator's name or NULL in case @op is invalid.
     */
    function sql_operation_operator_to_string(op: SqlOperatorType | null): string;
    /**
     * Creates a new string representing the join type.
     * @param type a #GdaSqlSelectJoinType structure to be copied
     * @returns a string representing the Join type.
     */
    function sql_select_join_type_to_string(type: SqlSelectJoinType | null): string;
    function sql_statement_get_contents_infos(type: SqlStatementType | null): SqlStatementContentsInfo;
    /**
     * Converts a string to a #GdaSqlStatementType value, see also gda_sql_statement_type_to_string()
     * @param type a string representing a #GdaSqlStatementType type
     * @returns a #GdaSqlStatementType value
     */
    function sql_statement_string_to_type(type: string): SqlStatementType;
    /**
     * Converts a #GdaSqlStatementType to a string, see also gda_sql_statement_string_to_type()
     * @param type a #GdaSqlStatementType value
     * @returns a constant string
     */
    function sql_statement_type_to_string(type: SqlStatementType | null): string;
    /**
     * Simplified version of gda_value_stringify().
     * @param value a #GValue pointer
     * @returns a new string
     */
    function sql_value_stringify(value: GObject.Value | any): string;
    /**
     * Performs the reverse of gda_binary_to_string() (note that for any "\xyz" succession
     * of 4 characters where "xyz" represents a valid octal value, the resulting read value will
     * be modulo 256).
     *
     * I `str` is %NULL, then an empty (i.e. where the `data` part is %NULL) #GdaBinary is created and returned.
     * @param str a string to convert, or %NULL
     * @returns a new #GdaBinary if no error were found in @str, or %NULL otherwise
     */
    function string_to_binary(str?: string | null): Binary;
    /**
     * Performs the reverse of gda_blob_to_string().
     * @param str a string to convert
     * @returns a new #gdaBlob if no error were found in @str, or NULL otherwise
     */
    function string_to_blob(str: string): Blob;
    /**
     * The "encoding" consists in replacing non
     * alphanumeric character with the string "__gdaXX" where XX is the hex. representation
     * of the non alphanumeric char.
     * @param text the text to convert
     * @returns a new string
     */
    function text_to_alphanum(text: string): string;
    /**
     * Check the column types of a GdaDataModel.
     * @param model a #GdaDataModel object
     * @param types array with @nbcols length of type GType or null (if any data type is accepted)
     * @returns %TRUE if the data model's columns match the provided data types and number
     */
    function utility_check_data_model(model: DataModel, types: GObject.GType[]): boolean;
    /**
     * Dump the data in a #GdaDataModel into a xmlNodePtr (as used in libxml).
     *
     * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
     * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
     * to access data in `model` previously to calling this method, and this iterator will be moved (point to
     * another row).
     * @param model a #GdaDataModel
     * @param parent the parent XML node
     * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
     * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
     * @param use_col_ids set to %TRUE to add column ID information
     * @returns %TRUE if no error occurred
     */
    function utility_data_model_dump_data_to_xml(
        model: DataModel,
        parent: libxml2.NodePtr,
        cols: number[] | null,
        rows: number[] | null,
        use_col_ids: boolean,
    ): boolean;
    /**
     * Finds the description of a field into Metadata from a #GdaDataModel.
     * @param model a #GdaDataSelect data model
     * @param field_name field name
     * @returns The field's description, or NULL if description is not set
     */
    function utility_data_model_find_column_description(model: DataSelect, field_name: string): string | null;
    /**
     * Note: this method may set the "source" custom string property
     * @param holder a #GdaHolder
     * @param node an xmlNodePtr with a &lt;parameter&gt; tag
     * @param sources a list of #GdaDataModel
     * @returns %TRUE if no error occurred
     */
    function utility_holder_load_attributes(
        holder: Holder,
        node: libxml2.NodePtr,
        sources?: DataModel[] | null,
    ): boolean;
    /**
     * Compares two values of the same type, with the exception that a value of any type can be
     * compared to a GDA_TYPE_NULL value, specifically:
     * <itemizedlist>
     *   <listitem><para>if `value1` and `value2` are both GDA_TYPE_NULL values then the returned value is 0</para></listitem>
     *   <listitem><para>if `value1` is a GDA_TYPE_NULL value and `value2` is of another type then the returned value is -1</para></listitem>
     *   <listitem><para>if `value1` is of another type and `value2` is a GDA_TYPE_NULL value then the returned value is 1</para></listitem>
     *   <listitem><para>in all other cases, `value1` and `value2` must be of the same type and their values are compared</para></listitem>
     * </itemizedlist>
     * @param value1 a #GValue to compare (not %NULL)
     * @param value2 the other #GValue to be compared to @value1 (not %NULL)
     * @returns if both values have the same type, returns 0 if both contain the same value, an integer less than 0 if @value1 is less than @value2 or an integer greater than 0 if @value1 is greater than @value2.
     */
    function value_compare(value1: GObject.Value | any, value2: GObject.Value | any): number;
    /**
     * Creates a new #GValue from an existing one.
     * @param value value to get a copy from.
     * @returns a newly allocated #GValue with a copy of the data in @value. Free-function: gda_value_free
     */
    function value_copy(value: GObject.Value | any): unknown;
    /**
     * Tells if two values are equal or not, by comparing memory representations. Unlike gda_value_compare(),
     * the returned value is boolean, and gives no idea about ordering.
     *
     * The two values must be of the same type, with the exception that a value of any type can be
     * compared to a GDA_TYPE_NULL value, specifically:
     * <itemizedlist>
     *   <listitem><para>if `value1` and `value2` are both GDA_TYPE_NULL values then the returned value is 0</para></listitem>
     *   <listitem><para>if `value1` is a GDA_TYPE_NULL value and `value2` is of another type then the returned value is 1</para></listitem>
     *   <listitem><para>if `value1` is of another type and `value2` is a GDA_TYPE_NULL value then the returned value is 1</para></listitem>
     *   <listitem><para>in all other cases, `value1` and `value2` must be of the same type and their values are compared</para></listitem>
     * </itemizedlist>
     * @param value1 a #GValue to compare.
     * @param value2 the other #GValue to be compared to @value1.
     * @returns a non 0 value if @value1 and @value2 differ, and 0 if they are equal
     */
    function value_differ(value1: GObject.Value | any, value2: GObject.Value | any): number;
    /**
     * Deallocates all memory associated to a #GValue.
     * @param value the resource to free (or %NULL)
     */
    function value_free(value?: GObject.Value | null): void;
    function value_get_binary(value: GObject.Value | any): Binary;
    function value_get_blob(value: GObject.Value | any): Blob;
    function value_get_geometric_point(value: GObject.Value | any): GeometricPoint;
    function value_get_meta_store_change(value: GObject.Value | any): MetaStoreChange;
    function value_get_numeric(value: GObject.Value | any): Numeric;
    function value_get_short(value: GObject.Value | any): number;
    function value_get_time(value: GObject.Value | any): Time;
    function value_get_ushort(value: GObject.Value | any): number;
    /**
     * Tests if a given `value` is of type #GDA_TYPE_NULL.
     * @param value value to test.
     * @returns a boolean that says whether or not @value is of type #GDA_TYPE_NULL.
     */
    function value_is_null(value: GObject.Value | any): boolean;
    /**
     * Gets whether the value stored in the given #GValue is of numeric type or not.
     * @param value a #GValue.
     * @returns %TRUE if a number, %FALSE otherwise.
     */
    function value_is_number(value: GObject.Value | any): boolean;
    /**
     * Creates a new #GValue of type `type,` left in the same state as when g_value_init() is called.
     * @param type the new value type.
     * @returns the newly created #GValue with the specified @type. You need to set the value in the returned GValue. Free-function: gda_value_free
     */
    function value_new(type: GObject.GType): unknown;
    /**
     * Makes a new #GValue of type #GDA_TYPE_BINARY with value `val`.
     * @param val value to set for the new #GValue.
     * @param size the size of the memory pool pointer to by @val.
     * @returns the newly created #GValue. Free-function: gda_value_free
     */
    function value_new_binary(val: number, size: number): unknown;
    /**
     * Makes a new #GValue of type #GDA_TYPE_BLOB with the data contained by `val`.
     * @param val value to set for the new #GValue.
     * @param size the size of the memory pool pointer to by @val.
     * @returns the newly created #GValue. Free-function: gda_value_free
     */
    function value_new_blob(val: number, size: number): unknown;
    /**
     * Makes a new #GValue of type #GDA_TYPE_BLOB interfacing with the contents of the file
     * named `filename`
     * @param filename name of the file to manipulate
     * @returns the newly created #GValue. Free-function: gda_value_free
     */
    function value_new_blob_from_file(filename: string): unknown;
    /**
     * Makes a new #GValue of type #G_TYPE_DATE_TIME with value `val`
     * (of type time_t). The returned timestamp's value is relative to the current
     * timezone (i.e. is localtime).
     *
     * For example, to get a time stamp representing the current date and time, use:
     *
     * <code>
     * ts = gda_value_new_date_time_from_timet (time (NULL));
     * </code>
     * @param val value to set for the new #GValue.
     * @returns the newly created #GValue, or %NULL in case of error Free-function: gda_value_free
     */
    function value_new_date_time_from_timet(val: number): unknown;
    /**
     * Creates a new default value.
     * @param default_val the default value as a string, or %NULL
     * @returns a new #GValue of the type #GDA_TYPE_DEFAULT
     */
    function value_new_default(default_val?: string | null): unknown;
    /**
     * Makes a new #GValue of type `type` from its string representation.
     *
     * For more information
     * about the string format, see the gda_value_set_from_string() function.
     * This function is typically used when reading configuration files or other non-user input that should be locale
     * independent.
     * @param as_string stringified representation of the value.
     * @param type the new value type.
     * @returns the newly created #GValue or %NULL if the string representation cannot be converted to the specified @type. Free-function: gda_value_free
     */
    function value_new_from_string(as_string: string, type: GObject.GType): unknown;
    /**
     * Creates a GValue from an XML representation of it. That XML
     * node corresponds to the following string representation:
     * &lt;value type="gdatype"&gt;value&lt;/value&gt;
     *
     * For more information
     * about the string format, see the gda_value_set_from_string() function.
     * This function is typically used when reading configuration files or other non-user input that should be locale
     * independent.
     * @param node an XML node representing the value.
     * @returns the newly created #GValue. Free-function: gda_value_free
     */
    function value_new_from_xml(node: libxml2.NodePtr): unknown;
    /**
     * Creates a new #GValue initiated to a #GdaNull structure with a #GDA_TYPE_NULL, to
     * represent a NULL in the database.
     * @returns a new #GValue of the type #GDA_TYPE_NULL
     */
    function value_new_null(): unknown;
    /**
     * Makes a new #GValue of type #GDA_TYPE_TIME with value `val`
     * (of type time_t). The returned times's value is relative to the current
     * timezone (i.e. is localtime).
     *
     * For example, to get a time representing the current time, use:
     *
     * <code>
     * ts = gda_value_new_time_from_timet (time (NULL));
     * </code>
     * @param val value to set for the new #GValue.
     * @returns the newly created #GValue, or %NULL in case of error Free-function: gda_value_free
     */
    function value_new_time_from_timet(val: number): unknown;
    /**
     * Resets the #GValue and set a new type to #GType.
     * @param value the #GValue to be reseted
     * @param type the #GType to set to
     */
    function value_reset_with_type(value: GObject.Value | any, type: GObject.GType): void;
    /**
     * Stores `val` into `value`.
     * @param value a #GValue that will store @val.
     * @param binary a #GdaBinary structure with the data and its size to be stored in @value.
     */
    function value_set_binary(value: GObject.Value | any, binary: Binary): void;
    /**
     * Stores `val` into `value`.
     * @param value a #GValue that will store @val.
     * @param blob a #GdaBlob structure with the data and its size to be stored in @value.
     */
    function value_set_blob(value: GObject.Value | any, blob: Blob): void;
    /**
     * Stores the value data from its string representation as `type`.
     *
     * The accepted formats are:
     * <itemizedlist>
     *   <listitem><para>G_TYPE_BOOLEAN: a caseless comparison is made with "true" or "false"</para></listitem>
     *   <listitem><para>numerical types: C locale format (dot as a fraction separator)</para></listitem>
     *   <listitem><para>G_TYPE_DATE: see <link linkend="gda-parse-iso8601-date">gda_parse_iso8601_date()</link></para></listitem>
     *   <listitem><para>GDA_TYPE_TIME: see <link linkend="gda-parse-iso8601-time">gda_parse_iso8601_time()</link></para></listitem>
     *   <listitem><para>GDA_TYPE_TIMESTAMP: see <link linkend="g-date-time-new-iso8601">g_date_time_new_from_iso8601()</link></para></listitem>
     * </itemizedlist>
     *
     * This function is typically used when reading configuration files or other non-user input that should be locale
     * independent.
     * @param value a #GValue that will store @val.
     * @param as_string the stringified representation of the value.
     * @param type the type of the value
     * @returns %TRUE if the value has been converted to @type from its string representation; it not means that the value is converted successfully, just that the transformation is available. %FALSE otherwise.
     */
    function value_set_from_string(value: GObject.Value | any, as_string: string, type: GObject.GType): boolean;
    /**
     * Sets the value of a #GValue from another #GValue. This
     * is different from #gda_value_copy, which creates a new #GValue.
     * #gda_value_set_from_value, on the other hand, copies the contents
     * of `copy` into `value,` which must already be allocated.
     *
     * If values are incompatible (see `g_value_type_compatible)` then `value` is set to a
     * #GDA_TYPE_NULL, and %FALSE is returned.
     * @param value a #GValue.
     * @param from the value to copy from.
     * @returns %TRUE if successful, %FALSE otherwise.
     */
    function value_set_from_value(value: GObject.Value | any, from: GObject.Value | any): boolean;
    /**
     * Stores `val` into `value`.
     * @param value a #GValue that will store @val.
     * @param val value to be stored in @value.
     */
    function value_set_geometric_point(value: GObject.Value | any, val: GeometricPoint): void;
    function value_set_meta_store_change(value: GObject.Value | any, change: MetaStoreChange): void;
    /**
     * Sets the type of `value` to #GDA_TYPE_NULL.
     * @param value a #GValue that will store a value of type #GDA_TYPE_NULL.
     */
    function value_set_null(value: GObject.Value | any): void;
    /**
     * Stores `val` into `value`.
     * @param value a #GValue that will store @val.
     * @param val value to be stored in @value.
     */
    function value_set_numeric(value: GObject.Value | any, val: Numeric): void;
    /**
     * Stores `val` into `value`.
     * @param value a #GValue that will store @val.
     * @param val value to be stored in @value.
     */
    function value_set_short(value: GObject.Value | any, val: number): void;
    /**
     * Stores `val` into `value`.
     * @param value a #GValue that will store @val.
     * @param val value to be stored in @value.
     */
    function value_set_time(value: GObject.Value | any, val: Time): void;
    /**
     * Stores `val` into `value`.
     * @param value a #GValue that will store @val.
     * @param val value to be stored in @value.
     */
    function value_set_ushort(value: GObject.Value | any, val: number): void;
    /**
     * Converts a GValue to its string representation which is a human readable value. Note that the
     * returned string does not take into account the current locale of the user (on the contrary to the
     * #GdaDataHandler objects). Using this function should be limited to debugging and values serialization
     * purposes.
     *
     * Output is in the "C" locale for numbers, and dates are converted in a YYYY-MM-DD format.
     * @param value a #GValue.
     * @returns a new string, or %NULL if the conversion cannot be done. Free the value with a g_free() when you've finished using it.
     */
    function value_stringify(value: GObject.Value | any): string;
    /**
     * Stores `val` into `value,` but on the contrary to gda_value_set_binary(), the `binary`
     * argument is not copied, but used as-is and it should be considered owned by `value`.
     * @param value a #GValue that will store @val.
     * @param binary a #GdaBinary structure with the data and its size to be stored in @value.
     */
    function value_take_binary(value: GObject.Value | any, binary: Binary): void;
    /**
     * Stores `val` into `value,` but on the contrary to gda_value_set_blob(), the `blob`
     * argument is not copied, but used as-is and it should be considered owned by `value`.
     * @param value a #GValue that will store @val.
     * @param blob a #GdaBlob structure with the data and its size to be stored in @value.
     */
    function value_take_blob(value: GObject.Value | any, blob: Blob): void;
    /**
     * This methods creates an XML string representation of a #GValue
     * @param value a #GValue to convert to string
     * @returns an string representing a #GValue in XML format
     */
    function value_to_xml_string(value: GObject.Value | any): string;
    function worker_error_quark(): GLib.Quark;
    /**
     * This function creates a new #GdaWorker, or reuses the one at `location`. Specifically:
     * <orderedlist>
     *   <listitem><para>if *`location` is %NULL, then a new #GdaWorker is created. In this case if `allow_destroy` is %FALSE, then the returned
     *     #GdaWorker's reference count is 2, thus preventing it form ever being destroyed (unless gda_worker_unref() is called somewhere else)</para></listitem>
     *   <listitem><para>if *`location` is not %NULL, the the #GdaWorker it points to is returned, its reference count increased by 1</para></listitem>
     * </orderedlist>
     *
     * When the returned #GdaWorker's reference count reaches 0, then it is destroyed, and *`location` is set to %NULL.
     *
     * In any case, the returned value is the same as *`location`.
     * @param location a place to store and test for existence, not %NULL
     * @param allow_destroy defines if the created @GdaWorker (see case 1 below) will allow its reference to drop to 0 and be destroyed
     * @returns a #GdaWorker
     */
    function worker_new_unique(location: Worker, allow_destroy: boolean): Worker;
    interface ConnectionOpenFunc {
        (cnc: Connection, job_id: number, result: boolean, error: GLib.Error, data?: any | null): void;
    }
    interface SqlForeachFunc {
        (part: SqlAnyPart, data?: any | null): boolean;
    }
    interface SqlReservedKeywordsFunc {
        (word: string): boolean;
    }
    interface TreeManagerNodeFunc {
        (manager: TreeManager, parent?: TreeNode | null, name?: string | null): TreeNode;
    }
    interface TreeManagerNodesFunc {
        (manager: TreeManager, node: TreeNode | null, children_nodes: TreeNode[]): TreeNode[];
    }
    interface WorkerCallback {
        (worker: Worker, job_id: number, result_data: any | null, error: GLib.Error): void;
    }
    interface WorkerFunc {
        (user_data?: any | null): any | null;
    }
    type Default = object | null;
    type Null = object | null;

    export namespace ColumnAttributes {
        export const $gtype: GObject.GType<ColumnAttributes>;
    }

    enum ColumnAttributes {
        NONE,
        PRIMARY_KEY,
        UNIQUE,
        FOREIGN_KEY,
        CHECK,
        HAVE_DEFAULT,
        CAN_BE_NULL,
        AUTO_INCREMENT,
    }
    /**
     * Specifies some aspects of a connection when opening it.
     *
     * Additional information about the GDA_CONNECTION_OPTIONS_SQL_IDENTIFIERS_CASE_SENSITIVE flag:
     * <itemizedlist>
     *   <listitem><para>For example without this flag, if the table
     *       name specified in a #GdaServerOperation to create a table is
     *       <emphasis>MyTable</emphasis>, then usually the database will create a table named
     *       <emphasis>mytable</emphasis>, whereas with this flag, the table will be created
     *       as <emphasis>MyTable</emphasis> (note that in the end the database may still decide
     *       to name the table <emphasis>mytable</emphasis> or differently if it can't do
     *       otherwise).</para></listitem>
     *   <listitem><para>Libgda will not apply this rule when parsing SQL code, the SQL code being parsed
     *       has to be conform to the database it will be used with</para></listitem>
     * </itemizedlist>
     *
     * Note about the `GDA_CONNECTION_OPTIONS_AUTO_META_DATA` flag:
     * <itemizedlist>
     *  <listitem><para>Every time a DDL statement is successfully executed, the associated meta data, if
     *               defined, will be updated, which has a impact on performances</para></listitem>
     *  <listitem><para>If a transaction is started and some DDL statements are executed and the transaction
     *            is not rolled back or committed, then the meta data may end up being wrong</para></listitem>
     * </itemizedlist>
     */

    /**
     * Specifies some aspects of a connection when opening it.
     *
     * Additional information about the GDA_CONNECTION_OPTIONS_SQL_IDENTIFIERS_CASE_SENSITIVE flag:
     * <itemizedlist>
     *   <listitem><para>For example without this flag, if the table
     *       name specified in a #GdaServerOperation to create a table is
     *       <emphasis>MyTable</emphasis>, then usually the database will create a table named
     *       <emphasis>mytable</emphasis>, whereas with this flag, the table will be created
     *       as <emphasis>MyTable</emphasis> (note that in the end the database may still decide
     *       to name the table <emphasis>mytable</emphasis> or differently if it can't do
     *       otherwise).</para></listitem>
     *   <listitem><para>Libgda will not apply this rule when parsing SQL code, the SQL code being parsed
     *       has to be conform to the database it will be used with</para></listitem>
     * </itemizedlist>
     *
     * Note about the `GDA_CONNECTION_OPTIONS_AUTO_META_DATA` flag:
     * <itemizedlist>
     *  <listitem><para>Every time a DDL statement is successfully executed, the associated meta data, if
     *               defined, will be updated, which has a impact on performances</para></listitem>
     *  <listitem><para>If a transaction is started and some DDL statements are executed and the transaction
     *            is not rolled back or committed, then the meta data may end up being wrong</para></listitem>
     * </itemizedlist>
     */
    export namespace ConnectionOptions {
        export const $gtype: GObject.GType<ConnectionOptions>;
    }

    enum ConnectionOptions {
        /**
         * no specific aspect
         */
        NONE,
        /**
         * this flag specifies that the connection to open should be in a read-only mode
         *                                    (this policy is not correctly enforced at the moment)
         */
        READ_ONLY,
        /**
         * this flag specifies that SQL identifiers submitted as input
         *                                      to Libgda have to keep their case sensitivity.
         */
        SQL_IDENTIFIERS_CASE_SENSITIVE,
        /**
         * this flags specifies that if a #GdaMetaStore has been associated
         *                                     to the connection, then it is kept up to date with the evolutions in the
         *                                     database's structure. Be aware however that there are some drawbacks
         *                                     explained below.
         */
        AUTO_META_DATA,
    }

    export namespace DataModelAccessFlags {
        export const $gtype: GObject.GType<DataModelAccessFlags>;
    }

    enum DataModelAccessFlags {
        RANDOM,
        CURSOR_FORWARD,
        CURSOR_BACKWARD,
        CURSOR,
        INSERT,
        UPDATE,
        DELETE,
        WRITE,
    }

    export namespace MetaGraphInfo {
        export const $gtype: GObject.GType<MetaGraphInfo>;
    }

    enum MetaGraphInfo {
        META_GRAPH_COLUMNS,
    }
    /**
     * Controls which features are computed about database objects.
     */

    /**
     * Controls which features are computed about database objects.
     */
    export namespace MetaStructFeature {
        export const $gtype: GObject.GType<MetaStructFeature>;
    }

    enum MetaStructFeature {
        /**
         * database objects only have their own attributes
         */
        NONE,
        /**
         * foreign keys are computed for tables
         */
        FOREIGN_KEYS,
        /**
         * for views, the tables they use are also computed
         */
        VIEW_DEPENDENCIES,
        /**
         * all the features are computed
         */
        ALL,
    }

    export namespace ServerOperationCreateTableFlag {
        export const $gtype: GObject.GType<ServerOperationCreateTableFlag>;
    }

    enum ServerOperationCreateTableFlag {
        NOTHING_FLAG,
        PKEY_FLAG,
        NOT_NULL_FLAG,
        UNIQUE_FLAG,
        AUTOINC_FLAG,
        FKEY_FLAG,
        PKEY_AUTOINC_FLAG,
    }
    /**
     * Specifies how SQL identifiers are represented by a specific database
     */

    /**
     * Specifies how SQL identifiers are represented by a specific database
     */
    export namespace SqlIdentifierStyle {
        export const $gtype: GObject.GType<SqlIdentifierStyle>;
    }

    enum SqlIdentifierStyle {
        /**
         * case insensitive SQL identifiers are represented in lower case (meaning that any SQL identifier which has a non lower case character is case sensitive)
         */
        LOWER_CASE,
        /**
         * case insensitive SQL identifiers are represented in upper case (meaning that any SQL identifier which has a non upper case character is case sensitive)
         */
        UPPER_CASE,
    }
    /**
     * These flags specify how the #GdaDataModel returned when executing a #GdaStatement will be used
     */

    /**
     * These flags specify how the #GdaDataModel returned when executing a #GdaStatement will be used
     */
    export namespace StatementModelUsage {
        export const $gtype: GObject.GType<StatementModelUsage>;
    }

    enum StatementModelUsage {
        /**
         * access to the data model will be random (usually this will result in a data model completely stored in memory)
         */
        RANDOM_ACCESS,
        /**
         * access to the data model will be done using a cursor moving forward
         */
        CURSOR_FORWARD,
        /**
         * access to the data model will be done using a cursor moving backward
         */
        CURSOR_BACKWARD,
        /**
         * access to the data model will be done using a cursor (moving both forward and backward)
         */
        CURSOR,
        /**
         * specifies that the data model should be executed even if some parameters required to execute it are invalid (in this case the data model will have no row, and will automatically be re-run when the missing parameters are once again valid)
         */
        ALLOW_NOPARAM,
        /**
         * specifies that the data model's contents will be fully loaded into the client side (the memory of the process using Libgda), not requiring the server any more to access the data (the default behaviour is to access the server any time data is to be read, and data is cached in memory). This flag is useful only if used in conjunction with the GDA_STATEMENT_MODEL_RANDOM_ACCESS flag (otherwise an error will be returned).
         */
        OFFLINE,
    }
    /**
     * Specifies rendering options
     */

    /**
     * Specifies rendering options
     */
    export namespace StatementSqlFlag {
        export const $gtype: GObject.GType<StatementSqlFlag>;
    }

    enum StatementSqlFlag {
        /**
         * rendering will replace parameters with their values
         */
        PARAMS_AS_VALUES,
        /**
         * rendering will include newlines and indentation to make it easy to read
         */
        PRETTY,
        /**
         * parameters will be rendered using the "/&ast; name:&lt;param_name&gt; ... &ast;/" syntax
         */
        PARAMS_LONG,
        /**
         * parameters will be rendered using the "##&lt;param_name&gt;..." syntax
         */
        PARAMS_SHORT,
        /**
         * parameters will be rendered using the ":&lt;param_name&gt;" syntax
         */
        PARAMS_AS_COLON,
        /**
         * parameters will be rendered using the "$&lt;param_number&gt;" syntax where parameters are numbered starting from 1
         */
        PARAMS_AS_DOLLAR,
        /**
         * parameters will be rendered using the "?&lt;param_number&gt;" syntax where parameters are numbered starting from 1
         */
        PARAMS_AS_QMARK,
        /**
         * parameters will be rendered using the "?" syntax
         */
        PARAMS_AS_UQMARK,
        /**
         * time and timestamp with a timezone information are converted to GMT before rendering, and rendering does not show the timezone information
         */
        TIMEZONE_TO_GMT,
    }
    /**
     * Attributes of a value, used internally by Libgda in different contexts. Values can be OR'ed.
     */

    /**
     * Attributes of a value, used internally by Libgda in different contexts. Values can be OR'ed.
     */
    export namespace ValueAttribute {
        export const $gtype: GObject.GType<ValueAttribute>;
    }

    enum ValueAttribute {
        /**
         * no specific attribute
         */
        NONE,
        /**
         * value is NULL (in the SQL sense)
         */
        IS_NULL,
        /**
         * value can be set to NULL (in the SQL sense)
         */
        CAN_BE_NULL,
        /**
         * value is defined as the default value (the value itself is not specified)
         */
        IS_DEFAULT,
        /**
         * a default value (not specified) exists for the value
         */
        CAN_BE_DEFAULT,
        /**
         * the value has not been changed (in the context of the attribute usage)
         */
        IS_UNCHANGED,
        /**
         * the value is not valid (with regards to the context)
         */
        DATA_NON_VALID,
        /**
         * the value can be resetted to its "original" value (i.e. before it was modified)
         */
        HAS_VALUE_ORIG,
        NO_MODIF,
        /**
         * the value can't be modified
         */
        READ_ONLY,
    }
    namespace Batch {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            changed: (arg0: GObject.Object) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class Batch extends GObject.Object {
        static $gtype: GObject.GType<Batch>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Batch.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Batch.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Batch;

        // Signals

        connect<K extends keyof Batch.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Batch.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Batch.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Batch.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Batch.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Batch.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_changed(changed_stmt: Statement): void;

        // Methods

        /**
         * Add `stmt` to the list of statements managed by `batch`. A #GdaStatement object can be
         * added multiple times to a #GdaBatch object. The `batch` increases reference count for `stmt` and
         * the `stmt` instance can be freed using g_object_unref().
         * @param stmt a statement to add to @batch's statements list
         */
        add_statement(stmt: Statement): void;
        /**
         * Copy constructor
         * @returns a the new copy of @orig
         */
        copy(): Batch;
        /**
         * Get a new #GdaSet object which groups all the execution parameters
         * which `batch` needs for all the statements it includes.
         * This new object is returned though `out_params`.
         *
         * Note that if `batch` does not need any parameter, then `out_params` is set to %NULL.
         * @returns TRUE if no error occurred.
         */
        get_parameters(): [boolean, Set | null];
        /**
         * Get a list of the #GdaStatement objects contained in `batch`
         * @returns a list of #GdaStatement which should not be modified.
         */
        get_statements(): Statement[];
        /**
         * Removes `stmt` from the list of statements managed by `batch`. If `stmt` is present several
         * times in `batch'`s statements' list, then only the first one is removed.
         * @param stmt a statement to remove from @batch's statements list
         */
        remove_statement(stmt: Statement): void;
        /**
         * Creates a string representing the contents of `batch`.
         * @returns a string containing the serialized version of @batch
         */
        serialize(): string;
    }

    namespace BlobOp {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::connection': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            connection: Connection;
        }
    }

    class BlobOp extends GObject.Object {
        static $gtype: GObject.GType<BlobOp>;

        // Properties

        get connection(): Connection;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BlobOp.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BlobOp.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof BlobOp.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BlobOp.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BlobOp.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BlobOp.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BlobOp.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BlobOp.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_length(): number;
        /**
         * Reads a chunk of bytes from the BLOB accessible through `op` into `blob`.
         * @param blob a #GdaBlob to read data to
         * @param offset offset to read from the start of the blob (starts at 0)
         * @param size maximum number of bytes to read.
         * @returns the number of bytes actually read. In case of error, -1 is returned and the provider should have added an error to the connection.
         */
        read(blob: Blob, offset: number, size: number): number;
        /**
         * Reads the whole contents of the blob manipulated by `op` into `blob`
         * @param blob a #GdaBlob to read data to
         * @returns TRUE if @blob->data contains the whole BLOB manipulated by @op
         */
        read_all(blob: Blob): boolean;
        /**
         * Writes a chunk of bytes from a `blob` to the BLOB accessible through `op,` `blob` is unchanged after
         * this call.
         *
         * If `blob` has an associated #GdaBlobOp (ie. if `blob->`op is not %NULL) then the data to be written
         * using `op` is the data fetched using `blob->`op.
         * @param blob a #GdaBlob which contains the data to write
         * @param offset offset to write from the start of the blob (starts at 0)
         * @returns the number of bytes written. In case of error, -1 is returned and the provider should have added an error to the connection.
         */
        write(blob: Blob, offset: number): number;
        /**
         * Writes the whole contents of `blob` into the blob manipulated by `op`. If necessary the resulting
         * blob is truncated from its previous length.
         * @param blob a #GdaBlob which contains the data to write
         * @returns TRUE on success
         */
        write_all(blob: Blob): boolean;
    }

    namespace Column {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'g-type-changed': (arg0: GObject.GType, arg1: GObject.GType) => void;
            'name-changed': (arg0: string) => void;
            'notify::desc': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            desc: string;
            id: string;
            name: string;
        }
    }

    class Column extends GObject.Object {
        static $gtype: GObject.GType<Column>;

        // Properties

        get desc(): string;
        set desc(val: string);
        get id(): string;
        set id(val: string);
        get name(): string;
        set name(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Column.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Column.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Column;

        // Signals

        connect<K extends keyof Column.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Column.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Column.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Column.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Column.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Column.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_g_type_changed(old_type: GObject.GType, new_type: GObject.GType): void;
        vfunc_name_changed(old_name: string): void;

        // Methods

        /**
         * Creates a new #GdaColumn object from an existing one.
         * @returns a newly allocated #GdaColumn with a copy of the data in @column.
         */
        copy(): Column;
        /**
         * Gets the 'allow null' flag of the given column.
         * @returns whether the given column allows null values or not (%TRUE or %FALSE).
         */
        get_allow_null(): boolean;
        get_auto_increment(): boolean;
        get_dbms_type(): string;
        get_default_value(): GObject.Value | null;
        get_description(): string;
        get_g_type(): GObject.GType;
        get_name(): string;
        get_position(): number;
        /**
         * Sets the 'allow null' flag of the given column.
         * @param allow whether the given column should allows null values or not.
         */
        set_allow_null(allow: boolean): void;
        /**
         * Sets the auto increment flag for the given column.
         * @param is_auto auto increment status.
         */
        set_auto_increment(is_auto: boolean): void;
        /**
         * Defines `column'`s database type
         * @param dbms_type a string
         */
        set_dbms_type(dbms_type: string): void;
        /**
         * Sets `column'`s default #GValue.
         * @param default_value default #GValue for the column
         */
        set_default_value(default_value?: GObject.Value | null): void;
        /**
         * Sets the column's description
         * @param descr description.
         */
        set_description(descr: string): void;
        /**
         * Sets the type of `column` to `type`.
         * @param type the new type of @column.
         */
        set_g_type(type: GObject.GType): void;
        /**
         * Sets the name of `column` to `name`.
         * @param name the new name of @column.
         */
        set_name(name: string): void;
        /**
         * Sets the position of the column refer to in the containing
         * data model.
         * @param position the wanted position of the column in the containing data model.
         */
        set_position(position: number): void;
    }

    namespace Config {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'dsn-added': (arg0: any | null) => void;
            'dsn-changed': (arg0: any | null) => void;
            'dsn-removed': (arg0: any | null) => void;
            'dsn-to-be-removed': (arg0: any | null) => void;
            'notify::system-filename': (pspec: GObject.ParamSpec) => void;
            'notify::user-filename': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            system_filename: string;
            systemFilename: string;
            user_filename: string;
            userFilename: string;
        }
    }

    class Config extends GObject.Object {
        static $gtype: GObject.GType<Config>;

        // Properties

        /**
         * File to use for system-wide DSN list. When changed, the whole list of DSN will be reloaded.
         */
        get system_filename(): string;
        set system_filename(val: string);
        /**
         * File to use for system-wide DSN list. When changed, the whole list of DSN will be reloaded.
         */
        get systemFilename(): string;
        set systemFilename(val: string);
        /**
         * File to use for per-user DSN list. When changed, the whole list of DSN will be reloaded.
         */
        get user_filename(): string;
        set user_filename(val: string);
        /**
         * File to use for per-user DSN list. When changed, the whole list of DSN will be reloaded.
         */
        get userFilename(): string;
        set userFilename(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Config.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Config.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Config.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Config.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Config.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Config.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Config.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Config.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Tells if the global (system) configuration can be modified (considering
         * system permissions and settings)
         */
        static can_modify_system_config(): boolean;
        /**
         * Add or update a DSN from the definition in `info`.
         *
         * This method may fail with a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
         * @param info a pointer to a filled GdaDsnInfo structure
         */
        static define_dsn(info: DsnInfo): boolean;
        /**
         * Tells if the data source identified as `dsn_name` needs any authentication. If a &lt;username&gt;
         * and optionally a &lt;password&gt; are specified, they are ignored.
         * @param dsn_name the name of a DSN, in the "[&lt;username&gt;[:&lt;password&gt;]@]&lt;DSN&gt;" format
         */
        static dsn_needs_authentication(dsn_name: string): boolean;
        static error_quark(): GLib.Quark;
        /**
         * Get a pointer to the global (unique) #GdaConfig object. This functions increments
         * the reference count of the object, so you need to call g_object_unref() on it once finished.
         */
        static get(): Config;
        /**
         * Get information about the DSN named `dsn_name`.
         *
         * `dsn_name'`s format is "[&lt;username&gt;[:&lt;password&gt;]`]`&lt;DSN&gt;" (if &lt;username&gt;
         * and optionally &lt;password&gt; are provided, they are ignored). Also see the gda_dsn_split() utility
         * function.
         * @param dsn_name the name of the DSN to look for
         */
        static get_dsn_info(dsn_name: string): DsnInfo;
        /**
         * Get a pointer to a read-only #GdaDsnInfo at the `index` position
         * @param index an index
         */
        static get_dsn_info_at_index(index: number): DsnInfo;
        /**
         * Get the index (starting at 0) of the DSN named `dsn_name`
         * @param dsn_name a DSN
         */
        static get_dsn_info_index(dsn_name: string): number;
        /**
         * Get the number of defined DSN
         */
        static get_nb_dsn(): number;
        /**
         * Get a pointer to the session-wide #GdaServerProvider for the
         * provider named `provider_name`. The caller must not call g_object_unref() on the
         * returned object.
         *
         * This method may fail with a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
         * @param provider_name a database provider
         */
        static get_provider(provider_name: string): ServerProvider;
        /**
         * Get some information about the a database provider (adapter) named
         * @param provider_name a database provider
         */
        static get_provider_info(provider_name: string): ProviderInfo;
        /**
         * Get a #GdaDataModel representing all the configured DSN, and keeping itself up to date with
         * the changes in the declared DSN.
         *
         * The returned data model is composed of the following columns:
         * <itemizedlist>
         *  <listitem><para>DSN name</para></listitem>
         *  <listitem><para>Provider name</para></listitem>
         *  <listitem><para>Description</para></listitem>
         *  <listitem><para>Connection string</para></listitem>
         *  <listitem><para>Username if it exists</para></listitem>
         * </itemizedlist>
         */
        static list_dsn(): DataModel;
        /**
         * Get a #GdaDataModel representing all the installed database providers.
         *
         * The returned data model is composed of the following columns:
         * <itemizedlist>
         *  <listitem><para>Provider name</para></listitem>
         *  <listitem><para>Description</para></listitem>
         *  <listitem><para>DSN parameters</para></listitem>
         *  <listitem><para>Authentication parameters</para></listitem>
         *  <listitem><para>File name of the plugin</para></listitem>
         * </itemizedlist>
         */
        static list_providers(): DataModel;
        /**
         * Remove the DSN named `dsn_name`.
         *
         * This method may fail with a %GDA_CONFIG_ERROR domain error (see the #GdaConfigError error codes).
         * @param dsn_name the name of the DSN to remove
         */
        static remove_dsn(dsn_name: string): boolean;

        // Virtual methods

        vfunc_dsn_added(new_dsn: DsnInfo): void;
        vfunc_dsn_changed(dsn: DsnInfo): void;
        vfunc_dsn_removed(old_dsn: DsnInfo): void;
        vfunc_dsn_to_be_removed(old_dsn: DsnInfo): void;
    }

    namespace Connection {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            closed: () => void;
            'dsn-changed': () => void;
            error: (arg0: ConnectionEvent) => void;
            opened: () => void;
            'status-changed': (arg0: ConnectionStatus) => void;
            'transaction-status-changed': () => void;
            'notify::auth-string': (pspec: GObject.ParamSpec) => void;
            'notify::cnc-string': (pspec: GObject.ParamSpec) => void;
            'notify::dsn': (pspec: GObject.ParamSpec) => void;
            'notify::events-history-size': (pspec: GObject.ParamSpec) => void;
            'notify::execution-slowdown': (pspec: GObject.ParamSpec) => void;
            'notify::execution-timer': (pspec: GObject.ParamSpec) => void;
            'notify::meta-store': (pspec: GObject.ParamSpec) => void;
            'notify::provider': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Lockable.ConstructorProps {
            auth_string: string;
            authString: string;
            cnc_string: string;
            cncString: string;
            dsn: string;
            events_history_size: number;
            eventsHistorySize: number;
            execution_slowdown: number;
            executionSlowdown: number;
            execution_timer: boolean;
            executionTimer: boolean;
            meta_store: MetaStore;
            metaStore: MetaStore;
            provider: ServerProvider;
        }
    }

    class Connection extends GObject.Object implements Lockable {
        static $gtype: GObject.GType<Connection>;

        // Properties

        get auth_string(): string;
        set auth_string(val: string);
        get authString(): string;
        set authString(val: string);
        get cnc_string(): string;
        set cnc_string(val: string);
        get cncString(): string;
        set cncString(val: string);
        get dsn(): string;
        set dsn(val: string);
        /**
         * Defines the number of #GdaConnectionEvent objects kept in memory which can
         * be fetched using gda_connection_get_events().
         */
        get events_history_size(): number;
        set events_history_size(val: number);
        /**
         * Defines the number of #GdaConnectionEvent objects kept in memory which can
         * be fetched using gda_connection_get_events().
         */
        get eventsHistorySize(): number;
        set eventsHistorySize(val: number);
        /**
         * Artificially slows down the execution of queries. This property can be used to
         * debug some problems. If non zero, this value is the number of microseconds waited before actually
         * executing each query.
         * NB: this parameter is ignored during the meta store update (it is set to 0 before the meta data update
         * and restored to its state after).
         */
        get execution_slowdown(): number;
        set execution_slowdown(val: number);
        /**
         * Artificially slows down the execution of queries. This property can be used to
         * debug some problems. If non zero, this value is the number of microseconds waited before actually
         * executing each query.
         * NB: this parameter is ignored during the meta store update (it is set to 0 before the meta data update
         * and restored to its state after).
         */
        get executionSlowdown(): number;
        set executionSlowdown(val: number);
        /**
         * Computes execution times for each statement executed.
         */
        get execution_timer(): boolean;
        set execution_timer(val: boolean);
        /**
         * Computes execution times for each statement executed.
         */
        get executionTimer(): boolean;
        set executionTimer(val: boolean);
        get meta_store(): MetaStore;
        set meta_store(val: MetaStore);
        get metaStore(): MetaStore;
        set metaStore(val: MetaStore);
        get provider(): ServerProvider;
        set provider(val: ServerProvider);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Connection.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Connection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_from_dsn(dsn: DsnInfo, auth_string: string | null, options: ConnectionOptions): Connection;

        static new_from_dsn_name(dsn_name: string, auth_string: string | null, options: ConnectionOptions): Connection;

        static new_from_string(
            provider_name: string | null,
            cnc_string: string,
            auth_string: string | null,
            options: ConnectionOptions,
        ): Connection;

        // Signals

        connect<K extends keyof Connection.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Connection.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Connection.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Connection.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Connection.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Connection.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;
        /**
         * Retreive a pointer to the #GdaWorker used internally by the connection. This function is reserved to
         * database provider's implementation and should not be used otherwise.
         * @param data a #GdaServerProviderConnectionData, or %NULL
         */
        static internal_get_worker(data?: ServerProviderConnectionData | null): Worker;
        /**
         * This function creates a connection and opens it, using a DSN. If opening fails, then no connection is created.
         * See gda_connection_new_from_dsn() for more information.
         * @param dsn data sourcename.
         * @param auth_string authentication string, or %NULL
         * @param options options for the connection (see #GdaConnectionOptions).
         */
        static open_from_dsn(dsn: DsnInfo, auth_string: string | null, options: ConnectionOptions): Connection;
        /**
         * This function creates a connection and opens it, using a DSN name. If opening fails, then no connection is created. The named DSN should be available.
         * See gda_connection_new_from_dsn_name() for more information.
         * @param dsn_name data source name.
         * @param auth_string authentication string, or %NULL
         * @param options options for the connection (see #GdaConnectionOptions).
         */
        static open_from_dsn_name(dsn_name: string, auth_string: string | null, options: ConnectionOptions): Connection;
        /**
         * This function creates a connection and opens it, using a connection string. If opening fails, then no connection is created.
         * See gda_connection_new_from_string() for more information.
         * @param provider_name provider ID to connect to, or %NULL
         * @param cnc_string connection string.
         * @param auth_string authentication string, or %NULL
         * @param options options for the connection (see #GdaConnectionOptions).
         */
        static open_from_string(
            provider_name: string | null,
            cnc_string: string,
            auth_string: string | null,
            options: ConnectionOptions,
        ): Connection;
        /**
         * Opens an SQLite connection even if the SQLite provider is not installed,
         * to be used by database providers which need a temporary database to store
         * some information.
         * @param directory the directory the database file will be in, or %NULL for the default TMP directory
         * @param filename the database file name
         * @param auto_unlink if %TRUE, then the database file will be removed afterwards
         */
        static open_sqlite(directory: string | null, filename: string, auto_unlink: boolean): Connection;
        /**
         * Extract the provider, connection parameters, username and password from `string`.
         * in `string,` the various parts are strings
         * which are expected to be encoded using an RFC 1738 compliant encoding. If they are specified,
         * the returned provider, username and password strings are correctly decoded.
         *
         * For example all the following connection strings:
         * <programlisting><![CDATA[
         * PostgreSQL://meme:pass`DB_NAME=`mydb;HOST=server
         * PostgreSQL://meme`DB_NAME=`mydb;HOST=server;PASSWORD=pass
         * PostgreSQL://meme`DB_NAME=`mydb;PASSWORD=pass;HOST=server
         * PostgreSQL://meme`PASSWORD=`pass;DB_NAME=mydb;HOST=server
         * PostgreSQL://DB_NAME=mydb;HOST=server;USERNAME=meme;PASSWORD=pass
         * PostgreSQL://DB_NAME=mydb;HOST=server;PASSWORD=pass;USERNAME=meme
         * PostgreSQL://DB_NAME=mydb;USERNAME=meme;PASSWORD=pass;HOST=server
         * PostgreSQL://PASSWORD=pass;USERNAME=meme;DB_NAME=mydb;HOST=server
         * PostgreSQL://:pass`USERNAME=`meme;DB_NAME=mydb;HOST=server
         * PostgreSQL://:pass`DB_NAME=`mydb;HOST=server;USERNAME=meme]]></programlisting>
         *
         * will return the following new strings (double quotes added here to delimit strings):
         * <programlisting><![CDATA[
         * out_cnc_params: "DB_NAME=mydb;HOST=server"
         * out_provider: "PostgreSQL"
         * out_username: "meme"
         * out_password: "pass"]]></programlisting>
         * @param string a string in the "[&lt;provider&gt;://][&lt;username&gt;[:&lt;password&gt;]@]&lt;connection_params&gt;" form
         */
        static string_split(string: string): [string, string, string, string];

        // Virtual methods

        vfunc_closed(): void;
        vfunc_dsn_changed(): void;
        vfunc_error(error: ConnectionEvent): void;
        vfunc_opened(): void;
        vfunc_status_changed(status: ConnectionStatus): void;
        vfunc_transaction_status_changed(): void;

        // Methods

        /**
         * Adds an event to the given connection. This function is usually
         * called by providers, to inform clients of events that happened
         * during some operation.
         *
         * As soon as a provider (or a client, it does not matter) calls this
         * function with an `event` object which is an error,
         * the connection object emits the "error" signal, to which clients can connect to be
         * informed of events.
         *
         * WARNING: the reference to the `event` object is stolen by this function!
         * @param event is stored internally, so you don't need to unref it.
         */
        add_event(event: ConnectionEvent): void;
        /**
         * Declares that `prepared_stmt` is a prepared statement object associated to `gda_stmt` within the connection
         * (meaning the connection increments the reference counter of `prepared_stmt)`.
         *
         * If `gda_stmt` changes or is destroyed, the the association will be lost and the connection will lose the
         * reference it has on `prepared_stmt`.
         * @param gda_stmt a #GdaStatement object
         * @param prepared_stmt a prepared statement object (as a #GdaPStmt object, or more likely a descendant)
         */
        add_prepared_statement(gda_stmt: Statement, prepared_stmt: PStmt): void;
        /**
         * Adds a SAVEPOINT named `name`.
         * @param name name of the savepoint to add
         * @returns TRUE if no error occurred
         */
        add_savepoint(name?: string | null): boolean;
        /**
         * Executes all the statements contained in `batch` (in the order in which they were added to `batch)`, and
         * returns a list of #GObject objects, at most one #GObject for each statement; see gda_connection_statement_execute()
         * for details about the returned objects.
         *
         * If one of the statement fails, then none of the subsequent statement will be executed, and the method returns
         * the list of #GObject created by the correct execution of the previous statements. If a transaction is required,
         * then it should be started before calling this method.
         * @param batch a #GdaBatch object which contains all the statements to execute
         * @param params a #GdaSet object (which can be obtained using gda_batch_get_parameters()), or %NULL
         * @param model_usage specifies how the returned data model(s) will be used, as a #GdaStatementModelUsage enum
         * @returns a new list of #GObject objects
         */
        batch_execute(batch: Batch, params: Set | null, model_usage: StatementModelUsage | null): GObject.Object[];
        /**
         * Starts a transaction on the data source, identified by the `name` parameter.
         *
         * Before starting a transaction, you can check whether the underlying
         * provider does support transactions or not by using the gda_connection_supports_feature() function.
         * @param name the name of the transation to start, or %NULL
         * @param level the requested transaction level (use %GDA_TRANSACTION_ISOLATION_SERVER_DEFAULT to apply the server default)
         * @returns %TRUE if the transaction was started successfully with the corresponding isolation level, %FALSE otherwise.
         */
        begin_transaction(name: string | null, level: TransactionIsolation | null): boolean;
        /**
         * This function lets you clear the list of #GdaConnectionEvent's of the
         * given connection.
         */
        clear_events_list(): void;
        /**
         * Closes the connection to the underlying data source.
         */
        close(): boolean;
        /**
         * Commits the given transaction to the backend database. You need to call
         * gda_connection_begin_transaction() first.
         * @param name the name of the transation to commit, or %NULL
         * @returns %TRUE if the transaction was finished successfully, %FALSE otherwise.
         */
        commit_transaction(name?: string | null): boolean;
        /**
         * A convenient method to create a new #GdaDbCatalog instance and set the current `cnc` as a
         * property.  If for some reason, this approach doesn't fit well, the same task can be achieved
         * by the following code:
         *
         * GdaDbCatalog *catalog = gda_db_catalog_new ();
         * g_object_set (catalog, "connection", cnc, NULL);
         * @returns A new instance of #GdaDbCatalog. The new object should be deallocated using g_object_unref().
         */
        create_db_catalog(): DbCatalog;
        /**
         * Creates a new #GdaServerOperation object which can be modified in order
         * to perform the type type of action. It is a wrapper around the gda_server_provider_create_operation()
         * method.
         * @param type the type of operation requested
         * @param options an optional list of parameters
         * @returns a new #GdaServerOperation object, or %NULL in the connection's provider does not support the @type type of operation or if an error occurred
         */
        create_operation(type: ServerOperationType | null, options?: Set | null): ServerOperation;
        /**
         * Creates a new parser object able to parse the SQL dialect understood by `cnc`.
         * If the #GdaServerProvider object internally used by `cnc` does not have its own parser,
         * then %NULL is returned, and a general SQL parser can be obtained
         * using gda_sql_parser_new().
         * @returns a new #GdaSqlParser object, or %NULL
         */
        create_parser(): SqlParser;
        /**
         * Removes any prepared statement associated to `gda_stmt` in `cnc:` this undoes what
         * gda_connection_add_prepared_statement() does.
         * @param gda_stmt a #GdaStatement object
         */
        del_prepared_statement(gda_stmt: Statement): void;
        /**
         * This is a convenience function, which creates a DELETE statement and executes it using the values
         * provided. It internally relies on variables which makes it immune to SQL injection problems.
         *
         * The equivalent SQL command is: DELETE FROM &lt;table&gt; WHERE &lt;condition_column_name&gt; = &lt;condition_value&gt;.
         *
         * A simple example to remove a row in database.
         *
         *
         * ```c
         *
         * GdaConnection *cnc;
         * //Open connection here
         *
         * GError *error = NULL;
         *
         * GValue *v_id = gda_value_new (G_TYPE_INT);
         * GValue *v_name = gda_value_new_from_string ("Aldibino Refinino", G_TYPE_STRING);
         *
         * //The number 10 represents a primary key record in the table
         * g_value_set_int (v_id, 10);
         *
         * //Delete a record with a specific ID in the col_id column
         * if (!gda_connection_delete_row_from_table (cnc, "TABLE_CONTACTS",
         *                                            "col_id", v_id,
         *                                            &error))
         * {
         *   g_error ("Could not delete row in table: %s\n",
         *            error && error->message ? error->message : "No detail");
         * }
         *
         * //Delete a record with a specific NAME in the col_name column
         * if (!gda_connection_delete_row_from_table (cnc, "TABLE_CONTACTS",
         *                                            "col_name", v_name,
         *                                            &error))
         * {
         *   g_error ("Could not delete row in table: %s\n",
         *            error && error->message ? error->message : "No detail");
         * }
         *
         * gda_value_free (v_id);
         * gda_value_free (v_name);
         *
         * g_error_free (error);
         *
         * ```
         *
         * @param table the table's name with the row's values to be updated
         * @param condition_column_name the name of the column to used in the WHERE condition clause
         * @param condition_value the @condition_column_type's GType
         * @returns TRUE if no error occurred, FALSE otherwise
         */
        delete_row_from_table(
            table: string,
            condition_column_name: string,
            condition_value: GObject.Value | any,
        ): boolean;
        /**
         * Delete the SAVEPOINT named `name` when not used anymore.
         * @param name name of the savepoint to delete
         * @returns TRUE if no error occurred
         */
        delete_savepoint(name?: string | null): boolean;
        /**
         * This is a convenience function to execute a SQL command over the opened connection. For the
         * returned value, see gda_connection_statement_execute_non_select()'s documentation.
         * @param sql a query statement that must not begin with "SELECT"
         * @returns the number of rows affected or -1, or -2
         */
        execute_non_select_command(sql: string): number;
        /**
         * Execute a SQL SELECT command over an opened connection.
         * @param sql a query statement that must begin with "SELECT"
         * @returns a new #GdaDataModel if successful, %NULL otherwise
         */
        execute_select_command(sql: string): DataModel;
        /**
         * Gets the user name used to open this connection.
         * @returns the user name.
         */
        get_authentication(): string;
        /**
         * Gets the connection string used to open this connection.
         *
         * The connection string is the string sent over to the underlying
         * database provider, which describes the parameters to be used
         * to open a connection on the underlying data source.
         * @returns the connection string used when opening the connection.
         */
        get_cnc_string(): string;
        /**
         * This function allows you to determine the actual format for the date values.
         * @returns %TRUE if no error occurred
         */
        get_date_format(): [boolean, GLib.DateDMY | null, GLib.DateDMY | null, GLib.DateDMY | null, string];
        get_dsn(): string;
        /**
         * Retrieves a list of the last errors occurred during the connection. The returned list is
         * chronologically ordered such as that the most recent event is the #GdaConnectionEvent of the first node.
         *
         * Warning: the `cnc` object may change the list if connection events occur
         * @returns a #GList of #GdaConnectionEvent objects (the list should not be modified)
         */
        get_events(): ConnectionEvent[];
        /**
         * Get the #GMainContext used while a potentially blocking operation is performed using `nc,` see
         * gda_connection_set_main_context(). If `cnc` is %NULL, then the setting applies to all the connections for which
         * no other similar setting has been set.
         *
         * If no main context has been defined, then some function calls (for example connection opening) may block until the
         * operation has finished.
         * @param thread the #GThread in which @context will be used, or %NULL (for the current thread)
         * @returns a #GMainContext, or %NULL
         */
        get_main_context(thread?: GLib.Thread | null): GLib.MainContext;
        /**
         * Get or initializes the #GdaMetaStore associated to `cnc`
         * @returns a #GdaMetaStore object
         */
        get_meta_store(): MetaStore;
        /**
         * see #gda_connection_get_meta_store_data
         * @param meta_type describes which data to get.
         * @param filters a #GList of #GdaHolder objects
         * @returns a #GdaDataModel containing the data required. The caller is responsible for freeing the returned model using g_object_unref().
         */
        get_meta_store_data(meta_type: ConnectionMetaType | null, filters: Holder[]): DataModel;
        /**
         * Gets the #GdaConnectionOptions used to open this connection.
         * @returns the connection options.
         */
        get_options(): ConnectionOptions;
        /**
         * Retrieves a pointer to an object representing a prepared statement for `gda_stmt` within `cnc`. The
         * association must have been done using gda_connection_add_prepared_statement().
         * @param gda_stmt a #GdaStatement object
         * @returns the prepared statement, or %NULL if no association exists
         */
        get_prepared_statement(gda_stmt: Statement): PStmt;
        /**
         * Gets a pointer to the #GdaServerProvider object used to access the database
         * @returns the #GdaServerProvider (NEVER NULL)
         */
        get_provider(): ServerProvider;
        /**
         * Gets the name (identifier) of the database provider used by `cnc`
         * @returns a non modifiable string
         */
        get_provider_name(): string;
        /**
         * Get the current status of `cnc`. Note that this function needs to lock the connection (see #GdaLockable)
         * to obtain the result.
         * @returns the connection's status
         */
        get_status(): ConnectionStatus;
        /**
         * Get the status of `cnc` regarding transactions. The returned object should not be modified
         * or destroyed; however it may be modified or destroyed by the connection itself.
         *
         * If %NULL is returned, then no transaction has been associated with `cnc`
         * @returns a #GdaTransactionStatus object, or %NULL
         */
        get_transaction_status(): TransactionStatus;
        /**
         * `col_names` and `values` must have length (&gt;= 1).
         *
         * This is a convenience function, which creates an INSERT statement and executes it using the values
         * provided. It internally relies on variables which makes it immune to SQL injection problems.
         *
         * The equivalent SQL command is: INSERT INTO &lt;table&gt; (&lt;column_name&gt; [,...]) VALUES (&lt;column_name&gt; = &lt;new_value&gt; [,...]).
         * @param table table's name to insert into
         * @param col_names a list of column names (as const gchar *)
         * @param values a list of values (as #GValue)
         * @returns TRUE if no error occurred, FALSE otherwise
         */
        insert_row_into_table_v(table: string, col_names: string[], values: (GObject.Value | any)[]): boolean;
        /**
         * Internal function to be called by database providers to force a transaction status
         * change.
         * @param newstate the new state
         */
        internal_change_transaction_state(newstate: TransactionStatusState | null): void;
        /**
         * Get the opaque pointer previously set using gda_connection_internal_set_provider_data().
         * If it's not set, then add a connection event and returns %NULL
         * @returns the pointer to the opaque structure set using gda_connection_internal_set_provider_data(), or %NULL
         */
        internal_get_provider_data_error(): ServerProviderConnectionData | null;
        /**
         * Internal function to be called by database providers to reset the transaction status.
         */
        internal_reset_transaction_status(): void;
        /**
         * Internal functions to be called by database providers when a savepoint has been added
         * to keep track of the transaction status of the connection
         *
         * Note: this function should not be called if gda_connection_internal_statement_executed()
         * has already been called because a statement's execution was necessary to perform
         * the action.
         * @param parent_trans name of the parent transaction, or %NULL
         * @param svp_name savepoint's name, or %NULL
         */
        internal_savepoint_added(parent_trans: string | null, svp_name: string): void;
        /**
         * Internal functions to be called by database providers when a savepoint has been removed
         * to keep track of the transaction status of the connection
         *
         * Note: this function should not be called if gda_connection_internal_statement_executed()
         * has already been called because a statement's execution was necessary to perform
         * the action.
         * @param svp_name savepoint's name, or %NULL
         */
        internal_savepoint_removed(svp_name?: string | null): void;
        /**
         * Internal functions to be called by database providers when a savepoint has been rolled back
         * to keep track of the transaction status of the connection
         *
         * Note: this function should not be called if gda_connection_internal_statement_executed()
         * has already been called because a statement's execution was necessary to perform
         * the action.
         * @param svp_name savepoint's name, or %NULL
         */
        internal_savepoint_rolledback(svp_name?: string | null): void;
        /**
         * Note: calling this function more than once will not make it call `destroy_func` on any previously
         * set opaque `data,` you'll have to do it yourself.
         *
         * Note: `destroy_func,` needs to free the memory associated to `data,` if necessary.
         * @param data a #GdaServerProviderConnectionData, which can be extended as needed by the provider for which @cnc is opened
         */
        internal_set_provider_data(data: ServerProviderConnectionData): void;
        /**
         * Internal functions to be called by database providers when a statement has been executed
         * to keep track of the transaction status of the connection
         * @param stmt a #GdaStatement which has been executed
         * @param params execution's parameters
         * @param error a #GdaConnectionEvent if the execution failed, or %NULL
         */
        internal_statement_executed(stmt: Statement, params: Set | null, error: ConnectionEvent): void;
        /**
         * Internal functions to be called by database providers when a transaction has been committed
         * to keep track of the transaction status of the connection
         *
         * Note: this function should not be called if gda_connection_internal_statement_executed()
         * has already been called because a statement's execution was necessary to perform
         * the action.
         * @param trans_name transaction's name, or %NULL
         */
        internal_transaction_committed(trans_name?: string | null): void;
        /**
         * Internal functions to be called by database providers when a transaction has been rolled
         * back to keep track of the transaction status of the connection
         *
         * Note: this function should not be called if gda_connection_internal_statement_executed()
         * has already been called because a statement's execution was necessary to perform
         * the action.
         * @param trans_name transaction's name, or %NULL
         */
        internal_transaction_rolledback(trans_name?: string | null): void;
        /**
         * Internal functions to be called by database providers when a transaction has been started
         * to keep track of the transaction status of the connection.
         *
         * Note: this function should not be called if gda_connection_internal_statement_executed()
         * has already been called because a statement's execution was necessary to perform
         * the action.
         * @param parent_trans name of the parent transaction, or %NULL
         * @param trans_name transaction's name, or %NULL
         * @param isol_level isolation level.
         */
        internal_transaction_started(
            parent_trans: string | null,
            trans_name: string,
            isol_level: TransactionIsolation | null,
        ): void;
        /**
         * Checks whether a connection is open or not.
         * @returns %TRUE if the connection is open, %FALSE if it's not.
         */
        is_opened(): boolean;
        /**
         * Tries to open the connection. The function either blocks or, if a #GMaincontext has been specified using
         * gda_connection_set_main_context(), processes the events for that main context until either the
         * connection opening has succeeded or failed.
         *
         * If the connection is already opened, then this function returns %TRUE immediately.
         * @returns TRUE if the connection is opened, and FALSE otherwise.
         */
        open(): boolean;
        /**
         * This function requests that the connection be opened.
         *
         * If the connection is already opened, then this function returns an error (with the %GDA_CONNECTION_ALREADY_OPENED_ERROR code).
         *
         * Note: `callback` function will be called when processing events from the #GMainContext defined by
         * gda_connection_set_main_context(), for example when there is a main loop for that main context.
         * @param callback a #GdaConnectionOpenFunc which will be called after the connection has been opened (of failed to open)
         * @returns a job ID
         */
        open_async(callback: ConnectionOpenFunc): number;
        /**
         * This method is similar to gda_server_operation_get_value_at(), but for SQL identifiers: a new string
         * is returned instead of a #GValue. Also the returned string is assumed to represents an SQL identifier
         * and will correctly be quoted to be used with `cnc`.
         * @param op a #GdaServerOperation object
         * @param path a complete path to a node (starting with "/")
         * @returns a new string, or %NULL if the value is undefined or if the @path is not defined or @path does not hold any value, or if the value held is not a string or a valid SQL identifier.
         */
        operation_get_sql_identifier_at_path(op: ServerOperation, path: string): string | null;
        /**
         * This function helps to parse a SQL string which uses parameters and store them at `params`.
         * @param sql an SQL command to parse, not %NULL
         * @returns a #GdaStatement representing the SQL command, or %NULL if an error occurred
         */
        parse_sql_string(sql: string): [Statement, Set | null];
        /**
         * Performs the operation described by `op` (which should have been created using
         * gda_connection_create_operation()). It is a wrapper around the gda_server_provider_perform_operation()
         * method.
         * @param op a #GdaServerOperation object
         * @returns TRUE if no error occurred
         */
        perform_operation(op: ServerOperation): boolean;
        /**
         * Use this method to get a pointer to the next available connection event which can then be customized
         * and taken into account using gda_connection_add_event().
         * @param type a #GdaConnectionEventType
         * @returns a pointer to the next available connection event, or %NULL if event should be ignored
         */
        point_available_event(type: ConnectionEventType | null): ConnectionEvent;
        /**
         * Add more arguments if the flag needs them:
         *
         * GDA_SERVER_OPERATION_CREATE_TABLE_FKEY_FLAG:
         * <itemizedlist>
         *   <listitem><para>string with the table's name referenced</para></listitem>
         *   <listitem><para>an integer with the number pairs "local_field", "referenced_field"
         *   used in the reference</para></listitem>
         *   <listitem><para>Pairs of "local_field", "referenced_field" to use, must match
         *    the number specified above.</para></listitem>
         *   <listitem><para>a string with the action for ON DELETE; can be: "RESTRICT", "CASCADE",
         *    "NO ACTION", "SET NULL" and "SET DEFAULT". Example: "ON UPDATE CASCADE".</para></listitem>
         *   <listitem><para>a string with the action for ON UPDATE (see above).</para></listitem>
         * </itemizedlist>
         *
         * Create a #GdaServerOperation object using an opened connection, taking three
         * arguments, a column's name the column's GType and #GdaServerOperationCreateTableFlag
         * flag, you need to finish the list using %NULL.
         *
         * You'll be able to modify the #GdaServerOperation object to add custom options
         * to the operation. When finished call #gda_server_operation_perform_create_table
         * or #gda_server_provider_perform_operation
         * in order to execute the operation.
         * @param table_name name of the table to create
         * @param _arguments list of arguments as #GdaServerOperationPrepareCreateTableArg containing column's name, column's #GType and a #GdaServerOperationCreateTableFlag flag
         * @returns a #GdaServerOperation if no errors; NULL and set @error otherwise
         */
        prepare_operation_create_table(
            table_name: string,
            _arguments: ServerOperationCreateTableArg[],
        ): ServerOperation | null;
        /**
         * This is just a convenient function to create a #GdaServerOperation to drop a
         * table in an opened connection.
         * @param table_name name of the table to drop
         * @returns a new #GdaServerOperation or %NULL if couldn't create the opereration.
         */
        prepare_operation_drop_table(table_name: string): ServerOperation | null;
        /**
         * Use this method to get a correctly quoted (if necessary) SQL identifier which can be used
         * in SQL statements, from `id`. If `id` is already correctly quoted for `cnc,` then a copy of `id`
         * may be returned.
         *
         * This method may add double quotes (or other characters) around `id:`
         * <itemizedlist>
         *  <listitem><para>if `id` is a reserved SQL keyword (such as SELECT, INSERT, ...)</para></listitem>
         *  <listitem><para>if `id` contains non allowed characters such as spaces, or if it starts with a digit</para></listitem>
         *  <listitem><para>in any other event as necessary for `cnc,` depending on the the options passed when opening the `cnc`
         *            connection, and specifically the <link linkend="GDA-CONNECTION-OPTIONS-SQL-IDENTIFIERS-CASE-SENSITIVE:CAPS">
         *            GDA_CONNECTION_OPTIONS_SQL_IDENTIFIERS_CASE_SENSITIVE</link> option.</para></listitem>
         * </itemizedlist>
         *
         * One can safely pass an already quoted `id` to this method, either with quoting characters allowed by `cnc` or using the
         * double quote (") character.
         * @param id an SQL identifier
         * @returns a new string, to free with g_free() once not needed anymore
         */
        quote_sql_identifier(id: string): string;
        /**
         * Executes the statement upon which `rstmt` is built. Note that as several statements can actually be executed by this
         * method, it is recommended to be within a transaction.
         *
         * If `error` is not %NULL and `stop_on_error` is %FALSE, then it may contain the last error which occurred.
         * @param rstmt a #GdaRepetitiveStatement object
         * @param model_usage specifies how the returned data model will be used as a #GdaStatementModelUsage enum
         * @param col_types an array of GType to request each returned GdaDataModel's column's GType, see gda_connection_statement_execute_select_full() for more information
         * @param stop_on_error set to TRUE if the method has to stop on the first error.
         * @returns a new list of #GObject pointers (see gda_connection_statement_execute() for more information about what they represent), one for each actual execution of the statement upon which @rstmt is built. If @stop_on_error is %FALSE, then the list may contain some %NULL pointers which refer to statements which failed to execute.
         */
        repetitive_statement_execute(
            rstmt: RepetitiveStatement,
            model_usage: StatementModelUsage | null,
            col_types: GObject.GType[] | null,
            stop_on_error: boolean,
        ): GObject.Object[];
        /**
         * Rollback all the modifications made after the SAVEPOINT named `name`.
         * @param name name of the savepoint to rollback to
         * @returns TRUE if no error occurred
         */
        rollback_savepoint(name?: string | null): boolean;
        /**
         * Rollbacks the given transaction. This means that all changes
         * made to the underlying data source since the last call to
         * #gda_connection_begin_transaction() or #gda_connection_commit_transaction()
         * will be discarded.
         * @param name the name of the transation to commit, or %NULL
         * @returns %TRUE if the operation was successful, %FALSE otherwise.
         */
        rollback_transaction(name?: string | null): boolean;
        /**
         * Defines the #GMainContext which will still process events while a potentially blocking operation is performed using
         * `cnc`. If `cnc` is %NULL, then this function applies to all the connections, except the ones for which a different
         * context has been defined (be it user defined connections or internal connections used in other objects).
         * On the other hand, if `cnc` is not %NULL, then the setting only applied to `cnc`.
         *
         * For exemple if there is a GUI which needs to continue to handle events, then you can use this function to pass
         * the default #GMainContext used for the UI refreshing, for example:
         *
         * <programlisting><![CDATA[GMainContext *context;
         * cnc = gda_connection_new_...;
         * context = g_main_context_ref_thread_default ();
         * gda_connection_set_main_context (cnc, NULL, context);
         * g_main_context_unref (context);
         * GError *error = NULL;
         * if (! gda_connection_open (cnc, &error))
         *     ...
         * ]]></programlisting>
         *
         * If `context` is %NULL, then potentially blocking operation will actually block any event from being processed
         * while the blocking operation is being performed.
         * @param thread the #GThread in which @context will be used, or %NULL (for the current thread)
         * @param context a #GMainContext, or %NULL
         */
        set_main_context(thread?: GLib.Thread | null, context?: GLib.MainContext | null): void;
        /**
         * Executes `stmt`.
         *
         * As `stmt` can, by design (and if not abused), contain only one SQL statement, the
         * return object will either be:
         * <itemizedlist>
         *   <listitem><para>a #GdaDataSelect object (which is also a #GdaDataModel) if `stmt` is a SELECT statement
         *             (usually a GDA_SQL_STATEMENT_SELECT, see #GdaSqlStatementType)
         *             containing the results of the SELECT. The resulting data model is by default read only, but
         *             modifications can be enabled, see the #GdaDataSelect's documentation for more information.</para></listitem>
         *   <listitem><para>a #GdaSet for any other SQL statement which correctly executed. In this case
         *        (if the provider supports it), then the #GdaSet may contain value holders named:
         *        <itemizedlist>
         *          <listitem><para>a (gint) #GdaHolder named "IMPACTED_ROWS"</para></listitem>
         *          <listitem><para>a (GObject) #GdaHolder named "EVENT" which contains a #GdaConnectionEvent</para></listitem>
         *        </itemizedlist></para></listitem>
         * </itemizedlist>
         *
         * If `last_insert_row` is not %NULL and `stmt` is an INSERT statement, then it will contain a new #GdaSet
         * object composed of value holders named "+&lt;column number&gt;"
         * starting at column 0 which contain the actual inserted values. For example if a table is composed of an 'id' column
         * which is auto incremented and a 'name' column then the execution of a "INSERT INTO mytable (name) VALUES ('joe')"
         * query will return a #GdaSet with two holders:
         * <itemizedlist>
         *   <listitem><para>one with the '+0' ID which may for example contain 1 (note that its "name" property should be "id")</para></listitem>
         *   <listitem><para>one with the '+1' ID which will contain 'joe' (note that its "name" property should be "name")</para></listitem>
         * </itemizedlist>
         * Note that the value pointer by `last_insert_row` may be %NULL after the function call if either the database provider
         * does not support it, or if the last interted row could not be determined (for example with SQLite if the table
         * in which the data is inserted has the WITHOUT ROWID optimization).
         *
         * This method may fail with a %GDA_SERVER_PROVIDER_ERROR domain error (see the #GdaServerProviderError error codes).
         *
         * Note1: If `stmt` is a SELECT statement which has some parameters and  if `params` is %NULL, then the statement can't
         * be executed and this method will return %NULL.
         *
         * Note2: If `stmt` is a SELECT statement which has some parameters and  if `params` is not %NULL but contains some
         * invalid parameters, then the statement can't be executed and this method will return %NULL, unless the
         * `model_usage` has the GDA_STATEMENT_MODEL_ALLOW_NOPARAM flag.
         *
         * Note3: If `stmt` is a SELECT statement which has some parameters and  if `params` is not %NULL but contains some
         * invalid parameters and if `model_usage` has the GDA_STATEMENT_MODEL_ALLOW_NOPARAM flag, then the returned
         * data model will contain no row but will have all the correct columns (even though some of the columns might
         * report as GDA_TYPE_NULL). In this case, if (after this method call) any of `params'` parameters change
         * then the resulting data model will re-run itself, see the GdaDataSelect's
         * <link linkend="GdaDataSelect--auto-reset">auto-reset</link> property for more information.
         *
         * Note4: if `model_usage` does not contain the GDA_STATEMENT_MODEL_RANDOM_ACCESS or
         * GDA_STATEMENT_MODEL_CURSOR_FORWARD flags, then the default will be to return a random access data model
         *
         * Note5: If `stmt` is a SELECT statement which returns blob values (of type %GDA_TYPE_BLOB), then an implicit
         * transaction will have been started by the database provider, and it's up to the caller to close the transaction
         * (which will then be locked) once all the blob ressources have been
         * liberated (when the returned data model is destroyed). See the section about
         * <link linkend="gen:blobs">Binary large objects (BLOBs)</link> for more information.
         *
         * Also see the <link linkend="limitations">provider's limitations</link>, and the
         * <link linkend="data-select">Advanced GdaDataSelect usage</link> sections.
         * @param stmt a #GdaStatement object
         * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
         * @param model_usage in the case where @stmt is a SELECT statement, specifies how the returned data model will be used
         * @returns a #GObject, or %NULL if an error occurred
         */
        statement_execute<T = GObject.Object>(
            stmt: Statement,
            params: Set | null,
            model_usage: StatementModelUsage | null,
        ): [T, Set | null];
        /**
         * Executes a non-selection statement on the given connection.
         *
         * This function returns the number of rows affected by the execution of `stmt,` or -1
         * if an error occurred, or -2 if the connection's provider does not return the number of rows affected.
         *
         * This function is just a convenience function around the gda_connection_statement_execute()
         * function.
         * See the documentation of the gda_connection_statement_execute() for information
         * about the `params` list of parameters.
         *
         * See gda_connection_statement_execute() form more information about `last_insert_row`.
         * @param stmt a #GdaStatement object.
         * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
         * @returns the number of rows affected (&gt;=0) or -1 or -2
         */
        statement_execute_non_select(stmt: Statement, params?: Set | null): [number, Set | null];
        /**
         * Executes a selection command on the given connection.
         *
         * This function returns a #GdaDataModel resulting from the SELECT statement, or %NULL
         * if an error occurred.
         *
         * This function is just a convenience function around the gda_connection_statement_execute()
         * function.
         *
         * See the documentation of the gda_connection_statement_execute() for information
         * about the `params` list of parameters.
         * @param stmt a #GdaStatement object.
         * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
         * @returns a #GdaDataModel containing the data returned by the data source, or %NULL if an error occurred
         */
        statement_execute_select(stmt: Statement, params?: Set | null): DataModel;
        /**
         * Executes a selection command on the given connection.
         *
         * This function returns a #GdaDataModel resulting from the SELECT statement, or %NULL
         * if an error occurred.
         *
         * This function is just a convenience function around the gda_connection_statement_execute()
         * function.
         *
         * See the documentation of the gda_connection_statement_execute() for information
         * about the `params` list of parameters.
         * @param stmt a #GdaStatement object.
         * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
         * @param model_usage specifies how the returned data model will be used as a #GdaStatementModelUsage enum
         * @param col_types an array of GType to request each returned #GdaDataModel's column's GType, terminated with the G_TYPE_NONE value. Any value left to 0 will make the database provider determine the real GType. @col_types can also be %NULL if no column type is specified.
         * @returns a #GdaDataModel containing the data returned by the data source, or %NULL if an error occurred
         */
        statement_execute_select_full(
            stmt: Statement,
            params: Set | null,
            model_usage: StatementModelUsage | null,
            col_types?: GObject.GType[] | null,
        ): DataModel;
        /**
         * Ask the database accessed through the `cnc` connection to prepare the usage of `stmt`. This is only useful
         * if `stmt` will be used more than once (however some database providers may always prepare statements
         * before executing them).
         *
         * This function is also useful to make sure `stmt` is fully understood by the database before actually executing it.
         *
         * Note however that it is also possible that gda_connection_statement_prepare() fails when
         * gda_connection_statement_execute() does not fail (this will usually be the case with statements such as
         * <![CDATA["SELECT * FROM ##tablename::string"]]> because database usually don't allow variables to be used in place of a
         * table name).
         * @param stmt a #GdaStatement object
         * @returns TRUE if no error occurred.
         */
        statement_prepare(stmt: Statement): boolean;
        /**
         * Renders `stmt` as an SQL statement, adapted to the SQL dialect used by `cnc`
         * @param stmt a #GdaStatement object
         * @param params a #GdaSet object (which can be obtained using gda_statement_get_parameters()), or %NULL
         * @param flags SQL rendering flags, as #GdaStatementSqlFlag OR'ed values
         * @returns a new string, or %NULL if an error occurred
         */
        statement_to_sql(
            stmt: Statement,
            params: Set | null,
            flags: StatementSqlFlag | null,
        ): [string, Holder[] | null];
        /**
         * Asks the underlying provider for if a specific feature is supported.
         * @param feature feature to ask for.
         * @returns %TRUE if the provider supports it, %FALSE if not.
         */
        supports_feature(feature: ConnectionFeature | null): boolean;
        /**
         * Updates `cnc'`s associated #GdaMetaStore. If `context` is not %NULL, then only the parts described by
         * `context` will be updated, and if it is %NULL, then the complete meta store will be updated. Detailed
         * explanations follow:
         *
         * In order to keep the meta store's contents in a consistent state, the update process involves updating
         * the contents of all the tables related to one where the contents change. For example the "_columns"
         * table (which lists all the columns of a table) depends on the "_tables" table (which lists all the tables
         * in a schema), so if a row is added, removed or modified in the "_tables", then the "_columns" table's contents
         * needs to be updated as well regarding that row.
         *
         * If `context` is %NULL, then the update process will simply overwrite any data that was present in all the
         * meta store's tables with new (up to date) data even if nothing has changed, without having to build the
         * tables' dependency tree. This is the recommended way of proceeding when dealing with a meta store which
         * might be outdated.
         *
         * On the other hand, if `context` is not %NULL, then a tree of the dependencies has to be built (depending on
         * `context)` and only some parts of the meta store are updated following that dependencies tree. Specifying a
         * context may be useful for example in the following situations:
         * <itemizedlist>
         *   <listitem><para>One knows that a database object has changed (for example a table created), and
         *                   may use the `context` to request that only the information about that table be updated
         *             </para></listitem>
         *   <listitem><para>One is only interested in the list of views, and may request that only the information
         *                   about views may be updated</para></listitem>
         * </itemizedlist>
         *
         * When `context` is not %NULL, and contains specified SQL identifiers (for example the "table_name" of the "_tables"
         * table), then each SQL identifier has to match the convention the #GdaMetaStore has adopted regarding
         * case sensitivity, using gda_connection_quote_sql_identifier() or gda_meta_store_sql_identifier_quote().
         *
         * see the <link linkend="information_schema:sql_identifiers">
         * meta data section about SQL identifiers</link> for more information, and the documentation about the
         * gda_sql_identifier_quote() function which will be most useful.
         *
         * Note however that usually <emphasis>more</emphasis> information will be updated than strictly requested by
         * the `context` argument.
         *
         * For more information, see the <link linkend="information_schema">Database structure</link> section, and
         * the <link linkend="howto-meta2">Update the meta data about a table</link> howto.
         * @param context description of which part of @cnc's associated #GdaMetaStore should be updated, or %NULL
         * @returns TRUE if no error occurred
         */
        update_meta_store(context?: MetaContext | null): boolean;
        /**
         * `col_names` and `values` must have length (&gt;= 1).
         *
         * This is a convenience function, which creates an UPDATE statement and executes it using the values
         * provided. It internally relies on variables which makes it immune to SQL injection problems.
         *
         * The equivalent SQL command is: UPDATE &lt;table&gt; SET &lt;column_name&gt; = &lt;new_value&gt; [,...] WHERE &lt;condition_column_name&gt; = &lt;condition_value&gt;.
         * @param table the table's name with the row's values to be updated
         * @param condition_column_name the name of the column to used in the WHERE condition clause
         * @param condition_value the @condition_column_type's GType
         * @param col_names a list of column names (as const gchar *)
         * @param values a list of values (as #GValue)
         * @returns TRUE if no error occurred, FALSE otherwise
         */
        update_row_in_table_v(
            table: string,
            condition_column_name: string,
            condition_value: GObject.Value | any,
            col_names: string[],
            values: (GObject.Value | any)[],
        ): boolean;
        /**
         * Produces a fully quoted and escaped string from a GValue
         * @param from #GValue to convert from
         * @returns escaped and quoted value or NULL if not supported.
         */
        value_to_sql_string(from: GObject.Value | any): string;

        // Inherited methods
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         * @returns TRUE if the object has successfully been locked.
         */
        trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        unlock(): void;
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        vfunc_unlock(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace ConnectionEvent {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::type': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            type: number;
        }
    }

    class ConnectionEvent extends GObject.Object {
        static $gtype: GObject.GType<ConnectionEvent>;

        // Properties

        get type(): number;
        set type(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ConnectionEvent.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ConnectionEvent.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ConnectionEvent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ConnectionEvent.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ConnectionEvent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ConnectionEvent.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ConnectionEvent.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ConnectionEvent.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_code(): number;
        /**
         * Get the description of the event. Note that is `event'`s type is GDA_CONNECTION_EVENT_COMMAND,
         * the the description is the SQL of the command.
         * @returns @event's description.
         */
        get_description(): string;
        /**
         * Get `event'`s severity (from a simple notice to a fatal event)
         * @returns the event type
         */
        get_event_type(): ConnectionEventType;
        /**
         * Retrieve the code associated to `event`.
         * @returns the #GdaConnectionEventCode event's code
         */
        get_gda_code(): ConnectionEventCode;
        get_source(): string;
        /**
         * Get the SQLSTATE value of `event`. Even though the SQLSTATE values are specified by ANSI SQL and ODBC,
         * consult each DBMS for the possible values. However, the "00000" (success) value means that there is no error,
         * and the "HY000" (general error) value means an error but no better error code available.
         * @returns @event's SQL state.
         */
        get_sqlstate(): string;
        /**
         * Sets `event'`s code: the code is specific to the provider being used.
         * If you want to have a common understanding of the event codes, use
         * gda_connection_event_get_gda_code() instead.
         *
         * This function should not be called directly
         * @param code a code.
         */
        set_code(code: number): void;
        /**
         * Sets `event'`s `description`. This function should not be called directly.
         * @param description a description, or %NULL (to unset current description if any)
         */
        set_description(description?: string | null): void;
        /**
         * Sets `event'`s severity (from a simple notice to a fatal event)
         * This function should not be called directly.
         * @param type the severity of the event
         */
        set_event_type(type: ConnectionEventType | null): void;
        /**
         * Sets `event'`s gda code: that code is standardized by the libgda
         * library. If you want to specify the corresponding provider specific code,
         * use gda_connection_event_get_code() or gda_connection_event_get_sqlstate() instead.
         *
         * This function should not be called directly
         * @param code a code
         */
        set_gda_code(code: ConnectionEventCode | null): void;
        /**
         * Sets `event'`s `source;` this function should not be called directly
         * @param source a source.
         */
        set_source(source: string): void;
        /**
         * Changes the SQLSTATE code of `event,` this function should not be called directly
         *
         * Sets `event'`s SQL state.
         * @param sqlstate SQL state.
         */
        set_sqlstate(sqlstate: string): void;
    }

    namespace ConnectionModelParams {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::cnc-string': (pspec: GObject.ParamSpec) => void;
            'notify::pasword': (pspec: GObject.ParamSpec) => void;
            'notify::user': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            cnc_string: string;
            cncString: string;
            pasword: string;
            user: string;
        }
    }

    class ConnectionModelParams extends GObject.Object {
        static $gtype: GObject.GType<ConnectionModelParams>;

        // Properties

        get cnc_string(): string;
        set cnc_string(val: string);
        get cncString(): string;
        set cncString(val: string);
        get pasword(): string;
        set pasword(val: string);
        get user(): string;
        set user(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ConnectionModelParams.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ConnectionModelParams.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ConnectionModelParams;

        // Signals

        connect<K extends keyof ConnectionModelParams.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ConnectionModelParams.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ConnectionModelParams.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ConnectionModelParams.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ConnectionModelParams.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ConnectionModelParams.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_cnc_string(): string;
        get_pasword(): string;
        get_user(): string;
        set_cnc_string(value: string): void;
        set_pasword(value: string): void;
        set_user(value: string): void;
    }

    namespace DataAccessWrapper {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::model': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            model: DataModel;
        }
    }

    class DataAccessWrapper extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataAccessWrapper>;

        // Properties

        get model(): DataModel;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataAccessWrapper.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataAccessWrapper.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataAccessWrapper.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataAccessWrapper.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataAccessWrapper.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataAccessWrapper.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataAccessWrapper.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataAccessWrapper.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates a new #GdaDataModel object which buffers the rows of `model`. This object is useful
         * only if `model` can only be accessed using cursor based method.
         * @param model a #GdaDataModel
         */
        static ['new'](model: DataModel): DataModel;

        // Methods

        /**
         * `wrapper` will report as many columns as `mapping_size,` and for each value at position 'i' in `mapping,`
         * `wrapper` will report the 'i'th column, mapped to the wrapped data model column at position mapping[i].
         * For example if mapping is {3, 4, 0}, then `wrapper` will report 3 columns, respectively mapped to the 4th,
         * 5th and 1st columns of the wrapped data model (as column numbers start at 0).
         *
         * If `mapping` is %NULL, then no mapping is done and `wrapper'`s columns will be the same as the wrapped
         * data model.
         *
         * If a column in `mapping` does not exist in the wrapped data model, then it is simply ignored (no error
         * reported).
         *
         * Please note that if `wrapper` has already been used and if the wrapped data model offers a cursor forward
         * access mode, then this method will return %FALSE and no action will be done.
         *
         * If the mapping is applied, then any existing iterator will be invalid, and `wrapper` is reset as if it
         * had just been created.
         * @param mapping an array of #gint which represents the mapping between @wrapper's columns and the columns of the wrapped data model
         * @returns %TRUE if the mapping actually changed
         */
        set_mapping(mapping?: number[] | null): boolean;

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataComparator {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'diff-computed': (arg0: any | null) => boolean | void;
            'notify::new-model': (pspec: GObject.ParamSpec) => void;
            'notify::old-model': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            new_model: DataModel;
            newModel: DataModel;
            old_model: DataModel;
            oldModel: DataModel;
        }
    }

    class DataComparator extends GObject.Object {
        static $gtype: GObject.GType<DataComparator>;

        // Properties

        get new_model(): DataModel;
        set new_model(val: DataModel);
        get newModel(): DataModel;
        set newModel(val: DataModel);
        get old_model(): DataModel;
        set old_model(val: DataModel);
        get oldModel(): DataModel;
        set oldModel(val: DataModel);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataComparator.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataComparator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](old_model: DataModel, new_model: DataModel): DataComparator;

        // Signals

        connect<K extends keyof DataComparator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataComparator.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataComparator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataComparator.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataComparator.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataComparator.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_diff_computed(diff: Diff): boolean;

        // Methods

        /**
         * Actually computes the differences between the data models for which `comp` is defined.
         *
         * For each difference computed, stored in a #GdaDiff structure, the "diff-computed" signal is emitted.
         * If one connects to this signal and returns FALSE in the signal handler, then computing differences will be
         * stopped and an error will be returned.
         * @returns TRUE if all the differences have been successfully computed, and FALSE if an error occurred
         */
        compute_diff(): boolean;
        /**
         * Get a pointer to the #GdaDiff structure representing the difference which number is `pos`
         * @param pos the requested difference number (starting at 0)
         * @returns a pointer to a #GdaDiff, or %NULL if @pos is invalid
         */
        get_diff(pos: number): Diff;
        /**
         * Get the number of differences as computed by the last time gda_data_comparator_compute_diff() was called.
         * @returns the number of computed differences
         */
        get_n_diffs(): number;
        /**
         * Defines the columns which will be used as a key when searching data. This is not mandatory but
         * will speed things up as less data will be processed.
         * @param col_numbers an array of @nb_cols values
         */
        set_key_columns(col_numbers: number[]): void;
    }

    namespace DataModelArray {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::n-columns': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            n_columns: number;
            nColumns: number;
            read_only: boolean;
            readOnly: boolean;
        }
    }

    class DataModelArray extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataModelArray>;

        // Properties

        get n_columns(): number;
        set n_columns(val: number);
        get nColumns(): number;
        set nColumns(val: number);
        get read_only(): boolean;
        set read_only(val: boolean);
        get readOnly(): boolean;
        set readOnly(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataModelArray.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataModelArray.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataModelArray.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelArray.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataModelArray.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelArray.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataModelArray.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataModelArray.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates a new #GdaDataModel object without initializing the column
         * types. Using gda_data_model_array_new_with_g_types() is usually better.
         * @param cols number of columns for rows in this data model.
         */
        static ['new'](cols: number): DataModel;
        /**
         * Creates a new #GdaDataModel object with the column types as
         * specified.
         * @param cols number of columns for rows in this data model.
         * @param types array of types of the columns of the model to create as #GType, as many as indicated by @cols
         */
        static new_with_g_types(cols: number, types: GObject.GType[]): DataModel;

        // Methods

        /**
         * Frees all the rows in `model`.
         */
        clear(): void;
        /**
         * Get a pointer to a row in `model`
         * @param row row number (starting from 0)
         * @returns the #GdaRow, or %NULL if an error occurred
         */
        get_row(row: number): Row;
        /**
         * Sets the number of columns for rows inserted in this model.
         * `cols` must be greated than or equal to 0.
         *
         * Also clears `model'`s contents.
         * @param cols number of columns for rows this data model should use.
         */
        set_n_columns(cols: number): void;

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataModelDir {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::basedir': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            basedir: string;
        }
    }

    class DataModelDir extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataModelDir>;

        // Properties

        get basedir(): string;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataModelDir.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataModelDir.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataModelDir.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelDir.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataModelDir.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelDir.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataModelDir.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataModelDir.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates a new #GdaDataModel object to list all the files starting from `basedir`
         * @param basedir a directory
         */
        static ['new'](basedir: string): DataModel;

        // Methods

        /**
         * Reset the list of errors which have occurred while using `model`
         */
        clean_errors(): void;
        /**
         * Get the list of errors which have occurred while using `model`
         * @returns a read-only list of #GError pointers, or %NULL if no error has occurred
         */
        get_errors(): GLib.Error[];

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataModelImport {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::data-string': (pspec: GObject.ParamSpec) => void;
            'notify::filename': (pspec: GObject.ParamSpec) => void;
            'notify::options': (pspec: GObject.ParamSpec) => void;
            'notify::random-access': (pspec: GObject.ParamSpec) => void;
            'notify::strict': (pspec: GObject.ParamSpec) => void;
            'notify::xml-node': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            data_string: string;
            dataString: string;
            filename: string;
            options: Set;
            random_access: boolean;
            randomAccess: boolean;
            strict: boolean;
            xml_node: any;
            xmlNode: any;
        }
    }

    class DataModelImport extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataModelImport>;

        // Properties

        /**
         * Data to import, as a string.
         */
        get data_string(): string;
        /**
         * Data to import, as a string.
         */
        get dataString(): string;
        /**
         * Name of the file to import.
         */
        get filename(): string;
        /**
         * Data model options.
         */
        get options(): Set;
        /**
         * Defines if the data model will be accessed randomly or through a cursor. If set to %FALSE,
         * access will have to be done using a cursor.
         */
        get random_access(): boolean;
        /**
         * Defines if the data model will be accessed randomly or through a cursor. If set to %FALSE,
         * access will have to be done using a cursor.
         */
        get randomAccess(): boolean;
        /**
         * Defines the behaviour in case the imported data contains recoverable errors (usually too
         * many or too few data per row). If set to %TRUE, an error will be reported and the import
         * will stop, and if set to %FALSE, then the error will be reported but the import will not stop.
         */
        get strict(): boolean;
        set strict(val: boolean);
        /**
         * Data to import, as a pointer to an XML node (a #xmlNodePtr).
         */
        get xml_node(): any;
        /**
         * Data to import, as a pointer to an XML node (a #xmlNodePtr).
         */
        get xmlNode(): any;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataModelImport.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataModelImport.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataModelImport.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelImport.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataModelImport.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelImport.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataModelImport.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataModelImport.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates a new #GdaDataModel object which contains the data stored within the `filename` file.
         *
         * The options are the following ones:
         * <itemizedlist>
         *   <listitem><para>For the CSV format:
         *      <itemizedlist>
         *         <listitem><para>ENCODING (string): specifies the encoding of the data in the file</para></listitem>
         *         <listitem><para>SEPARATOR (string): specifies the CSV separator (comma as default)</para></listitem>
         *         <listitem><para>QUOTE (string): specifies the character used as quote (double quote as default)</para></listitem>
         *         <listitem><para>NAMES_ON_FIRST_LINE (boolean): consider that the first line of the file contains columns' titles (note that the TITLE_AS_FIRST_LINE option is also accepted as a synonym)</para></listitem>
         *         <listitem><para>G_TYPE_&lt;column number&gt; (GType): specifies the type of value expected in column &lt;column number&gt;</para></listitem>
         *      </itemizedlist>
         *   </para></listitem>
         *   <listitem><para>Other formats: no option</para></listitem>
         * </itemizedlist>
         *
         * Note: after the creation, please use gda_data_model_import_get_errors() to check any error.
         * @param filename the file to import data from
         * @param random_access TRUE if random access will be required
         * @param options importing options
         */
        static new_file(filename: string, random_access: boolean, options?: Set | null): DataModel;
        /**
         * Creates a new #GdaDataModel object which contains the data stored in the `data` string.
         *
         * Important note: the `data` string is not copied for memory efficiency reasons and should not
         * therefore be altered in any way as long as the returned data model exists.
         * @param data a string containing the data to import
         * @param random_access TRUE if random access will be required
         * @param options importing options, see gda_data_model_import_new_file() for more information
         */
        static new_mem(data: string, random_access: boolean, options?: Set | null): DataModel;
        /**
         * Creates a new #GdaDataModel and loads the data in `node`. The resulting data model
         * can be accessed in a random way.
         * @param node an XML node corresponding to a &lt;data-array&gt; tag
         */
        static new_xml_node(node: libxml2.NodePtr): DataModel;

        // Methods

        /**
         * Clears the history of errors `model` has to report
         */
        clean_errors(): void;
        /**
         * Get the list of errors which `model` has to report. The returned list is a list of
         * #GError structures, and must not be modified
         * @returns the list of errors (which must not be modified), or %NULL
         */
        get_errors(): GLib.Error[];

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataModelImportIter {
        // Signal signatures
        interface SignalSignatures extends DataModelIter.SignalSignatures {
            'notify::current-row': (pspec: GObject.ParamSpec) => void;
            'notify::data-model': (pspec: GObject.ParamSpec) => void;
            'notify::update-model': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::holders': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::validate-changes': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends DataModelIter.ConstructorProps {}
    }

    class DataModelImportIter extends DataModelIter {
        static $gtype: GObject.GType<DataModelImportIter>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataModelImportIter.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataModelImportIter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataModelImportIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelImportIter.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataModelImportIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelImportIter.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataModelImportIter.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataModelImportIter.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace DataModelIter {
        // Signal signatures
        interface SignalSignatures extends Set.SignalSignatures {
            'end-of-data': () => void;
            'row-changed': (arg0: number) => void;
            'notify::current-row': (pspec: GObject.ParamSpec) => void;
            'notify::data-model': (pspec: GObject.ParamSpec) => void;
            'notify::update-model': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::holders': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::validate-changes': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Set.ConstructorProps {
            current_row: number;
            currentRow: number;
            data_model: DataModel;
            dataModel: DataModel;
            update_model: boolean;
            updateModel: boolean;
        }
    }

    class DataModelIter extends Set {
        static $gtype: GObject.GType<DataModelIter>;

        // Properties

        get current_row(): number;
        set current_row(val: number);
        get currentRow(): number;
        set currentRow(val: number);
        get data_model(): DataModel;
        set data_model(val: DataModel);
        get dataModel(): DataModel;
        set dataModel(val: DataModel);
        get update_model(): boolean;
        set update_model(val: boolean);
        get updateModel(): boolean;
        set updateModel(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataModelIter.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataModelIter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataModelIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelIter.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataModelIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelIter.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataModelIter.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataModelIter.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_end_of_data(): void;
        /**
         * Moves `iter` one row further than where it already is
         * (synchronizes the values of the parameters in `iter` with the values at the new row).
         *
         * If the iterator was on the data model's last row, then it can't be moved forward
         * anymore, and the returned value is %FALSE; note also that the "current-row" property
         * is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE)
         *
         * This function can return %FALSE if it was not allowed to be moved (as it emits the
         * "validate-set" signal before being moved).
         *
         * When this function returns %TRUE, then `iter` has actually been moved to the next row,
         * but some values may not have been read correctly in the row, in which case the
         * correcsponding #GdaHolder will be left invalid.
         */
        vfunc_move_next(): boolean;
        /**
         * Moves `iter` one row before where it already is (synchronizes the values of the parameters in `iter`
         * with the values at the new row).
         *
         * If the iterator was on the data model's first row, then it can't be moved backwards
         * anymore, and the returned value is %FALSE; note also that the "current-row" property
         * is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE).
         *
         * This function can return %FALSE if it was not allowed to be moved (as it emits the
         * "validate-set" signal before being moved).
         *
         * When this function returns %TRUE, then `iter` has actually been moved to the next row,
         * but some values may not have been read correctly in the row, in which case the
         * correcsponding #GdaHolder will be left invalid.
         */
        vfunc_move_prev(): boolean;
        /**
         * Synchronizes the values of the parameters in `iter` with the values at the `row` row.
         *
         * If `row` is not a valid row, then the returned value is %FALSE, and the "current-row"
         * property is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE),
         * with the exception that if `row` is -1, then the returned value is %TRUE.
         *
         * This function can return %FALSE if it was not allowed to be moved (as it emits the
         * "validate-set" signal before being moved).
         *
         * When this function returns %TRUE, then `iter` has actually been moved to the next row,
         * but some values may not have been read correctly in the row, in which case the
         * correcsponding #GdaHolder will be left invalid.
         * @param row the row to set @iter to
         */
        vfunc_move_to_row(row: number): boolean;
        vfunc_row_changed(row: number): void;
        /**
         * Sets a value in `iter,` at the column specified by `col`
         * @param col the column number
         * @param value a #GValue (not %NULL)
         */
        vfunc_set_value_at(col: number, value: GObject.Value | any): boolean;

        // Methods

        /**
         * Fetch a pointer to the #GdaHolder object which is synchronized with data at
         * column `col`
         * @param col the requested column
         * @returns the #GdaHolder, or %NULL if an error occurred
         */
        get_holder_for_field(col: number): Holder;
        /**
         * Get the row which `iter` represents in the data model
         * @returns the row number, or -1 if @iter is invalid
         */
        get_row(): number;
        /**
         * Get the value stored at the column `col` in `iter`. The returned value must not be modified.
         * @param col the requested column
         * @returns the #GValue, or %NULL if the value could not be fetched
         */
        get_value_at(col: number): GObject.Value | null;
        /**
         * Get the value stored at the column `col` in `iter`. The returned value must not be modified.
         * @param col the requested column
         * @returns the #GValue, or %NULL if the value could not be fetched
         */
        get_value_at_e(col: number): GObject.Value | null;
        /**
         * Get the value stored at the column `field_name` in `iter`
         * @param field_name the requested column name
         * @returns the #GValue, or %NULL
         */
        get_value_for_field(field_name: string): GObject.Value | null;
        /**
         * Declare all the parameters in `iter` invalid, without modifying the
         * #GdaDataModel `iter` is for or changing the row it represents. This method
         * is for internal usage. Note that for gda_data_model_iter_is_valid() to return %FALSE,
         * it is also necessary to set the "current-row" property to -1.
         */
        invalidate_contents(): void;
        /**
         * Tells if `iter` is a valid iterator (if it actually corresponds to a valid row in the model)
         * @returns TRUE if @iter is valid
         */
        is_valid(): boolean;
        /**
         * Moves `iter` one row further than where it already is
         * (synchronizes the values of the parameters in `iter` with the values at the new row).
         *
         * If the iterator was on the data model's last row, then it can't be moved forward
         * anymore, and the returned value is %FALSE; note also that the "current-row" property
         * is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE)
         *
         * This function can return %FALSE if it was not allowed to be moved (as it emits the
         * "validate-set" signal before being moved).
         *
         * When this function returns %TRUE, then `iter` has actually been moved to the next row,
         * but some values may not have been read correctly in the row, in which case the
         * correcsponding #GdaHolder will be left invalid.
         * @returns %TRUE if the iterator is now at the next row
         */
        move_next(): boolean;
        /**
         * Moves `iter` one row before where it already is (synchronizes the values of the parameters in `iter`
         * with the values at the new row).
         *
         * If the iterator was on the data model's first row, then it can't be moved backwards
         * anymore, and the returned value is %FALSE; note also that the "current-row" property
         * is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE).
         *
         * This function can return %FALSE if it was not allowed to be moved (as it emits the
         * "validate-set" signal before being moved).
         *
         * When this function returns %TRUE, then `iter` has actually been moved to the next row,
         * but some values may not have been read correctly in the row, in which case the
         * correcsponding #GdaHolder will be left invalid.
         * @returns %TRUE if the iterator is now at the previous row
         */
        move_prev(): boolean;
        /**
         * Synchronizes the values of the parameters in `iter` with the values at the `row` row.
         *
         * If `row` is not a valid row, then the returned value is %FALSE, and the "current-row"
         * property is set to -1 (which means that gda_data_model_iter_is_valid() would return %FALSE),
         * with the exception that if `row` is -1, then the returned value is %TRUE.
         *
         * This function can return %FALSE if it was not allowed to be moved (as it emits the
         * "validate-set" signal before being moved).
         *
         * When this function returns %TRUE, then `iter` has actually been moved to the next row,
         * but some values may not have been read correctly in the row, in which case the
         * correcsponding #GdaHolder will be left invalid.
         * @param row the row to set @iter to
         * @returns %TRUE if no error occurred
         */
        move_to_row(row: number): boolean;
        /**
         * Sets a value in `iter,` at the column specified by `col`
         * @param col the column number
         * @param value a #GValue (not %NULL)
         * @returns TRUE if no error occurred
         */
        set_value_at(col: number, value: GObject.Value | any): boolean;
    }

    namespace DataModelSelect {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            updated: () => void;
            'notify::valid': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            valid: boolean;
        }
    }

    class DataModelSelect extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataModelSelect>;

        // Properties

        get valid(): boolean;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataModelSelect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataModelSelect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](cnc: Connection, stm: Statement, params?: Set | null): DataModelSelect;

        static new_from_string(cnc: Connection, sql: string): DataModelSelect;

        // Signals

        connect<K extends keyof DataModelSelect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelSelect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataModelSelect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataModelSelect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataModelSelect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataModelSelect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_updated(): void;

        // Methods

        get_parameters(): Set;
        /**
         * If at creation or after parameters change has been set, a SELECT statement
         * is ejectuted, if unsuccess then this model is at invalid state.
         * @returns TRUE if a valid data model is present
         */
        is_valid(): boolean;
        set_parameters(params: Set): void;

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataPivot {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::model': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            model: DataModel;
        }
    }

    class DataPivot extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataPivot>;

        // Properties

        get model(): DataModel;
        set model(val: DataModel);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataPivot.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataPivot.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataPivot.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataPivot.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataPivot.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataPivot.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataPivot.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataPivot.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;
        /**
         * Creates a new #GdaDataModel which will contain analysed data from `model`.
         * @param model a #GdaDataModel to analyse data from, or %NULL
         */
        static ['new'](model?: DataModel | null): DataModel;

        // Methods

        /**
         * Specifies that `field` has to be included in the analysis.
         * `field` is a field specification with the following accepted syntaxes:
         * <itemizedlist>
         *   <listitem><para>a column name in the source data model (see <link linkend="gda-data-model-get-column-index">gda_data_model_get_column_index()</link>); or</para></listitem>
         *   <listitem><para>an SQL expression involving a column name in the source data model, for examples:
         *   <programlisting>
         * price
         * firstname || ' ' || lastname
         * nb BETWEEN 5 AND 10</programlisting>
         * </para></listitem>
         * </itemizedlist>
         *
         * It is also possible to specify several fields to be added, while separating them by a comma (in effect
         * still forming a valid SQL syntax).
         * @param aggregate_type the type of aggregate operation to perform
         * @param field the field description, see below
         * @param alias the field alias, or %NULL
         * @returns %TRUE if no error occurred
         */
        add_data(aggregate_type: DataPivotAggregate | null, field: string, alias?: string | null): boolean;
        /**
         * Specifies that `field` has to be included in the analysis.
         * `field` is a field specification with the following accepted syntaxes:
         * <itemizedlist>
         *   <listitem><para>a column name in the source data model (see <link linkend="gda-data-model-get-column-index">gda_data_model_get_column_index()</link>); or</para></listitem>
         *   <listitem><para>an SQL expression involving a column name in the source data model, for example:
         *   <programlisting>
         * price
         * firstname || ' ' || lastname
         * nb BETWEEN 5 AND 10</programlisting>
         * </para></listitem>
         * </itemizedlist>
         *
         * It is also possible to specify several fields to be added, while separating them by a comma (in effect
         * still forming a valid SQL syntax).
         * @param field_type the type of field to add
         * @param field the field description, see below
         * @param alias the field alias, or %NULL
         * @returns %TRUE if no error occurred
         */
        add_field(field_type: DataPivotFieldType | null, field: string, alias?: string | null): boolean;
        /**
         * Acutally populates `pivot` by analysing the data from the provided data model.
         * @returns %TRUE if no error occurred.
         */
        populate(): boolean;

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataProxy {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'filter-changed': () => void;
            'row-changes-applied': (arg0: number, arg1: number) => void;
            'row-delete-changed': (arg0: number, arg1: boolean) => void;
            'sample-changed': (arg0: number, arg1: number) => void;
            'sample-size-changed': (arg0: number) => void;
            'validate-row-changes': (arg0: number, arg1: number) => GLib.Error;
            'notify::cache-changes': (pspec: GObject.ParamSpec) => void;
            'notify::defer-sync': (pspec: GObject.ParamSpec) => void;
            'notify::model': (pspec: GObject.ParamSpec) => void;
            'notify::prepend-null-entry': (pspec: GObject.ParamSpec) => void;
            'notify::sample-size': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            cache_changes: boolean;
            cacheChanges: boolean;
            defer_sync: boolean;
            deferSync: boolean;
            model: DataModel;
            prepend_null_entry: boolean;
            prependNullEntry: boolean;
            sample_size: number;
            sampleSize: number;
        }
    }

    class DataProxy extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataProxy>;

        // Properties

        /**
         * Defines how changes kept in the data proxy are handled when the proxied data model
         * is changed (using the "model" property). The default is to silently discard all the
         * changes, but if this property is set to %TRUE, then the changes are cached.
         *
         * If set to %TRUE, each cached change will be re-applied to a newly set proxied data model if
         * the change's number of columns match the proxied data model's number of columns and based on:
         * <itemizedlist>
         *   <listitem><para>the contents of the proxied data model's modified row for updates and deletes</para></listitem>
         *   <listitem><para>the inserts are always kept</para></listitem>
         * </itemizedlist>
         */
        get cache_changes(): boolean;
        set cache_changes(val: boolean);
        /**
         * Defines how changes kept in the data proxy are handled when the proxied data model
         * is changed (using the "model" property). The default is to silently discard all the
         * changes, but if this property is set to %TRUE, then the changes are cached.
         *
         * If set to %TRUE, each cached change will be re-applied to a newly set proxied data model if
         * the change's number of columns match the proxied data model's number of columns and based on:
         * <itemizedlist>
         *   <listitem><para>the contents of the proxied data model's modified row for updates and deletes</para></listitem>
         *   <listitem><para>the inserts are always kept</para></listitem>
         * </itemizedlist>
         */
        get cacheChanges(): boolean;
        set cacheChanges(val: boolean);
        get defer_sync(): boolean;
        set defer_sync(val: boolean);
        get deferSync(): boolean;
        set deferSync(val: boolean);
        get model(): DataModel;
        set model(val: DataModel);
        get prepend_null_entry(): boolean;
        set prepend_null_entry(val: boolean);
        get prependNullEntry(): boolean;
        set prependNullEntry(val: boolean);
        get sample_size(): number;
        set sample_size(val: number);
        get sampleSize(): number;
        set sampleSize(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataProxy.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataProxy.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](model: DataModel): DataProxy;

        static new_with_data_model(model: DataModel): DataProxy;

        // Signals

        connect<K extends keyof DataProxy.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataProxy.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataProxy.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataProxy.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataProxy.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataProxy.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_filter_changed(): void;
        vfunc_row_changes_applied(row: number, proxied_row: number): void;
        vfunc_row_delete_changed(row: number, to_be_deleted: boolean): void;
        vfunc_sample_changed(sample_start: number, sample_end: number): void;
        vfunc_sample_size_changed(sample_size: number): void;
        vfunc_validate_row_changes(row: number, proxied_row: number): GLib.Error;

        // Methods

        /**
         * Alters the attributes of the value stored at (proxy_row, col) in `proxy`. the `alter_flags`
         * can only contain the GDA_VALUE_ATTR_IS_NULL, GDA_VALUE_ATTR_IS_DEFAULT and GDA_VALUE_ATTR_IS_UNCHANGED
         * flags (other flags are ignored).
         * @param proxy_row A proxy row number
         * @param col a valid column number
         * @param alter_flags flags to alter the attributes
         */
        alter_value_attributes(proxy_row: number, col: number, alter_flags: ValueAttribute | null): void;
        /**
         * Apply all the changes stored in the proxy to the proxied data model. The changes are done row
         * after row, and if an error
         * occurs, then it is possible that not all the changes to all the rows have been applied.
         * @returns TRUE if no error occurred
         */
        apply_all_changes(): boolean;
        /**
         * Commits the modified data in the proxy back into the #GdaDataModel.
         * @param proxy_row the row number to commit
         * @returns TRUE if no error occurred.
         */
        apply_row_changes(proxy_row: number): boolean;
        /**
         * Cancel all the changes stored in the proxy (the `proxy` will be reset to its state
         * as it was just after creation). Note that if there are some cached changes (i.e. not applied
         * to the current proxied data model), then these cached changes are not cleared (set the "cache-changes"
         * property to %FALSE for this).
         * @returns TRUE if no error occurred
         */
        cancel_all_changes(): boolean;
        /**
         * Resets data at the corresponding row and column. If `proxy_row` corresponds to a new row, then
         * that new row is deleted from `proxy`.
         * @param proxy_row the row to cancel changes
         * @param col the column to cancel changes, or less than 0 to cancel any change on the @row row
         */
        cancel_row_changes(proxy_row: number, col: number): void;
        /**
         * Marks the row `proxy_row` to be deleted
         * @param proxy_row A proxy row number
         */
        ['delete'](proxy_row: number): void;
        /**
         * Get the current filter expression used by `proxy`.
         * @returns the current filter expression or %NULL if no filter has been set
         */
        get_filter_expr(): string;
        /**
         * Get the total number of filtered rows in `proxy` if a filter has been applied. As new rows
         * (rows added to the proxy and not yet added to the proxied data model) and rows to remove
         * (rows marked for removal but not yet removed from the proxied data model) are also filtered,
         * the returned number also contains references to new rows and rows to be removed.
         * @returns the number of filtered rows in @proxy, or -1 if no filter has been applied
         */
        get_filtered_n_rows(): number;
        /**
         * Get the number of rows which have been modified in the proxy (the sum of rows existing in
         * the proxied data model which have been modified, and new rows).
         * @returns the number of modified rows
         */
        get_n_modified_rows(): number;
        /**
         * Get the number of rows which have been added to `proxy` and which are not part of
         * the proxied data model.
         * @returns the number of new rows
         */
        get_n_new_rows(): number;
        /**
         * Fetch the #GdaDataModel which `proxy` does proxy
         * @returns the proxied data model
         */
        get_proxied_model(): DataModel;
        /**
         * Get the number of columns in the proxied data model
         * @returns the number of columns, or -1 if an error occurred
         */
        get_proxied_model_n_cols(): number;
        /**
         * Get the number of rows in the proxied data model
         * @returns the number of rows, or -1 if the number of rows is not known
         */
        get_proxied_model_n_rows(): number;
        /**
         * Get the `proxy'`s proxied model row corresponding to `proxy_row`
         * @param proxy_row A proxy row number
         * @returns the proxied model's row, or -1 if @proxy row which only exists @proxy
         */
        get_proxied_model_row(proxy_row: number): number;
        /**
         * Get the number of the last row to be available in `proxy` (in reference to the proxied data model)
         * @returns the number of the last proxied model's row.
         */
        get_sample_end(): number;
        /**
         * Get the size of each chunk of data displayed at a time.
         * @returns the chunk (or sample) size, or 0 if chunking is disabled.
         */
        get_sample_size(): number;
        /**
         * Get the number of the first row to be available in `proxy` (in reference to the proxied data model)
         * @returns the number of the first proxied model's row.
         */
        get_sample_start(): number;
        /**
         * Get the attributes of the value stored at (proxy_row, col) in `proxy,` which
         * is an ORed value of #GdaValueAttribute flags
         * @param proxy_row a proxy row
         * @param col a valid proxy column
         * @returns a #GdaValueAttribute with the value's attributes at given position
         */
        get_value_attributes(proxy_row: number, col: number): ValueAttribute;
        /**
         * Retrieve a whole list of values from the `proxy` data model. This function
         * calls gda_data_proxy_get_value()
         * for each column index specified in `cols_index,` and generates a #GSList on the way.
         * @param proxy_row a proxy row
         * @param cols_index array containing the columns for which the values are requested
         * @returns a new list of values (the list must be freed, not the values), or %NULL if an error occurred
         */
        get_values(proxy_row: number, cols_index: number[]): unknown[];
        /**
         * Tells if `proxy` contains any modifications not applied to the proxied data model.
         * @returns TRUE if there are some modifications in @proxy
         */
        has_changed(): boolean;
        is_read_only(): boolean;
        /**
         * Tells if the row number `proxy_row` has changed
         * @param proxy_row A proxy row number
         * @returns TRUE if the row has changed
         */
        row_has_changed(proxy_row: number): boolean;
        /**
         * Tells if the row number `proxy_row` is marked to be deleted.
         * @param proxy_row A proxy row number
         * @returns TRUE if the row is marked to be deleted
         */
        row_is_deleted(proxy_row: number): boolean;
        /**
         * Tells if the row number `proxy_row` is a row which has been inserted in `proxy`
         * (and is thus not in the proxied data model).
         * @param proxy_row A proxy row number
         * @returns TRUE if the row is an inserted row
         */
        row_is_inserted(proxy_row: number): boolean;
        /**
         * Sets a filter among the rows presented by `proxy`. The filter is defined by a filter expression
         * which can be any SQL valid expression using `proxy'`s columns. For instance if `proxy` has the "id" and
         * "name" columns, then a filter can be "length(name) < 5" to filter only the rows where the length of the
         * name is strictly inferior to 5, or "id >= 1000 and id < 2000 order by name limit 50" to filter only the rows where the id
         * is between 1000 and 2000, ordered by name and limited to 50 rows.
         *
         * Note about column names: real column names can be used (double quoted if necessary), but columns can also be named
         * "_&lt;column number&gt;" with column numbers starting at 1.
         *
         * Note that any previous filter expression is replaced with the new `filter_expr` if no error occurs
         * (if an error occurs, then any previous filter is left unchanged).
         * @param filter_expr an SQL based expression which will filter the contents of @proxy, or %NULL to remove any previous filter
         * @returns TRUE if no error occurred
         */
        set_filter_expr(filter_expr?: string | null): boolean;
        /**
         * Orders by the `col` column
         * @param col the column number to order from
         * @returns TRUE if no error occurred
         */
        set_ordering_column(col: number): boolean;
        /**
         * Sets the size of each chunk of data to display: the maximum number of rows which
         * can be "displayed" at a time (the maximum number of rows which `proxy` pretends to have).
         * The default value is arbitrary 300 as it is big enough to
         * be able to display quite a lot of data, but small enough to avoid too much data
         * displayed at the same time.
         *
         * Note: the rows which have been added but not yet committed will always be displayed
         * regardless of the current chunk of data, and the modified rows which are not visible
         * when the displayed chunk of data changes are still held as modified rows.
         *
         * To remove the chunking of the data to display, simply pass `sample_size` the %0 value.
         * @param sample_size the requested size of a chunk, or 0
         */
        set_sample_size(sample_size: number): void;
        /**
         * Sets the number of the first row to be available in `proxy` (in reference to the proxied data model)
         * @param sample_start the number of the first row to be displayed
         */
        set_sample_start(sample_start: number): void;
        /**
         * Remove the "to be deleted" mark at the row `proxy_row,` if it existed.
         * @param proxy_row A proxy row number
         */
        undelete(proxy_row: number): void;

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataSelect {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::connection': (pspec: GObject.ParamSpec) => void;
            'notify::delete-stmt': (pspec: GObject.ParamSpec) => void;
            'notify::exec-params': (pspec: GObject.ParamSpec) => void;
            'notify::execution-delay': (pspec: GObject.ParamSpec) => void;
            'notify::insert-stmt': (pspec: GObject.ParamSpec) => void;
            'notify::model-usage': (pspec: GObject.ParamSpec) => void;
            'notify::prepared-stmt': (pspec: GObject.ParamSpec) => void;
            'notify::select-stmt': (pspec: GObject.ParamSpec) => void;
            'notify::store-all-rows': (pspec: GObject.ParamSpec) => void;
            'notify::update-stmt': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataModel.ConstructorProps {
            connection: Connection;
            delete_stmt: Statement;
            deleteStmt: Statement;
            exec_params: Set;
            execParams: Set;
            execution_delay: number;
            executionDelay: number;
            insert_stmt: Statement;
            insertStmt: Statement;
            model_usage: number;
            modelUsage: number;
            prepared_stmt: PStmt;
            preparedStmt: PStmt;
            select_stmt: Statement;
            selectStmt: Statement;
            store_all_rows: boolean;
            storeAllRows: boolean;
            update_stmt: Statement;
            updateStmt: Statement;
        }
    }

    class DataSelect extends GObject.Object implements DataModel {
        static $gtype: GObject.GType<DataSelect>;

        // Properties

        get connection(): Connection;
        get delete_stmt(): Statement;
        set delete_stmt(val: Statement);
        get deleteStmt(): Statement;
        set deleteStmt(val: Statement);
        get exec_params(): Set;
        get execParams(): Set;
        /**
         * This property stores the execution delay which has been necessary to obtain the data
         */
        get execution_delay(): number;
        set execution_delay(val: number);
        /**
         * This property stores the execution delay which has been necessary to obtain the data
         */
        get executionDelay(): number;
        set executionDelay(val: number);
        get insert_stmt(): Statement;
        set insert_stmt(val: Statement);
        get insertStmt(): Statement;
        set insertStmt(val: Statement);
        get model_usage(): number;
        get modelUsage(): number;
        get prepared_stmt(): PStmt;
        set prepared_stmt(val: PStmt);
        get preparedStmt(): PStmt;
        set preparedStmt(val: PStmt);
        get select_stmt(): Statement;
        get selectStmt(): Statement;
        get store_all_rows(): boolean;
        set store_all_rows(val: boolean);
        get storeAllRows(): boolean;
        set storeAllRows(val: boolean);
        get update_stmt(): Statement;
        set update_stmt(val: Statement);
        get updateStmt(): Statement;
        set updateStmt(val: Statement);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataSelect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataSelect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataSelect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataSelect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataSelect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataSelect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataSelect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataSelect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_fetch_at(prow: Row, rownum: number): boolean;
        vfunc_fetch_nb_rows(): number;
        vfunc_fetch_next(prow: Row, rownum: number): boolean;
        vfunc_fetch_prev(prow: Row, rownum: number): boolean;
        vfunc_fetch_random(prow: Row, rownum: number): boolean;
        vfunc_store_all(): boolean;

        // Methods

        /**
         * Computes correct attributes for each of `model'`s columns, which includes the "NOT NULL" attribute, the
         * default value, the precision and scale for numeric values.
         * @returns TRUE if no error occurred
         */
        compute_columns_attributes(): boolean;
        /**
         * Makes `model` try to compute INSERT, UPDATE and DELETE statements to be used when modifying `model'`s contents.
         * Note: any modification statement set using gda_data_select_set_modification_statement() will first be unset
         *
         * This function is similar to calling gda_data_select_compute_modification_statements_ext() with
         * `cond_type` set to %GDA_DATA_SELECT_COND_PK
         * @returns %TRUE if no error occurred. If %FALSE is returned, then some modification statement may still have been computed
         */
        compute_modification_statements(): boolean;
        /**
         * Makes `model` try to compute INSERT, UPDATE and DELETE statements to be used when modifying `model'`s contents.
         * Note: any modification statement set using gda_data_select_set_modification_statement() will first be unset
         * @param cond_type the type of condition for the modifications where one row only should be identified
         * @returns %TRUE if no error occurred. If %FALSE is returned, then some modification statement may still have been computed
         */
        compute_modification_statements_ext(cond_type: DataSelectConditionType | null): boolean;
        /**
         * Offers the same features as gda_data_select_set_row_selection_condition() but the expression
         * is computed from the meta data associated to the connection being used when `model` was created.
         *
         * NOTE1: make sure the meta data associated to the connection is up to date before using this
         * method, see gda_connection_update_meta_store().
         *
         * NOTE2: if the SELECT statement from which `model` has been created uses more than one table, or
         * if the table used does not have any primary key, then this method will fail
         * @returns TRUE if no error occurred.
         */
        compute_row_selection_condition(): boolean;
        get_advertized_nrows(): number;
        /**
         * Get a pointer to the #GdaConnection object which was used when `model` was created
         * (and which may be used internally by `model)`.
         * @returns a pointer to the #GdaConnection, or %NULL
         */
        get_connection(): Connection;
        get_nb_stored_rows(): number;
        get_prep_stmt(): PStmt;
        /**
         * Use this method to make sure all the data contained in the data model are stored on the client
         * side (and that no subsquent call to the server will be necessary to access that data), at the cost of
         * a higher memory consumption.
         *
         * This method is useful in the following situations:
         * <itemizedlist>
         *   <listitem><para>You need to disconnect from the server and continue to use the data in the data model</para></listitem>
         *   <listitem><para>You need to make sure the data in the data model can be used even though the connection to the server may be used for other purposes (for example executing other queries)</para></listitem>
         * </itemizedlist>
         *
         * Note that this method will fail if:
         * <itemizedlist>
         *   <listitem><para>the data model contains any blobs (because blobs reading requires acces to the server);
         *     binary values are Ok, though.</para></listitem>
         *   <listitem><para>the data model has been modified since it was created</para></listitem>
         * </itemizedlist>
         * @returns %TRUE if no error occurred
         */
        prepare_for_offline(): boolean;
        set_advertized_nrows(n: number): void;
        /**
         * Informs `model` that it should allow modifications to the data in some columns and some rows
         * using `mod_stmt` to propagate those modifications into the database.
         *
         * If `mod_stmt` is:
         * <itemizedlist>
         *  <listitem><para>an UPDATE statement, then all the rows in `model` will be writable</para></listitem>
         *  <listitem><para>a DELETE statement, then it will be possible to delete rows in `model<`/para></listitem>
         *  <listitem><para>in INSERT statement, then it will be possible to add some rows to `model<`/para></listitem>
         *  <listitem><para>any other statement, then this method will return an error</para></listitem>
         * </itemizedlist>
         *
         * This method can be called several times to specify different types of modification statements.
         *
         * Each modification statement will be executed when one or more values are modified in the data model;
         * each statement should then include variables which will be set to either the old value or the
         * new value of a column at the specified modified row (but can also contain other variables). Each variable
         * named as "+&lt;number&gt;" will be mapped to the new value of the number'th column (starting at 0), and
         * each variable named as "-&lt;number&gt;" will be mapped to the old value of the number'th column.
         *
         * Examples of the SQL equivalent of each statement are (for example if "mytable" has the "id" field as
         * primary key, and if that field is auto incremented and if the data model is the result of
         * executing "<![CDATA[SELECT * from mytable]]>").
         *
         * <itemizedlist>
         *  <listitem><para>"<![CDATA[INSERT INTO mytable (name) VALUES (##+1::string)]]>": the column ID can not be set
         *   for new rows</para></listitem>
         *  <listitem><para>"<![CDATA[DELETE FROM mytable WHERE id=##-0::int]]>"</para></listitem>
         *  <listitem><para>"<![CDATA[UPDATE mytable SET name=##+1::string WHERE id=##-0::int]]>": the column ID cannot be
         *   modified</para></listitem>
         * </itemizedlist>
         *
         * Also see the gda_data_select_set_row_selection_condition_sql() for more information about the WHERE
         * part of the UPDATE and DELETE statement types.
         *
         * If `mod_stmt` is an UPDATE or DELETE statement then it should have a WHERE part which identifies
         * a unique row in `model` (please note that this property can't be checked but may result
         * in `model` behaving in an unpredictable way).
         *
         * NOTE1: However, if the gda_data_select_set_row_selection_condition()
         * or gda_data_select_set_row_selection_condition_sql() have been successfully be called before, the WHERE
         * part of `mod_stmt` <emphasis>WILL</emphasis> be modified to use the row selection condition specified through one of
         * these methods (please not that it is then possible to avoid specifying a WHERE part in `mod_stmt` then).
         *
         * NOTE2: if gda_data_select_set_row_selection_condition()
         * or gda_data_select_set_row_selection_condition_sql() have not yet been successfully be called before, then
         * the WHERE part of `mod_stmt` will be used as if one of these functions had been called.
         * @param mod_stmt a #GdaStatement (INSERT, UPDATE or DELETE)
         * @returns %TRUE if no error occurred.
         */
        set_modification_statement(mod_stmt: Statement): boolean;
        /**
         * Offers the same feature as gda_data_select_set_modification_statement() but using an SQL statement.
         * @param sql an SQL text
         * @returns TRUE if no error occurred.
         */
        set_modification_statement_sql(sql: string): boolean;
        /**
         * Offers the same features as gda_data_select_set_row_selection_condition_sql() but using a #GdaSqlExpr
         * structure instead of an SQL syntax.
         * @param expr a #GdaSqlExpr expression
         * @returns TRUE if no error occurred
         */
        set_row_selection_condition(expr: SqlExpr): boolean;
        /**
         * Specifies the SQL condition corresponding to the WHERE part of a SELECT statement which would
         * return only 1 row (the expression of the primary key).
         *
         * For example for a table created as <![CDATA["CREATE TABLE mytable (part1 int NOT NULL, part2 string NOT NULL,
         * name string, PRIMARY KEY (part1, part2))"]]>, and if `pmodel` corresponds to the execution of the
         * <![CDATA["SELECT name, part1, part2 FROM mytable"]]>, then the sensible value for `sql_where` would be
         * <![CDATA["part1 = ##-1::int AND part2 = ##-2::string"]]> because the values of the 'part1' field are located
         * in `pmodel'`s column number 1 and the values of the 'part2' field are located
         * in `pmodel'`s column number 2 and the primary key is composed of (part1, part2).
         *
         * For more information about the syntax of the parameters (named <![CDATA["##-1::int"]]> for example), see the
         * <link linkend="GdaSqlParser.description">GdaSqlParser</link> documentation, and
         * gda_data_select_set_modification_statement().
         * @param sql_where an SQL condition (without the WHERE keyword)
         * @returns TRUE if no error occurred
         */
        set_row_selection_condition_sql(sql_where: string): boolean;

        // Inherited methods
        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DataSelectIter {
        // Signal signatures
        interface SignalSignatures extends DataModelIter.SignalSignatures {
            'notify::current-row': (pspec: GObject.ParamSpec) => void;
            'notify::data-model': (pspec: GObject.ParamSpec) => void;
            'notify::update-model': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::holders': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::validate-changes': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends DataModelIter.ConstructorProps {}
    }

    class DataSelectIter extends DataModelIter {
        static $gtype: GObject.GType<DataSelectIter>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DataSelectIter.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DataSelectIter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DataSelectIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataSelectIter.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DataSelectIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DataSelectIter.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DataSelectIter.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DataSelectIter.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace DbBase {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class DbBase extends GObject.Object {
        static $gtype: GObject.GType<DbBase>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbBase.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbBase.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbBase;

        // Signals

        connect<K extends keyof DbBase.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbBase.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbBase.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbBase.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbBase.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbBase.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Compares two objects similar to g_strcmp().
         * @param b second #GdaDbBase object
         * @returns 0 if catalog, schema and name are the same
         */
        compare(b: DbBase): number;
        /**
         * Returns current catalog name. The returned string should not be freed.
         * @returns Current catalog or %NULL
         */
        get_catalog(): string;
        /**
         * This method returns a full name in the format catalog.schema.name.
         * If schema is %NULL but catalog and name are not, then only name is
         * returned. If catalog is %NULL then full name will be in the format:
         * schema.name. If all three components are not set, then %NULL is returned.
         * @returns Full name of the database object or %NULL.
         */
        get_full_name(): string;
        /**
         * Returns current object name. The returned string should not be freed.
         * @returns Current object name or %NULL
         */
        get_name(): string;
        /**
         * Returns current schema name. The returned string should not be freed.
         * @returns Current scheme or %NULL
         */
        get_schema(): string;
        /**
         * Set catalog name
         * @param catalog Catalog name as a string
         */
        set_catalog(catalog: string): void;
        /**
         * Set object name. If `name` is %NULL the function just returns.
         * @param name Object name as a string
         */
        set_name(name: string): void;
        /**
         * Sets database object names. `catalog` and `schema` can be %NULL but
         * `name` always should be a valid, not %NULL string. The `name` must be
         * set. If `catalog` is %NULL `schema` may not be %NULL but if `schema` is
         * %NULL `catalog` also should be %NULL.
         * @param catalog a catalog name associated with the table
         * @param schema a schema name associated with the table
         * @param name a table name associated with the table
         */
        set_names(catalog: string | null, schema: string | null, name: string): void;
        /**
         * Set object schema. If `schema` is %NULL the function just returns.
         * @param schema Schema name as a string
         */
        set_schema(schema: string): void;
    }

    namespace DbCatalog {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::connection': (pspec: GObject.ParamSpec) => void;
            'notify::schema-name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            connection: Connection;
            schema_name: string;
            schemaName: string;
        }
    }

    class DbCatalog extends GObject.Object {
        static $gtype: GObject.GType<DbCatalog>;

        // Properties

        get connection(): Connection;
        set connection(val: Connection);
        get schema_name(): string;
        set schema_name(val: string);
        get schemaName(): string;
        set schemaName(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbCatalog.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbCatalog.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbCatalog;

        // Signals

        connect<K extends keyof DbCatalog.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbCatalog.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbCatalog.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbCatalog.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbCatalog.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbCatalog.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;
        /**
         * Convenient method to varify xmlfile before prsing it.
         * @param xmlfile xml file to validate
         */
        static validate_file_from_path(xmlfile: string): boolean;

        // Methods

        /**
         * This method append `table` to the total list of all tables stored in `self`. This method increase
         * reference count for `table`.
         * @param table table to append
         */
        append_table(table: DbTable): void;
        /**
         * This method append `view` to the total list of all views stored in `self`. This method increase
         * reference count for `view`.
         * @param view view to append
         */
        append_view(view: DbView): void;
        get_tables(): DbTable[];
        get_views(): DbView[];
        /**
         * Parse internal cnc to populate `self` object. This method should be called every time after
         * database was modified or `self` was just created using gda_connection_create_db_catalog(). The
         * method will return %FALSE if no internal #GdaConnection available.
         * @returns Returns %TRUE if succeeded, %FALSE otherwise.
         */
        parse_cnc(): boolean;
        /**
         * For detailed description see gda_db_catalog_parse_file_from_path()
         * @param xmlfile xml file as #GFile instance
         */
        parse_file(xmlfile: Gio.File): boolean;
        /**
         * This method reads information from `xmlfile` and populate `self` object.
         * The `xmlfile` should correspond to the following DTD format:
         *
         *
         * ```<!-- language="DTD" -->
         * <!ELEMENT schema (table+, view*)>
         * <!ATTLIST schema name           CDATA   #IMPLIED>
         *
         * <!ELEMENT table (comment?,column+, fkey*, constraint*)>
         * <!ATTLIST table temptable       (TRUE|FALSE)    "FALSE">
         * <!ATTLIST table name            CDATA           #REQUIRED>
         * <!ATTLIST table space           CDATA           #IMPLIED>
         *
         * <!ELEMENT column (comment?, value?, check?)>
         * <!ATTLIST column name           CDATA           #REQUIRED>
         * <!ATTLIST column type           CDATA           #REQUIRED>
         * <!ATTLIST column pkey           (TRUE|FALSE)    "FALSE">
         * <!ATTLIST column unique         (TRUE|FALSE)    "FALSE">
         * <!ATTLIST column autoinc        (TRUE|FALSE)    "FALSE">
         * <!ATTLIST column nnul           (TRUE|FALSE)    "FALSE">
         *
         * <!ELEMENT comment       (#PCDATA)>
         * <!ELEMENT value         (#PCDATA)>
         * <!ATTLIST value size            CDATA          #IMPLIED>
         * <!ATTLIST value scale           CDATA          #IMPLIED>
         *
         * <!ELEMENT check         (#PCDATA)>
         *
         * <!ELEMENT constraint    (#PCDATA)>
         *
         * <!ELEMENT fkey (fk_field?)>
         * <!ATTLIST fkey reftable CDATA #IMPLIED>
         * <!ATTLIST fkey onupdate (RESTRICT|CASCADE|SET_NULL|NO_ACTION|SET_DEFAULT)       #IMPLIED>
         * <!ATTLIST fkey ondelete (RESTRICT|CASCADE|SET_NULL|NO_ACTION|SET_DEFAULT)       #IMPLIED>
         *
         * <!ELEMENT fk_field (#PCDATA)>
         * <!ATTLIST fk_field name         CDATA           #REQUIRED>
         * <!ATTLIST fk_field reffield     CDATA           #REQUIRED>
         *
         * <!ELEMENT view (definition)>
         * <!ATTLIST view name             CDATA           #REQUIRED>
         * <!ATTLIST view replace          (TRUE|FALSE)    "FALSE">
         * <!ATTLIST view temp             (TRUE|FALSE)    "FALSE">
         * <!ATTLIST view ifnotexists      (TRUE|FALSE)    "TRUE">
         *
         * <!ELEMENT definition (#PCDATA)>
         * ```
         *
         *
         * Up to day description of the xml file schema can be found in DTD file
         * [libgda-db-catalog.dtd](https://gitlab.gnome.org/GNOME/libgda/blob/master/libgda/libgda-db-catalog.dtd)
         *
         * The given `xmlfile` will be checked before parsing and %FALSE will be
         * returned if fails. The `xmlfile` will be validated internally using
         * gda_db_catalog_validate_file_from_path(). he same method can be used to validate xmlfile
         * before parsing it.
         * @param xmlfile xml file to parse
         */
        parse_file_from_path(xmlfile: string): boolean;
        /**
         * After population `self` with all data this method may be
         * called to trigger code and modify user database. This is the main
         * method to work with database. For retrieving information from database to an
         * xml file use gda_db_catalog_parse_cnc() and gda_db_buildable_write_node().
         *
         * Connection can be added as a property using g_object_set() call and should be opened to use
         * this method. See gda_connection_open() method for reference.
         *
         * Only table can be created. Views are ignored
         *
         * Each table from database compared with each table in the #GdaDbCatalog
         * instance. If the table doesn't exist in database, it will be created (CREATE_TABLE).
         * If table exists in the database and xml file, all columns will be checked. If columns
         * are present in xml file but not in the database it will be created (ADD_COLUMN). If
         * column exists but has different parameters, e.g. nonnull it will not be
         * modified.
         *
         * Note: Pkeys are not checked. This is a limitation that should be removed. The corresponding
         * issue was open on gitlab page.
         */
        perform_operation(): boolean;
        /**
         * This method writes database description as xml file.
         * Similar to gda_db_catalog_write_to_path()
         * @param file a #GFile to write database description
         * @returns %TRUE if no error occurred, %FALSE otherwise.
         */
        write_to_file(file: Gio.File): boolean;
        /**
         * Save content of `self` to a user friendly xml file.
         * @param path path to xml file to save #GdaDbCatalog
         * @returns %TRUE is no error, %FALSE otherwise.
         */
        write_to_path(path: string): boolean;
    }

    namespace DbColumn {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::autoinc': (pspec: GObject.ParamSpec) => void;
            'notify::check': (pspec: GObject.ParamSpec) => void;
            'notify::comment': (pspec: GObject.ParamSpec) => void;
            'notify::default': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::nnul': (pspec: GObject.ParamSpec) => void;
            'notify::pkey': (pspec: GObject.ParamSpec) => void;
            'notify::scale': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::table': (pspec: GObject.ParamSpec) => void;
            'notify::unique': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                DbBuildable.ConstructorProps,
                DdlModifiable.ConstructorProps {
            autoinc: boolean;
            check: string;
            comment: string;
            default: string;
            name: string;
            nnul: boolean;
            pkey: boolean;
            scale: number;
            size: number;
            table: DbTable;
            unique: boolean;
        }
    }

    class DbColumn extends GObject.Object implements DbBuildable, DdlModifiable {
        static $gtype: GObject.GType<DbColumn>;

        // Properties

        get autoinc(): boolean;
        set autoinc(val: boolean);
        get check(): string;
        set check(val: string);
        get comment(): string;
        set comment(val: string);
        get default(): string;
        set default(val: string);
        get name(): string;
        set name(val: string);
        get nnul(): boolean;
        set nnul(val: boolean);
        get pkey(): boolean;
        set pkey(val: boolean);
        get scale(): number;
        set scale(val: number);
        get size(): number;
        set size(val: number);
        get table(): DbTable;
        set table(val: DbTable);
        get unique(): boolean;
        set unique(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbColumn.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbColumn.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbColumn;

        // Signals

        connect<K extends keyof DbColumn.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbColumn.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbColumn.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbColumn.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbColumn.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbColumn.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Methods

        /**
         * Get value for autoinc key
         * @returns %TRUE if column should be auto-incremented, %FALSE otherwise.
         */
        get_autoinc(): boolean;
        /**
         * Returns value of the check field.
         * @returns Column check string
         */
        get_check(): string;
        /**
         * Get value for column comment.
         * @returns Column comment as a string. %NULL is returned if comment is not set.
         */
        get_comment(): string;
        /**
         * Returns column type as a string derivied from #GType
         * @returns column type as a string or %NULL
         */
        get_ctype(): string;
        /**
         * Returns default value for the column. Can be %NULL if the default value hasn't been set.
         * @returns Default value for the column as a string.
         */
        get_default(): string;
        /**
         * Return of column type as #GType
         */
        get_gtype(): GObject.GType;
        /**
         * Returns name of the column
         * @returns Column name as a string or %NULL.
         */
        get_name(): string;
        /**
         * Specify if the column's value can be NULL.
         * @returns %TRUE if value can be %NULL, %FALSE otherwise.
         */
        get_nnul(): boolean;
        /**
         * Returns a primary key flag
         * @returns %TRUE if the column is primary key, %FALSE otherwise
         */
        get_pkey(): boolean;
        /**
         * Scale is used for float number representation to specify a number of decimal digits.
         * This value is ignore for column types except float or double.
         * @returns Current scale value
         */
        get_scale(): number;
        get_size(): number;
        /**
         * Get value for unique key
         * @returns %TRUE if column should have a unique value, %FALSE otherwise.
         */
        get_unique(): boolean;
        /**
         * Populate `op` with information stored in `self`. This method is used to
         * prepare `op` for %GDA_SERVER_OPERATION_ADD_COLUMN operation.
         * @param op #GdaServerOperation to add information
         * @returns %TRUE if success, %FALSE otherwise.
         */
        prepare_add(op: ServerOperation): boolean;
        /**
         * This method populate `op` with information stored in `self`.
         * @param op a #GdaServerOperation instance to update for TABLE_CREATE operation
         * @param order Order number for the column
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        prepare_create(op: ServerOperation, order: number): boolean;
        /**
         * Set value for auto-incremented key.
         * @param autoinc value to set
         */
        set_autoinc(autoinc: boolean): void;
        /**
         * Sets check string to the column.
         * @param value value to set
         */
        set_check(value: string): void;
        /**
         * Set value for column comment.
         * @param comnt comment to set
         */
        set_comment(comnt: string): void;
        set_default(value: string): void;
        /**
         * Set column name.
         * @param name name as a string
         */
        set_name(name: string): void;
        set_nnul(nnul: boolean): void;
        /**
         * If `pkey` is %TRUE, the given column will be marked with PRIMERY KEY flag
         * @param pkey value to set
         */
        set_pkey(pkey: boolean): void;
        /**
         * Scale is used for float number representation to specify a number of decimal digits.
         * This value is ignore for column types except float or double.
         * @param scale scale value to set
         */
        set_scale(scale: number): void;
        /**
         * Set value for column size. This is relevant only for string column type.
         * @param size value to set
         */
        set_size(size: number): void;
        /**
         * Set type of the column as a #GType. For numeric type, #GDA_TYPE_NUMERIC should be used. Other
         * types, e.g. %G_TYPE_FLOAT or %G_TYPE_DOUBLE can also be used but precision and scale should not be
         * set. In this case appropriate types for DB implementation will be used, e.g. float4.
         * @param type #GType for column
         */
        set_type(type: GObject.GType): void;
        /**
         * Set value for unique key.
         * @param unique value to set
         */
        set_unique(unique: boolean): void;

        // Inherited methods
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        write_node(node: libxml2.NodePtr): boolean;
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         */
        vfunc_parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         */
        vfunc_write_node(node: libxml2.NodePtr): boolean;
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        create(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        drop(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        rename(cnc: Connection, user_data?: any | null): boolean;
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         */
        vfunc_create(cnc: Connection): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         */
        vfunc_drop(cnc: Connection): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         */
        vfunc_rename(cnc: Connection): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DbFkey {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DbBuildable.ConstructorProps {}
    }

    class DbFkey extends GObject.Object implements DbBuildable {
        static $gtype: GObject.GType<DbFkey>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbFkey.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbFkey.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbFkey;

        // Signals

        connect<K extends keyof DbFkey.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbFkey.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbFkey.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbFkey.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbFkey.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbFkey.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_field_name(): string[];
        get_ondelete(): string;
        /**
         * The default value is %NO_ACTION
         * @returns ON DELETE action as a #GdaDbFkeyReferenceAction.
         */
        get_ondelete_id(): DbFkeyReferenceAction;
        get_onupdate(): string;
        get_onupdate_id(): DbFkeyReferenceAction;
        get_ref_field(): string[];
        get_ref_table(): string;
        /**
         * Prepare `op` object for execution by populating with information stored in `self`.
         * @param op a #GdaServerOperation to populate
         * @param i Order number
         * @returns %TRUE if no error or %FALSE otherwise.
         */
        prepare_create(op: ServerOperation, i: number): boolean;
        /**
         * All arguments should be valid strings.
         * @param field Field name as a string
         * @param reffield A reference field name as a string
         */
        set_field(field: string, reffield: string): void;
        /**
         * Set action for ON_DELETE
         * @param id #GdaDbFkeyReferenceAction action to set
         */
        set_ondelete(id: DbFkeyReferenceAction | null): void;
        /**
         * Set action for ON_UPDATE
         * @param id #GdaDbFkeyReferenceAction action to set
         */
        set_onupdate(id: DbFkeyReferenceAction | null): void;
        /**
         * Set reference table
         * @param rtable reference table name
         */
        set_ref_table(rtable: string): void;

        // Inherited methods
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        write_node(node: libxml2.NodePtr): boolean;
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         */
        vfunc_parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         */
        vfunc_write_node(node: libxml2.NodePtr): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DbIndex {
        // Signal signatures
        interface SignalSignatures extends DbBase.SignalSignatures {
            'notify::table': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends DbBase.ConstructorProps, DdlModifiable.ConstructorProps {
            table: DbTable;
        }
    }

    class DbIndex extends DbBase implements DdlModifiable {
        static $gtype: GObject.GType<DbIndex>;

        // Properties

        get table(): DbTable;
        set table(val: DbTable);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbIndex.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbIndex.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbIndex;

        // Signals

        connect<K extends keyof DbIndex.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbIndex.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbIndex.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbIndex.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbIndex.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbIndex.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Methods

        /**
         * Append to index filed to the current index instance, The `self` object will recieve full
         * ownership of the field. After this call, the reference count for `field` will be increased and
         * the instance of `fiels` must be destroyed by calling g_object_unref()
         * @param field a field to set
         */
        append_field(field: DbIndexField): void;
        /**
         * This function is thread safe, that is, `cnc` will be locked.
         * @returns A list of #GdaDbIndexField
         */
        get_fields(): DbIndexField[] | null;
        get_unique(): boolean;
        remove_field(name: string): void;
        /**
         * If `val` is %TRUE a "UNIQUE" will be added to the INDEX CREATE command, e.g.
         * CREATE UNIQUE INDEX ...
         * @param val if set to %TRUE UNIQUE index type will be used.
         */
        set_unique(val: boolean): void;

        // Inherited methods
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        create(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        drop(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        rename(cnc: Connection, user_data?: any | null): boolean;
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         */
        vfunc_create(cnc: Connection): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         */
        vfunc_drop(cnc: Connection): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         */
        vfunc_rename(cnc: Connection): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DbIndexField {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class DbIndexField extends GObject.Object {
        static $gtype: GObject.GType<DbIndexField>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbIndexField.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbIndexField.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbIndexField;

        // Signals

        connect<K extends keyof DbIndexField.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbIndexField.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbIndexField.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbIndexField.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbIndexField.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbIndexField.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_collate(): string;
        /**
         * Returns an active column that was asigned to #GdaDbIndexField instance
         * @returns A #GdaDbColumn where index should be added
         */
        get_column(): DbColumn;
        get_sort_order(): DbIndexSortOrder;
        get_sort_order_str(): string;
        /**
         * Unfortunately, collate can vary from provider to provider. This method accepts collate name as a
         * string but user should provide valid values. For instance, SQLite3 accepts only "BINARY",
         * "NOCASE", and "RTRIM" values. PostgreSQL, on the other hand expects a name of a callable object,
         * e.g. function.
         * @param collate collate to set
         */
        set_collate(collate: string): void;
        /**
         * Only full name will be extracted from `column`. The `column` instance should be freed using
         * g_object_unref(). The instance `self` take a copy of the `column` object by increasing its
         * referecne count.
         * @param column column to add index to
         */
        set_column(column: DbColumn): void;
        set_sort_order(sorder: DbIndexSortOrder | null): void;
    }

    namespace DbTable {
        // Signal signatures
        interface SignalSignatures extends DbBase.SignalSignatures {
            'notify::comment': (pspec: GObject.ParamSpec) => void;
            'notify::istemp': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends DbBase.ConstructorProps,
                DbBuildable.ConstructorProps,
                DdlModifiable.ConstructorProps {
            comment: string;
            istemp: string;
        }
    }

    class DbTable extends DbBase implements DbBuildable, DdlModifiable {
        static $gtype: GObject.GType<DbTable>;

        // Properties

        get comment(): string;
        set comment(val: string);
        get istemp(): string;
        set istemp(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbTable.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbTable.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbTable;

        // Signals

        connect<K extends keyof DbTable.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbTable.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbTable.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbTable.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbTable.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbTable.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Methods

        /**
         * Append `column` to the internal list of columns
         * @param column column to add
         */
        append_column(column: DbColumn): void;
        /**
         * Adds global table constraint. It will be added to the sql string by the provider implementation
         * if it supports it. Usually, table constraint is very complex and the current method just append
         * a list of constraints to the sql string.
         * @param constr a constraint string to append
         */
        append_constraint(constr: string): void;
        /**
         * Append `fkey` to the internal list of columns
         * @param fkey fkry to add
         */
        append_fkey(fkey: DbFkey): void;
        /**
         * Use this method to obtain internal list of all columns. The internal list
         * should not be freed.
         * @returns A list of #GdaDbColumn objects or %NULL if the internal list is not set or if %NULL is passed.
         */
        get_columns(): DbColumn[];
        /**
         * Use this method to obtain internal list of all fkeys. The internal list
         * should not be freed.
         * @returns A list of #GdaDbFkey objects or %NULL if the internal list is not set or %NULL is passed
         */
        get_fkeys(): DbFkey[];
        get_is_temp(): boolean;
        /**
         * This method returns %TRUE if at least one column is added to the table. It ruturns %FALSE if the
         * table has no columns.
         * @returns %TRUE or %FALSE
         */
        is_valid(): boolean;
        /**
         * Populate `op` with information stored in `self`. This method sets `op` to execute CREATE_TABLE
         * operation.
         * @param op an instance of #GdaServerOperation to populate.
         * @param ifnotexists Set it to TRUE if "IF NOT EXISTS" should be added
         * @returns %TRUE if no error occured and %FALSE otherwise.
         */
        prepare_create(op: ServerOperation, ifnotexists: boolean): boolean;
        /**
         * Set if the table should be temporary or not.  %FALSE is set by default.
         * @param istemp Set if the table should be temporary
         */
        set_is_temp(istemp: boolean): void;
        /**
         * With this method object `obj` in the database available through `cnc` will be updated using
         * ADD_COLUMN operation with information stored in `self`. This method is designed for internal use
         * only and should not be used for the new code. It will be obsolete.
         * @param obj The corresponding meta object to take data from
         * @param cnc opened connection
         * @returns %TRUE if no error and %FALSE otherwise
         */
        update(obj: MetaTable, cnc: Connection): boolean;

        // Inherited methods
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        write_node(node: libxml2.NodePtr): boolean;
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         */
        vfunc_parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         */
        vfunc_write_node(node: libxml2.NodePtr): boolean;
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        create(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        drop(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        rename(cnc: Connection, user_data?: any | null): boolean;
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         */
        vfunc_create(cnc: Connection): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         */
        vfunc_drop(cnc: Connection): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         */
        vfunc_rename(cnc: Connection): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DbView {
        // Signal signatures
        interface SignalSignatures extends DbBase.SignalSignatures {
            'notify::defstring': (pspec: GObject.ParamSpec) => void;
            'notify::ifnoexist': (pspec: GObject.ParamSpec) => void;
            'notify::istemp': (pspec: GObject.ParamSpec) => void;
            'notify::replace': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends DbBase.ConstructorProps,
                DbBuildable.ConstructorProps,
                DdlModifiable.ConstructorProps {
            defstring: string;
            ifnoexist: boolean;
            istemp: boolean;
            replace: boolean;
        }
    }

    class DbView extends DbBase implements DbBuildable, DdlModifiable {
        static $gtype: GObject.GType<DbView>;

        // Properties

        get defstring(): string;
        set defstring(val: string);
        get ifnoexist(): boolean;
        set ifnoexist(val: boolean);
        get istemp(): boolean;
        set istemp(val: boolean);
        get replace(): boolean;
        set replace(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DbView.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DbView.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DbView;

        // Signals

        connect<K extends keyof DbView.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbView.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DbView.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DbView.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DbView.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DbView.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_defstring(): string;
        get_ifnoexist(): boolean;
        get_istemp(): boolean;
        get_replace(): boolean;
        /**
         * Populate `op` with information needed to perform CREATE_VIEW operation. This method was desgned
         * for internal use and will be obsolete in the future. Do not use it for the new code.
         * @param op #GdaServerOperation instance to populate
         * @returns %TRUE if succeeded and %FALSE otherwise.
         */
        prepare_create(op: ServerOperation): boolean;
        set_defstring(str: string): void;
        set_ifnoexist(noexist: boolean): void;
        set_istemp(temp: boolean): void;
        set_replace(replace: boolean): void;

        // Inherited methods
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        write_node(node: libxml2.NodePtr): boolean;
        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         */
        vfunc_parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         */
        vfunc_write_node(node: libxml2.NodePtr): boolean;
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        create(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        drop(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        rename(cnc: Connection, user_data?: any | null): boolean;
        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         */
        vfunc_create(cnc: Connection): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         */
        vfunc_drop(cnc: Connection): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         */
        vfunc_rename(cnc: Connection): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HandlerBin {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataHandler.ConstructorProps {}
    }

    class HandlerBin extends GObject.Object implements DataHandler {
        static $gtype: GObject.GType<HandlerBin>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HandlerBin.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HandlerBin.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HandlerBin;

        // Signals

        connect<K extends keyof HandlerBin.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerBin.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HandlerBin.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerBin.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HandlerBin.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HandlerBin.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         */
        vfunc_accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         */
        vfunc_get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         */
        vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HandlerBoolean {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataHandler.ConstructorProps {}
    }

    class HandlerBoolean extends GObject.Object implements DataHandler {
        static $gtype: GObject.GType<HandlerBoolean>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HandlerBoolean.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HandlerBoolean.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HandlerBoolean;

        // Signals

        connect<K extends keyof HandlerBoolean.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerBoolean.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HandlerBoolean.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerBoolean.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HandlerBoolean.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HandlerBoolean.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         */
        vfunc_accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         */
        vfunc_get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         */
        vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HandlerNumerical {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataHandler.ConstructorProps {}
    }

    class HandlerNumerical extends GObject.Object implements DataHandler {
        static $gtype: GObject.GType<HandlerNumerical>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HandlerNumerical.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HandlerNumerical.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HandlerNumerical;

        // Signals

        connect<K extends keyof HandlerNumerical.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerNumerical.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HandlerNumerical.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerNumerical.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HandlerNumerical.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HandlerNumerical.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         */
        vfunc_accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         */
        vfunc_get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         */
        vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HandlerString {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataHandler.ConstructorProps {}
    }

    class HandlerString extends GObject.Object implements DataHandler {
        static $gtype: GObject.GType<HandlerString>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HandlerString.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HandlerString.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HandlerString;

        static new_with_provider(prov: ServerProvider, cnc?: Connection | null): HandlerString;

        // Signals

        connect<K extends keyof HandlerString.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerString.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HandlerString.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerString.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HandlerString.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HandlerString.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         */
        vfunc_accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         */
        vfunc_get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         */
        vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HandlerText {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataHandler.ConstructorProps {}
    }

    class HandlerText extends GObject.Object implements DataHandler {
        static $gtype: GObject.GType<HandlerText>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HandlerText.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HandlerText.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_with_connection(cnc?: Connection | null): HandlerText;

        // Signals

        connect<K extends keyof HandlerText.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerText.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HandlerText.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerText.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HandlerText.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HandlerText.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates a data handler for large strings
         */
        static ['new'](): DataHandler;

        // Inherited methods
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         */
        vfunc_accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         */
        vfunc_get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         */
        vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HandlerTime {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataHandler.ConstructorProps {}
    }

    class HandlerTime extends GObject.Object implements DataHandler {
        static $gtype: GObject.GType<HandlerTime>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HandlerTime.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HandlerTime.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HandlerTime;

        static new_no_locale(): HandlerTime;

        // Signals

        connect<K extends keyof HandlerTime.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerTime.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HandlerTime.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerTime.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HandlerTime.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HandlerTime.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Get a string representing the locale-dependent way to enter a date/time/datetime, using
         * a syntax suitable for the #GdauiFormatEntry widget
         * @param type the type of data being handled
         * @returns a new string
         */
        get_format(type: GObject.GType): string;
        /**
         * Get a string giving the user a hint about the locale-dependent requested format.
         * @param type the type of data being handled
         * @returns a new string
         */
        get_hint(type: GObject.GType): string;
        get_no_locale_str_from_value(value: GObject.Value | any): string;
        /**
         * Specifies the SQL output style of the `dh` data handler. The general format is "FIRSTsSECsTHIRD"
         * where FIRST, SEC and THIRD are specified by `first,` `sec` and `trird` and 's' is the separator,
         * specified by `separator`.
         *
         * The default implementation is `first=`G_DATE_MONTH, `sec=`G_DATE_DAY and `third=`G_DATE_YEAR
         * (the year is rendered on 4 digits) and the separator is '-'
         * @param first what comes first in the date representation
         * @param sec what comes second in the date representation
         * @param third what comes third in the date representation
         * @param separator separator character used between year, month and day
         * @param twodigits_years TRUE if year part of date must be rendered on 2 digits
         */
        set_sql_spec(
            first: GLib.DateDMY | null,
            sec: GLib.DateDMY | null,
            third: GLib.DateDMY | null,
            separator: number,
            twodigits_years: boolean,
        ): void;
        /**
         * Specifies the human readable output style of the `dh` data handler.
         * The general format is "FIRSTsSECsTHIRD"
         * where FIRST, SEC and THIRD are specified by `first,` `sec` and `trird` and 's' is the separator,
         * specified by `separator`.
         *
         * The default implementation depends on the current locale, except if `dh` was created
         * using gda_handler_time_new_no_locale().
         * @param first what comes first in the date representation
         * @param sec what comes second in the date representation
         * @param third what comes third in the date representation
         * @param separator separator character used between year, month and day
         * @param twodigits_years TRUE if year part of date must be rendered on 2 digits
         */
        set_str_spec(
            first: GLib.DateDMY | null,
            sec: GLib.DateDMY | null,
            third: GLib.DateDMY | null,
            separator: number,
            twodigits_years: boolean,
        ): void;

        // Inherited methods
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         */
        vfunc_accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         */
        vfunc_get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         */
        vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HandlerType {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DataHandler.ConstructorProps {}
    }

    class HandlerType extends GObject.Object implements DataHandler {
        static $gtype: GObject.GType<HandlerType>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HandlerType.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HandlerType.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HandlerType;

        // Signals

        connect<K extends keyof HandlerType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerType.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HandlerType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HandlerType.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HandlerType.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HandlerType.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         */
        vfunc_accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         */
        vfunc_get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         */
        vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         */
        vfunc_get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         */
        vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Holder {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            changed: () => void;
            'source-changed': () => void;
            'to-default': () => void;
            'validate-change': (arg0: GObject.Value) => GLib.Error;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::full-bind': (pspec: GObject.ParamSpec) => void;
            'notify::g-type': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::not-null': (pspec: GObject.ParamSpec) => void;
            'notify::plugin': (pspec: GObject.ParamSpec) => void;
            'notify::simple-bind': (pspec: GObject.ParamSpec) => void;
            'notify::source-column': (pspec: GObject.ParamSpec) => void;
            'notify::source-model': (pspec: GObject.ParamSpec) => void;
            'notify::validate-changes': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Lockable.ConstructorProps {
            description: string;
            full_bind: Holder;
            fullBind: Holder;
            g_type: GObject.GType;
            gType: GObject.GType;
            id: string;
            name: string;
            not_null: boolean;
            notNull: boolean;
            plugin: string;
            simple_bind: Holder;
            simpleBind: Holder;
            source_column: number;
            sourceColumn: number;
            source_model: DataModel;
            sourceModel: DataModel;
            validate_changes: boolean;
            validateChanges: boolean;
        }
    }

    class Holder extends GObject.Object implements Lockable {
        static $gtype: GObject.GType<Holder>;

        // Properties

        get description(): string;
        set description(val: string);
        get full_bind(): Holder;
        set full_bind(val: Holder);
        get fullBind(): Holder;
        set fullBind(val: Holder);
        get g_type(): GObject.GType;
        set g_type(val: GObject.GType);
        get gType(): GObject.GType;
        set gType(val: GObject.GType);
        get id(): string;
        set id(val: string);
        get name(): string;
        set name(val: string);
        get not_null(): boolean;
        set not_null(val: boolean);
        get notNull(): boolean;
        set notNull(val: boolean);
        get plugin(): string;
        set plugin(val: string);
        get simple_bind(): Holder;
        set simple_bind(val: Holder);
        get simpleBind(): Holder;
        set simpleBind(val: Holder);
        get source_column(): number;
        set source_column(val: number);
        get sourceColumn(): number;
        set sourceColumn(val: number);
        get source_model(): DataModel;
        set source_model(val: DataModel);
        get sourceModel(): DataModel;
        set sourceModel(val: DataModel);
        /**
         * Defines if the "validate-change" signal gets emitted when
         * the holder's value changes.
         */
        get validate_changes(): boolean;
        set validate_changes(val: boolean);
        /**
         * Defines if the "validate-change" signal gets emitted when
         * the holder's value changes.
         */
        get validateChanges(): boolean;
        set validateChanges(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Holder.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Holder.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](type: GObject.GType, id: string): Holder;

        // Signals

        connect<K extends keyof Holder.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Holder.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Holder.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Holder.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Holder.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Holder.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_changed(): void;
        vfunc_source_changed(): void;
        vfunc_to_default(): void;
        vfunc_validate_change(new_value: GObject.Value | any): GLib.Error;

        // Methods

        /**
         * Copy constructor.
         *
         * Note1: if `orig` is set with a static value (see gda_holder_take_static_value())
         * its copy will have a fresh new allocated GValue, so that user should free it when done.
         * @returns a new #GdaHolder object
         */
        copy(): Holder;
        /**
         * Forces a holder to be invalid; to set it valid again, a new value must be assigned
         * to it using gda_holder_set_value() or gda_holder_take_value().
         *
         * `holder'`s value is set to %NULL.
         */
        force_invalid(): void;
        /**
         * Forces a holder to be invalid; to set it valid again, a new value must be assigned
         * to it using gda_holder_set_value() or gda_holder_take_value().
         *
         * `holder'`s value is set to %NULL.
         * @param error a #GError explaining why @holder is declared invalid, or %NULL
         */
        force_invalid_e(error?: GLib.Error | null): void;
        /**
         * Get an "encoded" version of `holder'`s name. The "encoding" consists in replacing non
         * alphanumeric character with the string "__gdaXX" where XX is the hex. representation
         * of the non alphanumeric char.
         *
         * This method is just a wrapper around the gda_text_to_alphanum() function.
         * @returns a new string
         */
        get_alphanum_id(): string;
        /**
         * Get the holder which makes `holder` change its value when the holder's value is changed.
         * @returns the #GdaHolder or %NULL
         */
        get_bind(): Holder;
        /**
         * Get the default value held into the holder. WARNING: the default value does not need to be of
         * the same type as the one required by `holder`.
         * @returns the default value
         */
        get_default_value(): unknown;
        /**
         * Get `holder'`s type
         * @returns the data type
         */
        get_g_type(): GObject.GType;
        /**
         * Get the ID of `holder`. The ID can be set using `holder'`s "id" property
         * @returns the ID (don't modify the string).
         */
        get_id(): string;
        /**
         * Get wether the holder can be NULL or not
         * @returns TRUE if the holder cannot be NULL
         */
        get_not_null(): boolean;
        /**
         * If gda_holder_set_source_model() has been used to provide a hint that `holder'`s value
         * should be among the values contained in a column of a data model, then this method
         * returns which data model, and if `col` is not %NULL, then it is set to the restricting column
         * as well.
         *
         * Otherwise, this method returns %NULL, and if `col` is not %NULL, then it is set to 0.
         * @param col a place to store the column in the model sourcing the holder, or %NULL
         * @returns a pointer to a #GdaDataModel, or %NULL
         */
        get_source_model(col: number): DataModel;
        /**
         * Get the value held into the holder. If `holder` is set to use its default value
         * and that default value is not of the same type as `holder,` then %NULL is returned.
         *
         * If `holder` is set to NULL, then the returned value is a #GDA_TYPE_NULL GValue.
         *
         * If `holder` is invalid, then the returned value is %NULL.
         * @returns the value, or %NULL
         */
        get_value(): GObject.Value | null;
        /**
         * Same functionality as gda_holder_get_value() except that it returns the value as a string
         * (the conversion is done using `dh` if not %NULL, or the default data handler otherwise).
         * @param dh a #GdaDataHandler to use, or %NULL
         * @returns the value, or %NULL
         */
        get_value_str(dh?: DataHandler | null): string;
        /**
         * Get the validity of `holder` (that is, of the value held by `holder)`
         * @returns TRUE if @holder's value can safely be used
         */
        is_valid(): boolean;
        /**
         * Get the validity of `holder` (that is, of the value held by `holder)`
         * @returns TRUE if @holder's value can safely be used
         */
        is_valid_e(): boolean;
        /**
         * Sets `holder` to change when `bind_to` changes (and does not make `bind_to` change when `holder` changes).
         * For the operation to succeed, the GType of `holder` and `bind_to` must be the same, with the exception that
         * any of them can have a %GDA_TYPE_NULL type (in this situation, the GType of the two #GdaHolder objects
         * involved is set to match the other when any of them sets its type to something different than GDA_TYPE_NULL).
         *
         * If `bind_to` is %NULL, then `holder` will not be bound anymore.
         * @param bind_to a #GdaHolder or %NULL
         * @returns TRUE if no error occurred
         */
        set_bind(bind_to: Holder): boolean;
        /**
         * Sets the default value within the holder. If `value` is %NULL then `holder` won't have a
         * default value anymore. To set a default value to %NULL, then pass a #GValue created using
         * gda_value_new_null().
         *
         * NOTE: the default value does not need to be of the same type as the one required by `holder`.
         * @param value a value to set the holder's default value, or %NULL
         */
        set_default_value(value: GObject.Value | any): void;
        /**
         * Sets if the holder can have a NULL value. If `not_null` is TRUE, then that won't be allowed
         * @param not_null TRUE if @holder should not accept %NULL values
         */
        set_not_null(not_null: boolean): void;
        /**
         * Sets an hint that `holder'`s values should be restricted among the values
         * contained in the `col` column of the `model` data model. Note that this is just a hint,
         * meaning this policy is not enforced by `holder'`s implementation.
         *
         * If `model` is %NULL, then the effect is to cancel ant previous call to gda_holder_set_source_model()
         * where `model` was not %NULL.
         * @param model a #GdaDataModel object or %NULL
         * @param col the reference column in @model
         * @returns TRUE if no error occurred
         */
        set_source_model(model: DataModel, col: number): boolean;
        /**
         * Sets the value within the holder. If `holder` is an alias for another
         * holder, then the value is also set for that other holder.
         *
         * On success, the action of any call to gda_holder_force_invalid() is cancelled
         * as soon as this method is called (even if `holder'`s value does not actually change)
         *
         * If the value is not different from the one already contained within `holder,`
         * then `holder` is not changed and no signal is emitted.
         *
         * Note1: the `value` argument is treated the same way if it is %NULL or if it is a #GDA_TYPE_NULL value
         *
         * Note2: if `holder` can't accept the `value` value, then this method returns FALSE, and `holder` will be left
         * in an invalid state.
         *
         * Note3: before the change is accepted by `holder,` the "validate-change" signal will be emitted (the value
         * of which can prevent the change from happening) which can be connected to to have a greater control
         * of which values `holder` can have, or implement some business rules.
         * @param value a value to set the holder to, or %NULL
         * @returns TRUE if value has been set
         */
        set_value(value?: GObject.Value | null): boolean;
        /**
         * Same functionality as gda_holder_set_value() except that it uses a string representation
         * of the value to set, which will be converted into a GValue first (using default data handler if
         * `dh` is %NULL).
         *
         * Note1: if `value` is %NULL or is the "NULL" string, then `holder'`s value is set to %NULL.
         * Note2: if `holder` can't accept the `value` value, then this method returns FALSE, and `holder` will be left
         * in an invalid state.
         * @param dh a #GdaDataHandler to use, or %NULL
         * @param value a value to set the holder to, as a string
         * @returns TRUE if value has been set
         */
        set_value_str(dh: DataHandler, value: string): boolean;
        /**
         * Set `holder'`s value to its default value.
         * @returns TRUE if @holder has got a default value
         */
        set_value_to_default(): boolean;
        /**
         * Sets the const value within the holder. If `holder` is an alias for another
         * holder, then the value is also set for that other holder.
         *
         * The value will not be freed, and user should take care of it, either for its
         * freeing or for its correct value at the moment of query.
         *
         * If the value is not different from the one already contained within `holder,`
         * then `holder` is not changed and no signal is emitted.
         *
         * Note1: if `holder` can't accept the `value` value, then this method returns NULL, and `holder` will be left
         * in an invalid state.
         *
         * Note2: before the change is accepted by `holder,` the "validate-change" signal will be emitted (the value
         * of which can prevent the change from happening) which can be connected to to have a greater control
         * of which values `holder` can have, or implement some business rules.
         * @param value a const value to set the holder to
         * @param value_changed a boolean set with TRUE if the value changes, FALSE elsewhere.
         * @returns NULL if an error occurred or if the previous GValue was NULL itself. It returns the static GValue user set previously, so that he can free it.
         */
        take_static_value(value: GObject.Value | any, value_changed: boolean): unknown;
        /**
         * Sets the value within the holder. If `holder` is an alias for another
         * holder, then the value is also set for that other holder.
         *
         * On success, the action of any call to gda_holder_force_invalid() is cancelled
         * as soon as this method is called (even if `holder'`s value does not actually change).
         *
         * If the value is not different from the one already contained within `holder,`
         * then `holder` is not changed and no signal is emitted.
         *
         * Note1: if `holder` can't accept the `value` value, then this method returns FALSE, and `holder` will be left
         * in an invalid state.
         *
         * Note2: before the change is accepted by `holder,` the "validate-change" signal will be emitted (the value
         * of which can prevent the change from happening) which can be connected to to have a greater control
         * of which values `holder` can have, or implement some business rules.
         *
         * Note3: if user previously set this holder with gda_holder_take_static_value () the GValue
         * stored internally will be forgiven and replaced by the `value`. User should then
         * take care of the 'old' static GValue.
         *
         * Note4: in any case, the caller should not use `value` anymore after this function returns because it may
         * have been freed. If necessary, use gda_holder_get_value() to get the real value.
         * @param value a value to set the holder to
         * @returns TRUE if value has been set
         */
        take_value(value: GObject.Value | any): boolean;
        /**
         * Tells if `holder'`s current value is the default one.
         * @returns TRUE if @holder @holder's current value is the default one
         */
        value_is_default(): boolean;

        // Inherited methods
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         * @returns TRUE if the object has successfully been locked.
         */
        trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        unlock(): void;
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        vfunc_unlock(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace MetaStore {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'meta-changed': (arg0: MetaStoreChange[]) => void;
            'meta-reset': () => void;
            'suggest-update': (arg0: MetaContext) => GLib.Error;
            'notify::catalog': (pspec: GObject.ParamSpec) => void;
            'notify::cnc': (pspec: GObject.ParamSpec) => void;
            'notify::cnc-string': (pspec: GObject.ParamSpec) => void;
            'notify::schema': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            catalog: string;
            cnc: Connection;
            cnc_string: string;
            cncString: string;
            schema: string;
        }
    }

    class MetaStore extends GObject.Object {
        static $gtype: GObject.GType<MetaStore>;

        // Properties

        set catalog(val: string);
        get cnc(): Connection;
        set cnc_string(val: string);
        set cncString(val: string);
        set schema(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: MetaStore.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<MetaStore.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](cnc_string?: string | null): MetaStore;

        static new_with_file(file_name: string): MetaStore;

        // Signals

        connect<K extends keyof MetaStore.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, MetaStore.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof MetaStore.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, MetaStore.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof MetaStore.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<MetaStore.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;
        /**
         * Use this method to get a correctly quoted (if necessary) SQL identifier which can be used
         * to retrieve or filter information in a #GdaMetaStore which stores meta data about `cnc`.
         *
         * The returned SQL identifier can be used in conjunction with gda_connection_update_meta_store(),
         * gda_connection_get_meta_store_data(), gda_connection_get_meta_store_data_v() and
         * gda_meta_store_extract().
         * @param id an SQL identifier
         * @param cnc a #GdaConnection
         */
        static sql_identifier_quote(id: string, cnc: Connection): string;

        // Virtual methods

        vfunc_meta_reset(): void;
        vfunc_suggest_update(suggest: MetaContext): GLib.Error;

        // Methods

        /**
         * Creates a new #GdaDataModelArray data model which can be used, after being correctly filled,
         * with the gda_meta_store_modify*() methods.*
         *
         * To be used by provider's implementation
         * @param table_name the name of a table present in @store
         * @returns a new #GdaDataModel
         */
        create_modify_data_model(table_name: string): DataModel;
        create_struct(features: MetaStructFeature | null): MetaStruct;
        /**
         * Defines a new declared foreign key into `store`. If another declared foreign key is already defined
         * between the two tables and with the same name, then it is first removed.
         *
         * This method begins a transaction if possible (ie. none is already started), and if it can't,
         * then if there is an error, the job may be partially done.
         *
         * A check is always performed to make sure all the database objects actually
         * exist and returns an error if not. The check is performed using `mstruct` if it's not %NULL (in
         * this case only the tables already represented in `mstruct` will be considered, in other words: `mstruct`
         * will not be modified), and using an internal #GdaMetaStruct is %NULL.
         *
         * The `catalog,` `schema,` `table,` `ref_catalog,` `ref_schema` and `ref_table` must follow the SQL
         * identifiers naming convention, see the <link linkend="gen:sql_identifiers">SQL identifiers</link>
         * section. The same convention needs to be respected for the strings in `conames` and `ref_colnames`.
         *
         * If `catalog` is not %NULL, then `schema` must also be not %NULL (the same restriction applies to
         * `ref_catalog` and `ref_schema)`.
         * @param mstruct a #GdaMetaStruct, or %NULL
         * @param fk_name the name of the foreign key to declare
         * @param catalog the catalog in which the table (for which the foreign key is for) is, or %NULL
         * @param schema the schema in which the table (for which the foreign key is for) is, or %NULL
         * @param table the name of the table (for which the foreign key is for)
         * @param ref_catalog the catalog in which the referenced table is, or %NULL
         * @param ref_schema the schema in which the referenced table is, or %NULL
         * @param ref_table the name of the referenced table
         * @param colnames an array of column names from the table for which the foreign key is for
         * @param ref_colnames an array of column names from the referenced table
         * @returns %TRUE if no error occurred
         */
        declare_foreign_key(
            mstruct: MetaStruct | null,
            fk_name: string,
            catalog: string | null,
            schema: string | null,
            table: string,
            ref_catalog: string | null,
            ref_schema: string | null,
            ref_table: string,
            colnames: string[],
            ref_colnames: string[],
        ): boolean;
        /**
         * Extracts some data stored in `store` using a custom SELECT query. If the `select_sql` filter involves
         * SQL identifiers (such as table or column names), then the values should have been adapted using
         * gda_meta_store_sql_identifier_quote().
         *
         * For more information about
         * SQL identifiers are represented in `store,` see the
         * <link linkend="information_schema:sql_identifiers">meta data section about SQL identifiers</link>.
         * @param select_sql a SELECT statement
         * @param vars a hash table with all variables names as keys and GValue* as value, representing values for all the variables mentioned in @select_sql. If there is no variable then this part can be omitted.
         * @returns a new #GdaDataModel, or %NULL if an error occurred
         */
        extract(select_sql: string, vars?: GLib.HashTable<string, GObject.Value> | null): DataModel;
        /**
         * The #GdaMetaStore object maintains a list of (name,value) attributes (attributes names starting with a '_'
         * character are for internal use only and cannot be altered). This method and the gda_meta_store_set_attribute_value()
         * method allows the user to add, set or remove attributes specific to their usage.
         *
         * This method allows to get the value of a attribute stored in `store`. The returned attribute value is
         * placed at `att_value,` the caller is responsible for free that string.
         *
         * If there is no attribute named `att_name` then `att_value` is set to %NULL
         * and `error` will contain the GDA_META_STORE_ATTRIBUTE_NOT_FOUND_ERROR error code, and FALSE is returned.
         * @param att_name name of the attribute to get
         * @returns TRUE if no error occurred
         */
        get_attribute_value(att_name: string): [boolean, string];
        /**
         * Get a pointer to the #GdaConnection object internally used by `store` to store
         * its contents.
         *
         * The returned connection can be used to access some other data than the one managed by `store`
         * itself. The returned object is not owned by the caller (if you need to keep it, then use g_object_ref()).
         * Do not close the connection.
         * @returns a #GdaConnection, or %NULL
         */
        get_internal_connection(): Connection;
        /**
         * Get `store'`s internal schema's version
         * @returns the version (incremented each time the schema changes, backward compatible)
         */
        get_version(): number;
        /**
         * Propagates an update to `store,` the update's contents is represented by `new_data,` this function is
         * primarily reserved to database providers.
         * @param table_name the name of the table to modify within @store
         * @param new_data a #GdaDataModel containing the new data to set in @table_name, or %NULL (treated as a data model with no row at all)
         * @param condition SQL expression (which may contain variables) defining the rows which are being obsoleted by @new_data, or %NULL
         * @param value_names names of values
         * @param values values
         * @returns %TRUE if no error occurred
         */
        modify(
            table_name: string,
            new_data: DataModel | null,
            condition: string | null,
            value_names: string[],
            values: (GObject.Value | any)[],
        ): boolean;
        /**
         * Propagates an update to `store,` the update's contents is represented by `new_data,` this function is
         * primarily reserved to database providers.
         * @param context a #GdaMetaContext context describing what to modify in @store
         * @param new_data a #GdaDataModel containing the new data to set in @table_name, or %NULL (treated as a data model with no row at all)
         * @returns TRUE if no error occurred
         */
        modify_with_context(context: MetaContext, new_data?: DataModel | null): boolean;
        /**
         * The internal database used by `store` can be 'augmented' with some user-defined database objects
         * (such as tables or views). This method allows one to add a new database object.
         *
         * If the internal database already contains the object, then:
         * <itemizedlist>
         *   <listitem><para>if the object is equal to the provided description then TRUE is returned</para></listitem>
         *   <listitem><para>if the object exists but differs from the provided description, then FALSE is returned,
         *      with the GDA_META_STORE_SCHEMA_OBJECT_CONFLICT_ERROR error code</para></listitem>
         * </itemizedlist>
         *
         * The `xml_description` defines the table of view's definition, for example:
         * <programlisting><![CDATA[<table name="mytable">
         *     <column name="id" pkey="TRUE"/>
         *     <column name="value"/>
         * </table>]]></programlisting>
         *
         * The partial DTD for this XML description of the object to add is the following (the top node must be
         * a &lt;table&gt; or a &lt;view&gt;):
         * <programlisting><![CDATA[<!ELEMENT table (column*,check*,fkey*)>
         * <!ATTLIST table
         *           name NMTOKEN #REQUIRED>
         *
         * <!ELEMENT column EMPTY>
         * <!ATTLIST column
         *           name NMTOKEN #REQUIRED
         *           type CDATA #IMPLIED
         *           pkey (TRUE|FALSE) #IMPLIED
         *           autoinc (TRUE|FALSE) #IMPLIED
         *           nullok (TRUE|FALSE) #IMPLIED>
         *
         * <!ELEMENT check (#PCDATA)>
         *
         * <!ELEMENT fkey (part+)>
         * <!ATTLIST fkey
         *           ref_table NMTOKEN #REQUIRED>
         *
         * <!ELEMENT part EMPTY>
         * <!ATTLIST part
         *           column NMTOKEN #IMPLIED
         *           ref_column NMTOKEN #IMPLIED>
         *
         * <!ELEMENT view (definition)>
         * <!ATTLIST view
         *           name NMTOKEN #REQUIRED
         *           descr CDATA #IMPLIED>
         *
         * <!ELEMENT definition (#PCDATA)>]]></programlisting>
         * @param xml_description an XML description of the table or view to add to @store
         * @returns TRUE if the new object has successfully been added
         */
        schema_add_custom_object(xml_description: string): boolean;
        /**
         * Get an ordered list of the tables `store` knows about. The tables are ordered in a way that tables dependencies
         * are respected: if table B has a foreign key on table A, then table A will be listed before table B in the returned
         * list.
         * @returns a new list of tables names (as gchar*), the list must be freed when no longer needed, but the strings present in the list must not be modified.
         */
        schema_get_all_tables(): string[];
        /**
         * Get an ordered list of the tables `store` knows about on which the `table_name` table depends (recursively).
         * The tables are ordered in a way that tables dependencies
         * are respected: if table B has a foreign key on table A, then table A will be listed before table B in the returned
         * list.
         * @param table_name the name of the table for which all the dependencies must be listed
         * @returns a new list of tables names (as gchar*), the list must be freed when no longer needed, but the strings present in the list must not be modified.
         */
        schema_get_depend_tables(table_name: string): string[];
        /**
         * Creates a new #GdaMetaStruct object representing `store'`s internal database structure.
         * @returns a new #GdaMetaStruct object, or %NULL if an error occurred
         */
        schema_get_structure(): MetaStruct;
        /**
         * Removes the custom database object named `obj_name`.
         * @param obj_name name of the custom object to remove
         * @returns TRUE if the custom object has successfully been removed
         */
        schema_remove_custom_object(obj_name: string): boolean;
        /**
         * Set the value of the attribute named `att_name` to `att_value;` see gda_meta_store_get_attribute_value() for
         * more information.
         * @param att_name name of the attribute to set
         * @param att_value value of the attribute to set, or %NULL to unset the attribute
         * @returns TRUE if no error occurred
         */
        set_attribute_value(att_name: string, att_value?: string | null): boolean;
        /**
         * Specifies how `store` must handle SQL identifiers it has to store. This method is mainly used by
         * database providers.
         * @param style a style
         */
        set_identifiers_style(style: SqlIdentifierStyle | null): void;
        /**
         * Specifies a function which `store` will use to determine if a keyword is an SQL reserved
         * keyword or not.
         *
         * This method is mainly used by database providers.
         * @param func a #GdaSqlReservedKeywordsFunc function, or %NULL
         */
        set_reserved_keywords_func(func?: SqlReservedKeywordsFunc | null): void;
        /**
         * Removes a declared foreign key from `store`.
         *
         * This method begins a transaction if possible (ie. none is already started), and if it can't, then if there
         * is an error, the job may be partially done.
         *
         * A check is always performed to make sure all the database objects actually
         * exist and returns an error if not. The check is performed using `mstruct` if it's not %NULL (in
         * this case only the tables already represented in `mstruct` will be considered, in other words: `mstruct`
         * will not be modified), and using an internal #GdaMetaStruct is %NULL.
         *
         * See gda_meta_store_declare_foreign_key() for more information anout the `catalog,` `schema,` `name,`
         * `ref_catalog,` `ref_schema` and `ref_name` arguments.
         * @param mstruct a #GdaMetaStruct, or %NULL
         * @param fk_name the name of the foreign key to declare
         * @param catalog the catalog in which the table (for which the foreign key is for) is, or %NULL
         * @param schema the schema in which the table (for which the foreign key is for) is, or %NULL
         * @param table the name of the table (for which the foreign key is for)
         * @param ref_catalog the catalog in which the referenced table is, or %NULL
         * @param ref_schema the schema in which the referenced table is, or %NULL
         * @param ref_table the name of the referenced table
         * @returns %TRUE if no error occurred
         */
        undeclare_foreign_key(
            mstruct: MetaStruct | null,
            fk_name: string,
            catalog: string | null,
            schema: string | null,
            table: string,
            ref_catalog: string | null,
            ref_schema: string | null,
            ref_table: string,
        ): boolean;
    }

    namespace MetaStruct {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::features': (pspec: GObject.ParamSpec) => void;
            'notify::meta-store': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            features: number;
            meta_store: MetaStore;
            metaStore: MetaStore;
        }
    }

    class MetaStruct extends GObject.Object {
        static $gtype: GObject.GType<MetaStruct>;

        // Properties

        get features(): number;
        get meta_store(): MetaStore;
        get metaStore(): MetaStore;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: MetaStruct.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<MetaStruct.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof MetaStruct.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, MetaStruct.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof MetaStruct.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, MetaStruct.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof MetaStruct.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<MetaStruct.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Methods

        /**
         * Creates a new #GdaMetaDbObject structure in `mstruct` to represent the database object (of type `type)`
         * which can be uniquely identified as `catalog`.`schema`.`name`.
         *
         * If `catalog` is not %NULL, then `schema` should not be %NULL.
         *
         * If both `catalog` and `schema` are %NULL, then the database object will be the one which is
         * "visible" by default (that is which can be accessed only by its short `name` name).
         *
         * If `catalog` is %NULL and `schema` is not %NULL, then the database object will be the one which
         * can be accessed by its `schema`.`name` name.
         *
         * Important note: `catalog,` `schema` and `name` will be used using the following convention:
         * <itemizedlist>
         *   <listitem><para>be surrounded by double quotes for a case sensitive search</para></listitem>
         *   <listitem><para>otherwise for case insensitive search</para></listitem>
         * </itemizedlist>
         *
         * For more information, see the <link linkend="information_schema:sql_identifiers">
         * meta data section about SQL identifiers</link>.
         * @param type the type of object to add (which can be GDA_META_DB_UNKNOWN)
         * @param catalog the catalog the object belongs to (as a G_TYPE_STRING GValue), or %NULL
         * @param schema the schema the object belongs to (as a G_TYPE_STRING GValue), or %NULL
         * @param name the object's name (as a G_TYPE_STRING GValue), not %NULL
         * @returns the #GdaMetaDbObject corresponding to the database object if no error occurred, or %NULL
         */
        complement(
            type: MetaDbObjectType | null,
            catalog: GObject.Value | null,
            schema: GObject.Value | null,
            name: GObject.Value | any,
        ): MetaDbObject | null;
        /**
         * This method is similar to gda_meta_struct_complement() and gda_meta_struct_complement_default()
         * but creates #GdaMetaDbObject for all the database object.
         *
         * Please refer to gda_meta_struct_complement() form more information.
         * @returns TRUE if no error occurred
         */
        complement_all(): boolean;
        /**
         * This method is similar to gda_meta_struct_complement() and gda_meta_struct_complement_all()
         * but creates #GdaMetaDbObject for all the
         * database object which are usable using only their short name (that is which do not need to be prefixed by
         * the schema in which they are to be used).
         *
         * Please refer to gda_meta_struct_complement() form more information.
         * @returns TRUE if no error occurred
         */
        complement_default(): boolean;
        /**
         * This method is similar to gda_meta_struct_complement() but creates #GdaMetaDbObject for all the dependencies
         * of `dbo`.
         *
         * Please refer to gda_meta_struct_complement() form more information.
         * @param dbo a #GdaMetaDbObject part of @mstruct
         * @returns TRUE if no error occurred
         */
        complement_depend(dbo: MetaDbObject): boolean;
        /**
         * This method is similar to gda_meta_struct_complement() but creates #GdaMetaDbObject for all the
         * database object which are in the `schema` schema (and in the `catalog` catalog).
         * If `catalog` is %NULL, then any catalog will be used, and
         * if `schema` is %NULL then any schema will be used (if `schema` is %NULL then catalog must also be %NULL).
         *
         * Please refer to gda_meta_struct_complement() form more information.
         * @param catalog name of a catalog, or %NULL
         * @param schema name of a schema, or %NULL
         * @returns TRUE if no error occurred
         */
        complement_schema(catalog?: GObject.Value | null, schema?: GObject.Value | null): boolean;
        /**
         * Creates a new graph (in the GraphViz syntax) representation of `mstruct`.
         * @param info informs what kind of information to show in the resulting graph
         * @returns a new string, or %NULL if an error occurred.
         */
        dump_as_graph(info: MetaGraphInfo | null): string | null;
        /**
         * Get a list of all the #GdaMetaDbObject structures representing database objects in `mstruct`. Note that
         * no #GdaMetaDbObject structure must not be modified.
         * @returns a new #GSList list of pointers to #GdaMetaDbObject structures which must be destroyed after usage using g_slist_free(). The individual #GdaMetaDbObject must not be modified.
         */
        get_all_db_objects(): MetaDbObject[] | null;
        /**
         * Tries to locate the #GdaMetaDbObject structure representing the database object named after
         * `catalog,` `schema` and `name`.
         *
         * If one or both of `catalog` and `schema` are %NULL, and more than one database object matches the name, then
         * the return value is also %NULL.
         * @param catalog the catalog the object belongs to (as a G_TYPE_STRING GValue), or %NULL
         * @param schema the schema the object belongs to (as a G_TYPE_STRING GValue), or %NULL
         * @param name the object's name (as a G_TYPE_STRING GValue), not %NULL
         * @returns the #GdaMetaDbObject or %NULL if not found
         */
        get_db_object(
            catalog: GObject.Value | null,
            schema: GObject.Value | null,
            name: GObject.Value | any,
        ): MetaDbObject | null;
        /**
         * Tries to find the #GdaMetaTableColumn representing the column named `col_name` in `table`.
         * @param table the #GdaMetaTable structure to find the column for
         * @param col_name the name of the column to find (as a G_TYPE_STRING GValue)
         * @returns the #GdaMetaTableColumn or %NULL if not found
         */
        get_table_column(table: MetaTable, col_name: GObject.Value | any): MetaTableColumn | null;
        /**
         * Loads an XML description into `mstruct`. This method is still experimental and no description
         * the XML file structure is given, and no guarantee that it will remain as it is given.
         * @param catalog the catalog name, or %NULL
         * @param schema the schema name, or %NULL
         * @param xml_spec_file the specifications as the name of an XML file
         * @returns TRUE if no error has occurred
         */
        load_from_xml_file(catalog: string | null, schema: string | null, xml_spec_file: string): boolean;
        /**
         * Reorders the list of database objects within `mstruct` in a way specified by `sort_type`.
         * @param sort_type the kind of sorting requested
         * @returns TRUE if no error occurred
         */
        sort_db_objects(sort_type: MetaSortType | null): boolean;
    }

    namespace PStmt {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class PStmt extends GObject.Object {
        static $gtype: GObject.GType<PStmt>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: PStmt.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<PStmt.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof PStmt.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PStmt.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof PStmt.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PStmt.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof PStmt.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<PStmt.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Copies `src'`s data to `dest`
         * @param dest a #GdaPStmt object
         */
        copy_contents(dest: PStmt): void;
        /**
         * Get a pointer to the #GdaStatement which led to the creation of this prepared statement.
         *
         * Note: if that statement has been modified since the creation of `pstmt,` then this method
         * will return %NULL
         * @returns the #GdaStatement
         */
        get_gda_statement(): Statement;
        get_ncols(): number;
        /**
         * List of parameters' IDs (as gchar *)
         * @returns a list of string with parameters ID's
         */
        get_param_ids(): string[];
        /**
         * Actual SQL code used for this prepared statement, mem freed by GdaPStmt
         * @returns SQL command used
         */
        get_sql(): string;
        /**
         * List of #GdaColumn objects which data models created from this
         * prepared statement can copy
         * @returns a list of #GdaColumn objects
         */
        get_tmpl_columns(): Column[];
        /**
         * Set column's types for statement. `types` will be stolen and should
         * no be modified anymore.
         * @returns an array of #GType used in the columns
         */
        get_types(): GObject.GType[];
        /**
         * Set column's types for statement. `types` is stalen and should
         * no be modified
         * @param types an array of types to use for each column
         */
        set_cols(types: GObject.GType[]): void;
        /**
         * Informs `pstmt` that it corresponds to the preparation of the `stmt` statement
         * @param stmt a #GdaStatement object, or %NULL
         */
        set_gda_statement(stmt?: Statement | null): void;
        /**
         * List of parameters' IDs (as gchar *), list is stolen
         * @param params a list of strings with ID's to set
         */
        set_param_ids(params: string[]): void;
        /**
         * Set SQL code used for this prepared statement, mem freed by GdaPStmt
         * @param sql
         */
        set_sql(sql: string): void;
        /**
         * Set the list of #GdaColumn objects which data models created from this
         * prepared statement can copy. The list is stolen, so you should not
         * free it.
         * @param columns a list of #GdaColumn
         */
        set_tmpl_columns(columns: Column[]): void;
    }

    namespace RepetitiveStatement {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::statement': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            statement: Statement;
        }
    }

    class RepetitiveStatement extends GObject.Object {
        static $gtype: GObject.GType<RepetitiveStatement>;

        // Properties

        get statement(): Statement;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: RepetitiveStatement.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<RepetitiveStatement.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](stmt: Statement): RepetitiveStatement;

        // Signals

        connect<K extends keyof RepetitiveStatement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, RepetitiveStatement.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof RepetitiveStatement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, RepetitiveStatement.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof RepetitiveStatement.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<RepetitiveStatement.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Specifies that `rstmt` be executed one time with the values contained in `values`.
         *
         * A new #GdaSet to be used as the `values` argument can be obtained using
         * gda_repetitive_statement_get_template_set().
         * @param values a #GdaSet object with the values to be used
         * @param make_copy %TRUE if @values is copied, and %FALSE if @values is only ref'ed
         * @returns a new #GdaRepetitiveStatement object
         */
        append_set(values: Set, make_copy: boolean): boolean;
        /**
         * Get all the values sets which will have been added using gda_repetitive_statement_append_set().
         * @returns a new #GSList of #GdaSet objects (free with g_slist_free()).
         */
        get_all_sets(): Set[];
        /**
         * Gets a new #GdaSet object with the parameters used by the template statement in the
         * `rstmt` object.
         *
         * Use this object with gda_repetitive_statement_append_set().
         * @param set a place to store the returned template set
         * @returns %TRUE on success, %FALSE on error
         */
        get_template_set(set: Set): boolean;
    }

    namespace Row {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::model': (pspec: GObject.ParamSpec) => void;
            'notify::model-row': (pspec: GObject.ParamSpec) => void;
            'notify::nb-values': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            model: DataModel;
            model_row: number;
            modelRow: number;
            nb_values: number;
            nbValues: number;
        }
    }

    class Row extends GObject.Object {
        static $gtype: GObject.GType<Row>;

        // Properties

        get model(): DataModel;
        get model_row(): number;
        get modelRow(): number;
        get nb_values(): number;
        get nbValues(): number;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Row.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Row.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](count: number): Row;

        static new_from_data_model(model: DataModel, row: number): Row;

        // Signals

        connect<K extends keyof Row.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Row.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Row.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Row.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Row.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Row.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_length(): number;
        /**
         * Gets a pointer to a #GValue stored in a #GdaRow.
         *
         * This is a pointer to the internal array of values. Don't try to free
         * or modify it (modifying is reserved to database provider's implementations).
         * @param num field index.
         * @returns a pointer to the #GValue in the position @num of @row.
         */
        get_value(num: number): GObject.Value | null;
        /**
         * Marks `value` as being invalid. This method is mainly used by database
         * providers' implementations to report any error while reading a value from the database.
         * @param value a #GValue belonging to @row (obtained with gda_row_get_value()).
         */
        invalidate_value(value: GObject.Value | any): void;
        /**
         * Marks `value` as being invalid. This method is mainly used by database
         * providers' implementations to report any error while reading a value from the database.
         * @param value a #GValue belonging to @row (obtained with gda_row_get_value()).
         * @param error the error which lead to the invalidation
         */
        invalidate_value_e(value: GObject.Value | any, error?: GLib.Error | null): void;
        /**
         * Tells if `value` has been marked as being invalid by gda_row_invalidate_value().
         * This method is mainly used by database
         * providers' implementations to report any error while reading a value from the database.
         * @param value a #GValue belonging to @row (obtained with gda_row_get_value()).
         * @returns %TRUE if @value is valid
         */
        value_is_valid(value: GObject.Value | any): boolean;
        /**
         * Tells if `value` has been marked as being invalid by gda_row_invalidate_value().
         * This method is mainly used by database
         * providers' implementations to report any error while reading a value from the database.
         * @param value a #GValue belonging to @row (obtained with gda_row_get_value()).
         * @returns %TRUE if @value is valid
         */
        value_is_valid_e(value: GObject.Value | any): boolean;
    }

    namespace ServerOperation {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'sequence-item-added': (arg0: string, arg1: number) => void;
            'sequence-item-remove': (arg0: string, arg1: number) => void;
            'notify::connection': (pspec: GObject.ParamSpec) => void;
            'notify::op-type': (pspec: GObject.ParamSpec) => void;
            'notify::provider': (pspec: GObject.ParamSpec) => void;
            'notify::spec-filename': (pspec: GObject.ParamSpec) => void;
            'notify::spec-resource': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            connection: Connection;
            op_type: number;
            opType: number;
            provider: ServerProvider;
            spec_filename: string;
            specFilename: string;
            spec_resource: string;
            specResource: string;
        }
    }

    class ServerOperation extends GObject.Object {
        static $gtype: GObject.GType<ServerOperation>;

        // Properties

        get connection(): Connection;
        get op_type(): number;
        get opType(): number;
        get provider(): ServerProvider;
        set spec_filename(val: string);
        set specFilename(val: string);
        set spec_resource(val: string);
        set specResource(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ServerOperation.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ServerOperation.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](op_type: ServerOperationType, xml_file: string): ServerOperation;

        // Signals

        connect<K extends keyof ServerOperation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ServerOperation.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ServerOperation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ServerOperation.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ServerOperation.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ServerOperation.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;
        /**
         * Get a string version of `type`
         * @param type a #GdaServerOperationType value
         */
        static op_type_to_string(type: ServerOperationType): string;
        /**
         * Creates a new #GdaServerOperation object which contains the specifications required
         * to create a database. Once these specifications are provided, use
         * gda_server_operation_perform_create_database() to perform the database creation.
         *
         * If `db_name` is left %NULL, then the name of the database to create will have to be set in the
         * returned #GdaServerOperation using gda_server_operation_set_value_at().
         * @param provider the database provider to use
         * @param db_name the name of the database to create, or %NULL
         */
        static prepare_create_database(provider: string, db_name?: string | null): ServerOperation | null;
        /**
         * Creates a new #GdaServerOperation object which contains the specifications required
         * to drop a database. Once these specifications provided, use
         * gda_server_operation_perform_drop_database() to perform the database creation.
         *
         * If `db_name` is left %NULL, then the name of the database to drop will have to be set in the
         * returned #GdaServerOperation using gda_server_operation_set_value_at().
         * @param provider the database provider to use
         * @param db_name the name of the database to drop, or %NULL
         */
        static prepare_drop_database(provider: string, db_name?: string | null): ServerOperation | null;
        /**
         * Performs the reverse of gda_server_operation_op_type_to_string()
         * @param str a string
         */
        static string_to_op_type(str: string): ServerOperationType;

        // Virtual methods

        vfunc_seq_item_added(seq_path: string, item_index: number): void;
        vfunc_seq_item_remove(seq_path: string, item_index: number): void;

        // Methods

        add_item_to_sequence(seq_path: string): number;
        del_item_from_sequence(item_path: string): boolean;
        /**
         * Get the complete path to the parent of the node defined by `path`
         * @param path a complete path to a node (starting with "/")
         * @returns a new string or %NULL if the node does not have any parent or does not exist.
         */
        get_node_parent(path: string): string;
        /**
         * Get the last part of `path`
         * @param path a complete path to a node (starting with "/")
         * @returns a new string, or %NULL if an error occurred
         */
        get_node_path_portion(path: string): string;
        /**
         * Convenience function to get the type of a node.
         * @param path a complete path to a node (starting with "/")
         * @param status a place to store the status of the node, or %NULL
         * @returns the type of node, or GDA_SERVER_OPERATION_NODE_UNKNOWN if the node was not found
         */
        get_node_type(path: string, status?: (ServerOperationNodeStatus | null) | null): ServerOperationNodeType;
        /**
         * Get the type of operation `op` is for
         * @returns a #GdaServerOperationType enum
         */
        get_op_type(): ServerOperationType;
        /**
         * Get an array of strings containing the paths of nodes situated at the root of `op`.
         * @returns a new array, which must be freed with g_strfreev().
         */
        get_root_nodes(): string[];
        /**
         * Fetch the contents of a sequence. `path` can describe either a sequence (for example "/SEQNAME") or an item in a sequence
         * (for example "/SEQNAME/3")
         * @param path a complete path to a sequence node (starting with "/")
         * @returns a array of strings containing the complete paths of the nodes contained at @path (free with g_strfreev())
         */
        get_sequence_item_names(path: string): string[];
        get_sequence_max_size(path: string): number;
        get_sequence_min_size(path: string): number;
        get_sequence_name(path: string): string;
        get_sequence_size(path: string): number;
        get_sql_identifier_at_path(path: string): string;
        /**
         * Get the value for the node at the `path` path
         * @param path a complete path to a node (starting with "/")
         * @returns a constant #GValue if a value has been defined, or %NULL if the value is undefined or if the @path is not defined or @path does not hold any value.
         */
        get_value_at(path: string): GObject.Value | null;
        /**
         * Tells if all the required values in `op` have been defined.
         *
         * if `xml_file` is not %NULL, the validity of `op` is tested against that specification,
         * and not against the current `op'`s specification.
         * @param xml_file an XML specification file (see gda_server_operation_new()) or %NULL
         * @returns %TRUE if @op is valid
         */
        is_valid(xml_file?: string | null): boolean;
        /**
         * Tells if all the required values in `op` have been defined.
         *
         * if `xml_data` is not %NULL, the validity of `op` is tested against that specification,
         * and not against the current `op'`s specification.
         * @param resource the name of a resource containing an XML specification data (see gda_server_operation_new()) or %NULL
         * @returns %TRUE if @op is valid
         */
        is_valid_from_resource(resource?: string | null): boolean;
        /**
         * Loads the contents of `node` into `op`. The XML tree passed through the `node`
         * argument must correspond to an XML tree saved using gda_server_operation_save_data_to_xml().
         * @param node a #xmlNodePtr
         * @returns %TRUE if no error occurred
         */
        load_data_from_xml(node: libxml2.NodePtr): boolean;
        /**
         * Creates a new database using the specifications in `op`. `op` can be obtained using
         * gda_server_provider_create_operation(), or gda_server_operation_prepare_create_database().
         * @param provider the database provider to use, or %NULL if @op has been created using gda_server_operation_prepare_create_database()
         * @returns TRUE if no error occurred and the database has been created, FALSE otherwise
         */
        perform_create_database(provider?: string | null): boolean;
        /**
         * Destroys an existing database using the specifications in `op`. `op` can be obtained using
         * gda_server_provider_create_operation(), or gda_server_operation_prepare_drop_database().
         * @param provider the database provider to use, or %NULL if @op has been created using gda_server_operation_prepare_drop_database()
         * @returns TRUE if no error occurred and the database has been destroyed
         */
        perform_drop_database(provider?: string | null): boolean;
        /**
         * Creates an SQL statement (possibly using some specific extensions of the DBMS) corresponding to the
         * `op` operation. Note that the returned string may actually contain more than one SQL statement.
         *
         * This function's purpose is mainly informative to get the actual SQL code which would be executed to perform
         * the operation; to actually perform the operation, use gda_server_operation_perform().
         * @returns a new string, or %NULL if an error occurred or operation cannot be rendered as SQL.
         */
        render(): string | null;
        save_data_to_xml_string(): string;
        /**
         * Set the value for the node at the path formed using `path_format` and the ... ellipse (the rules are the same as
         * for g_strdup_printf()).
         *
         * Note that trying to set a value for a path which is not used by the current
         * provider, such as "/TABLE_OPTIONS_P/TABLE_ENGINE" for a PostgreSQL connection (this option is only supported for MySQL),
         * will <emphasis>not</emphasis> generate
         * any error; this allows one to give values to a superset of the parameters and thus use the same code for several providers.
         *
         * Here are the possible formats of `path_format:`
         * <itemizedlist>
         *  <listitem><para>If the path corresponds to a #GdaHolder, then the parameter is set to <![CDATA["`value"`]]></para></listitem>
         *  <listitem><para>If the path corresponds to a sequence item like for example "/SEQUENCE_NAME/5/NAME" for
         *     the "NAME" value of the 6th item of the "SEQUENCE_NAME" sequence then:
         *     <itemizedlist>
         *        <listitem><para>if the sequence already has 6 or more items, then the value is just set to the corresponding
         *           value in the 6th item of the sequence</para></listitem>
         *        <listitem><para>if the sequence has less then 6 items, then items are added up to the 6th one before setting
         *           the value to the corresponding in the 6th item of the sequence</para></listitem>
         *     </itemizedlist>
         *  </para></listitem>
         *  <listitem><para>If the path corresponds to a #GdaDataModel, like for example "/ARRAY/`@`COLUMN/5" for the value at the
         *     6th row of the "COLUMN" column of the "ARRAY" data model, then:
         *     <itemizedlist>
         *        <listitem><para>if the data model already contains 6 or more rows, then the value is just set</para></listitem>
         *        <listitem><para>if the data model has less than 6 rows, then rows are added up to the 6th one before setting
         *           the value</para></listitem>
         *     </itemizedlist>
         *  </para></listitem>
         * </itemizedlist>
         * @param value a string
         * @param path a complete path to a node (starting with "/")
         * @returns %TRUE if no error occurred
         */
        set_value_at(value: string | null, path: string): boolean;
    }

    namespace ServerProvider {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Lockable.ConstructorProps {}
    }

    abstract class ServerProvider extends GObject.Object implements Lockable {
        static $gtype: GObject.GType<ServerProvider>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ServerProvider.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ServerProvider.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ServerProvider.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ServerProvider.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ServerProvider.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ServerProvider.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ServerProvider.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ServerProvider.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;
        static get_impl_functions_for_class(
            klass: typeof GObject.Object,
            type: ServerProviderFunctionsType,
        ): any | null;
        /**
         * Obtain a #GMainContext on which to iterate. This function is reserved to database provider's implementations.
         *
         * NB: if `cnc` is NOT %NULL and has a #GdaWorker associated, and if we are in its worker thread, then this function
         *     returns %NULL (to avoid generating contexts which are never used)
         * @param cnc a #GdaConnection, or %NULL
         */
        static get_real_main_context(cnc?: Connection | null): GLib.MainContext;
        /**
         * Loads and returns the contents of the specified resource.
         * This function should only be used by database provider's implementations
         * @param prov_name the provider's name
         * @param resource the name of the resource to load
         */
        static load_resource_contents(prov_name: string, resource: string): string;
        /**
         * Upon creation, used by provider's implementors to set the implementation functions. Passing %NULL
         * as the `functions_set` has no effect.
         *
         * If some pointers of `functions_set` are %NULL, they are replaced by functions from the parent class of
         * `provider`.
         *
         * Warning: this function must only be called once for each different values of `type` and for each `klass`
         * @param klass a #GdaServerProviderClass object
         * @param type a #GdaServerProviderFunctionsType type
         * @param functions_set a pointer to the function set, or %NULL
         */
        static set_impl_functions(
            klass: typeof ServerProvider,
            type: ServerProviderFunctionsType,
            functions_set?: any | null,
        ): void;

        // Methods

        /**
         * Creates a new #GdaServerOperation object which can be modified in order to perform the `type` type of
         * action. The `options` can contain:
         * <itemizedlist>
         *  <listitem>named values which ID is a path in the resulting GdaServerOperation object, to initialize some value</listitem>
         *  <listitem>named values which may change the contents of the GdaServerOperation, see <link linkend="gda-server-op-information-std">this section</link> for more information</listitem>
         * </itemizedlist>
         * @param cnc a #GdaConnection object which will be used to perform an action, or %NULL
         * @param type the type of operation requested
         * @param options a list of parameters or %NULL
         * @returns a new #GdaServerOperation object, or %NULL in the provider does not support the @type type of operation or if an error occurred
         */
        create_operation(
            cnc: Connection | null,
            type: ServerOperationType | null,
            options?: Set | null,
        ): ServerOperation | null;
        /**
         * Creates a new #GdaSqlParser object which is adapted to `provider` (and possibly depending on
         * `cnc` for the actual database version).
         *
         * If `prov` does not have its own parser, then %NULL is returned, and a general SQL parser can be obtained
         * using gda_sql_parser_new().
         * @param cnc a #GdaConnection, or %NULL
         * @returns a new #GdaSqlParser object, or %NULL.
         */
        create_parser(cnc?: Connection | null): SqlParser;
        /**
         * Escapes `str` for use within an SQL command (to avoid SQL injection attacks). Note that the returned value still needs
         * to be enclosed in single quotes before being used in an SQL statement.
         * @param cnc a #GdaConnection object, or %NULL
         * @param str a string to escape
         * @returns a new string suitable to use in SQL statements
         */
        escape_string(cnc: Connection | null, str: string): string;
        /**
         * Find a #GdaDataHandler object to manipulate data of type `for_type`.
         *
         * Note: this function is currently very poorly implemented by database providers.
         * @param cnc a #GdaConnection object, or %NULL
         * @param for_type a DBMS type definition
         * @returns a #GdaDataHandler, or %NULL if the provider does not know about the @for_type type
         */
        get_data_handler_dbms(cnc: Connection | null, for_type: string): DataHandler;
        /**
         * Find a #GdaDataHandler object to manipulate data of type `for_type`. The returned object must not be modified.
         * @param cnc a #GdaConnection object, or %NULL
         * @param for_type a #GType
         * @returns a #GdaDataHandler, or %NULL if the provider does not support the requested @for_type data type
         */
        get_data_handler_g_type(cnc: Connection | null, for_type: GObject.GType): DataHandler;
        /**
         * Get the name of the most common data type which has `type` type.
         *
         * The returned value may be %NULL either if the provider does not implement that method, or if
         * there is no DBMS data type which could contain data of the `g_type` type (for example %NULL may be
         * returned if a DBMS has integers only up to 4 bytes and a #G_TYPE_INT64 is requested).
         * @param cnc a #GdaConnection object or %NULL
         * @param type a #GType value type
         * @returns the name of the DBMS type, or %NULL
         */
        get_default_dbms_type(cnc: Connection | null, type: GObject.GType): string | null;
        /**
         * Get the name (identifier) of the provider
         * @returns a string containing the provider's name
         */
        get_name(): string;
        /**
         * Get the version of the database to which the connection is opened.
         * @param cnc a #GdaConnection object
         * @returns a (read only) string, or %NULL if an error occurred
         */
        get_server_version(cnc: Connection): string;
        /**
         * Get the version of the provider.
         * @returns a string containing the version identification.
         */
        get_version(): string;
        handler_declare(dh: DataHandler, cnc: Connection, g_type: GObject.GType, dbms_type: string): void;
        /**
         * Reserved to database provider's implementations: get the #GdaDataHandler associated to `prov`
         * for connection `cnc`. You probably want to use gda_server_provider_get_data_handler_g_type().
         * @param cnc a #GdaConnection
         * @param g_type a #GType
         * @param dbms_type a database type
         * @returns the requested #GdaDataHandler, or %NULL if none found
         */
        handler_find(cnc: Connection | null, g_type: GObject.GType, dbms_type?: string | null): DataHandler;
        /**
         * Reserved to database provider's implementations. This method defines a default data handler for
         * `provider,` and returns that #GdaDataHandler.
         * @param type a #GType
         * @returns a #GdaDataHandler, or %NULL
         */
        handler_use_default(type: GObject.GType): DataHandler;
        /**
         * This is a factory method to get a unique instance of a #GdaSqlParser object
         * for each #GdaServerProvider object
         * Don't unref it.
         * @returns a #GdaSqlParser
         */
        internal_get_parser(): SqlParser;
        /**
         * Performs the operation described by `op`. Note that `op` is not destroyed by this method
         * and can be reused.
         * @param cnc a #GdaConnection object which will be used to perform the action, or %NULL
         * @param op a #GdaServerOperation object
         * @returns %TRUE if no error occurred
         */
        perform_operation(cnc: Connection | null, op: ServerOperation): boolean;
        /**
         * Performs the operation described by `op,` using the SQL from the rendering of the operation
         * @param cnc a #GdaConnection object which will be used to perform an action, or %NULL
         * @param op a #GdaServerOperation object
         * @returns %TRUE if no error occurred
         */
        perform_operation_default(cnc: Connection | null, op: ServerOperation): boolean;
        /**
         * Creates an SQL statement (possibly using some specific extensions of the DBMS) corresponding to the
         * `op` operation. Note that the returned string may actually contain more than one SQL statement.
         *
         * This function's purpose is mainly informative to get the actual SQL code which would be executed to perform
         * the operation; to actually perform the operation, use gda_server_provider_perform_operation().
         * @param cnc a #GdaConnection object which will be used to render the action, or %NULL
         * @param op a #GdaServerOperation object
         * @returns a new string, or %NULL if an error occurred or operation cannot be rendered as SQL.
         */
        render_operation(cnc: Connection | null, op: ServerOperation): string | null;
        /**
         * Use `provider` to create a new #GValue from a single string representation.
         *
         * The `preferred_type` can optionally ask `provider` to return a #GValue of the requested type
         * (but if such a value can't be created from `string,` then %NULL is returned);
         * pass #G_TYPE_INVALID if any returned type is acceptable.
         *
         * The returned value is either a new #GValue or %NULL in the following cases:
         * - `string` cannot be converted to `preferred_type` type
         * - the provider does not handle `preferred_type`
         * - the provider could not make a #GValue from `string`
         *
         * If `dbms_type` is not %NULL, then if will contain a constant string representing
         * the database type used for the conversion if the conversion was successfull, or %NULL
         * otherwise.
         * @param cnc a #GdaConnection object, or %NULL
         * @param string the SQL string to convert to a value
         * @param preferred_type a #GType, or #G_TYPE_INVALID
         * @param dbms_type place to get the actual database type used if the conversion succeeded, or %NULL
         * @returns a new #GValue, or %NULL
         */
        string_to_value(
            cnc: Connection | null,
            string: string,
            preferred_type: GObject.GType,
            dbms_type?: string | null,
        ): unknown;
        /**
         * Tests if a feature is supported
         * @param cnc a #GdaConnection object, or %NULL
         * @param feature #GdaConnectionFeature feature to test
         * @returns %TRUE if @feature is supported
         */
        supports_feature(cnc: Connection | null, feature: ConnectionFeature | null): boolean;
        /**
         * Tells if `provider` supports the `type` of operation on the `cnc` connection, using the
         * (optional) `options` parameters.
         * @param cnc a #GdaConnection object which would be used to perform an action, or %NULL
         * @param type the type of operation requested
         * @param options a list of named parameters, or %NULL
         * @returns %TRUE if the operation is supported
         */
        supports_operation(cnc: Connection | null, type: ServerOperationType | null, options?: Set | null): boolean;
        /**
         * Unescapes `str` for use within an SQL command. This is the exact opposite of gda_server_provider_escape_string().
         * @param cnc a #GdaConnection object, or %NULL
         * @param str a string to escape
         * @returns a new string
         */
        unescape_string(cnc: Connection | null, str: string): string;
        /**
         * Produces a fully quoted and escaped string from a GValue
         * @param cnc a #GdaConnection object, or %NULL
         * @param from #GValue to convert from
         * @returns escaped and quoted value or NULL if not supported.
         */
        value_to_sql_string(cnc: Connection | null, from: GObject.Value | any): string;

        // Inherited methods
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         * @returns TRUE if the object has successfully been locked.
         */
        trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        unlock(): void;
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        vfunc_unlock(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Set {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'holder-attr-changed': (arg0: Holder, arg1: string, arg2: GObject.Value) => void;
            'holder-changed': (arg0: Holder) => void;
            'holder-type-set': (arg0: Holder) => void;
            'public-data-changed': () => void;
            'source-model-changed': (arg0: any | null) => void;
            'validate-holder-change': (arg0: Holder, arg1: GObject.Value) => GLib.Error;
            'validate-set': () => GLib.Error;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::holders': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::validate-changes': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            description: string;
            holders: any;
            id: string;
            name: string;
            validate_changes: boolean;
            validateChanges: boolean;
        }
    }

    class Set extends GObject.Object {
        static $gtype: GObject.GType<Set>;

        // Properties

        get description(): string;
        set description(val: string);
        set holders(val: any);
        get id(): string;
        set id(val: string);
        get name(): string;
        set name(val: string);
        /**
         * Defines if the "validate-set" signal gets emitted when
         * any holder in the data set changes. This property also affects the
         * GdaHolder:validate-changes property.
         */
        get validate_changes(): boolean;
        set validate_changes(val: boolean);
        /**
         * Defines if the "validate-set" signal gets emitted when
         * any holder in the data set changes. This property also affects the
         * GdaHolder:validate-changes property.
         */
        get validateChanges(): boolean;
        set validateChanges(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Set.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Set.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](holders: Holder[]): Set;

        static new_from_spec_node(xml_spec: libxml2.NodePtr): Set;

        static new_from_spec_string(xml_spec: string): Set;

        static new_read_only(holders: Holder[]): Set;

        // Signals

        connect<K extends keyof Set.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Set.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Set.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Set.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Set.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Set.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_holder_attr_changed(holder: Holder, attr_name: string, attr_value: GObject.Value | any): void;
        vfunc_holder_changed(holder: Holder): void;
        vfunc_holder_type_set(holder: Holder): void;
        vfunc_public_data_changed(): void;
        vfunc_source_model_changed(source: SetSource): void;
        vfunc_validate_holder_change(holder: Holder, new_value: GObject.Value | any): GLib.Error;
        vfunc_validate_set(): GLib.Error;

        // Methods

        /**
         * Adds `holder` to the list of holders managed within `set`.
         *
         * NOTE: if `set` already has a #GdaHolder with the same ID as `holder,` then `holder`
         * will not be added to the set (even if `holder'`s type or value is not the same as the
         * one already in `set)`.
         * @param holder a #GdaHolder object
         * @returns %TRUE if @holder has been added to @set (and FALSE if it has not been added because there is another #GdaHolder with the same ID)
         */
        add_holder(holder: Holder): boolean;
        /**
         * Creates a new #GdaSet object, copy of `set`
         * @returns a new #GdaSet object
         */
        copy(): Set;
        /**
         * Finds a #GdaSetGroup which lists a  #GdaSetNode containing `holder,`
         * don't modify the returned structure.
         * @param holder a #GdaHolder object
         * @returns the requested #GdaSetGroup or %NULL
         */
        get_group(holder: Holder): SetGroup;
        get_groups(): SetGroup[];
        /**
         * Finds a #GdaHolder using its ID
         * @param holder_id the ID of the requested value holder
         * @returns the requested #GdaHolder or %NULL
         */
        get_holder(holder_id: string): Holder;
        /**
         * Get the value of the #GdaHolder which ID is `holder_id`
         * @param holder_id the ID of the holder to set the value
         * @returns the requested GValue, or %NULL (see gda_holder_get_value())
         */
        get_holder_value(holder_id: string): GObject.Value | null;
        get_holders(): Holder[];
        /**
         * Finds a #GdaSetNode holding information for `holder,` don't modify the returned structure
         * @param holder a #GdaHolder object
         * @returns the requested #GdaSetNode or %NULL
         */
        get_node(holder: Holder): SetNode;
        get_nodes(): SetNode[];
        /**
         * Finds a #GdaHolder using its position
         * @param pos the position of the requested #GdaHolder, starting at %0
         * @returns the requested #GdaHolder or %NULL
         */
        get_nth_holder(pos: number): Holder;
        /**
         * Finds a #GdaSetSource which contains the #GdaDataModel restricting the possible values of
         * `holder,` don't modify the returned structure.
         * @param holder a #GdaHolder object
         * @returns the requested #GdaSetSource or %NULL
         */
        get_source(holder: Holder): SetSource;
        /**
         * Finds the #GdaSetSource structure used in `set` for which `model` is a
         * the data model (the returned structure should not be modified).
         * @param model a #GdaDataModel object
         * @returns the requested #GdaSetSource pointer or %NULL.
         */
        get_source_for_model(model: DataModel): SetSource;
        get_sources(): SetSource[];
        /**
         * This method tells if all `set'`s #GdaHolder objects are valid, and if
         * they represent a valid combination of values, as defined by rules
         * external to Libgda: the "validate-set" signal is emitted and if none of the signal handlers return an
         * error, then the returned value is TRUE, otherwise the return value is FALSE as soon as a signal handler
         * returns an error.
         * @returns TRUE if the set is valid
         */
        is_valid(): boolean;
        /**
         * Add to `set` all the holders of `set_to_merge`.
         * Note1: only the #GdaHolder of `set_to_merge` for which no holder in `set` has the same ID are merged
         * Note2: all the #GdaHolder merged in `set` are still used by `set_to_merge`.
         * @param set_to_merge a #GdaSet object
         */
        merge_with_set(set_to_merge: Set): void;
        /**
         * Removes a #GdaHolder from the list of holders managed by `set`
         * @param holder the #GdaHolder to remove from @set
         */
        remove_holder(holder: Holder): void;
        /**
         * Replaces `source->`data_model with `model,` which must have the same
         * characteristics as `source->`data_model (same column types)
         *
         * Also for each #GdaHolder for which `source->`data_model is a source model,
         * this method calls gda_holder_set_source_model() with `model` to replace
         * the source by the new model
         * @param source a pointer to a #GdaSetSource in @set
         * @param model a #GdaDataModel
         */
        replace_source_model(source: SetSource, model: DataModel): void;
    }

    namespace Short {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}
    }

    class Short {
        static $gtype: GObject.GType<Short>;

        // Constructors

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Short.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Short.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Short.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Short.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Short.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Short.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace SqlBuilder {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class SqlBuilder extends GObject.Object {
        static $gtype: GObject.GType<SqlBuilder>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: SqlBuilder.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<SqlBuilder.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](stmt_type: SqlStatementType): SqlBuilder;

        // Signals

        connect<K extends keyof SqlBuilder.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SqlBuilder.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof SqlBuilder.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SqlBuilder.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof SqlBuilder.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<SqlBuilder.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Methods

        /**
         * Creates a new CASE ... WHEN ... THEN ... ELSE ... END expression. The WHEN expression and the THEN
         * expression IDs are taken from the `when_array` and `then_array` at the same index, for each index inferior to
         * `args_size`.
         * @param test_expr the expression ID representing the test of the CASE, or %0
         * @param else_expr the expression ID representing the ELSE expression, or %0
         * @param when_array an array containing each WHEN expression ID, having at least @args_size elements
         * @param then_array an array containing each THEN expression ID, having at least @args_size elements
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_case(
            test_expr: SqlBuilderId,
            else_expr: SqlBuilderId,
            when_array: SqlBuilderId[],
            then_array: SqlBuilderId[],
        ): SqlBuilderId;
        /**
         * Builds a new expression which represents a condition (or operation).
         * @param op type of condition
         * @param op1 the ID of the 1st argument (not 0)
         * @param op2 the ID of the 2nd argument (may be %0 if @op needs only one operand)
         * @param op3 the ID of the 3rd argument (may be %0 if @op needs only one or two operand)
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_cond(op: SqlOperatorType | null, op1: SqlBuilderId, op2: SqlBuilderId, op3: SqlBuilderId): SqlBuilderId;
        /**
         * Builds a new expression which represents a condition (or operation).
         *
         * As a side case, if `ops_ids_size` is 1,
         * then `op` is ignored, and the returned ID represents `op_ids[`0] (this avoids any problem for example
         * when `op` is GDA_SQL_OPERATOR_TYPE_AND and there is in fact only one operand).
         * @param op type of condition
         * @param op_ids an array of ID for the arguments (not %0)
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_cond_v(op: SqlOperatorType | null, op_ids: SqlBuilderId[]): SqlBuilderId;
        /**
         * Defines an expression in `builder` which may be reused to build other parts of a statement.
         *
         * The new expression will contain the value passed as the `value` argument.
         *
         * If `value'`s type is a string then it is possible to customize how the value has to be interpreted by passing a
         * specific #GdaDataHandler object as `dh`. This feature is very rarely used and the `dh` argument should generally
         * be %NULL.
         * @param value value to set the expression to, or %NULL or a GDA_TYPE_NULL value to represent an SQL NULL
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_expr_value(value?: GObject.Value | null): SqlBuilderId;
        /**
         * Defines an expression representing a field in `builder,`
         * which may be reused to build other parts of a statement,
         * for instance as a parameter to gda_sql_builder_add_cond() or
         * gda_sql_builder_add_field_value_id().
         *
         * Calling this with a %NULL `table_name` is equivalent to calling gda_sql_builder_add_id().
         *
         * For SELECT queries, see gda_sql_builder_select_add_field().
         * @param field_name a field name
         * @param table_name a table name, or %NULL
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_field_id(field_name: string, table_name?: string | null): SqlBuilderId;
        /**
         * Valid only for: INSERT, UPDATE statements.
         *
         * Specifies that the field represented by `field_name` will be set to the value identified
         * by `value`
         * @param field_name a field name
         * @param value value to set the field to, or %NULL or a GDA_TYPE_NULL value to represent an SQL NULL
         */
        add_field_value_as_gvalue(field_name: string, value?: GObject.Value | null): void;
        /**
         * Valid only for: INSERT, UPDATE, SELECT statements
         * <itemizedlist>
         * <listitem><para>For UPDATE: specifies that the field represented by `field_id` will be set to the value identified
         *    by `value_id`.</para></listitem>
         * <listitem><para>For SELECT: add a selected item to the statement, and if `value_id` is not %0, then use it as an
         *    alias</para></listitem>
         * <listitem><para>For INSERT: if `field_id` represents an SQL identifier (obtained using gda_sql_builder_add_id()): then if
         *    `value_id` is not %0 then specifies that the field represented by `field_id` will be set to the
         *    value identified by `value_id,` otherwise just specifies a named field to be given a value.
         *    If `field_id` represents a sub SELECT (obtained using gda_sql_builder_add_sub_select()), then
         *    this method call defines the sub SELECT from which values to insert are taken.</para></listitem>
         * </itemizedlist>
         *
         * See also gda_sql_builder_add_field_value() and gda_sql_builder_add_field_value_as_gvalue().
         * @param field_id the ID of the field's name or definition
         * @param value_id the ID of the value to set the field to, or %0
         */
        add_field_value_id(field_id: SqlBuilderId, value_id: SqlBuilderId): void;
        /**
         * Builds a new expression which represents a function applied to some arguments
         * @param func_name the functions's name
         * @param args an array of IDs representing the function's arguments
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_function(func_name: string, args: SqlBuilderId[]): SqlBuilderId;
        /**
         * Defines an expression representing an identifier in `builder,`
         * which may be reused to build other parts of a statement,
         * for instance as a parameter to gda_sql_builder_add_cond() or
         * gda_sql_builder_add_field_value_id().
         *
         * The new expression will contain the `str` literal.
         * For example:
         * <programlisting>
         * gda_sql_builder_add_id (b, "name")
         * gda_sql_builder_add_id (b, "date")
         * </programlisting>
         *
         * will be rendered as SQL as:
         * <programlisting>
         * name
         * "date"
         * </programlisting>
         *
         * because "date" is an SQL reserved keyword.
         *
         * For fields, see gda_sql_builder_add_field_id().
         * @param str a string
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_id(str: string): SqlBuilderId;
        /**
         * Defines a parameter in `builder` which may be reused to build other parts of a statement.
         *
         * The new expression will contain the `string` literal.
         * For example:
         * <programlisting>
         * gda_sql_builder_add_param (b, "age", G_TYPE_INT, FALSE)
         * </programlisting>
         *
         * will be rendered as SQL as:
         * <programlisting><![CDATA[
         * ##age::int
         * ]]>
         * </programlisting>
         * @param param_name parameter's name
         * @param type parameter's type
         * @param nullok TRUE if the parameter can be set to %NULL
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_param(param_name: string, type: GObject.GType, nullok: boolean): SqlBuilderId;
        /**
         * Adds an expression which is a subselect.
         * @param sqlst a pointer to a #GdaSqlStatement, which has to be a SELECT or compound SELECT. This will be copied.
         * @returns the ID of the new expression, or %0 if there was an error
         */
        add_sub_select(sqlst: SqlStatement): SqlBuilderId;
        /**
         * Add a sub select to a COMPOUND statement
         * @param sqlst a pointer to a #GdaSqlStatement, which has to be a SELECT or compound SELECT. This will be copied.
         */
        compound_add_sub_select(sqlst: SqlStatement): void;
        /**
         * Add a sub select to a COMPOUND statement
         * @param subselect a #GdaSqlBuilder, which has to be a SELECT or compound SELECT. This will be copied.
         */
        compound_add_sub_select_from_builder(subselect: SqlBuilder): void;
        /**
         * Changes the type of compound which `builder` is making, for a COMPOUND statement
         * @param compound_type a type of compound
         */
        compound_set_type(compound_type: SqlStatementCompoundType | null): void;
        /**
         * Exports a part managed by `builder` as a new #GdaSqlExpr, which can represent any expression
         * in a statement.
         * @param id the ID of the expression to be exported, (must be a valid ID in @builder, not %0)
         * @returns a pointer to a new #GdaSqlExpr structure, free using gda_sql_expr_free() when not needed anymore. If the part with @id as ID cannot be found, the returned value is %NULL.
         */
        export_expression(id: SqlBuilderId): SqlExpr;
        /**
         * Creates a new #GdaSqlStatement structure from `builder'`s contents.
         *
         * The returned pointer belongs to `builder'`s internal representation.
         * Use gda_sql_statement_copy() if you need to keep it.
         * @returns a #GdaSqlStatement pointer
         */
        get_sql_statement(): SqlStatement | null;
        /**
         * Creates a new #GdaStatement statement from `builder'`s contents.
         * @returns a new #GdaStatement object, or %NULL if an error occurred
         */
        get_statement(): Statement;
        /**
         * Imports the `expr` into `builder`.
         * @param expr a #GdaSqlExpr obtained using gda_sql_builder_export_expression()
         * @returns the ID of the new expression, or %0 if there was an error
         */
        import_expression(expr: SqlExpr): SqlBuilderId;
        /**
         * Imports the an expression located in `query` into `builder`.
         * @param query a #GdaSqlBuilder object to get expression from
         * @param expr_id a #GdaSqlBuilderId of the expression in @query
         * @returns the ID of the new expression, or %0 if there was an error
         */
        import_expression_from_builder(query: SqlBuilder, expr_id: SqlBuilderId): SqlBuilderId;
        /**
         * Alter a join in a SELECT statement to make its condition use equal field
         * values in the fields named `field_name` in both tables, via the USING keyword.
         * @param join_id the ID of the join to modify (not %0)
         * @param field_name the name of the field to use in the join condition (not %NULL)
         */
        join_add_field(join_id: SqlBuilderId, field_name: string): void;
        /**
         * Valid only for: SELECT statements.
         *
         * Add a selected selected item to the SELECT statement.
         *
         * For non-SELECT statements, see gda_sql_builder_add_field_id().
         * @param field_name a field name
         * @param table_name a table name, or %NULL
         * @param alias an alias (eg. for the "AS" clause), or %NULL
         * @returns the ID of the added field, or %0 if there was an error
         */
        select_add_field(field_name: string, table_name?: string | null, alias?: string | null): SqlBuilderId;
        /**
         * Adds a new target to a SELECT statement
         * @param table_name the name of the target table
         * @param alias the alias to give to the target, or %NULL
         * @returns the ID of the new target, or %0 if there was an error
         */
        select_add_target(table_name: string, alias?: string | null): SqlBuilderId;
        /**
         * Adds a new target to a SELECT statement. If there already exists a target representing
         * the same table and the same alias (or with the same absence of alias) then the same target
         * ID is returned instead of the ID of a new target.
         * @param table_id the ID of the expression holding a table reference (not %0)
         * @param alias the alias to give to the target, or %NULL
         * @returns the ID of the new (or existing) target, or %0 if there was an error
         */
        select_add_target_id(table_id: SqlBuilderId, alias?: string | null): SqlBuilderId;
        /**
         * Valid only for: SELECT statements
         *
         * Adds the `expr_id` expression to the GROUP BY clause's expressions list
         * @param expr_id the ID of the expression to set use in the GROUP BY clause, or 0 to unset any previous GROUP BY clause
         */
        select_group_by(expr_id: SqlBuilderId): void;
        /**
         * Joins two targets in a SELECT statement, using the `join_type` type of join.
         *
         * Note: if the target represented by `left_target_id` is actually situated after (on the right) of
         * the target represented by `right_target_id,` then the actual type of join may be switched from
         * %GDA_SQL_SELECT_JOIN_LEFT to %GDA_SQL_SELECT_JOIN_RIGHT or from %GDA_SQL_SELECT_JOIN_RIGHT to
         * %GDA_SQL_SELECT_JOIN_LEFT.
         * @param left_target_id the ID of the left target to use (not %0)
         * @param right_target_id the ID of the right target to use (not %0)
         * @param join_type the type of join
         * @param join_expr joining expression's ID, or %0
         * @returns the ID of the new join, or %0 if there was an error
         */
        select_join_targets(
            left_target_id: SqlBuilderId,
            right_target_id: SqlBuilderId,
            join_type: SqlSelectJoinType | null,
            join_expr: SqlBuilderId,
        ): SqlBuilderId;
        /**
         * Adds a new ORDER BY expression to a SELECT statement.
         * @param expr_id the ID of the expression to use during sorting (not %0)
         * @param asc %TRUE for an ascending sorting
         * @param collation_name name of the collation to use when sorting, or %NULL
         */
        select_order_by(expr_id: SqlBuilderId, asc: boolean, collation_name?: string | null): void;
        /**
         * Defines (if `distinct` is %TRUE) or removes (if `distinct` is %FALSE) a DISTINCT clause
         * for a SELECT statement.
         *
         * If `distinct` is %TRUE, then the ID of an expression can be specified as the `expr_id` argument:
         * if not %0, this is the expression used to apply the DISTINCT clause on (the resuting SQL
         * will then usually be "... DISTINCT ON &lt;expression&gt;...").
         * @param distinct set to %TRUE to have the DISTINCT requirement
         * @param expr_id the ID of the DISTINCT ON expression, or %0 if no expression is to be used. It is ignored           if @distinct is %FALSE.
         */
        select_set_distinct(distinct: boolean, expr_id: SqlBuilderId): void;
        /**
         * Valid only for: SELECT statements
         *
         * Sets the HAVING condition of the statement
         * @param cond_id the ID of the expression to set as HAVING condition, or 0 to unset any previous HAVING condition
         */
        select_set_having(cond_id: SqlBuilderId): void;
        /**
         * If `limit_count_expr_id` is not %0, defines the maximum number of rows in the #GdaDataModel
         * resulting from the execution of the built statement. In this case, the offset from which the
         * rows must be collected can be defined by the `limit_offset_expr_id` expression if not %0 (note that
         * this feature may not be supported by all the database providers).
         *
         * If `limit_count_expr_id` is %0, then removes any LIMIT which may have been imposed by a previous
         * call to this method.
         * @param limit_count_expr_id the ID of the LIMIT expression, or %0
         * @param limit_offset_expr_id the ID of the OFFSET expression, or %0
         */
        select_set_limit(limit_count_expr_id: SqlBuilderId, limit_offset_expr_id: SqlBuilderId): void;
        /**
         * Valid only for: INSERT, UPDATE, DELETE statements
         *
         * Sets the name of the table on which the built statement operates.
         * @param table_name a table name
         */
        set_table(table_name: string): void;
        /**
         * Valid only for: UPDATE, DELETE, SELECT statements
         *
         * Sets the WHERE condition of the statement
         * @param cond_id the ID of the expression to set as WHERE condition, or 0 to unset any previous WHERE condition
         */
        set_where(cond_id: SqlBuilderId): void;
    }

    namespace SqlParser {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::column-error': (pspec: GObject.ParamSpec) => void;
            'notify::line-error': (pspec: GObject.ParamSpec) => void;
            'notify::mode': (pspec: GObject.ParamSpec) => void;
            'notify::tokenizer-flavour': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Lockable.ConstructorProps {
            column_error: number;
            columnError: number;
            line_error: number;
            lineError: number;
            mode: number;
            tokenizer_flavour: number;
            tokenizerFlavour: number;
        }
    }

    class SqlParser extends GObject.Object implements Lockable {
        static $gtype: GObject.GType<SqlParser>;

        // Properties

        get column_error(): number;
        get columnError(): number;
        get line_error(): number;
        get lineError(): number;
        get mode(): number;
        set mode(val: number);
        get tokenizer_flavour(): number;
        set tokenizer_flavour(val: number);
        get tokenizerFlavour(): number;
        set tokenizerFlavour(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: SqlParser.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<SqlParser.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): SqlParser;

        // Signals

        connect<K extends keyof SqlParser.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SqlParser.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof SqlParser.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SqlParser.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof SqlParser.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<SqlParser.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Methods

        /**
         * Parse `filename'`s contents and creates a #GdaBatch object which contains all the
         *  #GdaStatement objects created while parsing (one object per SQL statement).
         *
         * `filename'`s contents are parsed and #GdaStatement objects are created as long as no error is found. If an error is found
         * at some point, then the parsing stops, `error` may be set and %NULL is returned
         *
         * if `sql` is %NULL, then the returned #GdaBatch object will contain no statement.
         * @param filename name of the file to parse
         * @returns a new #GdaBatch object, or %NULL if an error occurred
         */
        parse_file_as_batch(filename: string): Batch | null;
        /**
         * Parses `sql` and creates a #GdaStatement statement from the first SQL statement contained in `sql:` if `sql`
         * contains more than one statement, then the remaining part of the string is not parsed at all, and `remain` (if
         * not %NULL) will point at the first non parsed character.
         *
         * To include variables in the `sql` string, see the
         * <link linkend="GdaSqlParser.description">GdaSqlParser's object description</link>.
         * @param sql the SQL string to parse
         * @returns a new #GdaStatement object, or %NULL if an error occurred
         */
        parse_string(sql: string): [Statement | null, string];
        /**
         * Parse `sql` and creates a #GdaBatch object which contains all the #GdaStatement objects created while parsing (one object
         * per SQL statement). Empty statements (composed of spaces only) do not appear in the resulting object.
         *
         * `sql` is parsed and #GdaStatement objects are created as long as no error is found in `sql`. If an error is found
         * at some point, then the parsing stops and `remain` may contain a non %NULL pointer, `error` may be set, and %NULL
         * is returned.
         *
         * if `sql` is %NULL, then the returned #GdaBatch object will contain no statement.
         *
         * To include variables in the `sql` string, see the
         * <link linkend="GdaSqlParser.description">GdaSqlParser's object description</link>.
         * @param sql the SQL string to parse
         * @returns a new #GdaBatch object, or %NULL if an error occurred
         */
        parse_string_as_batch(sql: string): [Batch | null, string];
        set_overflow_error(): void;
        set_syntax_error(): void;

        // Inherited methods
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         * @returns TRUE if the object has successfully been locked.
         */
        trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        unlock(): void;
        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        vfunc_trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        vfunc_unlock(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Statement {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            checked: (arg0: Connection, arg1: boolean) => void;
            reset: () => void;
            'notify::structure': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            structure: SqlStatement;
        }
    }

    class Statement extends GObject.Object {
        static $gtype: GObject.GType<Statement>;

        // Properties

        get structure(): SqlStatement;
        set structure(val: SqlStatement);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Statement.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Statement.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Statement;

        // Signals

        connect<K extends keyof Statement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Statement.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Statement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Statement.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Statement.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Statement.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_checked(cnc: Connection, checked: boolean): void;
        vfunc_reset(): void;

        // Methods

        /**
         * Checks that `stmt'`s structure is correct.
         * @returns TRUE if @stmt's structure is correct
         */
        check_structure(): boolean;
        /**
         * If `cnc` is not %NULL then checks that every object (table, field, function) used in `stmt`
         * actually exists in `cnc'`s database
         *
         * If `cnc` is %NULL, then cleans anything related to `cnc` in `stmt`.
         *
         * See gda_sql_statement_check_validity() for more information.
         * @param cnc a #GdaConnection object, or %NULL
         * @returns TRUE if every object actually exists in @cnc's database
         */
        check_validity(cnc?: Connection | null): boolean;
        /**
         * Copy constructor
         * @returns a the new copy of @orig
         */
        copy(): Statement;
        /**
         * Get a new #GdaSet object which groups all the execution parameters
         * which `stmt` needs. This new object is returned though `out_params`.
         *
         * Note that if `stmt` does not need any parameter, then `out_params` is set to %NULL.
         * @returns TRUE if no error occurred.
         */
        get_parameters(): [boolean, Set | null];
        /**
         * Get the type of statement held by `stmt`. It returns GDA_SQL_STATEMENT_NONE if
         * `stmt` does not hold any statement
         * @returns the statement type
         */
        get_statement_type(): SqlStatementType;
        /**
         * Tells if `stmt` is composed only of spaces (that is it has no real SQL code), and is completely
         * useless as such.
         * @returns TRUE if executing @stmt does nothing
         */
        is_useless(): boolean;
        /**
         * "Normalizes" some parts of `stmt,` see gda_sql_statement_normalize() for more
         * information.
         * @param cnc a #GdaConnection object
         * @returns TRUE if no error occurred
         */
        normalize(cnc: Connection): boolean;
        /**
         * Rewrites `stmt` and creates a new #GdaSqlStatement where all the variables which are to a DEFAULT value
         * (as returned by gda_holder_value_is_default()) are either removed from the statement (if `remove`
         * is %TRUE) or replaced by the "DEFAULT" keyword (if `remove` is %FALSE).
         *
         * This function is only useful for database providers' implementations which have to deal with default
         * values when executing statements, and is only relevant in the case of INSERT or UPDATE statements
         * (in the latter case an error is returned if `remove` is %TRUE).
         *
         * For example the <programlisting><![CDATA[INSERT INTO mytable (id, name) VALUES (23, ##name::string)]]></programlisting>
         * is re-written into <programlisting><![CDATA[INSERT INTO mytable (id, name) VALUES (23, DEFAULT)]]></programlisting>
         * if `remove` is %FALSE and into <programlisting><![CDATA[INSERT INTO mytable (id) VALUES (23)]]></programlisting>
         * if `remove` is %TRUE.
         * @param params a #GdaSet containing the variable's values to be bound when executing @stmt
         * @param remove set to %TRUE if DEFAULT fields are removed, of %FALSE if the "DEFAULT" keyword is used
         * @returns a new #GdaSqlStatement, or %NULL if an error occurred
         */
        rewrite_for_default_values(params: Set, remove: boolean): SqlStatement | null;
        /**
         * Creates a string representing the contents of `stmt`.
         * @returns a string containing the serialized version of @stmt
         */
        serialize(): string;
        /**
         * Renders `stmt` as an SQL statement, with some control on how it is rendered.
         *
         * If `cnc` is not %NULL, then the rendered SQL will better be suited to be used by `cnc` (in particular
         * it may include some SQL tweaks and/or proprietary extensions specific to the database engine used by `cnc)`:
         * in this case the result is similar to calling gda_connection_statement_to_sql().
         * @param cnc a #GdaConnection object, or %NULL
         * @param params parameters contained in a single #GdaSet object, or %NULL
         * @param flags a set of flags to control the rendering
         * @returns a new string if no error occurred
         */
        to_sql_extended(
            cnc: Connection | null,
            params: Set | null,
            flags: StatementSqlFlag | null,
        ): [string, Holder[] | null];
    }

    namespace TransactionStatus {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class TransactionStatus extends GObject.Object {
        static $gtype: GObject.GType<TransactionStatus>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TransactionStatus.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TransactionStatus.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](name: string): TransactionStatus;

        // Signals

        connect<K extends keyof TransactionStatus.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TransactionStatus.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TransactionStatus.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TransactionStatus.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TransactionStatus.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TransactionStatus.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        add_event_sql(sql: string, conn_event: ConnectionEvent): TransactionStatusEvent;
        add_event_sub(sub_trans: TransactionStatus): TransactionStatusEvent;
        add_event_svp(svp_name: string): TransactionStatusEvent;
        find(str: string, destev: TransactionStatusEvent): TransactionStatus | null;
        /**
         * Find a pointer to the "current" _unnamed_ transaction, which is the last
         * transaction if there are several nested transactions
         * @param destev
         * @param unnamed_only
         */
        find_current(destev: TransactionStatusEvent, unnamed_only: boolean): TransactionStatus | null;
        free_events(event: TransactionStatusEvent, free_after: boolean): void;
        get_isolation_level(): TransactionIsolation;
        get_state(): TransactionStatusState;
        set_isolation_level(il: TransactionIsolation | null): void;
        set_state(state: TransactionStatusState | null): void;
    }

    namespace Tree {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'node-changed': (arg0: TreeNode) => void;
            'node-deleted': (arg0: string) => void;
            'node-has-child-toggled': (arg0: TreeNode) => void;
            'node-inserted': (arg0: TreeNode) => void;
            'notify::is-list': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            is_list: boolean;
            isList: boolean;
        }
    }

    class Tree extends GObject.Object {
        static $gtype: GObject.GType<Tree>;

        // Properties

        /**
         * Tells if the GdaTree is a list or a tree.
         */
        get is_list(): boolean;
        /**
         * Tells if the GdaTree is a list or a tree.
         */
        get isList(): boolean;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Tree.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Tree.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Tree;

        // Signals

        connect<K extends keyof Tree.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Tree.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Tree.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Tree.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Tree.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Tree.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_node_changed(node: TreeNode): void;
        vfunc_node_deleted(node_path: string): void;
        vfunc_node_has_child_toggled(node: TreeNode): void;
        vfunc_node_inserted(node: TreeNode): void;

        // Methods

        /**
         * Sets `manager` as a top #GdaTreeManager object, which will be responsible for creating top level nodes in `tree`.
         * @param manager a #GdaTreeManager object
         */
        add_manager(manager: TreeManager): void;
        /**
         * Removes any node in `tree`
         */
        clean(): void;
        /**
         * Dumps the contents of `tree` to `stream,` using a hierarchical view.
         * @param node a #GdaTreeNode to start the dump from, or %NULL for a full dump
         * @param stream a stream to send the dump to, or %NULL for STDOUT
         */
        dump(node?: TreeNode | null, stream?: any | null): void;
        /**
         * Locates a #GdaTreeNode using the `tree_path` path.
         * @param tree_path full path to the required nodes (if @use_names is %TRUE, then it must start with '/')
         * @param use_names if %TRUE, then @tree_path will be interpreted as a unix style path, and if %FALSE,             then @tree_path will be interpreted similarly to the #GtkTreePath's string representation.
         * @returns the requested #GdaTreeNode pointer, or %NULL if not found
         */
        get_node(tree_path: string, use_names: boolean): TreeNode | null;
        /**
         * Get the #GdaTreeManager which created `node` in `tree`
         * @param node a #GdaTreeNode present in @tree
         * @returns the #GdaTreeManager, or %NULL if @node is not present in @tree
         */
        get_node_manager(node: TreeNode): TreeManager;
        /**
         * Get the path associated to `node` in `tree`.
         * @param node a #GdaTreeNode node in @tree
         * @returns a new string, or %NULL if @node is not in @tree
         */
        get_node_path(node: TreeNode): string;
        /**
         * The returned list is a list of all the #GdaTreeNode nodes <emphasis>below</emphasis> the node
         * at the specified path.
         *
         * As a corner case if `tree_path` is %NULL, then the returned list contains all the top level nodes.
         * @param tree_path full path to the required nodes (if @use_names is %TRUE, then it must start with '/'), or %NULL
         * @param use_names if %TRUE, then @tree_path will be interpreted as a unix style path, and if %FALSE,             then @tree_path will be interpreted similarly to the #GtkTreePath's string representation.
         * @returns a new list of #GdaTreeNode pointers, free it with g_slist_free()
         */
        get_nodes_in_path(tree_path: string | null, use_names: boolean): TreeNode[];
        /**
         * Sets an attribute to `tree,` which will be accessible to any node in it.
         * @param attribute attribute name
         * @param value a #GValue, or %NULL
         */
        set_attribute(attribute: string, value: GObject.Value | any): void;
        /**
         * Requests that `tree` be populated with nodes. If an error occurs, then `tree'`s contents is left
         * unchanged, and otherwise `tree'`s previous contents is completely replaced by the new one.
         * @returns TRUE if no error occurred.
         */
        update_all(): boolean;
        /**
         * Update the children of `node` in `tree` (not recursively, to update recursively, use
         * gda_tree_update_part()). If `node` is %NULL then the top level nodes are updated.
         * @param node a #GdaTreeNode node in @tree, or %NULL
         * @returns TRUE if no error occurred.
         */
        update_children(node?: TreeNode | null): boolean;
        /**
         * Requests that `tree` be populated with nodes, starting from `node`
         * @param node a #GdaTreeNode node in @tree
         * @returns TRUE if no error occurred.
         */
        update_part(node: TreeNode): boolean;
    }

    namespace TreeManager {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::func': (pspec: GObject.ParamSpec) => void;
            'notify::recursive': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            func: TreeManagerNodesFunc;
            recursive: boolean;
        }
    }

    class TreeManager extends GObject.Object {
        static $gtype: GObject.GType<TreeManager>;

        // Properties

        /**
         * This property specifies the function which needs to be called when the list of #GdaTreeNode nodes
         * managed has to be updated
         */
        get func(): TreeManagerNodesFunc;
        set func(val: TreeManagerNodesFunc);
        /**
         * This property specifies if, when initially creating nodes or updating the list of nodes,
         * the tree manager shoud also request that each node it has created or updated also
         * initially create or update their children.
         *
         * This property can typically set to FALSE if the process of creating children nodes is lenghty
         * and needs to be postponed while an event occurs.
         */
        get recursive(): boolean;
        set recursive(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeManager.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_with_func(update_func: TreeManagerNodesFunc): TreeManager;

        // Signals

        connect<K extends keyof TreeManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeManager.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeManager.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeManager.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeManager.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Methods

        /**
         * Adds a sub manager to `manager`. Use this method to create the skeleton structure
         * of a #GdaTree. Note that a single #GdaTreeManager can be used by several #GdaTree objects
         * or several times in the same #GdaTree's structure.
         *
         * Please note that it's possible for `mgr` and `sub` to be the same object, but beware of the possible
         * infinite recursive behaviour in this case when creating children nodes
         * (depending on the actual implementation of the #GdaTreeManager).
         * @param sub a #GdaTreeManager object to add
         */
        add_manager(sub: TreeManager): void;
        /**
         * Requests that for any new node managed (eg. created) by `manager,` a new attribute will be set. This allows
         * one to customize the attributes of new nodes created by an existing #GdaTreeManager.
         *
         * As a side effect, if `value` is %NULL, then the corresponding attribute, if it was set, is unset.
         * @param attribute an attribute name
         * @param value the attribute's value, or %NULL
         */
        add_new_node_attribute(attribute: string, value?: GObject.Value | null): void;
        /**
         * Requests that `manager` creates a new #GdaTreeNode. The new node is not in any
         * way linked to `manager` yet, consider this method as a #GdaTreeNode factory.
         *
         * This method is usually used when implementing a #GdaTreeManagerNodesFunc function (to create nodes),
         * or when subclassing the #GdaTreeManager.
         * @param parent the parent the new node may have, or %NULL
         * @param name name given to the new node, or %NULL
         * @returns a new #GdaTreeNode
         */
        create_node(parent?: TreeNode | null, name?: string | null): TreeNode;
        /**
         * Get the list of sub managers which have already been added using gda_tree_manager_add_manager()
         * @returns a list of #GdaTreeMenager which should not be modified.
         */
        get_managers(): TreeManager[];
        /**
         * Sets the function to be called when a new node is being created by `manager`. If `func` is %NULL
         * then each created node will be a #GdaTreeNode object.
         *
         * Specifying a custom #GdaTreeManagerNodeFunc function for example allows one to use
         * specialized sub-classed #GdaTreeNode objects.
         * @param func a #GdaTreeManagerNodeFunc function pointer, or %NULL
         */
        set_node_create_func(func?: TreeManagerNodeFunc | null): void;
    }

    namespace TreeMgrColumns {
        // Signal signatures
        interface SignalSignatures extends TreeManager.SignalSignatures {
            'notify::connection': (pspec: GObject.ParamSpec) => void;
            'notify::meta-store': (pspec: GObject.ParamSpec) => void;
            'notify::schema': (pspec: GObject.ParamSpec) => void;
            'notify::table-name': (pspec: GObject.ParamSpec) => void;
            'notify::func': (pspec: GObject.ParamSpec) => void;
            'notify::recursive': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends TreeManager.ConstructorProps {
            connection: Connection;
            meta_store: MetaStore;
            metaStore: MetaStore;
            schema: string;
            table_name: string;
            tableName: string;
        }
    }

    class TreeMgrColumns extends TreeManager {
        static $gtype: GObject.GType<TreeMgrColumns>;

        // Properties

        /**
         * Defines the #GdaConnection to display information for. Necessary upon construction unless
         * the #GdaTreeMgrColumns:meta-store property is specified instead.
         */
        get connection(): Connection;
        /**
         * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
         * the #GdaTreeMgrColumns:connection property is specified instead. This property has
         * priority over the GdaTreeMgrColumns:connection property.
         */
        get meta_store(): MetaStore;
        /**
         * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
         * the #GdaTreeMgrColumns:connection property is specified instead. This property has
         * priority over the GdaTreeMgrColumns:connection property.
         */
        get metaStore(): MetaStore;
        /**
         * If no set, then the table name will be fetched from the parent node using the "schema" attribute
         */
        set schema(val: string);
        /**
         * If no set, then the table name will be fetched from the parent node using the "table_name" attribute
         */
        set table_name(val: string);
        /**
         * If no set, then the table name will be fetched from the parent node using the "table_name" attribute
         */
        set tableName(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeMgrColumns.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeMgrColumns.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](cnc: Connection, schema: string, table_name: string): TreeMgrColumns;

        // Signals

        connect<K extends keyof TreeMgrColumns.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrColumns.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeMgrColumns.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrColumns.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeMgrColumns.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeMgrColumns.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace TreeMgrLabel {
        // Signal signatures
        interface SignalSignatures extends TreeManager.SignalSignatures {
            'notify::label': (pspec: GObject.ParamSpec) => void;
            'notify::func': (pspec: GObject.ParamSpec) => void;
            'notify::recursive': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends TreeManager.ConstructorProps {
            label: string;
        }
    }

    class TreeMgrLabel extends TreeManager {
        static $gtype: GObject.GType<TreeMgrLabel>;

        // Properties

        set label(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeMgrLabel.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeMgrLabel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](label: string): TreeMgrLabel;

        // Signals

        connect<K extends keyof TreeMgrLabel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrLabel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeMgrLabel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrLabel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeMgrLabel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeMgrLabel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace TreeMgrSchemas {
        // Signal signatures
        interface SignalSignatures extends TreeManager.SignalSignatures {
            'notify::connection': (pspec: GObject.ParamSpec) => void;
            'notify::meta-store': (pspec: GObject.ParamSpec) => void;
            'notify::func': (pspec: GObject.ParamSpec) => void;
            'notify::recursive': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends TreeManager.ConstructorProps {
            connection: Connection;
            meta_store: MetaStore;
            metaStore: MetaStore;
        }
    }

    class TreeMgrSchemas extends TreeManager {
        static $gtype: GObject.GType<TreeMgrSchemas>;

        // Properties

        /**
         * Defines the #GdaConnection to display information for. Necessary upon construction unless
         * the #GdaTreeMgrSchema:meta-store property is specified instead.
         */
        get connection(): Connection;
        /**
         * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
         * the #GdaTreeMgrSchema:connection property is specified instead. This property has
         * priority over the GdaTreeMgrSchema:connection property.
         */
        get meta_store(): MetaStore;
        /**
         * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
         * the #GdaTreeMgrSchema:connection property is specified instead. This property has
         * priority over the GdaTreeMgrSchema:connection property.
         */
        get metaStore(): MetaStore;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeMgrSchemas.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeMgrSchemas.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](cnc: Connection): TreeMgrSchemas;

        // Signals

        connect<K extends keyof TreeMgrSchemas.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrSchemas.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeMgrSchemas.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrSchemas.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeMgrSchemas.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeMgrSchemas.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace TreeMgrSelect {
        // Signal signatures
        interface SignalSignatures extends TreeManager.SignalSignatures {
            'notify::connection': (pspec: GObject.ParamSpec) => void;
            'notify::params': (pspec: GObject.ParamSpec) => void;
            'notify::statement': (pspec: GObject.ParamSpec) => void;
            'notify::func': (pspec: GObject.ParamSpec) => void;
            'notify::recursive': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends TreeManager.ConstructorProps {
            connection: Connection;
            params: Set;
            statement: Statement;
        }
    }

    class TreeMgrSelect extends TreeManager {
        static $gtype: GObject.GType<TreeMgrSelect>;

        // Properties

        get connection(): Connection;
        get params(): Set;
        get statement(): Statement;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeMgrSelect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeMgrSelect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](cnc: Connection, stmt: Statement, params: Set): TreeMgrSelect;

        // Signals

        connect<K extends keyof TreeMgrSelect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrSelect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeMgrSelect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrSelect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeMgrSelect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeMgrSelect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace TreeMgrTables {
        // Signal signatures
        interface SignalSignatures extends TreeManager.SignalSignatures {
            'notify::connection': (pspec: GObject.ParamSpec) => void;
            'notify::meta-store': (pspec: GObject.ParamSpec) => void;
            'notify::schema': (pspec: GObject.ParamSpec) => void;
            'notify::func': (pspec: GObject.ParamSpec) => void;
            'notify::recursive': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends TreeManager.ConstructorProps {
            connection: Connection;
            meta_store: MetaStore;
            metaStore: MetaStore;
            schema: string;
        }
    }

    class TreeMgrTables extends TreeManager {
        static $gtype: GObject.GType<TreeMgrTables>;

        // Properties

        /**
         * Defines the #GdaConnection to display information for. Necessary upon construction unless
         * the #GdaTreeMgrTables:meta-store property is specified instead.
         */
        get connection(): Connection;
        /**
         * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
         * the #GdaTreeMgrTables:connection property is specified instead. This property has
         * priority over the GdaTreeMgrTables:connection property.
         */
        get meta_store(): MetaStore;
        /**
         * Defines the #GdaMetaStore to extract information from. Necessary upon construction unless
         * the #GdaTreeMgrTables:connection property is specified instead. This property has
         * priority over the GdaTreeMgrTables:connection property.
         */
        get metaStore(): MetaStore;
        /**
         * If no set, then the table name will be fetched from the parent node using the "schema" attribute. If not
         * found that way, then the list of visible tables (tables which can be identified without having to specify
         * a schema) will be used
         */
        set schema(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeMgrTables.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeMgrTables.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](cnc: Connection, schema?: string | null): TreeMgrTables;

        // Signals

        connect<K extends keyof TreeMgrTables.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrTables.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeMgrTables.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeMgrTables.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeMgrTables.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeMgrTables.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace TreeNode {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'node-changed': (arg0: TreeNode) => void;
            'node-deleted': (arg0: string) => void;
            'node-has-child-toggled': (arg0: TreeNode) => void;
            'node-inserted': (arg0: TreeNode) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            name: string;
        }
    }

    class TreeNode extends GObject.Object {
        static $gtype: GObject.GType<TreeNode>;

        // Properties

        get name(): string;
        set name(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeNode.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeNode.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](name?: string | null): TreeNode;

        // Signals

        connect<K extends keyof TreeNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_dump_children(prefix: string, in_string: GLib.String): void;
        vfunc_dump_header(): string;
        vfunc_node_changed(node: TreeNode): void;
        vfunc_node_deleted(relative_path: string): void;
        vfunc_node_has_child_toggled(node: TreeNode): void;
        vfunc_node_inserted(node: TreeNode): void;

        // Methods

        /**
         * Get the value associated to the attribute named `attribute` for `node`. If the attribute is not set,
         * then `node'`s parents is queries (recursively up to the top level node).
         *
         * Attributes can have any name, but Libgda proposes some default names,
         * see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
         * @param attribute attribute name as a string
         * @returns a read-only #GValue, or %NULL if not attribute named @attribute has been set for @node
         */
        fetch_attribute(attribute: string): unknown;
        /**
         * Get the #GdaTreeNode child of `node` at position `index` (starting at 0).
         * @param index a index
         * @returns the #GdaTreeNode, or %NULL if not found
         */
        get_child_index(index: number): TreeNode;
        /**
         * Get the #GdaTreeNode child of `node` which has the #GDA_ATTRIBUTE_NAME set to `name`
         * @param name requested node's name
         * @returns the #GdaTreeNode, or %NULL if not found
         */
        get_child_name(name: string): TreeNode;
        /**
         * Get a list of all `node'`s children, free it with g_slist_free() after usage
         * @returns a new #GSList of #GdaTreeNode objects, or %NULL if @node does not have any child
         */
        get_children(): TreeNode[];
        /**
         * Get the value associated to the attribute named `attribute` for `node`. The difference with gda_tree_node_fetch_attribute()
         * is that gda_tree_node_fetch_attribute() will also query `node'`s parents (recursively up to the top level node) if
         * the attribute is not set for `node`.
         *
         * Attributes can have any name, but Libgda proposes some default names,
         * see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
         * @param attribute attribute name as a string
         * @returns a read-only #GValue, or %NULL if not attribute named @attribute has been set for @node
         */
        get_node_attribute(attribute: string): unknown;
        /**
         * Get the #GdaTreeNode parent of `node` in the #GdaTree node belongs to. If `node` is at the top level,
         * then this method return %NULL.
         * @returns the parent #GdaTreeNode
         */
        get_parent(): TreeNode;
        /**
         * Set the value associated to a named attribute. The `attribute` string is used AS IT IS by this method (eg.
         * no copy of it is made), and
         * the memory it uses will be freed using the `destroy` function when no longer needed (if `destroy` is %NULL,
         * then the string will not be freed at all).
         *
         * Attributes can have any name, but Libgda proposes some default names,
         * see <link linkend="libgda-40-Attributes-manager.synopsis">this section</link>.
         *
         * For example one would use it as:
         *
         * <code>
         * gda_tree_node_set_node_attribute (node, g_strdup (my_attribute), my_value, g_free);
         * gda_tree_node_set_node_attribute (node, GDA_ATTRIBUTE_NAME, my_value, NULL);
         * </code>
         *
         * If there is already an attribute named `attribute` set, then its value is replaced with the new value (`value` is
         * copied), except if `value` is %NULL, in which case the attribute is removed.
         * @param attribute attribute name
         * @param value a #GValue, or %NULL
         */
        set_node_attribute(attribute: string, value?: GObject.Value | null): void;
    }

    namespace UShort {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}
    }

    class UShort {
        static $gtype: GObject.GType<UShort>;

        // Constructors

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof UShort.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, UShort.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof UShort.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, UShort.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof UShort.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<UShort.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XaTransaction {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::format-id': (pspec: GObject.ParamSpec) => void;
            'notify::transaction-id': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            format_id: number;
            formatId: number;
            transaction_id: string;
            transactionId: string;
        }
    }

    class XaTransaction extends GObject.Object {
        static $gtype: GObject.GType<XaTransaction>;

        // Properties

        get format_id(): number;
        get formatId(): number;
        get transaction_id(): string;
        get transactionId(): string;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XaTransaction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XaTransaction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](format: number, global_transaction_id: string): XaTransaction;

        // Signals

        connect<K extends keyof XaTransaction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XaTransaction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XaTransaction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XaTransaction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XaTransaction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XaTransaction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static error_quark(): GLib.Quark;
        /**
         * Creates a new #GdaXaTransactionId structure from its string representation, it's the opposite
         * of gda_xa_transaction_id_to_string().
         * @param str a string representation of a #GdaXaTransactionId, in the "gtrid,bqual,formatID" format
         */
        static string_to_id(str: string): XaTransactionId;

        // Methods

        /**
         * Begins a distributed transaction (managed by `xa_trans)`. Please note that this phase may fail
         * for some connections if a (normal) transaction is already started (this depends on the database
         * provider being used), so it's better to avoid starting any (normal) transaction on any of the
         * connections registered with `xa_trans`.
         * @returns TRUE if no error occurred
         */
        begin(): boolean;
        /**
         * Commits a distributed transaction (managed by `xa_trans)`. The commit is composed of two phases:
         * <itemizedlist>
         *   <listitem><para>a PREPARE phase where all the connections are required to store their transaction data to a
         *     permanent place (to be able to complete the commit should a problem occur afterwards)</para></listitem>
         *   <listitem><para>a COMMIT phase where the transaction data is actually written to the database</para></listitem>
         * </itemizedlist>
         *
         * If the PREPARE phase fails for any of the connection registered with `xa_trans,` then the distributed commit
         * fails and FALSE is returned. During the COMMIT phase, some commit may actually fail but the transaction can
         * still be completed because the PREPARE phase succeeded (through the recover method).
         * @returns TRUE if no error occurred (there may be some connections to recover, though)
         */
        commit(): [boolean, Connection[] | null];
        /**
         * Tries to commit the data prepared but which failed to commit (see gda_xa_transaction_commit()). This
         * method allows one to terminate a distributed transaction which succeeded but for which some
         * connections needed to be recovered.
         * @returns %TRUE if all the data which was still uncommitted has been committed
         */
        commit_recovered(): [boolean, Connection[] | null];
        /**
         * Registers `cnc` to be used by `xa_trans` to create a distributed transaction.
         *
         * Note: any #GdaConnection object can only be registered with at most one #GdaXaTransaction object; also
         * some connections may not be registered at all with a #GdaXaTransaction object because the database
         * provider being used does not support it.
         * @param cnc the connection to add to @xa_trans
         * @param branch the branch qualifier
         * @returns %TRUE if no error occurred
         */
        register_connection(cnc: Connection, branch: string): boolean;
        /**
         * Cancels a distributed transaction (managed by `xa_trans)`.
         * @returns %TRUE if no error occurred
         */
        rollback(): boolean;
        /**
         * Unregisters `cnc` to be used by `xa_trans` to create a distributed transaction. This is
         * the opposite of gda_xa_transaction_register_connection().
         * @param cnc the connection to add to @xa_trans
         */
        unregister_connection(cnc: Connection): void;
    }

    type AfectedRowsIface = typeof AfectedRows;
    type BatchClass = typeof Batch;
    class Binary {
        static $gtype: GObject.GType<Binary>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): Binary;

        // Methods

        /**
         * Creates a new #GdaBinary structure from an existing one.
         * @returns a newly allocated #GdaBinary which contains a copy of information in @boxed.
         */
        copy(): Binary;
        /**
         * Deallocates all memory associated to the given #GdaBinary.
         */
        free(): void;
        get_data(): any | null;
        get_size(): number;
        /**
         * Frees data referenced by #GdaBinary
         */
        reset_data(): void;
        /**
         * Set binary data to a #GdaBinary, holding a copy of the data.
         * @param val value to be copied by #GdaBinary.
         */
        set_data(val: Uint8Array | string): void;
        /**
         * Set binary data to a #GdaBinary, directly holding `val` (no copy made).
         * @param val value to be taken by #GdaBinary.
         */
        take_data(val: Uint8Array | string): void;
        /**
         * Converts all the non printable characters of bin->data into the "\xyz" representation
         * where "xyz" is the octal representation of the byte, and the '\' (backslash) character
         * is converted to "\\". Printable characters (defined by g_ascii_isprint()) as well as newline
         * character are not converted.
         *
         * Note that the backslash and newline characters are considered as printable characters and
         * will not be represented by the "\xyz" representation.
         *
         * Use this function to get a representation as much readable by humans as possible of a binary
         * chunk. Note that this function is internally called when transforming a binary value to
         * a string for example when using g_value_transform() or gda_value_stringify().
         * @param maxlen a maximum len used to truncate, or %0 for no maximum length
         * @returns a new string from @bin
         */
        to_string(maxlen: number): string;
    }

    /**
     * Represents some binary data, accessed through a #GdaBlobOp object.
     * `op` is generally set up by database providers when giving access to an existing BLOB in
     * a database, but can be modified if needed using gda_blob_set_op().
     */
    class Blob {
        static $gtype: GObject.GType<Blob>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): Blob;

        // Methods

        /**
         * Creates a new #GdaBlob structure from an existing one.
         * @returns a newly allocated #GdaBlob which contains a copy of information in @boxed.
         */
        copy(): Blob;
        /**
         * Deallocates all memory associated to the given #GdaBlob.
         */
        free(): void;
        get_binary(): Binary;
        get_op(): BlobOp;
        /**
         * Correctly assigns `op` to `blob` (increases `op'`s reference count)
         * @param op a #GdaBlobOp object, or %NULL
         */
        set_op(op?: BlobOp | null): void;
        /**
         * Converts all the non printable characters of blob->data into the \xxx representation
         * where xxx is the octal representation of the byte, and the '\' (backslash) character
         * is converted to "\\".
         * @param maxlen a maximum len used to truncate, or 0 for no maximum length
         * @returns a new string from @blob
         */
        to_string(maxlen: number): string;
    }

    type BlobOpClass = typeof BlobOp;
    class BlobOpFunctions {
        static $gtype: GObject.GType<BlobOpFunctions>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ColumnClass = typeof Column;
    type ColumnModelIface = typeof ColumnModel;
    type ConfigClass = typeof Config;
    type ConnectionClass = typeof Connection;
    type ConnectionEventClass = typeof ConnectionEvent;
    type ConnectionModelIface = typeof ConnectionModel;
    type ConnectionModelParamsClass = typeof ConnectionModelParams;
    abstract class ConnectionModelParamsPrivate {
        static $gtype: GObject.GType<ConnectionModelParamsPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CreateDatabaseBuilderIface = typeof CreateDatabaseBuilder;
    type CreateTableBuilderIface = typeof CreateTableBuilder;
    type DataAccessWrapperClass = typeof DataAccessWrapper;
    type DataComparatorClass = typeof DataComparator;
    type DataHandlerInterface = typeof DataHandler;
    type DataModelArrayClass = typeof DataModelArray;
    type DataModelDirClass = typeof DataModelDir;
    type DataModelIface = typeof DataModel;
    type DataModelImportClass = typeof DataModelImport;
    type DataModelImportIterClass = typeof DataModelImportIter;
    class DataModelInterface {
        static $gtype: GObject.GType<DataModelInterface>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DataModelIterClass = typeof DataModelIter;
    type DataModelSelectClass = typeof DataModelSelect;
    type DataPivotClass = typeof DataPivot;
    type DataProxyClass = typeof DataProxy;
    type DataSelectClass = typeof DataSelect;
    type DataSelectIterClass = typeof DataSelectIter;
    type DbBaseClass = typeof DbBase;
    type DbBuildableInterface = typeof DbBuildable;
    type DbCatalogClass = typeof DbCatalog;
    type DbColumnClass = typeof DbColumn;
    type DbFkeyClass = typeof DbFkey;
    type DbIndexClass = typeof DbIndex;
    type DbIndexFieldClass = typeof DbIndexField;
    type DbTableClass = typeof DbTable;
    type DbViewClass = typeof DbView;
    type DdlModifiableInterface = typeof DdlModifiable;
    class Diff {
        static $gtype: GObject.GType<Diff>;

        // Fields

        type: DiffType;
        old_row: number;
        new_row: number;

        // Constructors

        _init(...args: any[]): void;
    }

    type DropDatabaseBuilderIface = typeof DropDatabaseBuilder;
    type DropTableBuilderIface = typeof DropTableBuilder;
    /**
     * This structure defines the properties of a named data source (DSN).
     */
    class DsnInfo {
        static $gtype: GObject.GType<DsnInfo>;

        // Fields

        name: string;
        provider: string;
        description: string;
        cnc_string: string;
        auth_string: string;
        is_system: boolean;

        // Constructors

        constructor(
            properties?: Partial<{
                name: string;
                provider: string;
                description: string;
                cnc_string: string;
                auth_string: string;
                is_system: boolean;
            }>,
        );
        _init(...args: any[]): void;

        static ['new'](): DsnInfo;

        // Methods

        /**
         * Copy constructor.
         * @returns a new #GdaDsnInfo
         */
        copy(): DsnInfo;
        /**
         * Compares `dsn1` and `dsn2`.
         *
         * If both `dsn1` and `dsn2` are %NULL, then the function returns %TRUE.
         * If only one of `dsn1` or `dsn2` is %NULL, then the function return %FALSE.
         * @param dsn2 a #GdaDsnInfo
         * @returns %TRUE if they are equal.
         */
        equal(dsn2?: DsnInfo | null): boolean;
        /**
         * Frees any resources taken by `dsn` struct. If `dsn` is %NULL, then nothing happens.
         */
        free(): void;
    }

    type ForeignKeyIface = typeof ForeignKey;
    class GeometricPoint {
        static $gtype: GObject.GType<GeometricPoint>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): GeometricPoint;

        // Methods

        copy(): GeometricPoint;
        free(): void;
        get_x(): number;
        get_y(): number;
        set_x(x: number): void;
        set_y(y: number): void;
    }

    type HandlerBinClass = typeof HandlerBin;
    type HandlerBooleanClass = typeof HandlerBoolean;
    type HandlerNumericalClass = typeof HandlerNumerical;
    type HandlerStringClass = typeof HandlerString;
    type HandlerTextClass = typeof HandlerText;
    type HandlerTimeClass = typeof HandlerTime;
    type HandlerTypeClass = typeof HandlerType;
    type HolderClass = typeof Holder;
    type InsertedIface = typeof Inserted;
    type LockableInterface = typeof Lockable;
    type MetaCatalogIface = typeof MetaCatalog;
    type MetaColumnIface = typeof MetaColumn;
    /**
     * The <structname>GdaMetaContext</structname> represents a meta data modification
     * context: the <emphasis>how</emphasis> when used with gda_meta_store_modify_with_context(),
     * and the <emphasis>what</emphasis> when used with gda_connection_update_meta_store().
     *
     * To create a new #GdaMetaContext use #gda_meta_context_new.
     *
     * To add a new column/value pair use #gda_meta_context_add_column.
     *
     * To free a #GdaMetaContext, created by #gda_meta_context_new, use #gda_attributes_manager_free.
     *
     * Since 5.2, you must consider this struct as opaque. Any access to its internal must use public API.
     * Don't try to use #gda_meta_context_free on a struct that was created manually.
     */
    class MetaContext {
        static $gtype: GObject.GType<MetaContext>;

        // Fields

        table_name: string;
        size: number;
        column_names: string[];

        // Constructors

        constructor(
            properties?: Partial<{
                table_name: string;
                size: number;
                column_names: string[];
                column_values: GObject.Value[];
            }>,
        );
        _init(...args: any[]): void;

        static ['new'](): MetaContext;

        // Methods

        /**
         * Copy constructor.
         * @returns a new #GdaMetaContext
         */
        copy(): MetaContext;
        /**
         * Frees any resources taken by `ctx` struct. If `ctx` is %NULL, then nothing happens.
         */
        free(): void;
        get_n_columns(): number;
        /**
         * Get table's name to used in the context.
         * @returns A string with the table's name used in the context.
         */
        get_table(): string;
        /**
         * Sets a new column/value pair to the given context `ctx`. Column, must be a column in the given table's
         * name setted by #gda_meta_context_set_table () (a table in the <link linkend="information_schema">database
         * schema</link>). If the given `column` already exists it's value is overwrited.
         *
         * Column's name and value is copied and destroyed when #gda_meta_context_free is called.
         * @param column the column's name
         * @param value the column's value
         * @param cnc a #GdaConnection to be used when identifier are normalized, or NULL
         */
        set_column(column: string, value: GObject.Value | any, cnc?: Connection | null): void;
        /**
         * Set columns to use in the context. The #GHashTable use column's name as key and a #GValue as value,
         * to represent its value.
         *
         * `columns` incements its reference counting. Is recommended to use #gda_meta_context_free in order to free them.
         * @param columns a #GHashTable with the table's columns' name and their values to use in context.
         * @param cnc a #GdaConnection to used to normalize identifiers quoting, or NULL
         */
        set_columns(
            columns: { [key: string]: any } | GLib.HashTable<string, GObject.Value>,
            cnc?: Connection | null,
        ): void;
        /**
         * Set table's name to use in the context. The table is one of <link linkend="information_schema">database
         * schema</link> used to store meta information about the database. Use "_tables" to update meta information
         * about database's tables.
         * @param table a string with the table's name to use in context
         */
        set_table(table: string): void;
        /**
         * Creates a string representation of given context.
         * @returns a new string with the representation of the context
         */
        stringify(): string;
    }

    /**
     * Struture to hold information about each database object (tables, views, ...),
     * its contents must not be modified.
     *
     * Note: `obj_catalog,` `obj_schema,` `obj_name,` `obj_short_name` and `obj_full_name` respect the
     * <link linkend="information_schema:sql_identifiers">SQL identifiers</link> convention used in
     * #GdaMetaStore objects. Before using these SQL identifiers, you should check the
     * gda_sql_identifier_quote() to know if is it is necessary to surround by double quotes
     * before using in an SQL statement.
     */
    class MetaDbObject {
        static $gtype: GObject.GType<MetaDbObject>;

        // Fields

        obj_type: MetaDbObjectType;
        outdated: boolean;
        obj_catalog: string;
        obj_schema: string;
        obj_name: string;
        obj_short_name: string;
        obj_full_name: string;
        obj_owner: string;

        // Constructors

        _init(...args: any[]): void;
    }

    class MetaStoreChange {
        static $gtype: GObject.GType<MetaStoreChange>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MetaStoreChange;

        // Methods

        copy(): MetaStoreChange;
        free(): void;
        get_change_type(): MetaStoreChangeType;
        get_keys(): GLib.HashTable<string, GObject.Value>;
        get_table_name(): string;
        set_change_type(ctype: MetaStoreChangeType | null): void;
        set_table_name(table_name: string): void;
    }

    type MetaStoreClass = typeof MetaStore;
    type MetaStructClass = typeof MetaStruct;
    /**
     * This structure represents a table of view's column, its contents must not be modified.
     */
    class MetaTableColumn {
        static $gtype: GObject.GType<MetaTableColumn>;

        // Fields

        column_name: string;
        column_type: string;
        gtype: GObject.GType;
        pkey: boolean;
        nullok: boolean;
        default_value: string;
        auto_incement: boolean;
        desc: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * This structure represents a foreign key constraint, its contents must not be modified.
     */
    class MetaTableForeignKey {
        static $gtype: GObject.GType<MetaTableForeignKey>;

        // Fields

        cols_nb: number;
        fk_cols_array: number;
        fk_names_array: string;
        ref_pk_cols_array: number;
        ref_pk_names_array: string;
        fk_name: string;

        // Constructors

        _init(...args: any[]): void;
    }

    type MetaTableIface = typeof MetaTable;
    /**
     * This structure specifies a #GdaMetaDbObject to represent a view's specific attributes,
     * its contents must not be modified.
     */
    class MetaView {
        static $gtype: GObject.GType<MetaView>;

        // Fields

        table: MetaTable;
        view_def: string;
        is_updatable: boolean;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Holds numbers represented as strings.
     *
     * This struct must be considered as opaque. Any access to its members must use its
     * accessors added since version 5.0.2.
     */
    class Numeric {
        static $gtype: GObject.GType<Numeric>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): Numeric;

        // Methods

        /**
         * Creates a new #GdaNumeric structure from an existing one.
         * @returns a newly allocated #GdaNumeric which contains a copy of information in @boxed. Free-function: gda_numeric_free
         */
        copy(): Numeric;
        /**
         * Deallocates all memory associated to the given `boxed`
         */
        free(): void;
        get_double(): number;
        /**
         * Gets the precision of a #GdaNumeric.
         * @returns an integer with the precision of a #GdaNumeric.
         */
        get_precision(): number;
        /**
         * Get the string representation of `numeric,` in the C locale format (dot as a fraction separator).
         * @returns a new string representing the stored valued in @numeric
         */
        get_string(): string | null;
        /**
         * Gets the width of a #GdaNumeric. (Not yet implemented).
         * @returns an integer with the width of a #GdaNumeric. (Not jet implemented).
         */
        get_width(): number;
        /**
         * Sets `numeric` using a #gdouble represented by `number`.
         * @param number a #gdouble
         */
        set_double(number: number): void;
        /**
         * Sets `numeric` with a number represented by `str,` in the C locale format (dot as a fraction separator).
         * @param str a string representing a number, in the C locale format
         */
        set_from_string(str: string): void;
        /**
         * Sets the precision of a #GdaNumeric.
         * @param precision a #glong
         */
        set_precision(precision: number): void;
        /**
         * Sets the width of a #GdaNumeric. (Not yet implemented).
         * @param width a #glong
         */
        set_width(width: number): void;
    }

    type PStmtClass = typeof PStmt;
    type ParametersIface = typeof Parameters;
    type PreparedQueryIface = typeof PreparedQuery;
    /**
     * This structure holds the information associated to a database provider as discovered by Libgda.
     */
    class ProviderInfo {
        static $gtype: GObject.GType<ProviderInfo>;

        // Fields

        id: string;
        location: string;
        description: string;
        dsn_params: Set;
        auth_params: Set;
        icon_id: string;

        // Constructors

        _init(...args: any[]): void;
    }

    type ProviderInterface = typeof Provider;
    type ProviderMetaInterface = typeof ProviderMeta;
    class QuarkList {
        static $gtype: GObject.GType<QuarkList>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): QuarkList;

        static new_from_string(string: string): QuarkList;

        // Methods

        /**
         * `string` must be a semi-colon separated list of "&lt;key&gt;=&lt;value&gt;" strings (for example
         * "DB_NAME=notes;USERNAME=alfred"). Each key and value must respect the RFC 1738 recommendations: the
         * <constant>&lt;&gt;&quot;#%{}|\^~[]&apos;`;/?:`=`&amp;</constant> and space characters are replaced by
         * <constant>&quot;%%ab&quot;</constant> where
         * <constant>ab</constant> is the hexadecimal number corresponding to the character (for example the
         * "DB_NAME=notes;USERNAME=al%%20fred" string will specify a username as "al fred"). If this formalism
         * is not respected, then some unexpected results may occur.
         *
         * Some corner cases for any string part (delimited by the semi-colon):
         * <itemizedlist>
         *    <listitem><para>If it does not respect the "&lt;key&gt;=&lt;value&gt;" format then it will be ignored.</para></listitem>
         *    <listitem><para>Only the 1st equal character is used to separate the key from the value part (which means
         *       any other equal sign will be part of the value)</para></listitem>
         * </itemizedlist>
         *
         *
         * Adds new key->value pairs from the given `string`. If `cleanup` is
         * set to %TRUE, the previous contents will be discarded before adding
         * the new pairs.
         * @param string a string.
         * @param cleanup whether to cleanup the previous content or not.
         */
        add_from_string(string: string, cleanup: boolean): void;
        /**
         * Removes all strings in the given #GdaQuarkList.
         */
        clear(): void;
        /**
         * Creates a new #GdaQuarkList from an existing one.
         * @returns a newly allocated #GdaQuarkList with a copy of the data in @qlist.
         */
        copy(): QuarkList;
        /**
         * Searches for the value identified by `name` in the given #GdaQuarkList. For protected values
         * (authentification data), don't forget to call gda_quark_list_protect_values() when you
         * don't need them anymore (when needed again, they will be unmangled again).
         * @param name the name of the value to search for.
         * @returns the value associated with the given key if found, or %NULL if not found.
         */
        find(name: string): string;
        /**
         * Calls the given function for each of the key/value pairs in `qlist`. The function is passed the key and value
         * of each pair, and the given user_data parameter. `qlist` may not be modified while iterating over it.
         * @param func the function to call for each key/value pair
         */
        foreach(func: GLib.HFunc): void;
        /**
         * Releases all memory occupied by the given #GdaQuarkList.
         */
        free(): void;
        /**
         * Call this function to get rid of the clear version of all the values stored in `qlist`. If `qlist` is %NULL,
         * then this function does nothing.
         */
        protect_values(): void;
        /**
         * Removes an entry from the #GdaQuarkList, given its name.
         * @param name an entry name.
         */
        remove(name: string): void;
    }

    type QueryBuilderIface = typeof QueryBuilder;
    type QueryIface = typeof Query;
    type ReadonlyTableModelIface = typeof ReadonlyTableModel;
    type ReferencedColumnIface = typeof ReferencedColumn;
    type RepetitiveStatementClass = typeof RepetitiveStatement;
    type ResultIface = typeof Result;
    type ResultTableIface = typeof ResultTable;
    type RowClass = typeof Row;
    type RowModelIface = typeof RowModel;
    type ServerOperationClass = typeof ServerOperation;
    class ServerOperationCreateTableArg {
        static $gtype: GObject.GType<ServerOperationCreateTableArg>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): ServerOperationCreateTableArg;

        // Methods

        copy(): ServerOperationCreateTableArg;
        free(): void;
        get_column_name(): string;
        get_column_type(): GObject.GType;
        get_fkey_ondelete(): string;
        get_fkey_onupdate(): string;
        get_fkey_refs(): ServerOperationCreateTableArgFKeyRefField[];
        get_fkey_table(): string;
        get_flags(): ServerOperationCreateTableFlag;
        /**
         * Sets column name to be created with the new table.
         * @param name the table's column's name.
         */
        set_column_name(name: string): void;
        set_column_type(ctype: GObject.GType): void;
        /**
         * You should set this if you use a #GDA_SERVER_OPERATION_CREATE_TABLE_FKEY_FLAG flag.
         * @param action action to perform on delete action of the referenced field.
         */
        set_fkey_ondelete(action: string): void;
        set_fkey_ondupdate(action: string): void;
        /**
         * You should set this if you use a #GDA_SERVER_OPERATION_CREATE_TABLE_FKEY_FLAG flag.
         * @param refs list of references from local to foreign fields. This list is owned by @arg, then you should not free it.
         */
        set_fkey_refs(refs: ServerOperationCreateTableArgFKeyRefField[]): void;
        /**
         * You should set this if you use a #GDA_SERVER_OPERATION_CREATE_TABLE_FKEY_FLAG flag.
         * @param name the table's name of reference.
         */
        set_fkey_table(name: string): void;
        /**
         * Sets flags for new column to create with the table.
         * @param flags flags to used in this argument as #GdaServerOperationCreateTableFlag
         */
        set_flags(flags: ServerOperationCreateTableFlag | null): void;
    }

    class ServerOperationCreateTableArgFKeyRefField {
        static $gtype: GObject.GType<ServerOperationCreateTableArgFKeyRefField>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): ServerOperationCreateTableArgFKeyRefField;

        // Methods

        copy(): ServerOperationCreateTableArgFKeyRefField;
        free(): void;
        get_local_field(): string;
        get_referenced_field(): string;
        set_local_field(name: string): void;
        set_referenced_field(name: string): void;
    }

    class ServerOperationNode {
        static $gtype: GObject.GType<ServerOperationNode>;

        // Fields

        type: ServerOperationNodeType;
        status: ServerOperationNodeStatus;
        plist: Set;
        model: DataModel;
        column: Column;
        param: Holder;
        priv: any;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        copy(): ServerOperationNode;
        free(): void;
    }

    /**
     * Functions implementing basic features.
     *
     * A pointer to this structure is returned by _gda_server_provider_get_impl_functions() when requesting
     * `GDA_SERVER_PROVIDER_FUNCTIONS_BASE` functions.
     */
    class ServerProviderBase {
        static $gtype: GObject.GType<ServerProviderBase>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ServerProviderClass = typeof ServerProvider;
    /**
     * Opaque structure extended by database providers to store per-connection information (usually C handles
     * to the connection as required by the C API they use).
     *
     * Note: `worker` part is created in _gda_server_provider_open_connection() by the provider itself, which allows it to
     * either create a #GdaWorker for each connection, or create only one #GdaWorker for all connections (if the underlying
     * for example does not support multi-threading at all)
     */
    class ServerProviderConnectionData {
        static $gtype: GObject.GType<ServerProviderConnectionData>;

        // Fields

        provider_data_destroy_func: GLib.DestroyNotify;
        pad1: any;
        pad2: any;

        // Constructors

        _init(...args: any[]): void;
    }

    class ServerProviderHandlerInfo {
        static $gtype: GObject.GType<ServerProviderHandlerInfo>;

        // Fields

        cnc: Connection;
        g_type: GObject.GType;
        dbms_type: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * These methods must be implemented by providers to update a connection's associated metadata (in a
     * #GdaMetaStore object), see the <link linkend="prov-metadata">Virtual methods for providers/Methods - metadata</link>
     * for more information.
     */
    class ServerProviderMeta {
        static $gtype: GObject.GType<ServerProviderMeta>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Functions implementing distributed transactions.
     */
    class ServerProviderXa {
        static $gtype: GObject.GType<ServerProviderXa>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SetClass = typeof Set;
    /**
     * Since 5.2, you must consider this struct as opaque. Any access to its internal must use public API.
     * Don't try to use #gda_set_group_free on a struct that was created manually.
     */
    class SetGroup {
        static $gtype: GObject.GType<SetGroup>;

        // Constructors

        constructor(node: SetNode);
        _init(...args: any[]): void;

        static ['new'](node: SetNode): SetGroup;

        // Methods

        add_node(node: SetNode): void;
        /**
         * Copy constructor.
         * @returns a new #GdaSetGroup
         */
        copy(): SetGroup;
        /**
         * Frees any resources taken by `sg` struct. If `sg` is %NULL, then nothing happens.
         */
        free(): void;
        get_n_nodes(): number;
        /**
         * This method always return first #GdaSetNode in `sg`.
         * @returns first #GdaSetNode in @sg.
         */
        get_node(): SetNode;
        /**
         * Returns a #GSList with the #GdaSetNode grouped by `sg`. You must use
         * #g_slist_free on returned list.
         * @returns a #GSList with all nodes in @sg.
         */
        get_nodes(): SetNode[];
        get_source(): SetSource;
        set_source(source: SetSource): void;
    }

    /**
     * Since 5.2, you must consider this struct as opaque. Any access to its internal must use public API.
     * Don't try to use #gda_set_node_free on a struct that was created manually.
     */
    class SetNode {
        static $gtype: GObject.GType<SetNode>;

        // Constructors

        constructor(holder: Holder);
        _init(...args: any[]): void;

        static ['new'](holder: Holder): SetNode;

        // Methods

        /**
         * Copy constructor.
         * @returns a new #GdaSetNode
         */
        copy(): SetNode;
        /**
         * Frees any resources taken by `node` struct. If `node` is %NULL, then nothing happens.
         */
        free(): void;
        get_data_model(): DataModel;
        get_holder(): Holder;
        get_source_column(): number;
        /**
         * Set a #GdaDataModel to be used by `node`. `model` increment its reference
         * counting when set. Internally referenced column number is set to first column
         * in `model`.
         * @param model a #GdaDataModel to be used by @node
         */
        set_data_model(model?: DataModel | null): void;
        /**
         * Set a #GdaHolder to `node`.
         * @param holder
         */
        set_holder(holder: Holder): void;
        /**
         * Set column number in the #GdaDataModel used `node`. If no #GdaDataModel is set
         * then column is set to invalid (-1);
         * @param column
         */
        set_source_column(column: number): void;
    }

    /**
     * Since 5.2, you must consider this struct as opaque. Any access to its internal must use public API.
     * Don't try to use #gda_set_source_free on a struct that was created manually.
     */
    class SetSource {
        static $gtype: GObject.GType<SetSource>;

        // Constructors

        constructor(model: DataModel);
        _init(...args: any[]): void;

        static ['new'](model: DataModel): SetSource;

        // Methods

        /**
         * Set a #GdaDataModel
         * @param node a #GdaSetNode to add
         */
        add_node(node: SetNode): void;
        /**
         * Copy constructor.
         * @returns a new #GdaSetSource
         */
        copy(): SetSource;
        /**
         * Frees any resources taken by `s` struct. If `s` is %NULL, then nothing happens.
         */
        free(): void;
        get_data_model(): DataModel;
        get_n_nodes(): number;
        get_nodes(): SetNode[];
        /**
         * Set a #GdaDataModel
         * @param model a #GdaDataModel
         */
        set_data_model(model: DataModel): void;
    }

    /**
     * Base structure of which all structures (except #GdaSqlStatement) "inherit". It identifies, for each structure,
     * its type and its parent in the structure hierarchy.
     */
    class SqlAnyPart {
        static $gtype: GObject.GType<SqlAnyPart>;

        // Fields

        type: SqlAnyPartType;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Checks for any error in `node'`s structure to make sure it is valid. This
         * is the same as gda_sql_statement_check_structure() but for individual #GdaSqlAnyPart
         * parts. This function is mainly for database provider's implementations
         * @returns TRUE if no error occurred
         */
        check_structure(): boolean;
        /**
         * Calls a function for each element of a #GdaSqlAnyPart node
         * @param func function to call for each sub node
         * @returns TRUE if @func has been called for any sub node of @node and always returned TRUE, or FALSE otherwise.
         */
        foreach(func: SqlForeachFunc): boolean;
    }

    type SqlBuilderClass = typeof SqlBuilder;
    /**
     * This structure represents a CASE WHEN... construct
     */
    class SqlCase {
        static $gtype: GObject.GType<SqlCase>;

        // Fields

        when_expr_list: any[];
        then_expr_list: any[];

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlCase;

        // Methods

        /**
         * Creates a new #GdaSqlCase structure initiated with the values stored in `sc`.
         * @returns a new #GdaSqlCase structure.
         */
        copy(): SqlCase;
        /**
         * Frees a #GdaSqlCase structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representing a CASE clause. You need to free the returned string
         * using g_free();
         * @returns a new string with the description of the CASE clause or "null" in case @sc is invalid.
         */
        serialize(): string;
    }

    /**
     * This structure contains any expression, either as a value (the `value` part is set),
     * a variable (the `param_spec` is set), or as other types of expressions.
     *
     * Note 1 about the `value` field: if the expression represents a string value in the SQL statement,
     * the string itself must be represented as it would be in the actual SQL, ie. it should be
     * escaped (accordingly to the escaping rules of the database which will use the SQL). For
     * example a string representing the <userinput>'joe'</userinput> value should be
     * <userinput>"'joe'"</userinput> and not <userinput>"joe"</userinput>.
     *
     * Note 2 about the `value` field: if the expression represents an SQL identifier (such as a table
     * or field name), then the `value_is_ident` should be set to %TRUE, and `value` should be a string
     * which may contain double quotes around SQL identifiers which also are reserved keywords or which
     * are case sensitive.
     */
    class SqlExpr {
        static $gtype: GObject.GType<SqlExpr>;

        // Fields

        cast_as: string;
        value_is_ident: boolean;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlExpr;

        // Methods

        /**
         * Creates a new #GdaSqlExpr structure initiated with the values stored in `expr`.
         * @returns a new #GdaSqlExpr structure.
         */
        copy(): SqlExpr;
        /**
         * Frees a #GdaSqlExpr structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representation of the SQL expression. You need to free the returned string
         * using g_free();
         * @returns a new string with the SQL expression or "null" in case @expr is invalid.
         */
        serialize(): string;
        /**
         * Sets the expression's parent to the #GdaSqlStatementSelect held by `stmt`. After
         * calling this function `stmt` is freed.
         * @param stmt a #GdaSqlStatement holding the #GdaSqlStatementSelect to take from
         */
        take_select(stmt: SqlStatement): void;
    }

    /**
     * This structure represents the name of a table's field.
     */
    class SqlField {
        static $gtype: GObject.GType<SqlField>;

        // Fields

        field_name: string;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlField;

        // Methods

        /**
         * Creates a new GdaSqlField structure initiated with the values stored in `field`.
         * @returns a new #GdaSqlField structure.
         */
        copy(): SqlField;
        /**
         * Frees a #GdaSqlField structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representing a field. You need to free the returned string
         * using g_free();
         * @returns a new string with the name of the field or "null" in case @field is invalid.
         */
        serialize(): string;
        /**
         * Sets the field's name using the string held by `value`. When call, `value` is freed using
         * #gda_value_free().
         * @param value a #GValue holding a string to take from
         */
        take_name(value: GObject.Value | any): void;
    }

    /**
     * This structure represents a function or an aggregate with zero or more arguments.
     */
    class SqlFunction {
        static $gtype: GObject.GType<SqlFunction>;

        // Fields

        function_name: string;
        args_list: any[];

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlFunction;

        // Methods

        check_clean(): void;
        /**
         * Creates a new #GdaSqlFunction structure initiated with the values stored in `function`.
         * @returns a new #GdaSqlFunction structure.
         */
        copy(): SqlFunction;
        /**
         * Frees a #GdaSqlFunction structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representing a function. You need to free the returned string
         * using g_free();
         * @returns a new string with the description of the function or "null" in case @function is invalid.
         */
        serialize(): string;
        /**
         * Sets the function's arguments to point to `args,` then sets the
         * list's data elements' parent to `function`.
         * @param args a #GSList to take from
         */
        take_args_list(args: SqlExpr[]): void;
        /**
         * Sets the function's name using the string held by `value`. When call, `value` is freed using
         * #gda_value_free().
         * @param value a #GValue holding a string to take from
         */
        take_name(value: GObject.Value | any): void;
    }

    /**
     * This structure represents an operation between one or more operands.
     */
    class SqlOperation {
        static $gtype: GObject.GType<SqlOperation>;

        // Fields

        operator_type: SqlOperatorType;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlOperation;

        // Static methods

        /**
         * Returns #GdaSqlOperatorType that correspond with the string `op`.
         * @param op a #GdaSqlOperation structure
         */
        static operator_from_string(op: string): SqlOperatorType;
        /**
         * Returns a constant string representing a operator name. You don't need to free
         * the returned string.
         * @param op a #GdaSqlOperation structure
         */
        static operator_to_string(op: SqlOperatorType): string;

        // Methods

        /**
         * Creates a new #GdaSqlOperation structure initiated with the values stored in `operation`.
         * @returns a new #GdaSqlOperation structure.
         */
        copy(): SqlOperation;
        /**
         * Frees a #GdaSqlOperation structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representing an operator. You need to free the returned string
         * using g_free();
         * @returns a new string with the description of the operator or "null" in case @operation is invalid.
         */
        serialize(): string;
    }

    class SqlParamSpec {
        static $gtype: GObject.GType<SqlParamSpec>;

        // Fields

        name: string;
        descr: string;
        is_param: boolean;
        nullok: boolean;
        g_type: GObject.GType;
        validity_meta_dict: any;

        // Constructors

        constructor(simple_spec: GObject.Value | any);
        _init(...args: any[]): void;

        static ['new'](simple_spec: GObject.Value | any): SqlParamSpec;

        // Methods

        /**
         * Creates a copy of `pspec`.
         * @returns a new #GdaSqlParamSpec
         */
        copy(): SqlParamSpec;
        /**
         * Destroys `pspec`.
         */
        free(): void;
        /**
         * Creates a new string representing `pspec`.
         * @returns a new string.
         */
        serialize(): string;
        /**
         * Sets `pspec'`s description. `value'`s ownership is transferred to
         * `pspec` (which means `pspec` is then responsible for freeing it when no longer needed).
         * @param value a G_TYPE_STRING #GValue
         */
        take_descr(value: GObject.Value | any): void;
        /**
         * Sets `pspec'`s name. `value'`s ownership is transferred to
         * `pspec` (which means `pspec` is then responsible for freeing it when no longer needed).
         * @param value a G_TYPE_STRING #GValue
         */
        take_name(value: GObject.Value | any): void;
        /**
         * Sets `pspec'`s ability of being NULL. `value'`s ownership is transferred to
         * `pspec` (which means `pspec` is then responsible for freeing it when no longer needed).
         *
         * If `value'`s string starts by 't' or 'T' then `pspec` will be allowed to be %NULL
         * @param value a G_TYPE_STRING #GValue.
         */
        take_nullok(value: GObject.Value | any): void;
        /**
         * Sets `pspec'`s data type. `value'`s ownership is transferred to
         * `pspec` (which means `pspec` is then responsible for freeing it when no longer needed).
         *
         * `value` must represent a data type, as understood by gda_g_type_from_string().
         * @param value a G_TYPE_STRING #GValue
         */
        take_type(value: GObject.Value | any): void;
    }

    type SqlParserClass = typeof SqlParser;
    class SqlParserIface {
        static $gtype: GObject.GType<SqlParserIface>;

        // Fields

        parser: SqlParser;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * This structure represents a selected item in a SELECT statement (when executed, the returned data set
     * will have one column per selected item). Note that the `table_name` and
     * `field_name` field parts <emphasis>will be</emphasis> overwritten by &LIBGDA;,
     * set the value of `expr->`value instead.
     */
    class SqlSelectField {
        static $gtype: GObject.GType<SqlSelectField>;

        // Fields

        field_name: string;
        table_name: string;
        as: string;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlSelectField;

        // Methods

        /**
         * Creates a new #GdaSqlSelectField structure initiated with the values stored in `field`.
         * @returns a new #GdaSqlSelectField structure.
         */
        copy(): SqlSelectField;
        /**
         * Frees a #GdaSqlSelectField structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representing an expression used as field in a SELECT statement
         * before the FROM clause.
         * @returns a new string with the description of the expression or "null" in case @field is invalid.
         */
        serialize(): string;
        /**
         * Sets the 'as' field's string in the #GdaSqlSelectField structure. `alias` is freed
         * after call this function.
         * @param alias a #GValue to take from
         */
        take_alias(alias: GObject.Value | any): void;
        /**
         * Sets the expression field in the #GdaSqlSelectField structure to point to `expr`
         * and modify it to sets its parent to `field`.
         * @param expr a #GdaSqlExpr to take from
         */
        take_expr(expr: SqlExpr): void;
        /**
         * Sets the expression field's value in the #GdaSqlSelectField structure to point to `value;`
         * after this `field` is the owner of `value`.
         * @param value a #GValue to take from
         */
        take_star_value(value: GObject.Value | any): void;
    }

    /**
     * This structure represents the FROM clause of a SELECT statement, it lists targets and joins
     */
    class SqlSelectFrom {
        static $gtype: GObject.GType<SqlSelectFrom>;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlSelectFrom;

        // Methods

        /**
         * Creates a new #GdaSqlSelectFrom structure initiated with the values stored in `from`.
         * @returns a new #GdaSqlSelectFrom structure.
         */
        copy(): SqlSelectFrom;
        /**
         * Frees a #GdaSqlSelectFrom structure and its members.
         */
        free(): void;
        /**
         * Creates a new string description of the FROM clause used in a SELECT statement.
         * @returns a new string with the description of the FROM or "null" in case @from is invalid.
         */
        serialize(): string;
        /**
         * Append `join` to the joins in the FROM clause and set `join'`s parent to
         * `from;` after call this function `from` owns `join` then you must not free it.
         * @param join a #GdaSqlSelectJoin to take from
         */
        take_new_join(join: SqlSelectJoin): void;
        /**
         * Append `target` to the targets in the FROM clause and set `target'`s parent to
         * `from;` after call this function `from` owns `target` then you must not free it.
         * @param target a #GdaSqlSelectTarget to take from
         */
        take_new_target(target: SqlSelectTarget): void;
    }

    /**
     * This structure represents a join between two targets in a SELECT statement.
     */
    class SqlSelectJoin {
        static $gtype: GObject.GType<SqlSelectJoin>;

        // Fields

        type: SqlSelectJoinType;
        position: number;
        use: any[];

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlSelectJoin;

        // Static methods

        /**
         * Creates a new string representing the join type.
         * @param type a #GdaSqlSelectJoinType structure to be copied
         */
        static type_to_string(type: SqlSelectJoinType): string;

        // Methods

        /**
         * Creates a new #GdaSqlSelectJoin structure initiated with the values stored in `join`.
         * @returns a new #GdaSqlSelectJoin structure.
         */
        copy(): SqlSelectJoin;
        /**
         * Frees a #GdaSqlSelectJoin structure and its members.
         */
        free(): void;
        /**
         * Creates a new string description of the join used in a SELECT statement.
         * @returns a new string with the description of the join or "null" in case @join is invalid.
         */
        serialize(): string;
    }

    /**
     * This structure represents the ordering of a SELECT statement.
     */
    class SqlSelectOrder {
        static $gtype: GObject.GType<SqlSelectOrder>;

        // Fields

        asc: boolean;
        collation_name: string;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlSelectOrder;

        // Methods

        /**
         * Creates a new #GdaSqlSelectOrder structure initiated with the values stored in `order`.
         * @returns a new #GdaSqlSelectOrder structure.
         */
        copy(): SqlSelectOrder;
        /**
         * Frees a #GdaSqlSelectOrder structure and its members.
         */
        free(): void;
        /**
         * Creates a new string description of the ORDER BY clause used in a SELECT statement.
         * @returns a new string with the description of the ORDER BY or "null" in case @order is invalid.
         */
        serialize(): string;
    }

    /**
     * This structure represents a target used to fetch data from in a SELECT statement; it can represent a table or
     * a sub select. Note that the `table_name`
     * part <emphasis>will be</emphasis> overwritten by &LIBGDA;,
     * set the value of `expr->`value instead.
     */
    class SqlSelectTarget {
        static $gtype: GObject.GType<SqlSelectTarget>;

        // Fields

        table_name: string;
        as: string;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlSelectTarget;

        // Methods

        /**
         * Creates a new #GdaSqlSelectTarget structure initiated with the values stored in `target`.
         * @returns a new #GdaSqlSelectTarget structure.
         */
        copy(): SqlSelectTarget;
        /**
         * Frees a #GdaSqlSelectTarget structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representing a target used in a SELECT statement
         * after the FROM clause.
         * @returns a new string with the description of the expression or "null" in case @field is invalid.
         */
        serialize(): string;
        take_alias(alias: GObject.Value | any): void;
        /**
         * Sets the target to be a SELECT subquery setting target's expression to use
         * `stmt;` after call this function the target owns `stmt,` then you must not free it.
         * @param stmt a #GValue to take from
         */
        take_select(stmt: SqlStatement): void;
        /**
         * Sets the target's name using the string stored in `value` and the expression
         * to set its value to point to value; after call this function the target owns
         * `value,` then you must not free it.
         * @param value a #GValue to take from
         */
        take_table_name(value: GObject.Value | any): void;
    }

    /**
     * This structure is the top level structure encapsulating several type of statements.
     */
    class SqlStatement {
        static $gtype: GObject.GType<SqlStatement>;

        // Fields

        sql: string;
        stmt_type: SqlStatementType;
        contents: any;
        validity_meta_struct: MetaStruct;

        // Constructors

        constructor(type: SqlStatementType);
        _init(...args: any[]): void;

        static ['new'](type: SqlStatementType): SqlStatement;

        // Static methods

        static get_contents_infos(type: SqlStatementType): SqlStatementContentsInfo;
        /**
         * Converts a string to a #GdaSqlStatementType value, see also gda_sql_statement_type_to_string()
         * @param type a string representing a #GdaSqlStatementType type
         */
        static string_to_type(type: string): SqlStatementType;
        /**
         * Converts a #GdaSqlStatementType to a string, see also gda_sql_statement_string_to_type()
         * @param type a #GdaSqlStatementType value
         */
        static type_to_string(type: SqlStatementType): string;

        // Methods

        /**
         * Cleans any data set by a previous call to gda_sql_statement_check_validity().
         */
        check_clean(): void;
        /**
         * Checks for any error in `stmt'`s structure to make sure the statement is valid
         * (for example a SELECT statement must at least return a column, a DELETE statement must specify which table
         * is targeted).
         * @returns TRUE if no error occurred
         */
        check_structure(): boolean;
        /**
         * If `cnc` is not %NULL, then checks that all the database objects referenced in the statement actually
         * exist in the connection's database (for example the table being updated in a UPDATE statement must exist in the
         * connection's database for the check to succeed). This method fills the `stmt-&`gt;validity_meta_struct attribute.
         *
         * If `cnc` is %NULL, then remove any information from a previous call to this method stored in `stmt`. In this case,
         * the `stmt-&`gt;validity_meta_struct attribute is cleared.
         *
         * Also note that some parts of `stmt` may be modified: for example leading and trailing spaces in aliases or
         * objects names will be removed.
         * @param cnc a #GdaConnection object, or %NULL
         * @returns TRUE if no error occurred
         */
        check_validity(cnc?: Connection | null): boolean;
        /**
         * If `mstruct` is not %NULL, then checks that all the database objects referenced in the statement i
         * actually referenced in `mstruct`
         *  (for example the table being updated in a UPDATE statement must exist in the
         * connection's database for the check to succeed).
         * This method sets the `stmt-&`gt;validity_meta_struct attribute to `mstruct`.
         *
         * If `mstruct` is %NULL, then remove any information from a previous call to this method stored in `stmt`. In this case,
         * the `stmt-&`gt;validity_meta_struct attribute is cleared.
         *
         * Also note that some parts of `stmt` may be modified: for example leading and trailing spaces in aliases or
         * objects names will be removed.
         * @param mstruct a #GdaMetaStruct object, or %NULL
         * @returns TRUE if no error occurred
         */
        check_validity_m(mstruct?: MetaStruct | null): boolean;
        /**
         * Specifies `stmt'`s type of compound
         * @param type a #GdaSqlStatementCompoundType value
         */
        compound_set_type(type: SqlStatementCompoundType | null): void;
        /**
         * Adds the `s` sub-statement to the `stmt` compound statement. `s'`s reference is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param s a #GdaSqlStatement pointer
         */
        compound_take_stmt(s: SqlStatement): void;
        /**
         * Creates a copy of `stmt`.
         * @returns a new #GdaSqlStatement
         */
        copy(): SqlStatement;
        /**
         * Sets the WHERE condition of `stmt`. `cond'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param cond the WHERE condition of the DELETE statement, as a #GdaSqlExpr
         */
        delete_take_condition(cond: SqlExpr): void;
        /**
         * Sets the name of the table to delete from in `stmt`. `value'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param value a table name as a G_TYPE_STRING #GValue
         */
        delete_take_table_name(value: GObject.Value | any): void;
        /**
         * Releases any memory associated to `stmt`.
         */
        free(): void;
        /**
         * Sets a list of values to be inserted by `stmt`. `list'`s
         * ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param list a list of #GdaSqlExpr pointers
         */
        insert_take_1_values_list(list: SqlExpr[]): void;
        /**
         * Sets a list of list of values to be inserted by `stmt`. `list'`s
         * ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param list a list of #GSList of #GdaSqlExpr pointers
         */
        insert_take_extra_values_list(list: SqlExpr[]): void;
        /**
         * Sets the list of fields for which values will be specified in `stmt`. `list'`s
         * ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param list a list of #GdaSqlField pointers
         */
        insert_take_fields_list(list: SqlField[]): void;
        /**
         * Sets the name of the resolution conflict algorithm used by `stmt`. `value'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param value name of the resolution conflict algorithm, as a G_TYPE_STRING #GValue
         */
        insert_take_on_conflict(value: GObject.Value | any): void;
        /**
         * Specifies a SELECT statement, the values inserted will be the result set of `select`. `select'`s
         * ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param select a SELECT or COMPOUND #GdaSqlStatement pointer
         */
        insert_take_select(select: SqlStatement): void;
        /**
         * Sets the name of the table to insert into in `stmt`. `value'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param value name of the table to insert into, as a G_TYPE_STRING #GValue
         */
        insert_take_table_name(value: GObject.Value | any): void;
        /**
         * "Normalizes" (in place) some parts of `stmt,` which means `stmt` may be modified.
         * At the moment any "*" field in a SELECT statement will be replaced by one
         * #GdaSqlSelectField structure for each field in the referenced table.
         * @param cnc a #GdaConnection object, or %NULL
         * @returns TRUE if no error occurred
         */
        normalize(cnc?: Connection | null): boolean;
        /**
         * Sets the DISTINCT clause of `stmt`.
         *
         * `distinct_expr'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param distinct a TRUE/FALSE value
         * @param distinct_expr a #GdaSqlExpr pointer representing what the DISTINCT is on, or %NULL
         */
        select_take_distinct(distinct: boolean, distinct_expr?: SqlExpr | null): void;
        /**
         * Sets list of expressions selected by `stmt`
         *
         * `expr_list'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param expr_list a list of #GdaSqlSelectField pointers
         */
        select_take_expr_list(expr_list: SqlSelectField[]): void;
        /**
         * Sets the FROM clause of `stmt`
         *
         * `from'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param from a #GdaSqlSelectFrom pointer
         */
        select_take_from(from: SqlSelectFrom): void;
        /**
         * Sets the GROUP BY clause of `stmt`
         *
         * `group_by'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param group_by a list of #GdaSqlExpr pointer
         */
        select_take_group_by(group_by: SqlExpr[]): void;
        /**
         * Sets the HAVING clause of `stmt`
         *
         * `expr'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param expr a #GdaSqlExpr pointer
         */
        select_take_having_cond(expr: SqlExpr): void;
        /**
         * Sets the LIMIT clause of `stmt`
         *
         * `count` and `offset'`s responsibility are transferred to
         * `stmt` (which means `stmt` is then responsible for freeing them when no longer needed).
         * @param count a #GdaSqlExpr pointer
         * @param offset a #GdaSqlExpr pointer
         */
        select_take_limits(count: SqlExpr, offset: SqlExpr): void;
        /**
         * Sets the ORDER BY clause of `stmt`
         *
         * `order_by'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param order_by a list of #GdaSqlSelectOrder pointer
         */
        select_take_order_by(order_by: SqlSelectOrder[]): void;
        /**
         * Sets the WHERE clause of `stmt`
         *
         * `expr'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param expr a #GdaSqlExpr pointer
         */
        select_take_where_cond(expr: SqlExpr): void;
        /**
         * Creates a string representation of `stmt`.
         * @returns a new string
         */
        serialize(): string;
        trans_set_isol_level(level: TransactionIsolation | null): void;
        /**
         * Sets the model of the transaction
         *
         * `value'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param value a G_TYPE_STRING value
         */
        trans_take_mode(value: GObject.Value | any): void;
        /**
         * Sets the name of the transaction
         *
         * `value'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param value a G_TYPE_STRING value
         */
        trans_take_name(value: GObject.Value | any): void;
        /**
         * Sets `stmt'`s list of expressions
         *
         * `expressions'`s
         * ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param expressions a list of #GdaSqlExpr pointers
         */
        unknown_take_expressions(expressions: SqlExpr[]): void;
        /**
         * Sets the WHERE clause of `stmt`
         *
         * `expr'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param cond a #GdaSqlExpr pointer
         */
        update_take_condition(cond: SqlExpr): void;
        /**
         * Sets the name of the resolution conflict algorithm used by `stmt`. `value'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param value name of the resolution conflict algorithm, as a G_TYPE_STRING #GValue
         */
        update_take_on_conflict(value: GObject.Value | any): void;
        /**
         * Specifies that the field named `fname` will be updated with the expression `expr`.
         *
         * `fname` and `expr'`s responsibility are transferred to
         * `stmt` (which means `stmt` is then responsible for freeing them when no longer needed).
         * @param fname a field name, as a G_TYPE_STRING #GValue
         * @param expr a #GdaSqlExpr pointer
         */
        update_take_set_value(fname: GObject.Value | any, expr: SqlExpr): void;
        /**
         * Sets the name of the table to delete from in `stmt`.
         *
         * `value'`s ownership is transferred to
         * `stmt` (which means `stmt` is then responsible for freeing it when no longer needed).
         * @param value a table name, as a G_TYPE_STRING #GValue
         */
        update_take_table_name(value: GObject.Value | any): void;
    }

    /**
     * Validation against a dictionary
     */
    class SqlStatementCheckValidityData {
        static $gtype: GObject.GType<SqlStatementCheckValidityData>;

        // Fields

        cnc: Connection;
        store: MetaStore;
        mstruct: MetaStruct;

        // Constructors

        _init(...args: any[]): void;
    }

    class SqlStatementCompound {
        static $gtype: GObject.GType<SqlStatementCompound>;

        // Fields

        compound_type: SqlStatementCompoundType;
        stmt_list: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Contents' infos
     */
    class SqlStatementContentsInfo {
        static $gtype: GObject.GType<SqlStatementContentsInfo>;

        // Fields

        type: SqlStatementType;
        name: string;
        check_structure_func: SqlForeachFunc;
        check_validity_func: SqlForeachFunc;

        // Constructors

        _init(...args: any[]): void;
    }

    class SqlStatementDelete {
        static $gtype: GObject.GType<SqlStatementDelete>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The statement is an INSERT statement, any kind of INSERT statement can be represented using this structure
     * (if this is not the case
     * then report a bug).
     * <mediaobject>
     *   <imageobject role="html">
     *     <imagedata fileref="stmt-insert1.png" format="PNG"/>
     *   </imageobject>
     *   <caption>
     *     <para>
     * Example of a #GdaSqlStatement having a #GdaSqlStatementInsert as its contents with 2 lists of values
     * to insert.
     *     </para>
     *   </caption>
     * </mediaobject>
     * <mediaobject>
     *   <imageobject role="html">
     *     <imagedata fileref="stmt-insert2.png" format="PNG"/>
     *   </imageobject>
     *   <caption>
     *     <para>
     * Another example of a #GdaSqlStatement having a #GdaSqlStatementInsert as its contents, using a SELECT
     * to express the values to insert.
     *     </para>
     *   </caption>
     * </mediaobject>
     */
    class SqlStatementInsert {
        static $gtype: GObject.GType<SqlStatementInsert>;

        // Fields

        on_conflict: string;
        fields_list: any[];
        values_list: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    class SqlStatementSelect {
        static $gtype: GObject.GType<SqlStatementSelect>;

        // Fields

        distinct: boolean;
        expr_list: any[];
        group_by: any[];
        order_by: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The statement is a transaction management related statement (BEGIN, ROLLBACK, etc). The #GdaSqlStatementTransaction structure
     * does not hold enough information to reconstruct the complete SQL statement (some information may be missing) - the aim of this
     * structure is to identify a minimum set of information in the transaction statement. Note that the complete SQL which created the
     * statement should be available in the #GdaSqlStatement structure which encapsulates this structure.
     */
    class SqlStatementTransaction {
        static $gtype: GObject.GType<SqlStatementTransaction>;

        // Fields

        isolation_level: TransactionIsolation;
        trans_mode: string;
        trans_name: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Represents any statement which type is not identified (any DDL statement or database specific dialect)
     */
    class SqlStatementUnknown {
        static $gtype: GObject.GType<SqlStatementUnknown>;

        // Fields

        expressions: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    class SqlStatementUpdate {
        static $gtype: GObject.GType<SqlStatementUpdate>;

        // Fields

        on_conflict: string;
        fields_list: any[];
        expr_list: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * This structure represents the name of a table.
     */
    class SqlTable {
        static $gtype: GObject.GType<SqlTable>;

        // Fields

        table_name: string;

        // Constructors

        constructor(parent: SqlAnyPart);
        _init(...args: any[]): void;

        static ['new'](parent: SqlAnyPart): SqlTable;

        // Methods

        /**
         * Creates a new #GdaSqlTable structure initiated with the values stored in `table`.
         * @returns a new #GdaSqlTable structure.
         */
        copy(): SqlTable;
        /**
         * Frees a #GdaSqlTable structure and its members.
         */
        free(): void;
        /**
         * Creates a new string representing a table. You need to free the returned string
         * using g_free();
         * @returns a new string with the name of the field or "null" in case @table is invalid.
         */
        serialize(): string;
        /**
         * Sets the table's name using the string held by `value`. When call, `value` is freed using
         * gda_value_free().
         * @param value a #GValue holding a string to take from
         */
        take_name(value: GObject.Value | any): void;
    }

    type StatementClass = typeof Statement;
    type TableConstraintIface = typeof TableConstraint;
    type TableModelIface = typeof TableModel;
    class Text {
        static $gtype: GObject.GType<Text>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): Text;

        // Static methods

        /**
         * The "encoding" consists in replacing non
         * alphanumeric character with the string "__gdaXX" where XX is the hex. representation
         * of the non alphanumeric char.
         * @param text the text to convert
         */
        static to_alphanum(text: string): string;

        // Methods

        /**
         * Free resources on #GdaText object.
         */
        free(): void;
        get_string(): string;
        /**
         * Set string. The string is duplicated.
         * @param str a string to set from
         */
        set_string(str: string): void;
        /**
         * Takes ownership on a given string, so you don't need to free it.
         * @param str a string to take ownership on
         */
        take_string(str: string): void;
    }

    /**
     * Represents a time information.
     */
    class Time {
        static $gtype: GObject.GType<Time>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): Time;

        static new_from_date_time(dt: GLib.DateTime): Time;

        static new_from_values(hour: number, minute: number, second: number, fraction: number, timezone: number): Time;

        // Methods

        /**
         * Create a copy of #GdaTime
         * @returns a pointer to a new #GdaTime struct
         */
        copy(): Time;
        /**
         * Free resources holded by the #GdaTime instance
         */
        free(): void;
        /**
         * Extract fraction of seconds from the instance of #GdaTime
         * @returns fraction of seconds
         */
        get_fraction(): number;
        /**
         * Get hours from the #GdaTime instance
         */
        get_hour(): number;
        /**
         * Get minutes from the #GdaTime instance
         */
        get_minute(): number;
        /**
         * Get second component from #GdaTime
         */
        get_second(): number;
        /**
         * Returns number of seconds to be added to UTC time.
         */
        get_timezone(): number;
        /**
         * Returns a #GTimeZone in use in this `time`.
         */
        get_tz(): GLib.TimeZone;
        /**
         * Set new value for the second fraction
         * @param fraction new second fraction to set to.
         */
        set_fraction(fraction: number): void;
        /**
         * Set hour component to the #GdaTime instance.
         * @param hour new hours to set to
         */
        set_hour(hour: number): void;
        /**
         * Set minutes to the #GdaTime instance
         * @param minute new minutes to set to
         */
        set_minute(minute: number): void;
        /**
         * Set second component
         * @param second new seconds to set to
         */
        set_second(second: number): void;
        /**
         * Set timezone component for the instance of #GdaTime
         * @param timezone new time zone to set to. See #gda_time_change_timezone
         */
        set_timezone(timezone: number): void;
        /**
         * Creates a string representation of a #GdaTime in local time
         * with the timezone designation.
         * @returns a new string
         */
        to_string(): string;
        /**
         * Creates a string representation of a #GdaTime in local time
         * without timezone designation.
         * @returns a new string
         */
        to_string_local(): string;
        /**
         * Creates a string representation of a #GdaTime in UTC time
         * with time zone indication.
         * @returns a new string
         */
        to_string_utc(): string;
        /**
         * Translate `time'`s to give timezone
         * @param ntz a new #GTimeZone to use
         */
        to_timezone(ntz: GLib.TimeZone): Time;
        /**
         * Change time zone to UTC.
         */
        to_utc(): Time;
        /**
         * A time is always valid, so this method has been deprecated.
         * @returns #TRUE if #GdaTime is valid; %FALSE otherwise.
         */
        valid(): boolean;
    }

    type TransactionStatusClass = typeof TransactionStatus;
    class TransactionStatusEvent {
        static $gtype: GObject.GType<TransactionStatusEvent>;

        // Fields

        trans: TransactionStatus;
        type: TransactionStatusEventType;
        conn_event: ConnectionEvent;

        // Constructors

        _init(...args: any[]): void;
    }

    type TreeClass = typeof Tree;
    type TreeManagerClass = typeof TreeManager;
    type TreeMgrColumnsClass = typeof TreeMgrColumns;
    type TreeMgrLabelClass = typeof TreeMgrLabel;
    type TreeMgrSchemasClass = typeof TreeMgrSchemas;
    type TreeMgrSelectClass = typeof TreeMgrSelect;
    type TreeMgrTablesClass = typeof TreeMgrTables;
    type TreeNodeClass = typeof TreeNode;
    class Worker {
        static $gtype: GObject.GType<Worker>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): Worker;

        // Static methods

        static error_quark(): GLib.Quark;
        /**
         * This function creates a new #GdaWorker, or reuses the one at `location`. Specifically:
         * <orderedlist>
         *   <listitem><para>if *`location` is %NULL, then a new #GdaWorker is created. In this case if `allow_destroy` is %FALSE, then the returned
         *     #GdaWorker's reference count is 2, thus preventing it form ever being destroyed (unless gda_worker_unref() is called somewhere else)</para></listitem>
         *   <listitem><para>if *`location` is not %NULL, the the #GdaWorker it points to is returned, its reference count increased by 1</para></listitem>
         * </orderedlist>
         *
         * When the returned #GdaWorker's reference count reaches 0, then it is destroyed, and *`location` is set to %NULL.
         *
         * In any case, the returned value is the same as *`location`.
         * @param location a place to store and test for existence, not %NULL
         * @param allow_destroy defines if the created @GdaWorker (see case 1 below) will allow its reference to drop to 0 and be destroyed
         */
        static new_unique(location: Worker, allow_destroy: boolean): Worker;

        // Methods

        /**
         * Cancels a job which has not yet been processed. If the job cannot be found, is being processed or has already been processed,
         * then this function returns %FALSE.
         *
         * This function can be called on already cancelled jobs, and simply returns %TRUE in that case.
         * @param job_id the ID of the job, as returned by gda_worker_submit_job()
         * @returns %TRUE if the job was cancelled
         */
        cancel_job(job_id: number): boolean;
        /**
         * Request that the worker thread call `func` with the `data` argument, much like gda_worker_submit_job(),
         * but waits (starting a #GMainLoop) for a maximum of `timeout_ms` miliseconds for `func` to be executed.
         *
         * If this function is called from within `worker'`s worker thread, then this function simply calls `func` with `data` and does not
         * use `context`.
         *
         * The following cases are possible if this function is not called from within `worker'`s worker thread:
         * <itemizedlist>
         *  <listitem><para>the call to `func` took less than `timeout_ms` miliseconds: the return value is %TRUE and
         *    `out_result` contains the result of the `func'`s execution, and `out_job_id` contains %NULL. Note in this
         *    case that `error` may still contain an error code if `func'`s execution produced an error. Also note that in this case
         *    any setting defined by gda_worker_set_callback() is not applied (as the result is immediately returned)</para></listitem>
         *  <listitem><para>The call to `func` takes more then `timeout_ms` miliseconds: the return value is %TRUE and
         *    `out_result` is %NULL and `out_job_id` contains the ID of the job as if it had been submitted using gda_worker_submit_job().
         *    If `out_job_id` is %NULL, and if no setting has been defined using gda_worker_set_callback(), then the job will be discarded
         *    (as if gda_worker_forget_job() had been called).
         *    </para></listitem>
         *  <listitem><para>The call to `func` could not be done (some kind of plumbing error for instance): the returned value is %FALSE
         *    and `out_result` and `out_job_id` are set to %NULL (if they are not %NULL)</para></listitem>
         * </itemizedlist>
         *
         * Notes:
         * <itemizedlist>
         *  <listitem><para>`result_destroy_func` is needed in case `out_result` is %NULL (to avoid memory leaks)</para></listitem>
         *  <listitem><para>passing %NULL for `context` is similar to passing the result of g_main_context_ref_thread_default()</para></listitem>
         * </itemizedlist>
         * @param context a #GMainContext to execute a main loop in (while waiting), or %NULL
         * @param timeout_ms the maximum number of milisecons to wait before returning, or %0 for unlimited wait
         * @param out_result a place to store the result, if any, of @func's execution, or %NULL
         * @param out_job_id a place to store the ID of the job having been submitted, or %NULL
         * @param func the function to call from the worker thread
         * @param data_destroy_func a function to destroy @data, or %NULL
         * @param result_destroy_func a function to destroy the result, if any, of @func's execution, or %NULL
         * @returns %TRUE if no error occurred
         */
        do_job(
            context: GLib.MainContext | null,
            timeout_ms: number,
            out_result: any | null,
            out_job_id: number | null,
            func: WorkerFunc,
            data_destroy_func?: GLib.DestroyNotify | null,
            result_destroy_func?: GLib.DestroyNotify | null,
        ): boolean;
        /**
         * Fetch the value returned by execution the `job_id` job.
         *
         * Warning: if an error occurred during the
         * execution of the requested function within the worker thread, then it will show as `error,` while the return value
         * of this function will be %TRUE.
         *
         * Note: if there is a result, it will be stored in `out_result,` and it's up to the caller to free
         * the result, the #GdaWorker object will not do it (ownership of the result is transfered to the caller).
         * @param job_id the ID of the job, as returned by gda_worker_submit_job()
         * @param out_result a place to store the value returned by the execution of the requested function within the worker thread, or %NULL
         * @returns %TRUE if the jobs has completed
         */
        fetch_job_result(job_id: number, out_result?: any | null): boolean;
        /**
         * Forget all about the job with ID `job_id`. As opposed to gda_worker_cancel_job(), this function can be used to tell
         * `worker` that whatever happens to the specific job, you are not interrested anymore (i.e. that `worker` can
         * do whatever is possible to simple discard everything related to that job).
         * @param job_id the ID of the job, as returned by gda_worker_submit_job()
         */
        forget_job(job_id: number): void;
        /**
         * Get a pointer to `worker'`s inner worker thread
         * @returns the #GThread
         */
        get_worker_thread(): GLib.Thread;
        /**
         * Increases `worker'`s reference count.
         * @returns @worker
         */
        ref(): Worker;
        /**
         * Declare a callback function to be called when a job has been processed. If `callback` is %NULL, then any previously
         * effect of this function is removed. If the same function is called with a different `callback` value, then the previous one
         * is simply replaced.
         *
         * Since this function adds a new source of events to the specified #GMainContext (or the default one if `context` is %NULL),
         *
         * Notes:
         * <itemizedlist>
         *  <listitem><para>before calling this function, `worker` internally gets rid of the job, so the `jib_id` passed
         *   to `callback` does not actually designate a known job ID, and so calling gda_worker_fetch_job_result() for that
         *   job ID will fail</para></listitem>
         *  <listitem><para>the job's result, if any, has to be freed by `callback` (`worker` does not do it)</para></listitem>
         *  <listitem><para>any call to this function will only be honored for the jobs submitted _after_ calling it, the ones
         *   submitted before are not affected</para></listitem>
         *  <listitem><para>passing %NULL for `context` is similar to passing the result of g_main_context_ref_thread_default()</para></listitem>
         * </itemizedlist>
         * @param context a #GMainContext, or %NULL
         * @param callback the function to call when a job submitted from within the calling thread using gda_worker_submit_job() has finished being processed.
         * @returns %TRUE if no error occurred.
         */
        set_callback(context?: GLib.MainContext | null, callback?: WorkerCallback | null): boolean;
        /**
         * Request that the worker thread call `func` with the `data` argument.
         *
         * Notes:
         * <itemizedlist>
         *   <listitem><para>if `data_destroy_func` is not %NULL, then it will be called to destroy `data` when the job is removed,
         *    which can occur within the context of the worker thread, or within the context of any thread using `worker`.</para></listitem>
         *   <listitem><para>if `result_destroy_func` is not %NULL, then it will be called to destroy the result produced by `func`.
         *    Similarly to `data_destroy_func,` if it is not %NULL (and if there is a non %NULL result), then that function can be
         *    called in the context of any thread.</para></listitem>
         *   <listitem><para>the error here can only report failures while executing gda_worker_submit_job(), not any error which may occur
         *    while executing `func` from the worker thread.</para></listitem>
         *   <listitem><para>when this function returns, the job may already have been completed, so you should not assume that the job
         *    is in any specific state.</para></listitem>
         *  <listitem><para>passing %NULL for `callback_context` is similar to passing the result of g_main_context_ref_thread_default()</para></listitem>
         * </itemizedlist>
         * @param callback_context a #GMainContext, or %NULL (ignored if no setting has been defined with gda_worker_set_callback())
         * @param func the function to call from the worker thread
         * @param data_destroy_func a function to destroy @data, or %NULL
         * @param result_destroy_func a function to destroy the result, if any, of the execution of @func, or %NULL
         * @returns a job ID, or %0 if an error occurred
         */
        submit_job(
            callback_context: GLib.MainContext | null,
            func: WorkerFunc,
            data_destroy_func?: GLib.DestroyNotify | null,
            result_destroy_func?: GLib.DestroyNotify | null,
        ): number;
        /**
         * Tells if the thread from which this function is called is `worker'`s worker thread.
         * @returns %TRUE if this function is called is @worker's worker thread
         */
        thread_is_worker(): boolean;
        /**
         * Decreases `worker'`s reference count. When reference count reaches %0, then the
         * object is destroyed, note that in this case this function only returns when the
         * worker thread actually has terminated, which can take some time if it's busy.
         *
         * If `worker` is %NULL, then nothing happens.
         */
        unref(): void;
        /**
         * Request that the worker thread call `func` with the `data` argument, much like gda_worker_submit_job(),
         * but waits (blocks) until `func` has been executed.
         *
         * Note: it's up to the caller to free the result, the #GdaWorker object will not do it (ownership of the result is
         * transfered to the caller).
         * @param func the function to call from the worker thread
         * @param data_destroy_func a function to destroy @data, or %NULL
         * @returns the result of @func's execution
         */
        wait_job(func: WorkerFunc, data_destroy_func?: GLib.DestroyNotify | null): any | null;
    }

    type WritableTableModelIface = typeof WritableTableModel;
    type XaTransactionClass = typeof XaTransaction;
    class XaTransactionId {
        static $gtype: GObject.GType<XaTransactionId>;

        // Fields

        format: number;
        gtrid_length: number;
        bqual_length: number;
        data: number[];

        // Constructors

        constructor(
            properties?: Partial<{
                format: number;
                gtrid_length: number;
                bqual_length: number;
                data: number[];
            }>,
        );
        _init(...args: any[]): void;

        // Methods

        /**
         * Creates a string representation of `xid,` in the format &lt;gtrid&gt;,&lt;bqual&gt;,&lt;formatID&gt; the
         * &lt;gtrid&gt; and &lt;bqual&gt; strings contain alphanumeric characters, and non alphanumeric characters
         * are converted to "%ab" where ab is the hexadecimal representation of the character.
         * @returns a new string representation of @xid
         */
        to_string(): string;
    }

    namespace AfectedRows {
        /**
         * Interface for implementing AfectedRows.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_number(): number;
        }

        // Constructor properties interface

        interface ConstructorProps extends Result.ConstructorProps {
            number: number;
        }
    }

    export interface AfectedRowsNamespace {
        $gtype: GObject.GType<AfectedRows>;
        prototype: AfectedRows;
    }
    interface AfectedRows extends Result, AfectedRows.Interface {
        // Properties

        get number(): number;

        // Methods

        get_number(): number;
    }

    export const AfectedRows: AfectedRowsNamespace & {
        new (): AfectedRows; // This allows `obj instanceof AfectedRows`
    };

    namespace ColumnModel {
        /**
         * Interface for implementing ColumnModel.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_attributes(): ColumnAttributes;
            vfunc_get_data_type(): GObject.GType;
            vfunc_get_index(): number;
            vfunc_get_name(): string;
            vfunc_get_value(): unknown;
            vfunc_set_attributes(value: ColumnAttributes): void;
            vfunc_set_foreign_key(value: ForeignKey): void;
            vfunc_set_value(value: GObject.Value | any): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            attributes: ColumnAttributes;
            data_type: GObject.GType;
            dataType: GObject.GType;
            foreign_key: ForeignKey;
            foreignKey: ForeignKey;
            index: number;
            name: string;
            value: GObject.Value;
        }
    }

    export interface ColumnModelNamespace {
        $gtype: GObject.GType<ColumnModel>;
        prototype: ColumnModel;
    }
    interface ColumnModel extends GObject.Object, ColumnModel.Interface {
        // Properties

        get attributes(): ColumnAttributes;
        set attributes(val: ColumnAttributes);
        get data_type(): GObject.GType;
        get dataType(): GObject.GType;
        get foreign_key(): ForeignKey;
        set foreign_key(val: ForeignKey);
        get foreignKey(): ForeignKey;
        set foreignKey(val: ForeignKey);
        get index(): number;
        get name(): string;
        get value(): GObject.Value;
        set value(val: GObject.Value);

        // Methods

        get_attributes(): ColumnAttributes;
        get_data_type(): GObject.GType;
        get_index(): number;
        get_name(): string;
        get_value(): unknown;
        set_attributes(value: ColumnAttributes | null): void;
        set_foreign_key(value: ForeignKey): void;
        set_value(value: GObject.Value | any): void;
    }

    export const ColumnModel: ColumnModelNamespace & {
        new (): ColumnModel; // This allows `obj instanceof ColumnModel`
    };

    namespace ConnectionModel {
        /**
         * Interface for implementing ConnectionModel.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_close(): void;
            vfunc_close_no_warning(): void;
            vfunc_get_is_opened(): boolean;
            vfunc_open(): boolean;
            vfunc_set_cnc_params(value: ConnectionModelParams): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            cnc_params: ConnectionModelParams;
            cncParams: ConnectionModelParams;
            is_opened: boolean;
            isOpened: boolean;
        }
    }

    export interface ConnectionModelNamespace {
        $gtype: GObject.GType<ConnectionModel>;
        prototype: ConnectionModel;
    }
    interface ConnectionModel extends GObject.Object, ConnectionModel.Interface {
        // Properties

        get cnc_params(): ConnectionModelParams;
        set cnc_params(val: ConnectionModelParams);
        get cncParams(): ConnectionModelParams;
        set cncParams(val: ConnectionModelParams);
        get is_opened(): boolean;
        get isOpened(): boolean;

        // Methods

        close(): void;
        close_no_warning(): void;
        get_is_opened(): boolean;
        open(): boolean;
        set_cnc_params(value: ConnectionModelParams): void;
    }

    export const ConnectionModel: ConnectionModelNamespace & {
        new (): ConnectionModel; // This allows `obj instanceof ConnectionModel`
    };

    namespace CreateDatabaseBuilder {
        /**
         * Interface for implementing CreateDatabaseBuilder.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface extends QueryBuilder.Interface {
            // Virtual methods

            vfunc_get_database_name(): string;
            vfunc_set_database_name(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends QueryBuilder.ConstructorProps {
            database_name: string;
            databaseName: string;
        }
    }

    export interface CreateDatabaseBuilderNamespace {
        $gtype: GObject.GType<CreateDatabaseBuilder>;
        prototype: CreateDatabaseBuilder;
    }
    interface CreateDatabaseBuilder extends QueryBuilder, CreateDatabaseBuilder.Interface {
        // Properties

        get database_name(): string;
        set database_name(val: string);
        get databaseName(): string;
        set databaseName(val: string);

        // Methods

        get_database_name(): string;
        set_database_name(value: string): void;
    }

    export const CreateDatabaseBuilder: CreateDatabaseBuilderNamespace & {
        new (): CreateDatabaseBuilder; // This allows `obj instanceof CreateDatabaseBuilder`
    };

    namespace CreateTableBuilder {
        /**
         * Interface for implementing CreateTableBuilder.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface extends QueryBuilder.Interface {
            // Virtual methods

            vfunc_get_table_name(): string;
            vfunc_set_columns(value: Gio.ListModel): void;
            vfunc_set_contraints(value: Gio.ListModel): void;
            vfunc_set_table_name(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends QueryBuilder.ConstructorProps {
            columns: Gio.ListModel;
            contraints: Gio.ListModel;
            table_name: string;
            tableName: string;
        }
    }

    export interface CreateTableBuilderNamespace {
        $gtype: GObject.GType<CreateTableBuilder>;
        prototype: CreateTableBuilder;
    }
    interface CreateTableBuilder extends QueryBuilder, CreateTableBuilder.Interface {
        // Properties

        get columns(): Gio.ListModel;
        set columns(val: Gio.ListModel);
        get contraints(): Gio.ListModel;
        set contraints(val: Gio.ListModel);
        get table_name(): string;
        set table_name(val: string);
        get tableName(): string;
        set tableName(val: string);

        // Methods

        get_table_name(): string;
        set_columns(value: Gio.ListModel): void;
        set_contraints(value: Gio.ListModel): void;
        set_table_name(value: string): void;
    }

    export const CreateTableBuilder: CreateTableBuilderNamespace & {
        new (): CreateTableBuilder; // This allows `obj instanceof CreateTableBuilder`
    };

    namespace DataHandler {
        /**
         * Interface for implementing DataHandler.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            /**
             * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
             * @param type a #GType
             */
            vfunc_accepts_g_type(type: GObject.GType): boolean;
            /**
             * Get a short description of the GdaDataHandler
             */
            vfunc_get_descr(): string;
            /**
             * Creates a new GValue which holds a sane initial value to be used if no value is specifically
             * provided. For example for a simple string, this would return a new value containing the "" string.
             * @param type a #GType
             */
            vfunc_get_sane_init_value(type: GObject.GType): GObject.Value | null;
            /**
             * Creates a new string which is an SQL representation of the given value, the returned string
             * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
             * the returned string will be correctly quoted. Note however that it is a better practice
             * to use variables in statements instead of value literals, see
             * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
             *
             * If the value is NULL or is of type GDA_TYPE_NULL,
             * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
             * @param value the value to be converted to a string, or %NULL
             */
            vfunc_get_sql_from_value(value?: GObject.Value | null): string;
            /**
             * Creates a new string which is a "user friendly" representation of the given value
             * (in the user's locale, specially for the dates). If the value is
             * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
             *
             * Note: the returned value will be in the current locale representation.
             * @param value the value to be converted to a string, or %NULL
             */
            vfunc_get_str_from_value(value?: GObject.Value | null): string;
            /**
             * Creates a new GValue which represents the SQL value given as argument. This is
             * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
             * is used to determine the real data type requested for the returned value.
             *
             * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
             * if the `sql` string does not correspond to a valid SQL string for the requested type, then
             * the %NULL is returned.
             * @param sql an SQL string, or %NULL
             * @param type a GType
             */
            vfunc_get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
            /**
             * Creates a new GValue which represents the `str` value given as argument. This is
             * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
             * is used to determine the real data type requested for the returned value.
             *
             * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
             * if the `str` string does not correspond to a valid string for the requested type, then
             * %NULL is returned.
             *
             * Note: the `str` string must be in the current locale representation
             * @param str a string or %NULL
             * @param type a GType
             */
            vfunc_get_value_from_str(str: string | null, type: GObject.GType): unknown;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DataHandlerNamespace {
        $gtype: GObject.GType<DataHandler>;
        prototype: DataHandler;

        /**
         * Obtain a pointer to a #GdaDataHandler which can manage #GValue values of type `for_type`. The returned
         * data handler will be adapted to use the current locale information (for example dates will be formatted
         * taking into account the locale).
         *
         * The returned pointer is %NULL if there is no default data handler available for the `for_type` data type
         * @param for_type a #GType type
         */
        get_default(for_type: GObject.GType): DataHandler;
    }
    interface DataHandler extends GObject.Object, DataHandler.Interface {
        // Methods

        /**
         * Checks wether the GdaDataHandler is able to handle the gda type given as argument.
         * @param type a #GType
         * @returns %TRUE if the gda type can be handled
         */
        accepts_g_type(type: GObject.GType): boolean;
        /**
         * Get a short description of the GdaDataHandler
         * @returns the description
         */
        get_descr(): string;
        /**
         * Creates a new GValue which holds a sane initial value to be used if no value is specifically
         * provided. For example for a simple string, this would return a new value containing the "" string.
         * @param type a #GType
         * @returns the new #GValue, or %NULL if no such value can be created.
         */
        get_sane_init_value(type: GObject.GType): GObject.Value | null;
        /**
         * Creates a new string which is an SQL representation of the given value, the returned string
         * can be used directly in an SQL statement. For example if `value` is a G_TYPE_STRING, then
         * the returned string will be correctly quoted. Note however that it is a better practice
         * to use variables in statements instead of value literals, see
         * the <link linkend="GdaSqlParser.description">GdaSqlParser</link> for more information.
         *
         * If the value is NULL or is of type GDA_TYPE_NULL,
         * or is a G_TYPE_STRING and g_value_get_string() returns %NULL, the returned string is "NULL".
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_sql_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new string which is a "user friendly" representation of the given value
         * (in the user's locale, specially for the dates). If the value is
         * NULL or is of type GDA_TYPE_NULL, the returned string is a copy of "" (empty string).
         *
         * Note: the returned value will be in the current locale representation.
         * @param value the value to be converted to a string, or %NULL
         * @returns the new string, or %NULL if an error occurred
         */
        get_str_from_value(value?: GObject.Value | null): string;
        /**
         * Creates a new GValue which represents the SQL value given as argument. This is
         * the opposite of the function gda_data_handler_get_sql_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `sql` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `sql` string does not correspond to a valid SQL string for the requested type, then
         * the %NULL is returned.
         * @param sql an SQL string, or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_sql(sql: string | null, type: GObject.GType): unknown;
        /**
         * Creates a new GValue which represents the `str` value given as argument. This is
         * the opposite of the function gda_data_handler_get_str_from_value(). The type argument
         * is used to determine the real data type requested for the returned value.
         *
         * If the `str` string is %NULL, then the returned GValue is of type GDA_TYPE_NULL;
         * if the `str` string does not correspond to a valid string for the requested type, then
         * %NULL is returned.
         *
         * Note: the `str` string must be in the current locale representation
         * @param str a string or %NULL
         * @param type a GType
         * @returns the new #GValue or %NULL on error
         */
        get_value_from_str(str: string | null, type: GObject.GType): unknown;
    }

    export const DataHandler: DataHandlerNamespace & {
        new (): DataHandler; // This allows `obj instanceof DataHandler`
    };

    namespace DataModel {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DataModelNamespace {
        $gtype: GObject.GType<DataModel>;
        prototype: DataModel;

        error_quark(): GLib.Quark;
    }
    interface DataModel extends GObject.Object {
        // Methods

        /**
         * Adds the data from an XML node to the given data model (see the DTD for that node
         * in the $prefix/share/libgda/dtd/libgda-array.dtd file).
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param node an XML node representing a &lt;gda_array_data&gt; XML node.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        add_data_from_xml_node(node: libxml2.NodePtr): boolean;
        /**
         * Appends a row to the data model (the new row will possibly have NULL values for all columns,
         * or some other values depending on the data model implementation)
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_row(): number;
        /**
         * Appends a row to the given data model. If any value in `values` is actually %NULL, then
         * it is considered as a default value. If `values` is %NULL then all values are set to their default value.
         *
         * Upon errors -1 will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param values #GList of #GValue* representing the row to add.  The          length must match model's column count.  These #GValue     are value-copied (the user is still responsible for freeing them).
         * @returns the number of the added row, or -1 if an error occurred
         */
        append_values(values?: GObject.Value[] | null): number;
        /**
         * Makes a copy of `src` into a new #GdaDataModelArray object
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model(): DataModelArray | null;
        /**
         * Like gda_data_model_array_copy_model(), makes a copy of `src,` but copies only some
         * columns.
         * @param cols array of @src's columns to copy into the new array, not %NULL
         * @returns a new data model, or %NULL if an error occurred
         */
        array_copy_model_ext(cols: number[]): DataModelArray | null;
        /**
         * Creates a new iterator object #GdaDataModelIter object which can be used to iterate through
         * rows in `model`. The new #GdaDataModelIter does not hold any reference to `model` (ie. if `model`
         * is destroyed at some point, the new iterator will become useless but in any case it will not prevent
         * the data model from being destroyed).
         *
         * Depending on the data model's implementation, a new #GdaDataModelIter object may be created,
         * or a reference to an already existing #GdaDataModelIter may be returned. For example if `model` only
         * supports being accessed using a forward moving cursor (say a the result of a SELECT executed by SQLite
         * with a cursor access mode specified), then this method will always return the same iterator.
         *
         * If a new #GdaDataModelIter is created, then the row it represents is undefined.
         *
         * For models which can be accessed
         * randomly, any row can be set using gda_data_model_iter_move_to_row(),
         * and for models which are accessible sequentially only then use
         * gda_data_model_iter_move_next() (and gda_data_model_iter_move_prev() if
         * supported).
         *
         * Note: for the #GdaDataProxy data model (which proxies any #GdaDataModel for modifications and
         * has twice the number of columns of the proxied data model), this method will create an iterator
         * in which only the columns of the proxied data model appear. If you need to have a #GdaDataModelIter
         * in which all the proxy's columns appear, create it using:
         * <programlisting><![CDATA[iter = g_object_new (GDA_TYPE_DATA_MODEL_ITER, "data-model", proxy, NULL);]]></programlisting>
         * @returns a #GdaDataModelIter object, or %NULL if an error occurred
         */
        create_iter(): DataModelIter;
        /**
         * Queries the underlying data model implementation for a description
         * of a given column. That description is returned in the form of
         * a #GdaColumn structure, which contains all the information
         * about the given column in the data model.
         *
         * WARNING: the returned #GdaColumn object belongs to the `model` model and
         * and should not be destroyed; any modification will affect the whole data model.
         * @param col column number.
         * @returns the description of the column.
         */
        describe_column(col: number): Column | null;
        /**
         * Dumps a textual representation of the `model` to the `to_stream` stream
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ATTRIBUTES: if set, also dump the data model's columns' types and value's attributes</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @param to_stream where to dump the data model
         */
        dump(to_stream?: any | null): void;
        /**
         * Dumps a textual representation of the `model` into a new string. The main differences with gda_data_model_export_to_string() are that
         * the formatting options are passed using environment variables, and that the data is dumped regardless of the user locale (e.g. dates
         * are not formatted according to the locale).
         *
         * The following environment variables can affect the resulting output:
         * <itemizedlist>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_ROW_NUMBERS: if set, the first column of the output will contain row numbers</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TITLE: if set, also dump the data model's title</para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_NULL_AS_EMPTY: if set, replace the 'NULL' string with an empty string for NULL values </para></listitem>
         *   <listitem><para>GDA_DATA_MODEL_DUMP_TRUNCATE: if set to a numeric value, truncates the output to the width specified by the value. If the value is -1 then the actual terminal size (if it can be determined) is used</para></listitem>
         * </itemizedlist>
         * @returns a new string.
         */
        dump_as_string(): string;
        /**
         * Exports data contained in `model` to the `file` file; the format is specified using the `format` argument. Note that
         * the date format used is the one used by the connection from which the data model has been made (as the result of a
         * SELECT statement), or, for other kinds of data models, the default format (refer to gda_data_handler_get_default()) unless
         * the "cnc" property has been set and points to a #GdaConnection to use that connection's date format.
         *
         * Specifically, the parameters in the `options` list can be:
         * <itemizedlist>
         *   <listitem><para>"SEPARATOR": a string value of which the first character is used as a separator in case of CSV export
         *             </para></listitem>
         *   <listitem><para>"QUOTE": a string value of which the first character is used as a quote character in case of CSV export. The
         *             default if not specified is the double quote character</para></listitem>
         *   <listitem><para>"FIELD_QUOTE": a boolean value which can be set to FALSE if no quote around the individual fields
         *             is requeted, in case of CSV export</para></listitem>
         *   <listitem><para>"NAMES_ON_FIRST_LINE": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will add a first line with the name each exported field (note that "FIELDS_NAME" is also accepted as a synonym)</para></listitem>
         *   <listitem><para>"NAME": a string value used to name the exported data if the export format is XML or %GDA_DATA_MODEL_IO_TEXT_TABLE</para></listitem>
         *   <listitem><para>"OVERWRITE": a boolean value which tells if the file must be over-written if it already exists.</para></listitem>
         *   <listitem><para>"NULL_AS_EMPTY": a boolean value which, if set to %TRUE and in case of a CSV or %GDA_DATA_MODEL_IO_TEXT_TABLE export, will render and NULL value as the empty string (instead of the 'NULL' string)</para></listitem>
         *   <listitem><para>"INVALID_AS_NULL": a boolean value which, if set to %TRUE, considers any invalid data (for example for the date related values) as NULL</para></listitem>
         *   <listitem><para>"COLUMN_SEPARATORS": a boolean value which, if set to %TRUE, adds a separators lines between each column, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"SEPARATOR_LINE": a boolean value which, if set to %TRUE, adds an horizontal line between column titles and values, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"ROW_NUMBERS": a boolean value which, if set to %TRUE, prepends a column with row numbers, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         *   <listitem><para>"MAX_WIDTH": an integer value which, if greater than 0, makes all the lines truncated to have at most that number of characters, if the export format is %GDA_DATA_MODEL_IO_TEXT_TABLE
         *             </para></listitem>
         * </itemizedlist>
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * Upon errors %FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param format the format in which to export data
         * @param file the filename to export to
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        export_to_file(
            format: DataModelIOFormat | null,
            file: string,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): boolean;
        /**
         * Exports data contained in `model` to a string; the format is specified using the `format` argument, see the
         * gda_data_model_export_to_file() documentation for more information about the `options` argument (except for the
         * "OVERWRITE" option).
         *
         * Warning: this function uses a #GdaDataModelIter iterator, and if `model` does not offer a random access
         * (check using gda_data_model_get_access_flags()), the iterator will be the same as normally used
         * to access data in `model` previously to calling this method, and this iterator will be moved (point to
         * another row).
         *
         * See also gda_data_model_dump_as_string();
         * @param format the format in which to export data
         * @param cols an array containing which columns of @model will be exported, or %NULL for all columns
         * @param rows an array containing which rows of @model will be exported, or %NULL for all rows
         * @param options list of options for the export
         * @returns a new string, use g_free() when no longer needed
         */
        export_to_string(
            format: DataModelIOFormat | null,
            cols: number[] | null,
            rows: number[] | null,
            options: Set,
        ): string;
        /**
         * Disables notifications of changes on the given data model. To
         * re-enable notifications again, you should call the
         * #gda_data_model_thaw function.
         */
        freeze(): void;
        /**
         * Get the attributes of `model` such as how to access the data it contains if it's modifiable, etc.
         * @returns an ORed value of #GdaDataModelAccessFlags flags
         */
        get_access_flags(): DataModelAccessFlags;
        /**
         * Get the attributes of the value stored at (row, col) in `model,` which
         * is an ORed value of #GdaValueAttribute flags. As a special case, if
         * `row` is -1, then the attributes returned correspond to a "would be" value
         * if a row was added to `model`.
         * @param col a valid column number
         * @param row a valid row number, or -1
         * @returns the attributes as an ORed value of #GdaValueAttribute
         */
        get_attributes_at(col: number, row: number): ValueAttribute;
        /**
         * Get the index of the first column named `name` in `model`.
         * @param name a column name
         * @returns the column index, or -1 if no column named @name was found
         */
        get_column_index(name: string): number;
        get_column_name(col: number): string;
        get_column_title(col: number): string;
        /**
         * Get the global data model exception(s) that occurred when using `model`.
         * This is useful for example for the LDAP related
         * data models where some rows may be missing because the LDAP search has reached a limit
         * imposed by the LDAP server.
         * @returns a pointer to a %NULL terminated array of #GError, or %NULL.
         */
        get_exceptions(): GLib.Error[];
        get_n_columns(): number;
        get_n_rows(): number;
        /**
         * Returns the status of notifications changes on the given data model.
         */
        get_notify(): boolean;
        /**
         * Returns the first row where all the values in `values` at the columns identified at
         * `cols_index` match. If the row can't be identified, then returns -1;
         *
         * NOTE: the `cols_index` array MUST contain a column index for each value in `values`
         * @param values a list of #GValue values (no %NULL is allowed)
         * @param cols_index an array of #gint containing the column number to match each value of @values
         * @returns the requested row number, of -1 if not found
         */
        get_row_from_values(values: (GObject.Value | any)[], cols_index: number[]): number;
        /**
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This method is similar to gda_data_model_get_value_at(), except that it also allows one to specify the expected
         * #GType of the value to get: if the data model returned a #GValue of a type different than the expected one, then
         * this method returns %NULL and an error code.
         *
         * Note: the same limitations and usage instructions apply as for gda_data_model_get_value_at().
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @param expected_type the expected data type of the returned value
         * @param nullok if TRUE, then NULL values (value of type %GDA_TYPE_NULL) will not generate any error
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, wrong data type, etc).
         */
        get_typed_value_at(
            col: number,
            row: number,
            expected_type: GObject.GType,
            nullok: boolean,
        ): GObject.Value | null;
        /**
         * Retrieves the data stored in the given position (identified by
         * the `col` and `row` parameters) on a data model.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         *
         * This is the main function for accessing data in a model which allows random access to its data.
         * To access data in a data model using a cursor, use a #GdaDataModelIter object, obtained using
         * gda_data_model_create_iter().
         *
         * Note1: the returned #GValue must not be modified directly (unexpected behaviours may
         * occur if you do so).
         *
         * Note2: the returned value may become invalid as soon as any Libgda part is executed again,
         * which means if you want to keep the value, a copy must be made, however it will remain valid
         * as long as the only Libgda usage is calling gda_data_model_get_value_at() for different values
         * of the same row.
         *
         * If you want to modify a value stored in a #GdaDataModel, use the gda_data_model_set_value_at() or
         * gda_data_model_set_values() methods.
         *
         * Upon errors %NULL will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col a valid column number.
         * @param row a valid row number.
         * @returns a #GValue containing the value stored in the given position, or %NULL on error (out-of-bound position, etc).
         */
        get_value_at(col: number, row: number): GObject.Value | null;
        /**
         * Imports data contained in the `file` file into `model;` the format is detected.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param file the filename to import from
         * @param cols_trans a #GHashTable for columns translating, or %NULL, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred
         */
        import_from_file(file: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Copy the contents of the `from` data model to the `to` data model. The copy stops as soon as an error
         * orrurs.
         *
         * The `cols_trans` is a hash table for which keys are `to` columns numbers and the values are
         * the corresponding column numbers in the `from` data model. To set the values of a column in `to` to NULL,
         * create an entry in the hash table with a negative value. For example:
         * <programlisting><![CDATA[GHashTable *hash;
         * gint *ptr;
         * hash = g_hash_table_new_full (g_int_hash, g_int_equal, g_free, NULL);
         * ptr = g_new (gint, 1);
         * *ptr = 2;
         * g_hash_table_insert (hash, ptr, GINT_TO_POINTER (3));
         * gda_data_model_import_from_model (...);
         * g_hash_table_free (hash);
         * ]]></programlisting>
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param from the source #GdaDataModel
         * @param overwrite TRUE if @to is completely overwritten by @from's data, and FALSE if @from's data is appended to @to
         * @param cols_trans a #GHashTable for columns translating, or %NULL
         * @returns TRUE if no error occurred.
         */
        import_from_model(
            from: DataModel,
            overwrite: boolean,
            cols_trans?: GLib.HashTable<number, number> | null,
        ): boolean;
        /**
         * Loads the data from `string` into `model`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param string the string to import data from
         * @param cols_trans a hash table containing which columns of @model will be imported, or %NULL for all columns, see gda_data_model_import_from_model()
         * @param options list of options for the export
         * @returns TRUE if no error occurred.
         */
        import_from_string(string: string, cols_trans: GLib.HashTable<number, number> | null, options: Set): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_next_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_prev_default(iter: DataModelIter): boolean;
        /**
         * Method reserved to #GdaDataModelIter implementations, should not be called directly.
         * @param iter a #GdaDataModelIter iterating in @model
         * @param row the requested row
         * @returns %TRUE if @iter was moved correctly.
         */
        iter_move_to_row_default(iter: DataModelIter, row: number): boolean;
        /**
         * Removes a row from the data model.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row the row number to be removed.
         * @returns %TRUE if successful, %FALSE otherwise.
         */
        remove_row(row: number): boolean;
        /**
         * Emits the 'reset' and 'changed' signal on `model`.
         */
        reset(): void;
        /**
         * Emits the 'row_inserted' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been inserted.
         * @param row row number.
         */
        row_inserted(row: number): void;
        /**
         * Emits the 'row_removed' and 'changed' signal on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been removed
         * @param row row number.
         */
        row_removed(row: number): void;
        /**
         * Emits the 'row_updated' and 'changed' signals on `model`.
         *
         * This method should only be used by #GdaDataModel implementations to
         * signal that a row has been updated.
         * @param row row number.
         */
        row_updated(row: number): void;
        /**
         * Sends a hint to the data model. The hint may or may not be handled by the data
         * model, depending on its implementation
         * @param hint a hint to send to the model
         * @param hint_value an optional value to specify the hint, or %NULL
         */
        send_hint(hint: DataModelHint | null, hint_value?: GObject.Value | null): void;
        /**
         * Sets the `name` of the given `col` in `model,` and if its title is not set, also sets the
         * title to `name`.
         * @param col column number
         * @param name name for the given column.
         */
        set_column_name(col: number, name: string): void;
        /**
         * Sets the `title` of the given `col` in `model`.
         * @param col column number
         * @param title title for the given column.
         */
        set_column_title(col: number, title: string): void;
        /**
         * Modifies a value in `model,` at (`col,` `row)`.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param col column number.
         * @param row row number.
         * @param value a #GValue (not %NULL)
         * @returns TRUE if the value in the data model has been updated and no error occurred
         */
        set_value_at(col: number, row: number, value: GObject.Value | any): boolean;
        /**
         * In a similar way to gda_data_model_set_value_at(), this method modifies a data model's contents
         * by setting several values at once.
         *
         * If any value in `values` is actually %NULL, then the value in the corresponding column is left
         * unchanged.
         *
         * Upon errors FALSE will be returned and `error` will be assigned a
         * #GError from the #GDA_DATA_MODEL_ERROR domain.
         * @param row row number.
         * @param values a list of #GValue (or %NULL), one for at most the number of columns of @model
         * @returns %TRUE if the value in the data model has been updated and no error occurred
         */
        set_values(row: number, values?: GObject.Value[] | null): boolean;
        /**
         * Re-enables notifications of changes on the given data model.
         */
        thaw(): void;
    }

    export const DataModel: DataModelNamespace & {
        new (): DataModel; // This allows `obj instanceof DataModel`
    };

    namespace DbBuildable {
        /**
         * Interface for implementing DbBuildable.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            /**
             * This method parse XML node and populate `self` object.
             * @param node a node to parse
             */
            vfunc_parse_node(node: libxml2.NodePtr): boolean;
            /**
             * Write content from the `self` to the `node`
             * @param node a node to write data in
             */
            vfunc_write_node(node: libxml2.NodePtr): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DbBuildableNamespace {
        $gtype: GObject.GType<DbBuildable>;
        prototype: DbBuildable;
    }
    interface DbBuildable extends GObject.Object, DbBuildable.Interface {
        // Methods

        /**
         * This method parse XML node and populate `self` object.
         * @param node a node to parse
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        parse_node(node: libxml2.NodePtr): boolean;
        /**
         * Write content from the `self` to the `node`
         * @param node a node to write data in
         * @returns %TRUE on success, %FALSE if an error occurred
         */
        write_node(node: libxml2.NodePtr): boolean;
    }

    export const DbBuildable: DbBuildableNamespace & {
        new (): DbBuildable; // This allows `obj instanceof DbBuildable`
    };

    namespace DdlModifiable {
        /**
         * Interface for implementing DdlModifiable.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            /**
             * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
             * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
             * implements ADD COLUMN operation as part of ALTER TABLE operation.
             * @param cnc Opened connection
             */
            vfunc_create(cnc: Connection): boolean;
            /**
             * Execute corresponding DROP operation
             * @param cnc Opened connection
             */
            vfunc_drop(cnc: Connection): boolean;
            /**
             * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
             * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
             * @param cnc Opened connection
             */
            vfunc_rename(cnc: Connection): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DdlModifiableNamespace {
        $gtype: GObject.GType<DdlModifiable>;
        prototype: DdlModifiable;

        error_quark(): GLib.Quark;
    }
    interface DdlModifiable extends GObject.Object, DdlModifiable.Interface {
        // Methods

        /**
         * This method executes CREATE operation. That is, #GdaDbTable, #GdaDbIndex, and #GdaDbView
         * implement corresponding CREATE TABLE | CREATE INDEX | CREATE VIEW operations. #GdaDbColumn
         * implements ADD COLUMN operation as part of ALTER TABLE operation.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        create(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding DROP operation
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        drop(cnc: Connection, user_data?: any | null): boolean;
        /**
         * Execute corresponding RENAME operation. A lot of RENAME operations are not implemented by
         * SQLite3 provider. In this case, the SQL object must be deleted and a new one should be created.
         * @param cnc Opened connection
         * @param user_data Additional information provided by the user
         */
        rename(cnc: Connection, user_data?: any | null): boolean;
    }

    export const DdlModifiable: DdlModifiableNamespace & {
        new (): DdlModifiable; // This allows `obj instanceof DdlModifiable`
    };

    namespace DropDatabaseBuilder {
        /**
         * Interface for implementing DropDatabaseBuilder.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface extends QueryBuilder.Interface {
            // Virtual methods

            vfunc_get_database_name(): string;
            vfunc_set_database_name(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends QueryBuilder.ConstructorProps {
            database_name: string;
            databaseName: string;
        }
    }

    export interface DropDatabaseBuilderNamespace {
        $gtype: GObject.GType<DropDatabaseBuilder>;
        prototype: DropDatabaseBuilder;
    }
    interface DropDatabaseBuilder extends QueryBuilder, DropDatabaseBuilder.Interface {
        // Properties

        get database_name(): string;
        set database_name(val: string);
        get databaseName(): string;
        set databaseName(val: string);

        // Methods

        get_database_name(): string;
        set_database_name(value: string): void;
    }

    export const DropDatabaseBuilder: DropDatabaseBuilderNamespace & {
        new (): DropDatabaseBuilder; // This allows `obj instanceof DropDatabaseBuilder`
    };

    namespace DropTableBuilder {
        /**
         * Interface for implementing DropTableBuilder.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface extends QueryBuilder.Interface {
            // Virtual methods

            vfunc_get_cascade(): boolean;
            vfunc_get_table_name(): string;
            vfunc_set_cascade(value: boolean): void;
            vfunc_set_table_name(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends QueryBuilder.ConstructorProps {
            cascade: boolean;
            table_name: string;
            tableName: string;
        }
    }

    export interface DropTableBuilderNamespace {
        $gtype: GObject.GType<DropTableBuilder>;
        prototype: DropTableBuilder;
    }
    interface DropTableBuilder extends QueryBuilder, DropTableBuilder.Interface {
        // Properties

        get cascade(): boolean;
        set cascade(val: boolean);
        get table_name(): string;
        set table_name(val: string);
        get tableName(): string;
        set tableName(val: string);

        // Methods

        get_cascade(): boolean;
        get_table_name(): string;
        set_cascade(value: boolean): void;
        set_table_name(value: string): void;
    }

    export const DropTableBuilder: DropTableBuilderNamespace & {
        new (): DropTableBuilder; // This allows `obj instanceof DropTableBuilder`
    };

    namespace ForeignKey {
        /**
         * Interface for implementing ForeignKey.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_delete_rule(): ForeignKeyRule;
            vfunc_get_match(): ForeignKeyMatch;
            vfunc_get_name(): string;
            vfunc_get_refname(): string;
            vfunc_get_update_rule(): ForeignKeyRule;
            vfunc_set_delete_rule(value: ForeignKeyRule): void;
            vfunc_set_match(value: ForeignKeyMatch): void;
            vfunc_set_name(value: string): void;
            vfunc_set_refcol(value: Gio.ListModel): void;
            vfunc_set_refname(value: string): void;
            vfunc_set_reftable(value: TableModel): void;
            vfunc_set_update_rule(value: ForeignKeyRule): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            delete_rule: ForeignKeyRule;
            deleteRule: ForeignKeyRule;
            match: ForeignKeyMatch;
            name: string;
            refcol: Gio.ListModel;
            refname: string;
            reftable: TableModel;
            update_rule: ForeignKeyRule;
            updateRule: ForeignKeyRule;
        }
    }

    export interface ForeignKeyNamespace {
        $gtype: GObject.GType<ForeignKey>;
        prototype: ForeignKey;
    }
    interface ForeignKey extends GObject.Object, ForeignKey.Interface {
        // Properties

        get delete_rule(): ForeignKeyRule;
        set delete_rule(val: ForeignKeyRule);
        get deleteRule(): ForeignKeyRule;
        set deleteRule(val: ForeignKeyRule);
        get match(): ForeignKeyMatch;
        set match(val: ForeignKeyMatch);
        get name(): string;
        set name(val: string);
        get refcol(): Gio.ListModel;
        set refcol(val: Gio.ListModel);
        get refname(): string;
        set refname(val: string);
        get reftable(): TableModel;
        set reftable(val: TableModel);
        get update_rule(): ForeignKeyRule;
        set update_rule(val: ForeignKeyRule);
        get updateRule(): ForeignKeyRule;
        set updateRule(val: ForeignKeyRule);

        // Methods

        equal(fkey: ForeignKey): boolean;
        get_delete_rule(): ForeignKeyRule;
        get_match(): ForeignKeyMatch;
        get_name(): string;
        get_refname(): string;
        get_update_rule(): ForeignKeyRule;
        set_delete_rule(value: ForeignKeyRule | null): void;
        set_match(value: ForeignKeyMatch | null): void;
        set_name(value: string): void;
        set_refcol(value: Gio.ListModel): void;
        set_refname(value: string): void;
        set_reftable(value: TableModel): void;
        set_update_rule(value: ForeignKeyRule | null): void;
        to_string(): string;
    }

    export const ForeignKey: ForeignKeyNamespace & {
        new (): ForeignKey; // This allows `obj instanceof ForeignKey`
    };

    namespace Inserted {
        /**
         * Interface for implementing Inserted.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_number(): number;
        }

        // Constructor properties interface

        interface ConstructorProps extends Result.ConstructorProps {
            last_insertd: RowModel;
            lastInsertd: RowModel;
            number: number;
        }
    }

    export interface InsertedNamespace {
        $gtype: GObject.GType<Inserted>;
        prototype: Inserted;
    }
    interface Inserted extends Result, Inserted.Interface {
        // Properties

        get last_insertd(): RowModel;
        get lastInsertd(): RowModel;
        get number(): number;

        // Methods

        get_number(): number;
    }

    export const Inserted: InsertedNamespace & {
        new (): Inserted; // This allows `obj instanceof Inserted`
    };

    namespace Lockable {
        /**
         * Interface for implementing Lockable.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            /**
             * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
             * by the other thread.
             *
             * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
             * (and has to unlock it as many times to actually unlock it).
             */
            vfunc_lock(): void;
            /**
             * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
             * it locks `lockable`.
             *
             * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
             * (and has to unlock it as many times to actually unlock it).
             */
            vfunc_trylock(): boolean;
            /**
             * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
             * used gda_lockable_lock() or gda_lockable_trylock()).
             */
            vfunc_unlock(): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface LockableNamespace {
        $gtype: GObject.GType<Lockable>;
        prototype: Lockable;
    }
    interface Lockable extends GObject.Object, Lockable.Interface {
        // Methods

        /**
         * Locks `lockable`. If it is already locked by another thread, the current thread will block until it is unlocked
         * by the other thread.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         */
        lock(): void;
        /**
         * Tries to lock `lockable`. If it is already locked by another thread, then it immediately returns FALSE, otherwise
         * it locks `lockable`.
         *
         * Note: unlike g_mutex_lock(), this method recursive, which means a thread can lock `lockable` several times
         * (and has to unlock it as many times to actually unlock it).
         * @returns TRUE if the object has successfully been locked.
         */
        trylock(): boolean;
        /**
         * Unlocks `lockable`. This method should not be called if the current does not already holds a lock on `lockable` (having
         * used gda_lockable_lock() or gda_lockable_trylock()).
         */
        unlock(): void;
    }

    export const Lockable: LockableNamespace & {
        new (): Lockable; // This allows `obj instanceof Lockable`
    };

    namespace MetaCatalog {
        /**
         * Interface for implementing MetaCatalog.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_set_connection(value: ConnectionModel): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            connection: ConnectionModel;
        }
    }

    export interface MetaCatalogNamespace {
        $gtype: GObject.GType<MetaCatalog>;
        prototype: MetaCatalog;
    }
    interface MetaCatalog extends GObject.Object, MetaCatalog.Interface {
        // Properties

        get connection(): ConnectionModel;
        set connection(val: ConnectionModel);

        // Methods

        set_connection(value: ConnectionModel): void;
    }

    export const MetaCatalog: MetaCatalogNamespace & {
        new (): MetaCatalog; // This allows `obj instanceof MetaCatalog`
    };

    namespace MetaColumn {
        /**
         * Interface for implementing MetaColumn.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_column_type(): GObject.GType;
            vfunc_get_column_type_name(): string;
            vfunc_get_name(): string;
            vfunc_set_name(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            column_type: GObject.GType;
            columnType: GObject.GType;
            column_type_name: string;
            columnTypeName: string;
            name: string;
        }
    }

    export interface MetaColumnNamespace {
        $gtype: GObject.GType<MetaColumn>;
        prototype: MetaColumn;
    }
    interface MetaColumn extends GObject.Object, MetaColumn.Interface {
        // Properties

        get column_type(): GObject.GType;
        get columnType(): GObject.GType;
        get column_type_name(): string;
        get columnTypeName(): string;
        get name(): string;
        set name(val: string);

        // Methods

        get_column_type(): GObject.GType;
        get_column_type_name(): string;
        get_name(): string;
        set_name(value: string): void;
    }

    export const MetaColumn: MetaColumnNamespace & {
        new (): MetaColumn; // This allows `obj instanceof MetaColumn`
    };

    namespace MetaTable {
        /**
         * Interface for implementing MetaTable.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_catalog(): string;
            vfunc_get_name(): string;
            vfunc_get_schema(): string;
            vfunc_set_catalog(value: string): void;
            vfunc_set_name(value: string): void;
            vfunc_set_schema(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            catalog: string;
            columns: Gio.ListModel;
            name: string;
            schema: string;
        }
    }

    export interface MetaTableNamespace {
        $gtype: GObject.GType<MetaTable>;
        prototype: MetaTable;
    }
    interface MetaTable extends GObject.Object, MetaTable.Interface {
        // Properties

        get catalog(): string;
        set catalog(val: string);
        get columns(): Gio.ListModel;
        get name(): string;
        set name(val: string);
        get schema(): string;
        set schema(val: string);

        // Methods

        get_catalog(): string;
        get_name(): string;
        get_schema(): string;
        set_catalog(value: string): void;
        set_name(value: string): void;
        set_schema(value: string): void;
    }

    export const MetaTable: MetaTableNamespace & {
        new (): MetaTable; // This allows `obj instanceof MetaTable`
    };

    namespace Parameters {
        /**
         * Interface for implementing Parameters.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface<A extends GObject.Object = GObject.Object> extends Gio.ListModel.Interface {
            // Virtual methods

            vfunc_get_value(name: string): unknown;
            vfunc_set_value(name: string, val: GObject.Value | any): void;
        }

        // Constructor properties interface

        interface ConstructorProps<A extends GObject.Object = GObject.Object>
            extends Gio.ListModel.ConstructorProps<A> {}
    }

    export interface ParametersNamespace {
        $gtype: GObject.GType<Parameters>;
        prototype: Parameters;
    }
    interface Parameters<A extends GObject.Object = GObject.Object> extends Gio.ListModel, Parameters.Interface<A> {
        // Methods

        get_value(name: string): unknown;
        set_value(name: string, val: GObject.Value | any): void;
    }

    export const Parameters: ParametersNamespace & {
        new (): Parameters; // This allows `obj instanceof Parameters`
    };

    namespace PreparedQuery {
        /**
         * Interface for implementing PreparedQuery.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface extends Query.Interface {
            // Virtual methods

            vfunc_get_name(): string;
        }

        // Constructor properties interface

        interface ConstructorProps extends Query.ConstructorProps {
            name: string;
            parameters: Parameters;
        }
    }

    export interface PreparedQueryNamespace {
        $gtype: GObject.GType<PreparedQuery>;
        prototype: PreparedQuery;
    }
    interface PreparedQuery extends Query, PreparedQuery.Interface {
        // Properties

        get name(): string;
        get parameters(): Parameters;

        // Methods

        get_name(): string;
    }

    export const PreparedQuery: PreparedQueryNamespace & {
        new (): PreparedQuery; // This allows `obj instanceof PreparedQuery`
    };

    namespace Provider {
        /**
         * Interface for implementing Provider.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_add_savepoint(cnc: Connection, name: string): boolean;
            vfunc_begin_transaction(cnc: Connection, name: string, level: TransactionIsolation): boolean;
            vfunc_close_connection(cnc: Connection): boolean;
            vfunc_commit_transaction(cnc: Connection, name: string): boolean;
            vfunc_create_connection(): Connection;
            vfunc_create_operation(cnc: Connection, type: ServerOperationType, options: Set): ServerOperation;
            vfunc_create_parser(cnc: Connection): SqlParser;
            vfunc_delete_savepoint(cnc: Connection, name: string): boolean;
            vfunc_escape_string(cnc: Connection, str: string): string;
            vfunc_get_data_handler(cnc: Connection, g_type: GObject.GType, dbms_type: string): DataHandler;
            vfunc_get_def_dbms_type(cnc: Connection, g_type: GObject.GType): string;
            /**
             * This command should be called inmediately called after a INSERT SQL command
             * @param cnc a #GdaConnection to get last inserted from
             */
            vfunc_get_last_inserted(cnc: Connection): Set;
            vfunc_get_name(): string;
            vfunc_get_server_version(cnc: Connection): string;
            vfunc_get_version(): string;
            vfunc_identifier_quote(
                cnc: Connection | null,
                id: string,
                for_meta_store: boolean,
                force_quotes: boolean,
            ): string;
            vfunc_open_connection(cnc: Connection, params: QuarkList, auth: QuarkList): boolean;
            vfunc_perform_operation(cnc: Connection, op: ServerOperation): boolean;
            vfunc_prepare_connection(cnc: Connection, params: QuarkList, auth: QuarkList): boolean;
            vfunc_render_operation(cnc: Connection, op: ServerOperation): string;
            vfunc_rollback_savepoint(cnc: Connection, name: string): boolean;
            vfunc_rollback_transaction(cnc: Connection, name: string): boolean;
            vfunc_statement_execute<T = GObject.Object>(
                cnc: Connection,
                stmt: Statement,
                params: Set,
                model_usage: StatementModelUsage,
                col_types: GObject.GType,
                last_inserted_row: Set,
            ): T;
            vfunc_statement_prepare(cnc: Connection, stmt: Statement): boolean;
            vfunc_statement_rewrite(cnc: Connection, stmt: Statement, params: Set): SqlStatement;
            vfunc_statement_to_sql(
                cnc: Connection,
                stmt: Statement,
                params: Set | null,
                flags: StatementSqlFlag,
            ): [string, Holder[] | null];
            vfunc_supports_feature(cnc: Connection, feature: ConnectionFeature): boolean;
            vfunc_supports_operation(cnc: Connection, type: ServerOperationType, options: Set): boolean;
            vfunc_unescape_string(cnc: Connection, str: string): string;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ProviderNamespace {
        $gtype: GObject.GType<Provider>;
        prototype: Provider;
    }
    interface Provider extends GObject.Object, Provider.Interface {
        // Methods

        add_savepoint(cnc: Connection, name: string): boolean;
        begin_transaction(cnc: Connection, name: string, level: TransactionIsolation | null): boolean;
        close_connection(cnc: Connection): boolean;
        commit_transaction(cnc: Connection, name: string): boolean;
        create_connection(): Connection;
        create_operation(cnc: Connection, type: ServerOperationType | null, options: Set): ServerOperation;
        create_parser(cnc: Connection): SqlParser;
        delete_savepoint(cnc: Connection, name: string): boolean;
        escape_string(cnc: Connection, str: string): string;
        get_data_handler(cnc: Connection, g_type: GObject.GType, dbms_type: string): DataHandler;
        get_def_dbms_type(cnc: Connection, g_type: GObject.GType): string;
        /**
         * This command should be called inmediately called after a INSERT SQL command
         * @param cnc a #GdaConnection to get last inserted from
         * @returns a #GdaSet with all data of the last inserted row
         */
        get_last_inserted(cnc: Connection): Set;
        get_name(): string;
        get_server_version(cnc: Connection): string;
        get_version(): string;
        identifier_quote(cnc: Connection | null, id: string, for_meta_store: boolean, force_quotes: boolean): string;
        open_connection(cnc: Connection, params: QuarkList, auth: QuarkList): boolean;
        perform_operation(cnc: Connection, op: ServerOperation): boolean;
        prepare_connection(cnc: Connection, params: QuarkList, auth: QuarkList): boolean;
        render_operation(cnc: Connection, op: ServerOperation): string;
        rollback_savepoint(cnc: Connection, name: string): boolean;
        rollback_transaction(cnc: Connection, name: string): boolean;
        statement_execute<T = GObject.Object>(
            cnc: Connection,
            stmt: Statement,
            params: Set,
            model_usage: StatementModelUsage | null,
            col_types: GObject.GType,
            last_inserted_row: Set,
        ): T;
        statement_prepare(cnc: Connection, stmt: Statement): boolean;
        statement_rewrite(cnc: Connection, stmt: Statement, params: Set): SqlStatement;
        statement_to_sql(
            cnc: Connection,
            stmt: Statement,
            params: Set | null,
            flags: StatementSqlFlag | null,
        ): [string, Holder[] | null];
        supports_feature(cnc: Connection, feature: ConnectionFeature | null): boolean;
        supports_operation(cnc: Connection, type: ServerOperationType | null, options: Set): boolean;
        unescape_string(cnc: Connection, str: string): string;
    }

    export const Provider: ProviderNamespace & {
        new (): Provider; // This allows `obj instanceof Provider`
    };

    namespace ProviderMeta {
        /**
         * Interface for implementing ProviderMeta.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_btypes(): DataModel;
            vfunc_character_set(chset_catalog: string, chset_schema: string, chset_name_n: string): Row;
            vfunc_character_sets(): DataModel;
            vfunc_check_column(
                table_catalog: string,
                table_schema: string,
                table_name: string,
                constraint_name: string,
            ): Row;
            vfunc_check_columns(): DataModel;
            vfunc_collation(collation_catalog: string, collation_schema: string, collation_name_n: string): Row;
            vfunc_collations(): DataModel;
            vfunc_columns(): DataModel;
            vfunc_constraint_ref(
                table_catalog: string,
                table_schema: string,
                table_name: string,
                constraint_name: string,
            ): Row;
            vfunc_constraint_table(
                table_catalog: string,
                table_schema: string,
                table_name: string,
                constraint_name_n: string,
            ): Row;
            vfunc_constraints_ref(): DataModel;
            vfunc_constraints_ref_table(table_catalog: string, table_schema: string, table_name: string): DataModel;
            vfunc_constraints_table(table_catalog: string, table_schema: string, table_name: string): DataModel;
            vfunc_constraints_tables(): DataModel;
            vfunc_domain(domain_catalog: string, domain_schema: string): Row;
            vfunc_domain_constraint(
                domain_catalog: string,
                domain_schema: string,
                domain_name: string,
                constraint_name: string,
            ): Row;
            vfunc_domain_constraints(domain_catalog: string, domain_schema: string, domain_name: string): DataModel;
            vfunc_domains(): DataModel;
            vfunc_domains_constraints(): DataModel;
            vfunc_element_type(specific_name: string): Row;
            vfunc_element_types(): DataModel;
            vfunc_enum_type(udt_catalog: string, udt_schema: string, udt_name: string): Row;
            vfunc_enums_type(): DataModel;
            vfunc_index_col(table_catalog: string, table_schema: string, table_name: string, index_name: string): Row;
            vfunc_index_cols(): DataModel;
            vfunc_index_table(
                table_catalog: string,
                table_schema: string,
                table_name: string,
                index_name_n: string,
            ): Row;
            vfunc_indexes_table(table_catalog: string, table_schema: string, table_name: string): DataModel;
            vfunc_indexes_tables(): DataModel;
            vfunc_key_column(
                table_catalog: string,
                table_schema: string,
                table_name: string,
                constraint_name: string,
            ): Row;
            vfunc_key_columns(): DataModel;
            vfunc_routine(routine_catalog: string, routine_schema: string, routine_name_n: string): Row;
            vfunc_routine_col(rout_catalog: string, rout_schema: string, rout_name: string): Row;
            vfunc_routine_pars(rout_catalog: string, rout_schema: string, rout_name: string): Row;
            vfunc_routines(): DataModel;
            vfunc_routines_col(): DataModel;
            vfunc_routines_pars(): DataModel;
            vfunc_schemata(catalog_name: string, schema_name_n: string): Row;
            vfunc_schematas(): DataModel;
            vfunc_table(table_catalog: string, table_schema: string, table_name_n: string): Row;
            vfunc_table_column(
                table_catalog: string,
                table_schema: string,
                table_name: string,
                column_name: string,
            ): Row;
            vfunc_table_columns(table_catalog: string, table_schema: string, table_name: string): DataModel;
            vfunc_tables(): DataModel;
            vfunc_tables_columns(): DataModel;
            vfunc_trigger(table_catalog: string, table_schema: string, table_name: string): Row;
            vfunc_triggers(): DataModel;
            vfunc_udt(udt_catalog: string, udt_schema: string): Row;
            vfunc_udt_col(udt_catalog: string, udt_schema: string, udt_name: string): Row;
            vfunc_udt_cols(): DataModel;
            vfunc_udts(): DataModel;
            vfunc_view(view_catalog: string, view_schema: string, view_name_n: string): Row;
            vfunc_view_column(view_catalog: string, view_schema: string, view_name: string, column_name: string): Row;
            vfunc_view_columns(view_catalog: string, view_schema: string, view_name: string): DataModel;
            vfunc_views(): DataModel;
            vfunc_views_columns(): DataModel;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            connection: Connection;
        }
    }

    export interface ProviderMetaNamespace {
        $gtype: GObject.GType<ProviderMeta>;
        prototype: ProviderMeta;

        error_quark(): GLib.Quark;
    }
    interface ProviderMeta extends GObject.Object, ProviderMeta.Interface {
        // Properties

        get connection(): Connection;

        // Methods

        btypes(): DataModel;
        character_set(chset_catalog: string, chset_schema: string, chset_name_n: string): Row;
        character_sets(): DataModel;
        check_column(table_catalog: string, table_schema: string, table_name: string, constraint_name: string): Row;
        check_columns(): DataModel;
        collation(collation_catalog: string, collation_schema: string, collation_name_n: string): Row;
        collations(): DataModel;
        columns(): DataModel;
        constraint_ref(table_catalog: string, table_schema: string, table_name: string, constraint_name: string): Row;
        constraint_table(
            table_catalog: string,
            table_schema: string,
            table_name: string,
            constraint_name_n: string,
        ): Row;
        constraints_ref(): DataModel;
        constraints_ref_table(table_catalog: string, table_schema: string, table_name: string): DataModel;
        constraints_table(table_catalog: string, table_schema: string, table_name: string): DataModel;
        constraints_tables(): DataModel;
        domain(domain_catalog: string, domain_schema: string): Row;
        domain_constraint(
            domain_catalog: string,
            domain_schema: string,
            domain_name: string,
            contraint_name: string,
        ): Row;
        domain_constraints(domain_catalog: string, domain_schema: string, domain_name: string): DataModel;
        domains(): DataModel;
        domains_constraints(): DataModel;
        element_type(specific_name: string): Row;
        element_types(): DataModel;
        enum_type(udt_catalog: string, udt_schema: string, udt_name: string): Row;
        enums_type(): DataModel;
        /**
         * SQL is specific for current provider.
         * @param sql a string with the SQL to execute on provider
         * @param params a #GdaSet with all paramaters to use in query
         * @returns a new #GdaDataModel with as a result of the query
         */
        execute_query(sql: string, params?: Set | null): DataModel | null;
        /**
         * SQL is specific for current provider.
         * @param sql a string with the SQL to execute on provider
         * @param params
         * @returns a new #GdaDataModel with as a result of the query
         */
        execute_query_row(sql: string, params: Set): Row | null;
        get_connection(): Connection;
        index_col(table_catalog: string, table_schema: string, table_name: string, index_name: string): Row;
        index_cols(): DataModel;
        index_table(table_catalog: string, table_schema: string, table_name: string, index_name_n: string): Row;
        indexes_table(table_catalog: string, table_schema: string, table_name: string): DataModel;
        indexes_tables(): DataModel;
        key_column(table_catalog: string, table_schema: string, table_name: string, constraint_name: string): Row;
        key_columns(): DataModel;
        routine(routine_catalog: string, routine_schema: string, routine_name_n: string): Row;
        routine_col(rout_catalog: string, rout_schema: string, rout_name: string): Row;
        routine_pars(rout_catalog: string, rout_schema: string, rout_name: string): Row;
        routines(): DataModel;
        routines_col(): DataModel;
        routines_pars(): DataModel;
        schemata(catalog_name: string, schema_name_n: string): Row;
        schematas(): DataModel;
        table(table_catalog: string, table_schema: string, table_name_n: string): Row;
        table_column(table_catalog: string, table_schema: string, table_name: string, column_name: string): Row;
        table_columns(table_catalog: string, table_schema: string, table_name: string): DataModel;
        tables(): DataModel;
        tables_columns(): DataModel;
        trigger(table_catalog: string, table_schema: string, table_name: string): Row;
        triggers(): DataModel;
        udt(udt_catalog: string, udt_schema: string): Row;
        udt_col(udt_catalog: string, udt_schema: string, udt_name: string): Row;
        udt_cols(): DataModel;
        udts(): DataModel;
        view(view_catalog: string, view_schema: string, view_name_n: string): Row;
        view_column(view_catalog: string, view_schema: string, view_name: string, column_name: string): Row;
        view_columns(view_catalog: string, view_schema: string, view_name: string): DataModel;
        views(): DataModel;
        views_columns(): DataModel;
    }

    export const ProviderMeta: ProviderMetaNamespace & {
        new (): ProviderMeta; // This allows `obj instanceof ProviderMeta`
    };

    namespace Query {
        /**
         * Interface for implementing Query.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_cancel(_callback_?: Gio.AsyncReadyCallback | null, _user_data_?: any | null): void;
            vfunc_cancel_finish(_res_: Gio.AsyncResult): void;
            vfunc_execute(_callback_?: Gio.AsyncReadyCallback | null, _user_data_?: any | null): void;
            vfunc_get_name(): string;
            vfunc_get_sql(): string;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            connection: ConnectionModel;
            name: string;
            sql: string;
        }
    }

    export interface QueryNamespace {
        $gtype: GObject.GType<Query>;
        prototype: Query;
    }
    interface Query extends GObject.Object, Query.Interface {
        // Properties

        get connection(): ConnectionModel;
        get name(): string;
        get sql(): string;

        // Methods

        cancel(_callback_?: Gio.AsyncReadyCallback | null, _user_data_?: any | null): void;
        cancel_finish(_res_: Gio.AsyncResult): void;
        execute(_callback_?: Gio.AsyncReadyCallback | null, _user_data_?: any | null): void;
        get_name(): string;
        get_sql(): string;
    }

    export const Query: QueryNamespace & {
        new (): Query; // This allows `obj instanceof Query`
    };

    namespace QueryBuilder {
        /**
         * Interface for implementing QueryBuilder.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_add_savepoint(name: string): boolean;
            vfunc_begin_transaction(name: string): boolean;
            vfunc_commit_transaction(name: string): boolean;
            vfunc_delete_savepoint(name: string): boolean;
            vfunc_get_name(): string;
            vfunc_get_sql(): string;
            vfunc_rollback_savepoint(name: string): boolean;
            vfunc_rollback_transaction(name: string): boolean;
            vfunc_set_name(value: string): void;
            vfunc_set_sql(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            name: string;
            parameters: Parameters;
            sql: string;
        }
    }

    export interface QueryBuilderNamespace {
        $gtype: GObject.GType<QueryBuilder>;
        prototype: QueryBuilder;
    }
    interface QueryBuilder extends GObject.Object, QueryBuilder.Interface {
        // Properties

        get name(): string;
        set name(val: string);
        get parameters(): Parameters;
        get sql(): string;
        set sql(val: string);

        // Methods

        add_savepoint(name: string): boolean;
        begin_transaction(name: string): boolean;
        commit_transaction(name: string): boolean;
        delete_savepoint(name: string): boolean;
        get_name(): string;
        get_sql(): string;
        rollback_savepoint(name: string): boolean;
        rollback_transaction(name: string): boolean;
        set_name(value: string): void;
        set_sql(value: string): void;
    }

    export const QueryBuilder: QueryBuilderNamespace & {
        new (): QueryBuilder; // This allows `obj instanceof QueryBuilder`
    };

    namespace ReadonlyTableModel {
        /**
         * Interface for implementing ReadonlyTableModel.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface extends MetaTable.Interface {
            // Virtual methods

            vfunc_get_value(row: number, column: string, result: GObject.Value | any): void;
            vfunc_get_value_at(row: number, column: number, result: GObject.Value | any): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends MetaTable.ConstructorProps {
            rows: Gio.ListModel;
        }
    }

    export interface ReadonlyTableModelNamespace {
        $gtype: GObject.GType<ReadonlyTableModel>;
        prototype: ReadonlyTableModel;
    }
    interface ReadonlyTableModel extends MetaTable, ReadonlyTableModel.Interface {
        // Properties

        get rows(): Gio.ListModel;

        // Methods

        get_value(row: number, column: string, result: GObject.Value | any): void;
        get_value_at(row: number, column: number, result: GObject.Value | any): void;
    }

    export const ReadonlyTableModel: ReadonlyTableModelNamespace & {
        new (): ReadonlyTableModel; // This allows `obj instanceof ReadonlyTableModel`
    };

    namespace ReferencedColumn {
        /**
         * Interface for implementing ReferencedColumn.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_name(): string;
            vfunc_set_table_name(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            name: string;
            table_name: string;
            tableName: string;
        }
    }

    export interface ReferencedColumnNamespace {
        $gtype: GObject.GType<ReferencedColumn>;
        prototype: ReferencedColumn;
    }
    interface ReferencedColumn extends GObject.Object, ReferencedColumn.Interface {
        // Properties

        get name(): string;
        set table_name(val: string);
        set tableName(val: string);

        // Methods

        get_name(): string;
        set_table_name(value: string): void;
    }

    export const ReferencedColumn: ReferencedColumnNamespace & {
        new (): ReferencedColumn; // This allows `obj instanceof ReferencedColumn`
    };

    namespace Result {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ResultNamespace {
        $gtype: GObject.GType<Result>;
        prototype: Result;
    }
    interface Result extends GObject.Object {}

    export const Result: ResultNamespace & {
        new (): Result; // This allows `obj instanceof Result`
    };

    namespace ResultTable {
        // Constructor properties interface

        interface ConstructorProps extends MetaTable.ConstructorProps {}
    }

    export interface ResultTableNamespace {
        $gtype: GObject.GType<ResultTable>;
        prototype: ResultTable;
    }
    interface ResultTable extends MetaTable {}

    export const ResultTable: ResultTableNamespace & {
        new (): ResultTable; // This allows `obj instanceof ResultTable`
    };

    namespace RowModel {
        /**
         * Interface for implementing RowModel.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface<A extends GObject.Object = GObject.Object> extends Gio.ListModel.Interface {
            // Virtual methods

            vfunc_get_n_columns(): number;
        }

        // Constructor properties interface

        interface ConstructorProps<A extends GObject.Object = GObject.Object>
            extends Gio.ListModel.ConstructorProps<A> {
            n_columns: number;
            nColumns: number;
        }
    }

    export interface RowModelNamespace {
        $gtype: GObject.GType<RowModel>;
        prototype: RowModel;
    }
    interface RowModel<A extends GObject.Object = GObject.Object> extends Gio.ListModel, RowModel.Interface<A> {
        // Properties

        get n_columns(): number;
        get nColumns(): number;

        // Methods

        get_n_columns(): number;
    }

    export const RowModel: RowModelNamespace & {
        new (): RowModel; // This allows `obj instanceof RowModel`
    };

    namespace TableConstraint {
        /**
         * Interface for implementing TableConstraint.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            vfunc_get_definition(): string;
            vfunc_set_definition(value: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface TableConstraintNamespace {
        $gtype: GObject.GType<TableConstraint>;
        prototype: TableConstraint;
    }
    interface TableConstraint extends GObject.Object, TableConstraint.Interface {
        // Methods

        get_definition(): string;
        set_definition(value: string): void;
    }

    export const TableConstraint: TableConstraintNamespace & {
        new (): TableConstraint; // This allows `obj instanceof TableConstraint`
    };

    namespace TableModel {
        // Constructor properties interface

        interface ConstructorProps extends MetaTable.ConstructorProps {}
    }

    export interface TableModelNamespace {
        $gtype: GObject.GType<TableModel>;
        prototype: TableModel;
    }
    interface TableModel extends MetaTable {}

    export const TableModel: TableModelNamespace & {
        new (): TableModel; // This allows `obj instanceof TableModel`
    };

    namespace WritableTableModel {
        /**
         * Interface for implementing WritableTableModel.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface extends MetaTable.Interface {
            // Virtual methods

            vfunc_insert_row(new_row: RowModel): void;
            vfunc_set_value(row: number, column: string, value: GObject.Value | any): void;
            vfunc_set_value_at(row: number, column: number, value: GObject.Value | any): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends MetaTable.ConstructorProps {}
    }

    export interface WritableTableModelNamespace {
        $gtype: GObject.GType<WritableTableModel>;
        prototype: WritableTableModel;
    }
    interface WritableTableModel extends MetaTable, WritableTableModel.Interface {
        // Methods

        insert_row(new_row: RowModel): void;
        set_value(row: number, column: string, value: GObject.Value | any): void;
        set_value_at(row: number, column: number, value: GObject.Value | any): void;
    }

    export const WritableTableModel: WritableTableModelNamespace & {
        new (): WritableTableModel; // This allows `obj instanceof WritableTableModel`
    };

    type SqlBuilderId = number;
    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default Gda;

// END
