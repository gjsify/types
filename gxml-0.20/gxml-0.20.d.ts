/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

import '@girs/gjs';

// Module dependencies
import type libxml2 from '@girs/libxml2-2.0';
import type Gio from '@girs/gio-2.0';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type GModule from '@girs/gmodule-2.0';
import type Gee from '@girs/gee-0.8';

export namespace GXml {
    /**
     * GXml-0.20
     */

    export namespace CssCombiner {
        export const $gtype: GObject.GType<CssCombiner>;
    }

    enum CssCombiner {
        NULL,
        NONE,
        INSIDE,
        AND,
        PARENT,
        AFTER,
        PRECEDED,
    }

    export namespace CssSelectorType {
        export const $gtype: GObject.GType<CssSelectorType>;
    }

    enum CssSelectorType {
        CLASS,
        ID,
        ALL,
        ELEMENT,
        ATTRIBUTE,
        ATTRIBUTE_EQUAL,
        ATTRIBUTE_CONTAINS,
        ATTRIBUTE_SUBSTRING,
        ATTRIBUTE_STARTS_WITH,
        ATTRIBUTE_STARTS_WITH_WORD,
        ATTRIBUTE_ENDS_WITH,
        PSEUDO_CLASS,
    }

    export namespace NodeType {
        export const $gtype: GObject.GType<NodeType>;
    }

    enum NodeType {
        INVALID,
        ELEMENT,
        ATTRIBUTE,
        TEXT,
        CDATA_SECTION,
        ENTITY_REFERENCE,
        ENTITY,
        PROCESSING_INSTRUCTION,
        COMMENT,
        DOCUMENT,
        DOCUMENT_TYPE,
        DOCUMENT_FRAGMENT,
        NOTATION,
    }

    export namespace XPathObjectType {
        export const $gtype: GObject.GType<XPathObjectType>;
    }

    enum XPathObjectType {
        UNDEFINED,
        NODESET,
        BOOLEAN,
        NUMBER,
        STRING,
        POINT,
        RANGE,
        LOCATIONSET,
        USERS,
        XSLT_TREE,
    }
    class CssSelectorError extends GLib.Error {
        static $gtype: GObject.GType<CssSelectorError>;

        // Static fields

        static NULL: number;
        static EOF: number;
        static NOT: number;
        static PSEUDO: number;
        static ATTRIBUTE: number;
        static IDENTIFIER: number;
        static COMBINER: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class DomDocumentError extends GLib.Error {
        static $gtype: GObject.GType<DomDocumentError>;

        // Static fields

        static FILE_NOT_FOUND_ERROR: number;
        static INVALID_DOCUMENT_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class DomError extends GLib.Error {
        static $gtype: GObject.GType<DomError>;

        // Static fields

        static INDEX_SIZE_ERROR: number;
        static DOMSTRING_SIZE_ERROR: number;
        static HIERARCHY_REQUEST_ERROR: number;
        static WRONG_DOCUMENT_ERROR: number;
        static INVALID_CHARACTER_ERROR: number;
        static NO_DATA_ALLOWED_ERROR: number;
        static NO_MODIFICATION_ALLOWED_ERROR: number;
        static NOT_FOUND_ERROR: number;
        static NOT_SUPPORTED_ERROR: number;
        static INUSE_ATTRIBUTE_ERROR: number;
        static INVALID_STATE_ERROR: number;
        static SYNTAX_ERROR: number;
        static INVALID_MODIFICATION_ERROR: number;
        static NAMESPACE_ERROR: number;
        static INVALID_ACCESS_ERROR: number;
        static VALIDATION_ERROR: number;
        static TYPE_MISMATCH_ERROR: number;
        static SECURITY_ERROR: number;
        static NETWORK_ERROR: number;
        static ABORT_ERROR: number;
        static URL_MISMATCH_ERROR: number;
        static QUOTA_EXCEEDED_ERROR: number;
        static TIME_OUT_ERROR: number;
        static INVALID_NODE_TYPE_ERROR: number;
        static DATA_CLONE_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class EnumerationError extends GLib.Error {
        static $gtype: GObject.GType<EnumerationError>;

        // Static fields

        static INVALID_VALUE: number;
        static INVALID_TEXT: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class IXsdSchemaError extends GLib.Error {
        static $gtype: GObject.GType<IXsdSchemaError>;

        // Static fields

        static INVALIDATION_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class ParserError extends GLib.Error {
        static $gtype: GObject.GType<ParserError>;

        // Static fields

        static INVALID_DATA_ERROR: number;
        static INVALID_FILE_ERROR: number;
        static INVALID_STREAM_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class Error extends GLib.Error {
        static $gtype: GObject.GType<Error>;

        // Static fields

        static NOT_SUPPORTED: number;
        static PARSER: number;
        static WRITER: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class XPathError extends GLib.Error {
        static $gtype: GObject.GType<XPathError>;

        // Static fields

        static EXPRESSION_OK: number;
        static NUMBER_ERROR: number;
        static UNFINISHED_LITERAL_ERROR: number;
        static START_LITERAL_ERROR: number;
        static VARIABLE_REF_ERROR: number;
        static UNDEF_VARIABLE_ERROR: number;
        static INVALID_PREDICATE_ERROR: number;
        static EXPR_ERROR: number;
        static UNCLOSED_ERROR: number;
        static UNKNOWN_FUNC_ERROR: number;
        static INVALID_OPERAND: number;
        static INVALID_TYPE: number;
        static INVALID_ARITY: number;
        static INVALID_CTXT_SIZE: number;
        static INVALID_CTXT_POSITION: number;
        static MEMORY_ERROR: number;
        static XPTR_SYNTAX_ERROR: number;
        static XPTR_RESOURCE_ERROR: number;
        static XPTR_SUB_RESOURCE_ERROR: number;
        static UNDEF_PREFIX_ERROR: number;
        static ENCODING_ERROR: number;
        static INVALID_CHAR_ERROR: number;
        static INVALID_CTXT: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    class XPathObjectError extends GLib.Error {
        static $gtype: GObject.GType<XPathObjectError>;

        // Static fields

        static INVALID_NAMESPACE_ERROR: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    export namespace DomNodeFilterFilter {
        export const $gtype: GObject.GType<DomNodeFilterFilter>;
    }

    enum DomNodeFilterFilter {
        ACCEPT,
        REJECT,
        SKIP,
    }

    export namespace DomEventPhase {
        export const $gtype: GObject.GType<DomEventPhase>;
    }

    enum DomEventPhase {
        NONE,
        CAPTURING_PHASE,
        AT_TARGET,
        BUBBLING_PHASE,
    }

    export namespace DomNodeNodeType {
        export const $gtype: GObject.GType<DomNodeNodeType>;
    }

    enum DomNodeNodeType {
        INVALID,
        ELEMENT_NODE,
        ATTRIBUTE_NODE,
        TEXT_NODE,
        CDATA_SECTION_NODE,
        ENTITY_REFERENCE_NODE,
        ENTITY_NODE,
        PROCESSING_INSTRUCTION_NODE,
        COMMENT_NODE,
        DOCUMENT_NODE,
        DOCUMENT_TYPE_NODE,
        DOCUMENT_FRAGMENT_NODE,
        NOTATION_NODE,
    }

    export namespace DomRangeBoundaryPoints {
        export const $gtype: GObject.GType<DomRangeBoundaryPoints>;
    }

    enum DomRangeBoundaryPoints {
        START_TO_START,
        START_TO_END,
        END_TO_END,
        END_TO_START,
    }
    interface DomMutationCallback {
        (mutations: Gee.List, observer: DomMutationObserver): void;
    }

    export namespace DomEventFlags {
        export const $gtype: GObject.GType<DomEventFlags>;
    }

    enum DomEventFlags {
        STOP_PROPAGATION_FLAG,
        STOP_IMMEDIATE_PROPAGATION_FLAG,
        CANCELED_FLAG,
        INITIALIZED_FLAG,
        DISPATCH_FLAG,
    }

    export namespace DomNodeDocumentPosition {
        export const $gtype: GObject.GType<DomNodeDocumentPosition>;
    }

    enum DomNodeDocumentPosition {
        NONE,
        DISCONNECTED,
        PRECEDING,
        FOLLOWING,
        CONTAINS,
        CONTAINED_BY,
        IMPLEMENTATION_SPECIFIC,
    }
    namespace ArrayList {
        // Signal signatures
        interface SignalSignatures extends BaseCollection.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends BaseCollection.ConstructorProps, List.ConstructorProps {}
    }

    class ArrayList extends BaseCollection implements List {
        static $gtype: GObject.GType<ArrayList>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ArrayList.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ArrayList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ArrayList;

        // Signals

        connect<K extends keyof ArrayList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ArrayList.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ArrayList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ArrayList.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ArrayList.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ArrayList.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Attr {
        // Signal signatures
        interface SignalSignatures extends Node.SignalSignatures {
            'notify::is-referenced': (pspec: GObject.ParamSpec) => void;
            'notify::namespace-uri': (pspec: GObject.ParamSpec) => void;
            'notify::prefix': (pspec: GObject.ParamSpec) => void;
            'notify::local-name': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Node.ConstructorProps, DomAttr.ConstructorProps {
            is_referenced: boolean;
            isReferenced: boolean;
        }
    }

    class Attr extends Node implements DomAttr {
        static $gtype: GObject.GType<Attr>;

        // Properties

        get is_referenced(): boolean;
        get isReferenced(): boolean;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Attr.SignalSignatures;

        // Fields

        prop: Property;

        // Constructors

        constructor(properties?: Partial<Attr.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](element: DomElement, name: string, val: string): Attr;
        // Conflicted with GXml.Node.new

        static ['new'](...args: never[]): any;

        static namespace(
            element: DomElement,
            namespace_uri: string,
            prefix: string | null,
            name: string,
            val: string,
        ): Attr;

        static reference(element: DomElement, name: string): Attr;

        // Signals

        connect<K extends keyof Attr.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Attr.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Attr.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Attr.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Attr.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Attr.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_is_referenced(): boolean;

        // Inherited properties
        get namespace_uri(): string;
        get namespaceUri(): string;
        get prefix(): string;
        get local_name(): string;
        get localName(): string;
        get name(): string;
        get value(): string;
        set value(val: string);

        // Inherited methods
        get_namespace_uri(): string | null;
        get_prefix(): string | null;
        get_local_name(): string;
        get_name(): string;
        get_value(): string;
        set_value(value: string): void;
        get_specified(): boolean;
        vfunc_get_namespace_uri(): string | null;
        vfunc_get_prefix(): string | null;
        vfunc_get_local_name(): string;
        vfunc_get_name(): string;
        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
        vfunc_get_specified(): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BaseCollection {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::nodes-index': (pspec: GObject.ParamSpec) => void;
            'notify::element': (pspec: GObject.ParamSpec) => void;
            'notify::items-name': (pspec: GObject.ParamSpec) => void;
            'notify::items-type': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                Gee.Traversable.ConstructorProps,
                Gee.Iterable.ConstructorProps,
                Collection.ConstructorProps {}
    }

    abstract class BaseCollection extends GObject.Object implements Gee.Traversable, Gee.Iterable, Collection {
        static $gtype: GObject.GType<BaseCollection>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BaseCollection.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BaseCollection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof BaseCollection.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BaseCollection.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BaseCollection.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BaseCollection.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BaseCollection.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BaseCollection.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_validate_append(index: number, element: DomElement): boolean;
        vfunc_clear(): void;

        // Methods

        initialize_element(e: Element): void;
        validate_append(index: number, element: DomElement): boolean;
        clear(): void;

        // Inherited properties
        get nodes_index(): GLib.Queue;
        get nodesIndex(): GLib.Queue;
        get element(): DomElement;
        set element(val: DomElement);
        get items_name(): string;
        get itemsName(): string;
        get items_type(): GObject.GType;
        set items_type(val: GObject.GType);
        get itemsType(): GObject.GType;
        set itemsType(val: GObject.GType);

        // Inherited methods
        foreach(f: Gee.ForallFunc): boolean;
        stream(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.StreamFunc): Gee.Iterator;
        fold(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): any;
        map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.MapFunc): Gee.Iterator;
        scan(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): Gee.Iterator;
        filter(pred: Gee.Predicate): Gee.Iterator;
        chop(offset: number, length: number): Gee.Iterator;
        flat_map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FlatMapFunc): Gee.Iterator;
        tee(forks: number): Gee.Iterator[];
        first_match(pred: Gee.Predicate): any | null;
        any_match(pred: Gee.Predicate): boolean;
        all_match(pred: Gee.Predicate): boolean;
        max(compare: GLib.CompareDataFunc): any;
        min(compare: GLib.CompareDataFunc): any;
        order_by(compare?: GLib.CompareDataFunc | null): Gee.Iterator;
        get_element_type(): GObject.GType;
        vfunc_foreach(f: Gee.ForallFunc): boolean;
        vfunc_stream(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.StreamFunc): Gee.Iterator;
        vfunc_fold(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): any;
        vfunc_map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.MapFunc): Gee.Iterator;
        vfunc_scan(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): Gee.Iterator;
        vfunc_filter(pred: Gee.Predicate): Gee.Iterator;
        vfunc_chop(offset: number, length: number): Gee.Iterator;
        vfunc_flat_map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FlatMapFunc): Gee.Iterator;
        vfunc_tee(forks: number): Gee.Iterator[];
        vfunc_first_match(pred: Gee.Predicate): any | null;
        vfunc_any_match(pred: Gee.Predicate): boolean;
        vfunc_all_match(pred: Gee.Predicate): boolean;
        vfunc_max(compare: GLib.CompareDataFunc): any;
        vfunc_min(compare: GLib.CompareDataFunc): any;
        vfunc_order_by(compare?: GLib.CompareDataFunc | null): Gee.Iterator;
        vfunc_get_element_type(): GObject.GType;
        iterator(): Gee.Iterator;
        vfunc_iterator(): Gee.Iterator;
        get_nodes_index(): GLib.Queue;
        get_element(): DomElement;
        set_element(value: DomElement): void;
        get_items_name(): string;
        get_items_type(): GObject.GType;
        set_items_type(value: GObject.GType): void;
        search(): void;
        get_item(index: number): DomElement | null;
        append(node: DomElement): void;
        get_length(): number;
        initialize(t: GObject.GType): void;
        create_item(): DomElement | null;
        vfunc_get_nodes_index(): GLib.Queue;
        vfunc_get_element(): DomElement;
        vfunc_set_element(value: DomElement): void;
        vfunc_get_items_name(): string;
        vfunc_get_items_type(): GObject.GType;
        vfunc_set_items_type(value: GObject.GType): void;
        vfunc_search(): void;
        vfunc_get_item(index: number): DomElement | null;
        vfunc_append(node: DomElement): void;
        vfunc_get_length(): number;
        vfunc_initialize(t: GObject.GType): void;
        vfunc_create_item(): DomElement | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CssSelector {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::selector-type': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::combiner': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            selector_type: CssSelectorType;
            selectorType: CssSelectorType;
            name: string;
            value: string;
            combiner: CssCombiner;
        }
    }

    class CssSelector extends GObject.Object {
        static $gtype: GObject.GType<CssSelector>;

        // Properties

        get selector_type(): CssSelectorType;
        set selector_type(val: CssSelectorType);
        get selectorType(): CssSelectorType;
        set selectorType(val: CssSelectorType);
        get name(): string;
        set name(val: string);
        get value(): string;
        set value(val: string);
        get combiner(): CssCombiner;
        set combiner(val: CssCombiner);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CssSelector.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CssSelector.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](t: CssSelectorType, name: string): CssSelector;

        static with_value(t: CssSelectorType, name: string, value: string): CssSelector;

        // Signals

        connect<K extends keyof CssSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssSelector.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CssSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssSelector.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CssSelector.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CssSelector.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_selector_type(): CssSelectorType;
        set_selector_type(value: CssSelectorType | null): void;
        get_name(): string;
        set_name(value: string): void;
        get_value(): string;
        set_value(value: string): void;
        get_combiner(): CssCombiner;
        set_combiner(value: CssCombiner | null): void;
    }

    namespace CssElementSelector {
        // Signal signatures
        interface SignalSignatures extends CssSelector.SignalSignatures {
            'notify::prefixed': (pspec: GObject.ParamSpec) => void;
            'notify::prefix': (pspec: GObject.ParamSpec) => void;
            'notify::local-name': (pspec: GObject.ParamSpec) => void;
            'notify::selector-type': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::combiner': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CssSelector.ConstructorProps {
            prefixed: boolean;
            prefix: string;
            local_name: string;
            localName: string;
        }
    }

    class CssElementSelector extends CssSelector {
        static $gtype: GObject.GType<CssElementSelector>;

        // Properties

        get prefixed(): boolean;
        get prefix(): string;
        set prefix(val: string);
        get local_name(): string;
        set local_name(val: string);
        get localName(): string;
        set localName(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CssElementSelector.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CssElementSelector.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](prefix: string | null, local_name: string): CssElementSelector;
        // Conflicted with GXml.CssSelector.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof CssElementSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssElementSelector.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CssElementSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssElementSelector.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CssElementSelector.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CssElementSelector.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_prefixed(): boolean;
        get_prefix(): string | null;
        set_prefix(value?: string | null): void;
        get_local_name(): string;
        set_local_name(value: string): void;
    }

    namespace CssAttributeSelector {
        // Signal signatures
        interface SignalSignatures extends CssSelector.SignalSignatures {
            'notify::prefix': (pspec: GObject.ParamSpec) => void;
            'notify::local-name': (pspec: GObject.ParamSpec) => void;
            'notify::selector-type': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::combiner': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CssSelector.ConstructorProps {
            prefix: string;
            local_name: string;
            localName: string;
        }
    }

    class CssAttributeSelector extends CssSelector {
        static $gtype: GObject.GType<CssAttributeSelector>;

        // Properties

        get prefix(): string;
        set prefix(val: string);
        get local_name(): string;
        set local_name(val: string);
        get localName(): string;
        set localName(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CssAttributeSelector.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CssAttributeSelector.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](prefix: string | null, local_name: string): CssAttributeSelector;
        // Conflicted with GXml.CssSelector.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof CssAttributeSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssAttributeSelector.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CssAttributeSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssAttributeSelector.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CssAttributeSelector.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CssAttributeSelector.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_prefix(): string | null;
        set_prefix(value?: string | null): void;
        get_local_name(): string;
        set_local_name(value: string): void;
    }

    namespace CssNotSelector {
        // Signal signatures
        interface SignalSignatures extends CssSelector.SignalSignatures {
            'notify::selectors': (pspec: GObject.ParamSpec) => void;
            'notify::selector-type': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::combiner': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CssSelector.ConstructorProps {
            selectors: Gee.List;
        }
    }

    class CssNotSelector extends CssSelector {
        static $gtype: GObject.GType<CssNotSelector>;

        // Properties

        get selectors(): Gee.List;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CssNotSelector.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CssNotSelector.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): CssNotSelector;

        // Signals

        connect<K extends keyof CssNotSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssNotSelector.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CssNotSelector.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssNotSelector.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CssNotSelector.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CssNotSelector.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_selectors(): Gee.List;
    }

    namespace CssSelectorParser {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::selectors': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            selectors: Gee.List;
        }
    }

    class CssSelectorParser extends GObject.Object {
        static $gtype: GObject.GType<CssSelectorParser>;

        // Properties

        get selectors(): Gee.List;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CssSelectorParser.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CssSelectorParser.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): CssSelectorParser;

        // Signals

        connect<K extends keyof CssSelectorParser.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssSelectorParser.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CssSelectorParser.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CssSelectorParser.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CssSelectorParser.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CssSelectorParser.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        parse(selectors: string): void;
        get_selectors(): Gee.List;
        match(element: DomElement): boolean;
        query_selector_all(element: DomElement): DomNodeList;
    }

    namespace Document {
        // Signal signatures
        interface SignalSignatures extends Node.SignalSignatures {
            'notify::children': (pspec: GObject.ParamSpec) => void;
            'notify::first-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::last-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::child-element-count': (pspec: GObject.ParamSpec) => void;
            'notify::implementation': (pspec: GObject.ParamSpec) => void;
            'notify::url': (pspec: GObject.ParamSpec) => void;
            'notify::document-uri': (pspec: GObject.ParamSpec) => void;
            'notify::origin': (pspec: GObject.ParamSpec) => void;
            'notify::compat-mode': (pspec: GObject.ParamSpec) => void;
            'notify::character-set': (pspec: GObject.ParamSpec) => void;
            'notify::content-type': (pspec: GObject.ParamSpec) => void;
            'notify::doctype': (pspec: GObject.ParamSpec) => void;
            'notify::document-element': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Node.ConstructorProps,
                DomParentNode.ConstructorProps,
                DomNonElementParentNode.ConstructorProps,
                DomDocument.ConstructorProps,
                DomXMLDocument.ConstructorProps {}
    }

    class Document extends Node implements DomParentNode, DomNonElementParentNode, DomDocument, DomXMLDocument {
        static $gtype: GObject.GType<Document>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Document.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Document.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Document;

        static from_path(path: string): Document;

        static from_uri(uri: string): Document;

        static from_file(file: Gio.File): Document;

        static from_stream(stream: Gio.InputStream): Document;

        static from_string(str: string): Document;

        // Signals

        connect<K extends keyof Document.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Document.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Document.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Document.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Document.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Document.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        search_root_element_property(): Element;

        // Inherited properties
        get children(): DomHTMLCollection;
        get first_element_child(): DomElement;
        get firstElementChild(): DomElement;
        get last_element_child(): DomElement;
        get lastElementChild(): DomElement;
        get child_element_count(): number;
        get childElementCount(): number;
        get implementation(): DomImplementation;
        get url(): string;
        get document_uri(): string;
        get documentUri(): string;
        get origin(): string;
        get compat_mode(): string;
        get compatMode(): string;
        get character_set(): string;
        get characterSet(): string;
        get content_type(): string;
        get contentType(): string;
        get doctype(): DomDocumentType;
        get document_element(): DomElement;
        get documentElement(): DomElement;

        // Inherited methods
        get_children(): DomHTMLCollection;
        get_first_element_child(): DomElement | null;
        get_last_element_child(): DomElement | null;
        get_child_element_count(): number;
        query_selector(selectors: string): DomElement | null;
        query_selector_all(selectors: string): DomNodeList;
        get_elements_by_property_value(property: string, value: string): DomElementList;
        vfunc_get_children(): DomHTMLCollection;
        vfunc_get_first_element_child(): DomElement | null;
        vfunc_get_last_element_child(): DomElement | null;
        vfunc_get_child_element_count(): number;
        vfunc_query_selector(selectors: string): DomElement | null;
        vfunc_query_selector_all(selectors: string): DomNodeList;
        vfunc_get_elements_by_property_value(property: string, value: string): DomElementList;
        get_element_by_id(element_id: string): DomElement | null;
        vfunc_get_element_by_id(element_id: string): DomElement | null;
        get_implementation(): DomImplementation;
        get_url(): string;
        get_document_uri(): string;
        get_origin(): string;
        get_compat_mode(): string;
        get_character_set(): string;
        get_content_type(): string;
        get_doctype(): DomDocumentType | null;
        get_document_element(): DomElement | null;
        get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        get_elements_by_class_name(classNames: string): DomHTMLCollection;
        create_element(local_name: string): DomElement;
        create_element_ns(namespace: string | null, qualified_name: string): DomElement;
        create_document_fragment(): DomDocumentFragment;
        create_text_node(data: string): DomText;
        create_comment(data: string): DomComment;
        create_processing_instruction(target: string, data: string): DomProcessingInstruction;
        import_node(node: DomNode, deep: boolean): DomNode;
        adopt_node(node: DomNode): DomNode;
        create_event(_interface: string): DomEvent;
        create_range(): DomRange;
        create_node_iterator(root: DomNode, whatToShow: number): DomNodeIterator;
        create_tree_walker(root: DomNode, what_to_show: number): DomTreeWalker;
        write_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        write_file_async(file: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_file_async(
            file: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_stream(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): void;
        write_stream_async(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<Gio.InputStream>;
        create_stream_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        write_string(cancellable?: Gio.Cancellable | null): string;
        write_string_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<string>;
        write_string_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        read_from_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        read_from_file_async(file: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_file_async(
            file: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_file_finish(_res_: Gio.AsyncResult): void;
        read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        read_from_string_async(str: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_string_async(
            str: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_string_finish(_res_: Gio.AsyncResult): void;
        read_from_stream(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        read_from_stream_async(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_stream_async(
            stream: Gio.InputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_stream_async(
            stream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_stream_finish(_res_: Gio.AsyncResult): void;
        get_xml_parser(): Parser;
        set_xml_parser(parser: Parser): void;
        vfunc_get_implementation(): DomImplementation;
        vfunc_get_url(): string;
        vfunc_get_document_uri(): string;
        vfunc_get_origin(): string;
        vfunc_get_compat_mode(): string;
        vfunc_get_character_set(): string;
        vfunc_get_content_type(): string;
        vfunc_get_doctype(): DomDocumentType | null;
        vfunc_get_document_element(): DomElement | null;
        vfunc_get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_class_name(classNames: string): DomHTMLCollection;
        vfunc_create_element(local_name: string): DomElement;
        vfunc_create_element_ns(namespace: string | null, qualified_name: string): DomElement;
        vfunc_create_document_fragment(): DomDocumentFragment;
        vfunc_create_text_node(data: string): DomText;
        vfunc_create_comment(data: string): DomComment;
        vfunc_create_processing_instruction(target: string, data: string): DomProcessingInstruction;
        vfunc_import_node(node: DomNode, deep: boolean): DomNode;
        vfunc_adopt_node(node: DomNode): DomNode;
        vfunc_create_event(_interface: string): DomEvent;
        vfunc_create_range(): DomRange;
        vfunc_create_node_iterator(root: DomNode, whatToShow: number): DomNodeIterator;
        vfunc_create_tree_walker(root: DomNode, what_to_show: number): DomTreeWalker;
        vfunc_write_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_stream(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        vfunc_write_string(cancellable?: Gio.Cancellable | null): string;
        vfunc_write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_read_from_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_stream(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_stream_async(
            stream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_get_xml_parser(): Parser;
        vfunc_set_xml_parser(parser: Parser): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Implementation {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DomImplementation.ConstructorProps {}
    }

    class Implementation extends GObject.Object implements DomImplementation {
        static $gtype: GObject.GType<Implementation>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Implementation.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Implementation.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Implementation;

        // Signals

        connect<K extends keyof Implementation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Implementation.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Implementation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Implementation.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Implementation.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Implementation.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        create_document_type(qualified_name: string, public_id: string, system_id: string): DomDocumentType;
        create_document(
            nspace?: string | null,
            qualified_name?: string | null,
            doctype?: DomDocumentType | null,
        ): DomXMLDocument;
        create_html_document(title: string): DomDocument;
        has_feature(): boolean;
        vfunc_create_document_type(qualified_name: string, public_id: string, system_id: string): DomDocumentType;
        vfunc_create_document(
            nspace?: string | null,
            qualified_name?: string | null,
            doctype?: DomDocumentType | null,
        ): DomXMLDocument;
        vfunc_create_html_document(title: string): DomDocument;
        vfunc_has_feature(): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DocumentType {
        // Signal signatures
        interface SignalSignatures extends Node.SignalSignatures {
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::public-id': (pspec: GObject.ParamSpec) => void;
            'notify::system-id': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Node.ConstructorProps,
                DomChildNode.ConstructorProps,
                DomDocumentType.ConstructorProps {}
    }

    class DocumentType extends Node implements DomChildNode, DomDocumentType {
        static $gtype: GObject.GType<DocumentType>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DocumentType.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DocumentType.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            doc: DomDocument,
            name: string,
            public_id?: string | null,
            system_id?: string | null,
        ): DocumentType;
        // Conflicted with GXml.Node.new

        static ['new'](...args: never[]): any;

        static with_name(doc: DomDocument, name: string): DocumentType;

        static with_ids(doc: DomDocument, name: string, public_id: string, system_id: string): DocumentType;

        // Signals

        connect<K extends keyof DocumentType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DocumentType.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DocumentType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DocumentType.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DocumentType.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DocumentType.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get name(): string;
        get public_id(): string;
        get publicId(): string;
        get system_id(): string;
        get systemId(): string;

        // Inherited methods
        remove(): void;
        vfunc_remove(): void;
        get_name(): string;
        get_public_id(): string;
        get_system_id(): string;
        vfunc_get_name(): string;
        vfunc_get_public_id(): string;
        vfunc_get_system_id(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DocumentFragment {
        // Signal signatures
        interface SignalSignatures extends Node.SignalSignatures {
            'notify::children': (pspec: GObject.ParamSpec) => void;
            'notify::first-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::last-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::child-element-count': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Node.ConstructorProps,
                DomParentNode.ConstructorProps,
                DomNonElementParentNode.ConstructorProps,
                DomDocumentFragment.ConstructorProps {}
    }

    class DocumentFragment extends Node implements DomParentNode, DomNonElementParentNode, DomDocumentFragment {
        static $gtype: GObject.GType<DocumentFragment>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DocumentFragment.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DocumentFragment.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: DomDocument): DocumentFragment;
        // Conflicted with GXml.Node.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof DocumentFragment.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DocumentFragment.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DocumentFragment.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DocumentFragment.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DocumentFragment.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DocumentFragment.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get children(): DomHTMLCollection;
        get first_element_child(): DomElement;
        get firstElementChild(): DomElement;
        get last_element_child(): DomElement;
        get lastElementChild(): DomElement;
        get child_element_count(): number;
        get childElementCount(): number;

        // Inherited methods
        get_children(): DomHTMLCollection;
        get_first_element_child(): DomElement | null;
        get_last_element_child(): DomElement | null;
        get_child_element_count(): number;
        query_selector(selectors: string): DomElement | null;
        query_selector_all(selectors: string): DomNodeList;
        get_elements_by_property_value(property: string, value: string): DomElementList;
        vfunc_get_children(): DomHTMLCollection;
        vfunc_get_first_element_child(): DomElement | null;
        vfunc_get_last_element_child(): DomElement | null;
        vfunc_get_child_element_count(): number;
        vfunc_query_selector(selectors: string): DomElement | null;
        vfunc_query_selector_all(selectors: string): DomNodeList;
        vfunc_get_elements_by_property_value(property: string, value: string): DomElementList;
        get_element_by_id(element_id: string): DomElement | null;
        vfunc_get_element_by_id(element_id: string): DomElement | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DomNodeFilter {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class DomNodeFilter extends GObject.Object {
        static $gtype: GObject.GType<DomNodeFilter>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DomNodeFilter.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DomNodeFilter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DomNodeFilter;

        // Signals

        connect<K extends keyof DomNodeFilter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomNodeFilter.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DomNodeFilter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomNodeFilter.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DomNodeFilter.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DomNodeFilter.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace DomElementList {
        // Signal signatures
        interface SignalSignatures extends Gee.ArrayList.SignalSignatures {
            'notify::g-type': (pspec: GObject.ParamSpec) => void;
            'notify::g-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::g-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gee.ArrayList.ConstructorProps, DomHTMLCollection.ConstructorProps {}
    }

    class DomElementList extends Gee.ArrayList implements DomHTMLCollection {
        static $gtype: GObject.GType<DomElementList>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DomElementList.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DomElementList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DomElementList;

        // Signals

        connect<K extends keyof DomElementList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomElementList.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DomElementList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomElementList.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DomElementList.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DomElementList.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        get_element(index: number): DomElement | null;
        to_array(): DomElement[];
        // Conflicted with Gee.Collection.to_array
        to_array(...args: never[]): any;
        get_length(): number;
        item(index: number): DomElement | null;
        named_item(name: string): DomElement | null;
        vfunc_get_element(index: number): DomElement | null;
        vfunc_to_array(): DomElement[];
        // Conflicted with Gee.Collection.vfunc_to_array
        vfunc_to_array(...args: never[]): any;
        vfunc_get_length(): number;
        vfunc_item(index: number): DomElement | null;
        vfunc_named_item(name: string): DomElement | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractList.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace DomEventInit {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::bubbles': (pspec: GObject.ParamSpec) => void;
            'notify::cancelable': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            bubbles: boolean;
            cancelable: boolean;
        }
    }

    class DomEventInit extends GObject.Object {
        static $gtype: GObject.GType<DomEventInit>;

        // Properties

        get bubbles(): boolean;
        set bubbles(val: boolean);
        get cancelable(): boolean;
        set cancelable(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DomEventInit.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DomEventInit.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DomEventInit;

        // Signals

        connect<K extends keyof DomEventInit.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomEventInit.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DomEventInit.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomEventInit.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DomEventInit.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DomEventInit.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_bubbles(): boolean;
        set_bubbles(value: boolean): void;
        get_cancelable(): boolean;
        set_cancelable(value: boolean): void;
    }

    namespace DomCustomEventInit {
        // Signal signatures
        interface SignalSignatures extends DomEventInit.SignalSignatures {
            'notify::detail': (pspec: GObject.ParamSpec) => void;
            'notify::bubbles': (pspec: GObject.ParamSpec) => void;
            'notify::cancelable': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends DomEventInit.ConstructorProps {
            detail: GObject.Value;
        }
    }

    class DomCustomEventInit extends DomEventInit {
        static $gtype: GObject.GType<DomCustomEventInit>;

        // Properties

        get detail(): GObject.Value;
        set detail(val: GObject.Value);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DomCustomEventInit.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DomCustomEventInit.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DomCustomEventInit;

        // Signals

        connect<K extends keyof DomCustomEventInit.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomCustomEventInit.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DomCustomEventInit.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomCustomEventInit.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DomCustomEventInit.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DomCustomEventInit.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_detail(): unknown;
        set_detail(value: GObject.Value | any): void;
    }

    namespace DomTimeStamp {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::time': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            time: GLib.DateTime;
        }
    }

    class DomTimeStamp extends GObject.Object {
        static $gtype: GObject.GType<DomTimeStamp>;

        // Properties

        get time(): GLib.DateTime;
        set time(val: GLib.DateTime);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DomTimeStamp.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DomTimeStamp.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DomTimeStamp;

        // Signals

        connect<K extends keyof DomTimeStamp.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomTimeStamp.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DomTimeStamp.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomTimeStamp.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DomTimeStamp.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DomTimeStamp.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_time(): GLib.DateTime;
        set_time(value: GLib.DateTime): void;
        to_string(): string;
    }

    namespace DomMutationObserverInit {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::child-list': (pspec: GObject.ParamSpec) => void;
            'notify::attributes': (pspec: GObject.ParamSpec) => void;
            'notify::character-data': (pspec: GObject.ParamSpec) => void;
            'notify::subtree': (pspec: GObject.ParamSpec) => void;
            'notify::attribute-old-value': (pspec: GObject.ParamSpec) => void;
            'notify::character-data-old-value': (pspec: GObject.ParamSpec) => void;
            'notify::attribute-filter': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            child_list: boolean;
            childList: boolean;
            attributes: boolean;
            character_data: boolean;
            characterData: boolean;
            subtree: boolean;
            attribute_old_value: boolean;
            attributeOldValue: boolean;
            character_data_old_value: boolean;
            characterDataOldValue: boolean;
            attribute_filter: Gee.List;
            attributeFilter: Gee.List;
        }
    }

    class DomMutationObserverInit extends GObject.Object {
        static $gtype: GObject.GType<DomMutationObserverInit>;

        // Properties

        get child_list(): boolean;
        set child_list(val: boolean);
        get childList(): boolean;
        set childList(val: boolean);
        get attributes(): boolean;
        set attributes(val: boolean);
        get character_data(): boolean;
        set character_data(val: boolean);
        get characterData(): boolean;
        set characterData(val: boolean);
        get subtree(): boolean;
        set subtree(val: boolean);
        get attribute_old_value(): boolean;
        set attribute_old_value(val: boolean);
        get attributeOldValue(): boolean;
        set attributeOldValue(val: boolean);
        get character_data_old_value(): boolean;
        set character_data_old_value(val: boolean);
        get characterDataOldValue(): boolean;
        set characterDataOldValue(val: boolean);
        get attribute_filter(): Gee.List;
        set attribute_filter(val: Gee.List);
        get attributeFilter(): Gee.List;
        set attributeFilter(val: Gee.List);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DomMutationObserverInit.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DomMutationObserverInit.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DomMutationObserverInit;

        // Signals

        connect<K extends keyof DomMutationObserverInit.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomMutationObserverInit.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DomMutationObserverInit.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomMutationObserverInit.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DomMutationObserverInit.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DomMutationObserverInit.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_child_list(): boolean;
        set_child_list(value: boolean): void;
        get_attributes(): boolean;
        set_attributes(value: boolean): void;
        get_character_data(): boolean;
        set_character_data(value: boolean): void;
        get_subtree(): boolean;
        set_subtree(value: boolean): void;
        get_attribute_old_value(): boolean;
        set_attribute_old_value(value: boolean): void;
        get_character_data_old_value(): boolean;
        set_character_data_old_value(value: boolean): void;
        get_attribute_filter(): Gee.List;
        set_attribute_filter(value: Gee.List): void;
    }

    namespace DomErrorName {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class DomErrorName extends GObject.Object {
        static $gtype: GObject.GType<DomErrorName>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DomErrorName.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DomErrorName.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DomErrorName;

        // Signals

        connect<K extends keyof DomErrorName.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomErrorName.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DomErrorName.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DomErrorName.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DomErrorName.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DomErrorName.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_name(error_code: number): string;
        get_code(error_name: string): number;
    }

    namespace Element {
        // Signal signatures
        interface SignalSignatures extends Node.SignalSignatures {
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
            'notify::previous-element-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::next-element-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::children': (pspec: GObject.ParamSpec) => void;
            'notify::first-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::last-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::child-element-count': (pspec: GObject.ParamSpec) => void;
            'notify::namespace-uri': (pspec: GObject.ParamSpec) => void;
            'notify::prefix': (pspec: GObject.ParamSpec) => void;
            'notify::local-name': (pspec: GObject.ParamSpec) => void;
            'notify::tag-name': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::class-name': (pspec: GObject.ParamSpec) => void;
            'notify::class-list': (pspec: GObject.ParamSpec) => void;
            'notify::attributes': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Node.ConstructorProps,
                DomChildNode.ConstructorProps,
                DomNonDocumentTypeChildNode.ConstructorProps,
                DomParentNode.ConstructorProps,
                DomElement.ConstructorProps,
                Object.ConstructorProps {
            parse_children: boolean;
            parseChildren: boolean;
            unparsed: string;
            read_buffer: Gio.MemoryOutputStream;
            readBuffer: Gio.MemoryOutputStream;
        }
    }

    class Element extends Node implements DomChildNode, DomNonDocumentTypeChildNode, DomParentNode, DomElement, Object {
        static $gtype: GObject.GType<Element>;

        // Properties

        get parse_children(): boolean;
        set parse_children(val: boolean);
        get parseChildren(): boolean;
        set parseChildren(val: boolean);
        get unparsed(): string;
        set unparsed(val: string);
        get read_buffer(): Gio.MemoryOutputStream;
        set read_buffer(val: Gio.MemoryOutputStream);
        get readBuffer(): Gio.MemoryOutputStream;
        set readBuffer(val: Gio.MemoryOutputStream);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Element.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Element.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Element;

        // Signals

        connect<K extends keyof Element.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Element.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Element.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Element.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Element.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Element.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        lookup_prefix(nspace?: string | null): string | null;
        lookup_namespace_uri(prefix?: string | null): string | null;
        initialize(local_name: string): void;
        initialize_document(doc: DomDocument, local_name: string): void;
        initialize_with_namespace(namespace_uri: string | null, prefix: string | null, local_name: string): void;
        initialize_document_with_namespace(
            doc: DomDocument,
            namespace_uri: string | null,
            prefix: string | null,
            local_name: string,
        ): void;
        get_parse_children(): boolean;
        set_parse_children(value: boolean): void;
        get_unparsed(): string;
        set_unparsed(value: string): void;
        read_unparsed(): void;
        get_read_buffer(): Gio.MemoryOutputStream;
        set_read_buffer(value: Gio.MemoryOutputStream): void;
        parse_buffer(): void;
        parse_pending(): number;
        parse_buffer_async(): globalThis.Promise<void>;
        parse_buffer_async(_callback_: Gio.AsyncReadyCallback<this> | null): void;
        parse_buffer_async(_callback_?: Gio.AsyncReadyCallback<this> | null): globalThis.Promise<void> | void;
        parse_buffer_finish(_res_: Gio.AsyncResult): void;

        // Inherited properties
        get previous_element_sibling(): DomElement;
        get previousElementSibling(): DomElement;
        get next_element_sibling(): DomElement;
        get nextElementSibling(): DomElement;
        get children(): DomHTMLCollection;
        get first_element_child(): DomElement;
        get firstElementChild(): DomElement;
        get last_element_child(): DomElement;
        get lastElementChild(): DomElement;
        get child_element_count(): number;
        get childElementCount(): number;
        get namespace_uri(): string;
        get namespaceUri(): string;
        get prefix(): string;
        get local_name(): string;
        get localName(): string;
        get tag_name(): string;
        get tagName(): string;
        get id(): string;
        set id(val: string);
        get class_name(): string;
        set class_name(val: string);
        get className(): string;
        set className(val: string);
        get class_list(): DomTokenList;
        get classList(): DomTokenList;
        get attributes(): DomNamedNodeMap;

        // Inherited methods
        remove(): void;
        vfunc_remove(): void;
        get_previous_element_sibling(): DomElement | null;
        get_next_element_sibling(): DomElement | null;
        vfunc_get_previous_element_sibling(): DomElement | null;
        vfunc_get_next_element_sibling(): DomElement | null;
        get_children(): DomHTMLCollection;
        get_first_element_child(): DomElement | null;
        get_last_element_child(): DomElement | null;
        get_child_element_count(): number;
        query_selector(selectors: string): DomElement | null;
        query_selector_all(selectors: string): DomNodeList;
        get_elements_by_property_value(property: string, value: string): DomElementList;
        vfunc_get_children(): DomHTMLCollection;
        vfunc_get_first_element_child(): DomElement | null;
        vfunc_get_last_element_child(): DomElement | null;
        vfunc_get_child_element_count(): number;
        vfunc_query_selector(selectors: string): DomElement | null;
        vfunc_query_selector_all(selectors: string): DomNodeList;
        vfunc_get_elements_by_property_value(property: string, value: string): DomElementList;
        get_namespace_uri(): string | null;
        get_prefix(): string | null;
        get_local_name(): string;
        get_tag_name(): string;
        get_id(): string | null;
        set_id(value?: string | null): void;
        get_class_name(): string | null;
        set_class_name(value?: string | null): void;
        get_class_list(): DomTokenList;
        get_attributes(): DomNamedNodeMap;
        get_attribute(name: string): string | null;
        get_attribute_ns(namespace: string | null, local_name: string): string | null;
        set_attribute(name: string, value: string): void;
        // Conflicted with GXml.Object.set_attribute
        set_attribute(...args: never[]): any;
        set_attribute_ns(namespace: string | null, name: string, value: string): void;
        remove_attribute(name: string): void;
        // Conflicted with GXml.Object.remove_attribute
        remove_attribute(...args: never[]): any;
        remove_attribute_ns(namespace: string | null, local_name: string): void;
        has_attribute(name: string): boolean;
        has_attribute_ns(namespace: string | null, local_name: string): boolean;
        get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        get_elements_by_class_name(class_names: string): DomHTMLCollection;
        matches(selectors: string): boolean;
        read_from_uri(uri: string): void;
        read_from_uri_async(uri: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_uri_async(
            uri: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_uri_async(
            uri: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_uri_finish(_res_: Gio.AsyncResult): void;
        read_from_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        read_from_file_async(f: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_file_async(
            f: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_file_finish(_res_: Gio.AsyncResult): void;
        read_from_stream(istream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
        ): globalThis.Promise<void>;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_stream_finish(_res_: Gio.AsyncResult): void;
        read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        read_from_string_async(str: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_string_async(
            str: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_string_finish(_res_: Gio.AsyncResult): void;
        write_string(cancellable?: Gio.Cancellable | null): string;
        write_string_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<string>;
        write_string_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        write_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        write_file_async(f: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_file_async(
            f: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_stream(stream: Gio.OutputStream): void;
        write_stream_async(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<Gio.InputStream>;
        create_stream_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        vfunc_get_namespace_uri(): string | null;
        vfunc_get_prefix(): string | null;
        vfunc_get_local_name(): string;
        vfunc_get_tag_name(): string;
        vfunc_get_id(): string | null;
        vfunc_set_id(value?: string | null): void;
        vfunc_get_class_name(): string | null;
        vfunc_set_class_name(value?: string | null): void;
        vfunc_get_class_list(): DomTokenList;
        vfunc_get_attributes(): DomNamedNodeMap;
        vfunc_get_attribute(name: string): string | null;
        vfunc_get_attribute_ns(namespace: string | null, local_name: string): string | null;
        vfunc_set_attribute(name: string, value: string): void;
        // Conflicted with GXml.Object.vfunc_set_attribute
        vfunc_set_attribute(...args: never[]): any;
        vfunc_set_attribute_ns(namespace: string | null, name: string, value: string): void;
        vfunc_remove_attribute(name: string): void;
        // Conflicted with GXml.Object.vfunc_remove_attribute
        vfunc_remove_attribute(...args: never[]): any;
        vfunc_remove_attribute_ns(namespace: string | null, local_name: string): void;
        vfunc_has_attribute(name: string): boolean;
        vfunc_has_attribute_ns(namespace: string | null, local_name: string): boolean;
        vfunc_get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_class_name(class_names: string): DomHTMLCollection;
        vfunc_matches(selectors: string): boolean;
        vfunc_read_from_uri(uri: string): void;
        vfunc_read_from_uri_async(
            uri: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_uri_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_stream(istream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_string(cancellable?: Gio.Cancellable | null): string;
        vfunc_write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_write_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_stream(stream: Gio.OutputStream): void;
        vfunc_write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        get_properties_list(): GObject.ParamSpec[];
        find_property_name(nick: string): GObject.ParamSpec | null;
        find_object_property_name(pname: string): GObject.ParamSpec | null;
        get_property_element_list(): GObject.ParamSpec[];
        get_property_string(prop: GObject.ParamSpec): string | null;
        find_property(name: string): Property | null;
        get_child(name: string): DomElement | null;
        find_elements(name: string): DomElementList;
        set_instance_property(name: string): boolean;
        clean_property_elements(name: string): void;
        vfunc_get_properties_list(): GObject.ParamSpec[];
        vfunc_find_property_name(nick: string): GObject.ParamSpec | null;
        vfunc_find_object_property_name(pname: string): GObject.ParamSpec | null;
        vfunc_get_property_element_list(): GObject.ParamSpec[];
        vfunc_get_property_string(prop: GObject.ParamSpec): string | null;
        vfunc_find_property(name: string): Property | null;
        vfunc_get_child(name: string): DomElement | null;
        vfunc_find_elements(name: string): DomElementList;
        vfunc_set_instance_property(name: string): boolean;
        vfunc_clean_property_elements(name: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace ElementAttributes {
        // Signal signatures
        interface SignalSignatures extends Gee.HashMap.SignalSignatures {
            'notify::k-type': (pspec: GObject.ParamSpec) => void;
            'notify::k-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::k-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::v-type': (pspec: GObject.ParamSpec) => void;
            'notify::v-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::v-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
            'notify::keys': (pspec: GObject.ParamSpec) => void;
            'notify::values': (pspec: GObject.ParamSpec) => void;
            'notify::entries': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gee.HashMap.ConstructorProps, DomNamedNodeMap.ConstructorProps {}
    }

    class ElementAttributes extends Gee.HashMap implements DomNamedNodeMap {
        static $gtype: GObject.GType<ElementAttributes>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ElementAttributes.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ElementAttributes.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](element: Element): ElementAttributes;
        // Conflicted with Gee.HashMap.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof ElementAttributes.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ElementAttributes.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ElementAttributes.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ElementAttributes.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ElementAttributes.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ElementAttributes.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        add_reference(name: string): void;

        // Inherited properties
        get length(): number;

        // Inherited methods
        get_length(): number;
        item(index: number): DomNode | null;
        get_named_item(name: string): DomNode | null;
        set_named_item(node: DomNode): DomNode | null;
        remove_named_item(name: string): DomNode | null;
        remove_named_item_ns(namespace_uri: string, localName: string): DomNode | null;
        get_named_item_ns(namespace_uri: string, local_name: string): DomNode | null;
        set_named_item_ns(node: DomNode): DomNode | null;
        vfunc_get_length(): number;
        vfunc_item(index: number): DomNode | null;
        vfunc_get_named_item(name: string): DomNode | null;
        vfunc_set_named_item(node: DomNode): DomNode | null;
        vfunc_remove_named_item(name: string): DomNode | null;
        vfunc_remove_named_item_ns(namespace_uri: string, localName: string): DomNode | null;
        vfunc_get_named_item_ns(namespace_uri: string, local_name: string): DomNode | null;
        vfunc_set_named_item_ns(node: DomNode): DomNode | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractMap.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Enumeration {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}
    }

    class Enumeration {
        static $gtype: GObject.GType<Enumeration>;

        // Fields

        ref_count: number;

        // Constructors

        _init(...args: any[]): void;

        static ['new'](): Enumeration;

        // Signals

        connect<K extends keyof Enumeration.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Enumeration.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Enumeration.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Enumeration.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Enumeration.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Enumeration.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static get_nick(enumeration: GObject.GType, val: number): string;
        static get_nick_camelcase(enumeration: GObject.GType, val: number): string;
        static get_string(enumeration: GObject.GType, val: number, use_nick: boolean, camelcase: boolean): string;
        static parse(enumeration: GObject.GType, val: string): GObject.EnumValue | null;
        static to_array(enumeration: GObject.GType): GObject.EnumValue[];
        static parse_integer(enumeration: GObject.GType, val: number): GObject.EnumValue | null;
        static to_string_array(enumeration: GObject.GType): string[];
    }

    namespace Event {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::etype': (pspec: GObject.ParamSpec) => void;
            'notify::event-target': (pspec: GObject.ParamSpec) => void;
            'notify::current-target': (pspec: GObject.ParamSpec) => void;
            'notify::bubbles': (pspec: GObject.ParamSpec) => void;
            'notify::cancelable': (pspec: GObject.ParamSpec) => void;
            'notify::is-trusted': (pspec: GObject.ParamSpec) => void;
            'notify::time-stamp': (pspec: GObject.ParamSpec) => void;
            'notify::default-prevented': (pspec: GObject.ParamSpec) => void;
            'notify::event-phase': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DomEvent.ConstructorProps {}
    }

    class Event extends GObject.Object implements DomEvent {
        static $gtype: GObject.GType<Event>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Event.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Event.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Event;

        // Signals

        connect<K extends keyof Event.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Event.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Event.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Event.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Event.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Event.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get etype(): string;
        get event_target(): DomEventTarget;
        get eventTarget(): DomEventTarget;
        get current_target(): DomEventTarget;
        get currentTarget(): DomEventTarget;
        get bubbles(): boolean;
        get cancelable(): boolean;
        get is_trusted(): boolean;
        get isTrusted(): boolean;
        get time_stamp(): DomTimeStamp;
        get timeStamp(): DomTimeStamp;
        get default_prevented(): boolean;
        get defaultPrevented(): boolean;
        get event_phase(): DomEventPhase;
        get eventPhase(): DomEventPhase;

        // Inherited methods
        get_etype(): string;
        get_event_target(): DomEventTarget | null;
        get_current_target(): DomEventTarget | null;
        get_bubbles(): boolean;
        get_cancelable(): boolean;
        get_is_trusted(): boolean;
        get_time_stamp(): DomTimeStamp;
        get_default_prevented(): boolean;
        get_event_phase(): DomEventPhase;
        stop_propagation(): void;
        stop_immediate_propagation(): void;
        prevent_default(): void;
        init_event(type: string, bubbles: boolean, cancelable: boolean): void;
        vfunc_get_etype(): string;
        vfunc_get_event_target(): DomEventTarget | null;
        vfunc_get_current_target(): DomEventTarget | null;
        vfunc_get_bubbles(): boolean;
        vfunc_get_cancelable(): boolean;
        vfunc_get_is_trusted(): boolean;
        vfunc_get_time_stamp(): DomTimeStamp;
        vfunc_get_default_prevented(): boolean;
        vfunc_get_event_phase(): DomEventPhase;
        vfunc_stop_propagation(): void;
        vfunc_stop_immediate_propagation(): void;
        vfunc_prevent_default(): void;
        vfunc_init_event(type: string, bubbles: boolean, cancelable: boolean): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CustomEvent {
        // Signal signatures
        interface SignalSignatures extends Event.SignalSignatures {
            'notify::detail': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Event.ConstructorProps {
            detail: GObject.Value;
        }
    }

    class CustomEvent extends Event {
        static $gtype: GObject.GType<CustomEvent>;

        // Properties

        get detail(): GObject.Value;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CustomEvent.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CustomEvent.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): CustomEvent;

        // Signals

        connect<K extends keyof CustomEvent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CustomEvent.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CustomEvent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CustomEvent.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CustomEvent.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CustomEvent.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_detail(): unknown;
        init_custom_event(type: string, bubbles: boolean, cancelable: boolean, detail?: GObject.Value | null): void;
    }

    namespace HashMap {
        // Signal signatures
        interface SignalSignatures extends BaseCollection.SignalSignatures {
            'notify::attribute-key': (pspec: GObject.ParamSpec) => void;
            'notify::keys-set': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseCollection.ConstructorProps, Map.ConstructorProps {}
    }

    class HashMap extends BaseCollection implements Map {
        static $gtype: GObject.GType<HashMap>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HashMap.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HashMap.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HashMap;

        // Signals

        connect<K extends keyof HashMap.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HashMap.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HashMap.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HashMap.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HashMap.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HashMap.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        initialize_element_with_key(element: Element, items_type: GObject.GType, attribute_key: string): void;
        initialize_with_key(items_type: GObject.GType, attribute_key: string): void;
        get(key: string): DomElement | null;
        get_keys(): string[];

        // Inherited properties
        get attribute_key(): string;
        set attribute_key(val: string);
        get attributeKey(): string;
        set attributeKey(val: string);
        get keys_set(): Gee.Set;
        get keysSet(): Gee.Set;

        // Inherited methods
        get_attribute_key(): string;
        set_attribute_key(value: string): void;
        item(key: string): DomElement | null;
        has_key(key: string): boolean;
        get_keys_set(): Gee.Set;
        vfunc_get_attribute_key(): string;
        vfunc_set_attribute_key(value: string): void;
        vfunc_item(key: string): DomElement | null;
        vfunc_has_key(key: string): boolean;
        vfunc_get_keys_set(): Gee.Set;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HashPairedMap {
        // Signal signatures
        interface SignalSignatures extends BaseCollection.SignalSignatures {
            'notify::attribute-primary-key': (pspec: GObject.ParamSpec) => void;
            'notify::attribute-secondary-key': (pspec: GObject.ParamSpec) => void;
            'notify::primary-keys-set': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseCollection.ConstructorProps, PairedMap.ConstructorProps {}
    }

    class HashPairedMap extends BaseCollection implements PairedMap {
        static $gtype: GObject.GType<HashPairedMap>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HashPairedMap.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HashPairedMap.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HashPairedMap;

        // Signals

        connect<K extends keyof HashPairedMap.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HashPairedMap.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HashPairedMap.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HashPairedMap.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HashPairedMap.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HashPairedMap.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        initialize_element_with_keys(
            element: Element,
            items_type: GObject.GType,
            attribute_primary_key: string,
            attribute_secondary_key: string,
        ): void;
        initialize_with_keys(
            items_type: GObject.GType,
            attribute_primary_key: string,
            attribute_secondary_key: string,
        ): void;
        get(primary_key: string, secondary_key: string): DomElement | null;
        get_primary_keys(): string[];
        get_secondary_keys(pkey: string): string[];

        // Inherited properties
        get attribute_primary_key(): string;
        set attribute_primary_key(val: string);
        get attributePrimaryKey(): string;
        set attributePrimaryKey(val: string);
        get attribute_secondary_key(): string;
        set attribute_secondary_key(val: string);
        get attributeSecondaryKey(): string;
        set attributeSecondaryKey(val: string);
        get primary_keys_set(): Gee.Set;
        get primaryKeysSet(): Gee.Set;

        // Inherited methods
        get_attribute_primary_key(): string;
        set_attribute_primary_key(value: string): void;
        get_attribute_secondary_key(): string;
        set_attribute_secondary_key(value: string): void;
        get_primary_keys_set(): Gee.Set;
        item(primary_key: string, secondary_key: string): DomElement | null;
        has_primary_key(key: string): boolean;
        has_secondary_key(pkey: string, key: string): boolean;
        secondary_keys_set(pkey: string): Gee.Set;
        vfunc_get_attribute_primary_key(): string;
        vfunc_set_attribute_primary_key(value: string): void;
        vfunc_get_attribute_secondary_key(): string;
        vfunc_set_attribute_secondary_key(value: string): void;
        vfunc_get_primary_keys_set(): Gee.Set;
        vfunc_item(primary_key: string, secondary_key: string): DomElement | null;
        vfunc_has_primary_key(key: string): boolean;
        vfunc_has_secondary_key(pkey: string, key: string): boolean;
        vfunc_secondary_keys_set(pkey: string): Gee.Set;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HashThreeMap {
        // Signal signatures
        interface SignalSignatures extends BaseCollection.SignalSignatures {
            'notify::attribute-primary-key': (pspec: GObject.ParamSpec) => void;
            'notify::attribute-secondary-key': (pspec: GObject.ParamSpec) => void;
            'notify::attribute-third-key': (pspec: GObject.ParamSpec) => void;
            'notify::primary-keys-set': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseCollection.ConstructorProps, ThreeMap.ConstructorProps {}
    }

    class HashThreeMap extends BaseCollection implements ThreeMap {
        static $gtype: GObject.GType<HashThreeMap>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HashThreeMap.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HashThreeMap.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HashThreeMap;

        // Signals

        connect<K extends keyof HashThreeMap.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HashThreeMap.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HashThreeMap.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HashThreeMap.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HashThreeMap.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HashThreeMap.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        initialize_element_with_keys(
            element: Element,
            items_type: GObject.GType,
            attribute_primary_key: string,
            attribute_secondary_key: string,
            attribute_third_key: string,
        ): void;
        initialize_with_keys(
            items_type: GObject.GType,
            attribute_primary_key: string,
            attribute_secondary_key: string,
            attribute_third_key: string,
        ): void;
        get(primary_key: string, secondary_key: string, third_key: string): DomElement | null;
        get_primary_keys(): string[];
        get_secondary_keys(pkey: string): string[];
        get_third_keys(pkey: string, skey: string): string[];

        // Inherited properties
        get attribute_primary_key(): string;
        set attribute_primary_key(val: string);
        get attributePrimaryKey(): string;
        set attributePrimaryKey(val: string);
        get attribute_secondary_key(): string;
        set attribute_secondary_key(val: string);
        get attributeSecondaryKey(): string;
        set attributeSecondaryKey(val: string);
        get attribute_third_key(): string;
        set attribute_third_key(val: string);
        get attributeThirdKey(): string;
        set attributeThirdKey(val: string);
        get primary_keys_set(): Gee.Set;
        get primaryKeysSet(): Gee.Set;

        // Inherited methods
        get_attribute_primary_key(): string;
        set_attribute_primary_key(value: string): void;
        get_attribute_secondary_key(): string;
        set_attribute_secondary_key(value: string): void;
        get_attribute_third_key(): string;
        set_attribute_third_key(value: string): void;
        get_primary_keys_set(): Gee.Set;
        item(primary_key: string, secondary_key: string, third_key: string): DomElement | null;
        has_primary_key(key: string): boolean;
        has_secondary_key(pkey: string, key: string): boolean;
        has_third_key(pkey: string, skey: string, key: string): boolean;
        secondary_keys_set(pkey: string): Gee.Set;
        third_keys_set(pkey: string, skey: string): Gee.Set;
        vfunc_get_attribute_primary_key(): string;
        vfunc_set_attribute_primary_key(value: string): void;
        vfunc_get_attribute_secondary_key(): string;
        vfunc_set_attribute_secondary_key(value: string): void;
        vfunc_get_attribute_third_key(): string;
        vfunc_set_attribute_third_key(value: string): void;
        vfunc_get_primary_keys_set(): Gee.Set;
        vfunc_item(primary_key: string, secondary_key: string, third_key: string): DomElement | null;
        vfunc_has_primary_key(key: string): boolean;
        vfunc_has_secondary_key(pkey: string, key: string): boolean;
        vfunc_has_third_key(pkey: string, skey: string, key: string): boolean;
        vfunc_secondary_keys_set(pkey: string): Gee.Set;
        vfunc_third_keys_set(pkey: string, skey: string): Gee.Set;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HTMLCollection {
        // Signal signatures
        interface SignalSignatures extends Gee.ArrayList.SignalSignatures {
            'notify::g-type': (pspec: GObject.ParamSpec) => void;
            'notify::g-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::g-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gee.ArrayList.ConstructorProps, DomHTMLCollection.ConstructorProps {}
    }

    class HTMLCollection extends Gee.ArrayList implements DomHTMLCollection {
        static $gtype: GObject.GType<HTMLCollection>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HTMLCollection.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HTMLCollection.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HTMLCollection;

        // Signals

        connect<K extends keyof HTMLCollection.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HTMLCollection.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HTMLCollection.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HTMLCollection.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HTMLCollection.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HTMLCollection.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        get_element(index: number): DomElement | null;
        to_array(): DomElement[];
        // Conflicted with Gee.Collection.to_array
        to_array(...args: never[]): any;
        get_length(): number;
        item(index: number): DomElement | null;
        named_item(name: string): DomElement | null;
        vfunc_get_element(index: number): DomElement | null;
        vfunc_to_array(): DomElement[];
        // Conflicted with Gee.Collection.vfunc_to_array
        vfunc_to_array(...args: never[]): any;
        vfunc_get_length(): number;
        vfunc_item(index: number): DomElement | null;
        vfunc_named_item(name: string): DomElement | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractList.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace HtmlDocument {
        // Signal signatures
        interface SignalSignatures extends Document.SignalSignatures {
            'notify::html': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Document.ConstructorProps {
            html: DomElement;
        }
    }

    class HtmlDocument extends Document {
        static $gtype: GObject.GType<HtmlDocument>;

        // Properties

        get html(): DomElement;
        set html(val: DomElement);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HtmlDocument.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HtmlDocument.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HtmlDocument;

        // Signals

        connect<K extends keyof HtmlDocument.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HtmlDocument.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HtmlDocument.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HtmlDocument.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HtmlDocument.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HtmlDocument.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_html(): DomElement;
        set_html(value: DomElement): void;
    }

    namespace HtmlElement {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {}
    }

    class HtmlElement extends Element {
        static $gtype: GObject.GType<HtmlElement>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: HtmlElement.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<HtmlElement.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): HtmlElement;

        // Signals

        connect<K extends keyof HtmlElement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HtmlElement.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof HtmlElement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, HtmlElement.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof HtmlElement.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<HtmlElement.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace LXPathObject {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::object-type': (pspec: GObject.ParamSpec) => void;
            'notify::boolean-value': (pspec: GObject.ParamSpec) => void;
            'notify::string-value': (pspec: GObject.ParamSpec) => void;
            'notify::number-value': (pspec: GObject.ParamSpec) => void;
            'notify::nodeset': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, XPathObject.ConstructorProps {}
    }

    class LXPathObject extends GObject.Object implements XPathObject {
        static $gtype: GObject.GType<LXPathObject>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: LXPathObject.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<LXPathObject.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](document: XDocument, pointer?: any | null): LXPathObject;

        // Signals

        connect<K extends keyof LXPathObject.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, LXPathObject.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof LXPathObject.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, LXPathObject.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof LXPathObject.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<LXPathObject.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get object_type(): XPathObjectType;
        get objectType(): XPathObjectType;
        get boolean_value(): boolean;
        get booleanValue(): boolean;
        get string_value(): string;
        get stringValue(): string;
        get number_value(): number;
        get numberValue(): number;
        get nodeset(): DomHTMLCollection;

        // Inherited methods
        get_object_type(): XPathObjectType;
        get_boolean_value(): boolean;
        get_string_value(): string;
        get_number_value(): number;
        get_nodeset(): DomHTMLCollection;
        vfunc_get_object_type(): XPathObjectType;
        vfunc_get_boolean_value(): boolean;
        vfunc_get_string_value(): string;
        vfunc_get_number_value(): number;
        vfunc_get_nodeset(): DomHTMLCollection;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Node {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::node-type': (pspec: GObject.ParamSpec) => void;
            'notify::node-name': (pspec: GObject.ParamSpec) => void;
            'notify::base-uri': (pspec: GObject.ParamSpec) => void;
            'notify::owner-document': (pspec: GObject.ParamSpec) => void;
            'notify::parent-node': (pspec: GObject.ParamSpec) => void;
            'notify::parent-element': (pspec: GObject.ParamSpec) => void;
            'notify::child-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::previous-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::next-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::node-value': (pspec: GObject.ParamSpec) => void;
            'notify::text-content': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                DomEventTarget.ConstructorProps,
                DomNode.ConstructorProps {}
    }

    class Node extends GObject.Object implements DomEventTarget, DomNode {
        static $gtype: GObject.GType<Node>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Node.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Node.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Node;

        // Signals

        connect<K extends keyof Node.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Node.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Node.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Node.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Node.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Node.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get node_type(): DomNodeNodeType;
        get nodeType(): DomNodeNodeType;
        get node_name(): string;
        get nodeName(): string;
        get base_uri(): string;
        get baseUri(): string;
        get owner_document(): DomDocument;
        set owner_document(val: DomDocument);
        get ownerDocument(): DomDocument;
        set ownerDocument(val: DomDocument);
        get parent_node(): DomNode;
        get parentNode(): DomNode;
        get parent_element(): DomElement;
        get parentElement(): DomElement;
        get child_nodes(): DomNodeList;
        get childNodes(): DomNodeList;
        get first_child(): DomNode;
        get firstChild(): DomNode;
        get last_child(): DomNode;
        get lastChild(): DomNode;
        get previous_sibling(): DomNode;
        get previousSibling(): DomNode;
        get next_sibling(): DomNode;
        get nextSibling(): DomNode;
        get node_value(): string;
        set node_value(val: string);
        get nodeValue(): string;
        set nodeValue(val: string);
        get text_content(): string;
        set text_content(val: string);
        get textContent(): string;
        set textContent(val: string);

        // Inherited methods
        add_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        remove_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        dispatch_event(event: DomEvent): boolean;
        vfunc_add_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        vfunc_remove_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        vfunc_dispatch_event(event: DomEvent): boolean;
        get_node_type(): DomNodeNodeType;
        get_node_name(): string;
        get_base_uri(): string | null;
        get_owner_document(): DomDocument | null;
        set_owner_document(value?: DomDocument | null): void;
        get_parent_node(): DomNode | null;
        get_parent_element(): DomElement | null;
        get_child_nodes(): DomNodeList;
        get_first_child(): DomNode | null;
        get_last_child(): DomNode | null;
        get_previous_sibling(): DomNode | null;
        get_next_sibling(): DomNode | null;
        get_node_value(): string | null;
        set_node_value(value?: string | null): void;
        get_text_content(): string | null;
        set_text_content(value?: string | null): void;
        has_child_nodes(): boolean;
        normalize(): void;
        is_equal_node(node?: DomNode | null): boolean;
        compare_document_position(other: DomNode): DomNodeDocumentPosition;
        contains(other?: DomNode | null): boolean;
        lookup_prefix(nspace?: string | null): string | null;
        lookup_namespace_uri(prefix?: string | null): string | null;
        is_default_namespace(nspace?: string | null): boolean;
        insert_before(node: DomNode, child?: DomNode | null): DomNode;
        append_child(node: DomNode): DomNode;
        replace_child(node: DomNode, child: DomNode): DomNode;
        remove_child(child: DomNode): DomNode;
        vfunc_get_node_type(): DomNodeNodeType;
        vfunc_get_node_name(): string;
        vfunc_get_base_uri(): string | null;
        vfunc_get_owner_document(): DomDocument | null;
        vfunc_set_owner_document(value?: DomDocument | null): void;
        vfunc_get_parent_node(): DomNode | null;
        vfunc_get_parent_element(): DomElement | null;
        vfunc_get_child_nodes(): DomNodeList;
        vfunc_get_first_child(): DomNode | null;
        vfunc_get_last_child(): DomNode | null;
        vfunc_get_previous_sibling(): DomNode | null;
        vfunc_get_next_sibling(): DomNode | null;
        vfunc_get_node_value(): string | null;
        vfunc_set_node_value(value?: string | null): void;
        vfunc_get_text_content(): string | null;
        vfunc_set_text_content(value?: string | null): void;
        vfunc_has_child_nodes(): boolean;
        vfunc_normalize(): void;
        vfunc_is_equal_node(node?: DomNode | null): boolean;
        vfunc_compare_document_position(other: DomNode): DomNodeDocumentPosition;
        vfunc_contains(other?: DomNode | null): boolean;
        vfunc_lookup_prefix(nspace?: string | null): string | null;
        vfunc_lookup_namespace_uri(prefix?: string | null): string | null;
        vfunc_is_default_namespace(nspace?: string | null): boolean;
        vfunc_insert_before(node: DomNode, child?: DomNode | null): DomNode;
        vfunc_append_child(node: DomNode): DomNode;
        vfunc_replace_child(node: DomNode, child: DomNode): DomNode;
        vfunc_remove_child(child: DomNode): DomNode;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace NodeList {
        // Signal signatures
        interface SignalSignatures extends Gee.ArrayList.SignalSignatures {
            'notify::g-type': (pspec: GObject.ParamSpec) => void;
            'notify::g-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::g-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gee.ArrayList.ConstructorProps, DomNodeList.ConstructorProps {}
    }

    class NodeList extends Gee.ArrayList implements DomNodeList {
        static $gtype: GObject.GType<NodeList>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: NodeList.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<NodeList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): NodeList;

        // Signals

        connect<K extends keyof NodeList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, NodeList.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof NodeList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, NodeList.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof NodeList.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<NodeList.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get length(): number;

        // Inherited methods
        item(index: number): DomNode | null;
        get_length(): number;
        vfunc_item(index: number): DomNode | null;
        vfunc_get_length(): number;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractList.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace NodeIterator {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::root': (pspec: GObject.ParamSpec) => void;
            'notify::reference-node': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-before-reference-node': (pspec: GObject.ParamSpec) => void;
            'notify::what-to-show': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DomNodeIterator.ConstructorProps {}
    }

    class NodeIterator extends GObject.Object implements DomNodeIterator {
        static $gtype: GObject.GType<NodeIterator>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: NodeIterator.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<NodeIterator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](n: DomNode, what_to_show: number): NodeIterator;

        // Signals

        connect<K extends keyof NodeIterator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, NodeIterator.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof NodeIterator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, NodeIterator.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof NodeIterator.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<NodeIterator.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get root(): DomNode;
        get reference_node(): DomNode;
        get referenceNode(): DomNode;
        get pointer_before_reference_node(): boolean;
        get pointerBeforeReferenceNode(): boolean;
        get what_to_show(): number;
        get whatToShow(): number;

        // Inherited methods
        get_root(): DomNode;
        get_reference_node(): DomNode;
        get_pointer_before_reference_node(): boolean;
        get_what_to_show(): number;
        next_node(): DomNode | null;
        previous_node(): DomNode | null;
        detach(): void;
        vfunc_get_root(): DomNode;
        vfunc_get_reference_node(): DomNode;
        vfunc_get_pointer_before_reference_node(): boolean;
        vfunc_get_what_to_show(): number;
        vfunc_next_node(): DomNode | null;
        vfunc_previous_node(): DomNode | null;
        vfunc_detach(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BaseProperty {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Property.ConstructorProps {
            value: string;
        }
    }

    abstract class BaseProperty extends GObject.Object implements Property {
        static $gtype: GObject.GType<BaseProperty>;

        // Properties

        get value(): string;
        set value(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BaseProperty.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BaseProperty.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof BaseProperty.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BaseProperty.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BaseProperty.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BaseProperty.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BaseProperty.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BaseProperty.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_get_value(): string | null;
        vfunc_set_value(value?: string | null): void;
        vfunc_validate_value(val?: string | null): boolean;

        // Methods

        get_value(): string | null;
        set_value(value?: string | null): void;
        validate_value(val?: string | null): boolean;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace String {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {}
    }

    class String extends BaseProperty {
        static $gtype: GObject.GType<String>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: String.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<String.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static with_string(str: string): String;

        static ['new'](): String;

        // Signals

        connect<K extends keyof String.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, String.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof String.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, String.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof String.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<String.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace ArrayString {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {}
    }

    class ArrayString extends BaseProperty {
        static $gtype: GObject.GType<ArrayString>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ArrayString.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ArrayString.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ArrayString;

        // Signals

        connect<K extends keyof ArrayString.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ArrayString.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ArrayString.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ArrayString.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ArrayString.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ArrayString.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_values(): string[];
        initialize_strings(strs: string[]): void;
        is_valid_value(): boolean;
        select(index: number): void;
        search(str: string): boolean;
    }

    namespace XsdArrayString {
        // Signal signatures
        interface SignalSignatures extends ArrayString.SignalSignatures {
            'notify::simple-type': (pspec: GObject.ParamSpec) => void;
            'notify::source': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends ArrayString.ConstructorProps {
            simple_type: string;
            simpleType: string;
            source: Gio.File;
        }
    }

    class XsdArrayString extends ArrayString {
        static $gtype: GObject.GType<XsdArrayString>;

        // Properties

        get simple_type(): string;
        set simple_type(val: string);
        get simpleType(): string;
        set simpleType(val: string);
        get source(): Gio.File;
        set source(val: Gio.File);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdArrayString.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdArrayString.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdArrayString;

        // Signals

        connect<K extends keyof XsdArrayString.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdArrayString.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdArrayString.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdArrayString.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdArrayString.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdArrayString.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_simple_type(): string;
        set_simple_type(value: string): void;
        get_source(): Gio.File;
        set_source(value: Gio.File): void;
        load(): void;
    }

    namespace Double {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::decimals': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {
            decimals: number;
        }
    }

    class Double extends BaseProperty {
        static $gtype: GObject.GType<Double>;

        // Properties

        get decimals(): number;
        set decimals(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Double.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Double.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Double;

        // Signals

        connect<K extends keyof Double.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Double.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Double.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Double.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Double.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Double.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_decimals(): number;
        set_decimals(value: number): void;
        get_double(): number;
        set_double(value: number): void;
    }

    namespace Float {
        // Signal signatures
        interface SignalSignatures extends Double.SignalSignatures {
            'notify::decimals': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Double.ConstructorProps {}
    }

    class Float extends Double {
        static $gtype: GObject.GType<Float>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Float.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Float.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Float;

        // Signals

        connect<K extends keyof Float.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Float.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Float.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Float.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Float.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Float.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_float(): number;
        set_float(value: number): void;
    }

    namespace Int {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {}
    }

    class Int extends BaseProperty {
        static $gtype: GObject.GType<Int>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Int.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Int.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Int;

        // Signals

        connect<K extends keyof Int.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Int.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Int.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Int.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Int.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Int.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_integer(): number;
        set_integer(value: number): void;
    }

    namespace Boolean {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {}
    }

    class Boolean extends BaseProperty {
        static $gtype: GObject.GType<Boolean>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Boolean.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Boolean.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Boolean;

        // Signals

        connect<K extends keyof Boolean.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Boolean.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Boolean.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Boolean.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Boolean.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Boolean.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_boolean(): boolean;
        set_boolean(value: boolean): void;
    }

    namespace Enum {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::use-nick': (pspec: GObject.ParamSpec) => void;
            'notify::camel-case': (pspec: GObject.ParamSpec) => void;
            'notify::upper-case': (pspec: GObject.ParamSpec) => void;
            'notify::enum-type': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {
            use_nick: boolean;
            useNick: boolean;
            camel_case: boolean;
            camelCase: boolean;
            upper_case: boolean;
            upperCase: boolean;
            enum_type: GObject.GType;
            enumType: GObject.GType;
        }
    }

    class Enum extends BaseProperty {
        static $gtype: GObject.GType<Enum>;

        // Properties

        get use_nick(): boolean;
        set use_nick(val: boolean);
        get useNick(): boolean;
        set useNick(val: boolean);
        get camel_case(): boolean;
        set camel_case(val: boolean);
        get camelCase(): boolean;
        set camelCase(val: boolean);
        get upper_case(): boolean;
        set upper_case(val: boolean);
        get upperCase(): boolean;
        set upperCase(val: boolean);
        get enum_type(): GObject.GType;
        set enum_type(val: GObject.GType);
        get enumType(): GObject.GType;
        set enumType(val: GObject.GType);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Enum.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Enum.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Enum;

        // Signals

        connect<K extends keyof Enum.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Enum.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Enum.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Enum.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Enum.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Enum.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_use_nick(): boolean;
        set_use_nick(value: boolean): void;
        get_camel_case(): boolean;
        set_camel_case(value: boolean): void;
        get_upper_case(): boolean;
        set_upper_case(value: boolean): void;
        get_enum_type(): GObject.GType;
        set_enum_type(value: GObject.GType): void;
        initialize_enum(enum_type: GObject.GType): void;
        get_enum(): number;
        set_enum(value: number): void;
        is_valid(): boolean;
    }

    namespace Date {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {}
    }

    class Date extends BaseProperty {
        static $gtype: GObject.GType<Date>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Date.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Date.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Date;

        // Signals

        connect<K extends keyof Date.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Date.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Date.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Date.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Date.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Date.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_date(): GLib.Date;
        set_date(date: GLib.Date): void;
    }

    namespace DateTime {
        // Signal signatures
        interface SignalSignatures extends BaseProperty.SignalSignatures {
            'notify::format': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends BaseProperty.ConstructorProps {
            format: string;
        }
    }

    class DateTime extends BaseProperty {
        static $gtype: GObject.GType<DateTime>;

        // Properties

        get format(): string;
        set format(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DateTime.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DateTime.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DateTime;

        // Signals

        connect<K extends keyof DateTime.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DateTime.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DateTime.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DateTime.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DateTime.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DateTime.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_format(): string;
        set_format(value: string): void;
        get_datetime(): GLib.DateTime;
        set_datetime(dt: GLib.DateTime): void;
    }

    namespace Range {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::start-container': (pspec: GObject.ParamSpec) => void;
            'notify::start-offset': (pspec: GObject.ParamSpec) => void;
            'notify::end-container': (pspec: GObject.ParamSpec) => void;
            'notify::end-offset': (pspec: GObject.ParamSpec) => void;
            'notify::collapsed': (pspec: GObject.ParamSpec) => void;
            'notify::common-ancestor-container': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DomRange.ConstructorProps {}
    }

    class Range extends GObject.Object implements DomRange {
        static $gtype: GObject.GType<Range>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Range.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Range.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: DomDocument): Range;

        // Signals

        connect<K extends keyof Range.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Range.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Range.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Range.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Range.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Range.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get start_container(): DomNode;
        get startContainer(): DomNode;
        get start_offset(): number;
        get startOffset(): number;
        get end_container(): DomNode;
        get endContainer(): DomNode;
        get end_offset(): number;
        get endOffset(): number;
        get collapsed(): boolean;
        get common_ancestor_container(): DomNode;
        get commonAncestorContainer(): DomNode;

        // Inherited methods
        get_start_container(): DomNode;
        get_start_offset(): number;
        get_end_container(): DomNode;
        get_end_offset(): number;
        get_collapsed(): boolean;
        get_common_ancestor_container(): DomNode;
        set_start(node: DomNode, offset: number): void;
        set_end(node: DomNode, offset: number): void;
        set_start_before(node: DomNode): void;
        set_start_after(node: DomNode): void;
        set_end_before(node: DomNode): void;
        set_end_after(node: DomNode): void;
        collapse(to_start: boolean): void;
        select_node(node: DomNode): void;
        select_node_contents(node: DomNode): void;
        compare_boundary_points(how: DomRangeBoundaryPoints | null, sourceRange: DomRange): number;
        delete_contents(): void;
        extract_contents(): DomDocumentFragment | null;
        clone_contents(): DomDocumentFragment | null;
        insert_node(node: DomNode): void;
        surround_contents(newParent: DomNode): void;
        clone_range(): DomRange;
        detach(): void;
        is_point_in_range(node: DomNode, offset: number): boolean;
        compare_point(node: DomNode, offset: number): number;
        intersects_node(node: DomNode): boolean;
        to_string(): string;
        vfunc_get_start_container(): DomNode;
        vfunc_get_start_offset(): number;
        vfunc_get_end_container(): DomNode;
        vfunc_get_end_offset(): number;
        vfunc_get_collapsed(): boolean;
        vfunc_get_common_ancestor_container(): DomNode;
        vfunc_set_start(node: DomNode, offset: number): void;
        vfunc_set_end(node: DomNode, offset: number): void;
        vfunc_set_start_before(node: DomNode): void;
        vfunc_set_start_after(node: DomNode): void;
        vfunc_set_end_before(node: DomNode): void;
        vfunc_set_end_after(node: DomNode): void;
        vfunc_collapse(to_start: boolean): void;
        vfunc_select_node(node: DomNode): void;
        vfunc_select_node_contents(node: DomNode): void;
        vfunc_compare_boundary_points(how: DomRangeBoundaryPoints, sourceRange: DomRange): number;
        vfunc_delete_contents(): void;
        vfunc_extract_contents(): DomDocumentFragment | null;
        vfunc_clone_contents(): DomDocumentFragment | null;
        vfunc_insert_node(node: DomNode): void;
        vfunc_surround_contents(newParent: DomNode): void;
        vfunc_clone_range(): DomRange;
        vfunc_detach(): void;
        vfunc_is_point_in_range(node: DomNode, offset: number): boolean;
        vfunc_compare_point(node: DomNode, offset: number): number;
        vfunc_intersects_node(node: DomNode): boolean;
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace SettableTokenList {
        // Signal signatures
        interface SignalSignatures extends TokenList.SignalSignatures {
            'notify::g-type': (pspec: GObject.ParamSpec) => void;
            'notify::g-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::g-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends TokenList.ConstructorProps, DomSettableTokenList.ConstructorProps {}
    }

    class SettableTokenList extends TokenList implements DomSettableTokenList {
        static $gtype: GObject.GType<SettableTokenList>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: SettableTokenList.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<SettableTokenList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](e: DomElement, attr?: string | null): SettableTokenList;
        // Conflicted with Gee.ArrayList.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof SettableTokenList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SettableTokenList.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof SettableTokenList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SettableTokenList.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof SettableTokenList.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<SettableTokenList.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get value(): string;
        set value(val: string);

        // Inherited methods
        get_value(): string;
        set_value(value: string): void;
        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractList.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace StringRef {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Property.ConstructorProps {}
    }

    class StringRef extends GObject.Object implements Property {
        static $gtype: GObject.GType<StringRef>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: StringRef.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<StringRef.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](obj: Object, name: string): StringRef;

        // Signals

        connect<K extends keyof StringRef.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, StringRef.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof StringRef.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, StringRef.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof StringRef.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<StringRef.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get value(): string;
        set value(val: string);

        // Inherited methods
        get_value(): string | null;
        set_value(value?: string | null): void;
        validate_value(val?: string | null): boolean;
        vfunc_get_value(): string | null;
        vfunc_set_value(value?: string | null): void;
        vfunc_validate_value(val?: string | null): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CharacterData {
        // Signal signatures
        interface SignalSignatures extends Node.SignalSignatures {
            'notify::previous-element-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::next-element-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::data': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Node.ConstructorProps,
                DomNonDocumentTypeChildNode.ConstructorProps,
                DomChildNode.ConstructorProps,
                DomCharacterData.ConstructorProps {}
    }

    class CharacterData extends Node implements DomNonDocumentTypeChildNode, DomChildNode, DomCharacterData {
        static $gtype: GObject.GType<CharacterData>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CharacterData.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CharacterData.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): CharacterData;

        // Signals

        connect<K extends keyof CharacterData.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CharacterData.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CharacterData.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CharacterData.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CharacterData.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CharacterData.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get previous_element_sibling(): DomElement;
        get previousElementSibling(): DomElement;
        get next_element_sibling(): DomElement;
        get nextElementSibling(): DomElement;
        get data(): string;
        set data(val: string);

        // Inherited methods
        get_previous_element_sibling(): DomElement | null;
        get_next_element_sibling(): DomElement | null;
        vfunc_get_previous_element_sibling(): DomElement | null;
        vfunc_get_next_element_sibling(): DomElement | null;
        remove(): void;
        vfunc_remove(): void;
        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Text {
        // Signal signatures
        interface SignalSignatures extends CharacterData.SignalSignatures {
            'notify::data': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CharacterData.ConstructorProps, DomText.ConstructorProps {}
    }

    class Text extends CharacterData implements DomText {
        static $gtype: GObject.GType<Text>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Text.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Text.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: DomDocument, data: string): Text;
        // Conflicted with GXml.CharacterData.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof Text.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Text.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Text.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Text.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Text.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Text.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get data(): string;
        set data(val: string);

        // Inherited methods
        split_text(offset: number): DomText;
        get_whole_text(): string;
        vfunc_split_text(offset: number): DomText;
        vfunc_get_whole_text(): string;
        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
    }

    namespace ProcessingInstruction {
        // Signal signatures
        interface SignalSignatures extends CharacterData.SignalSignatures {
            'notify::target': (pspec: GObject.ParamSpec) => void;
            'notify::data': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CharacterData.ConstructorProps, DomProcessingInstruction.ConstructorProps {}
    }

    class ProcessingInstruction extends CharacterData implements DomProcessingInstruction {
        static $gtype: GObject.GType<ProcessingInstruction>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ProcessingInstruction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ProcessingInstruction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: DomDocument, target: string, data: string): ProcessingInstruction;
        // Conflicted with GXml.CharacterData.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof ProcessingInstruction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ProcessingInstruction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ProcessingInstruction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ProcessingInstruction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ProcessingInstruction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ProcessingInstruction.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get target(): string;
        get data(): string;
        set data(val: string);

        // Inherited methods
        get_target(): string;
        vfunc_get_target(): string;
        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
    }

    namespace Comment {
        // Signal signatures
        interface SignalSignatures extends CharacterData.SignalSignatures {
            'notify::data': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CharacterData.ConstructorProps, DomComment.ConstructorProps {}
    }

    class Comment extends CharacterData implements DomComment {
        static $gtype: GObject.GType<Comment>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Comment.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Comment.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: DomDocument, data: string): Comment;
        // Conflicted with GXml.CharacterData.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof Comment.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Comment.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Comment.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Comment.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Comment.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Comment.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get data(): string;
        set data(val: string);

        // Inherited methods
        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
    }

    namespace TokenList {
        // Signal signatures
        interface SignalSignatures extends Gee.ArrayList.SignalSignatures {
            'notify::g-type': (pspec: GObject.ParamSpec) => void;
            'notify::g-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::g-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gee.ArrayList.ConstructorProps, DomTokenList.ConstructorProps {}
    }

    class TokenList extends Gee.ArrayList implements DomTokenList {
        static $gtype: GObject.GType<TokenList>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TokenList.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TokenList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](e: DomElement, attr?: string | null): TokenList;
        // Conflicted with Gee.ArrayList.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof TokenList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TokenList.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TokenList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TokenList.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TokenList.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TokenList.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        update(): void;

        // Inherited properties
        get length(): number;

        // Inherited methods
        get_length(): number;
        item(index: number): string | null;
        contains(token: string): boolean;
        // Conflicted with Gee.AbstractCollection.contains
        contains(...args: never[]): any;
        add(tokens: string[]): void;
        // Conflicted with Gee.AbstractCollection.add
        add(...args: never[]): any;
        remove(tokens: string[]): void;
        // Conflicted with Gee.AbstractCollection.remove
        remove(...args: never[]): any;
        toggle(token: string, force: boolean, _auto_: boolean): boolean;
        to_string(): string;
        vfunc_get_length(): number;
        vfunc_item(index: number): string | null;
        vfunc_contains(token: string): boolean;
        // Conflicted with Gee.AbstractCollection.vfunc_contains
        vfunc_contains(...args: never[]): any;
        vfunc_add(tokens: string[]): void;
        // Conflicted with Gee.AbstractCollection.vfunc_add
        vfunc_add(...args: never[]): any;
        vfunc_remove(tokens: string[]): void;
        // Conflicted with Gee.AbstractCollection.vfunc_remove
        vfunc_remove(...args: never[]): any;
        vfunc_toggle(token: string, force: boolean, _auto_: boolean): boolean;
        vfunc_to_string(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractList.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace TreeWalker {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::root': (pspec: GObject.ParamSpec) => void;
            'notify::what-to-show': (pspec: GObject.ParamSpec) => void;
            'notify::current-node': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, DomTreeWalker.ConstructorProps {}
    }

    class TreeWalker extends GObject.Object implements DomTreeWalker {
        static $gtype: GObject.GType<TreeWalker>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TreeWalker.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TreeWalker.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](root: DomNode, w: number): TreeWalker;

        // Signals

        connect<K extends keyof TreeWalker.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeWalker.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TreeWalker.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TreeWalker.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TreeWalker.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TreeWalker.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get root(): DomNode;
        get what_to_show(): number;
        get whatToShow(): number;
        get current_node(): DomNode;
        get currentNode(): DomNode;

        // Inherited methods
        get_root(): DomNode;
        get_what_to_show(): number;
        get_current_node(): DomNode;
        parent_node(): DomNode | null;
        first_child(): DomNode | null;
        last_child(): DomNode | null;
        previous_sibling(): DomNode | null;
        next_sibling(): DomNode | null;
        previous_node(): DomNode | null;
        next_node(): DomNode | null;
        vfunc_get_root(): DomNode;
        vfunc_get_what_to_show(): number;
        vfunc_get_current_node(): DomNode;
        vfunc_parent_node(): DomNode | null;
        vfunc_first_child(): DomNode | null;
        vfunc_last_child(): DomNode | null;
        vfunc_previous_sibling(): DomNode | null;
        vfunc_next_sibling(): DomNode | null;
        vfunc_previous_node(): DomNode | null;
        vfunc_next_node(): DomNode | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XAttribute {
        // Signal signatures
        interface SignalSignatures extends XNode.SignalSignatures {
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::namespace-uri': (pspec: GObject.ParamSpec) => void;
            'notify::prefix': (pspec: GObject.ParamSpec) => void;
            'notify::local-name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XNode.ConstructorProps, DomAttr.ConstructorProps {}
    }

    class XAttribute extends XNode implements DomAttr {
        static $gtype: GObject.GType<XAttribute>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XAttribute.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XAttribute.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XAttribute;

        // Signals

        connect<K extends keyof XAttribute.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XAttribute.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XAttribute.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XAttribute.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XAttribute.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XAttribute.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get namespace_uri(): string;
        get namespaceUri(): string;
        get prefix(): string;
        get local_name(): string;
        get localName(): string;
        get name(): string;
        get value(): string;
        set value(val: string);

        // Inherited methods
        get_namespace_uri(): string | null;
        get_prefix(): string | null;
        get_local_name(): string;
        get_name(): string;
        get_value(): string;
        set_value(value: string): void;
        get_specified(): boolean;
        vfunc_get_namespace_uri(): string | null;
        vfunc_get_prefix(): string | null;
        vfunc_get_local_name(): string;
        vfunc_get_name(): string;
        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
        vfunc_get_specified(): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XCharacterData {
        // Signal signatures
        interface SignalSignatures extends XNonDocumentChildNode.SignalSignatures {
            'notify::str': (pspec: GObject.ParamSpec) => void;
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::data': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XNonDocumentChildNode.ConstructorProps, DomCharacterData.ConstructorProps {
            str: string;
        }
    }

    class XCharacterData extends XNonDocumentChildNode implements DomCharacterData {
        static $gtype: GObject.GType<XCharacterData>;

        // Properties

        get str(): string;
        set str(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XCharacterData.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XCharacterData.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XCharacterData;

        // Signals

        connect<K extends keyof XCharacterData.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XCharacterData.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XCharacterData.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XCharacterData.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XCharacterData.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XCharacterData.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_str(): string;
        set_str(value: string): void;

        // Inherited properties
        get data(): string;
        set data(val: string);

        // Inherited methods
        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XChildNode {
        // Signal signatures
        interface SignalSignatures extends XNode.SignalSignatures {
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XNode.ConstructorProps, DomChildNode.ConstructorProps {}
    }

    class XChildNode extends XNode implements DomChildNode {
        static $gtype: GObject.GType<XChildNode>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XChildNode.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XChildNode.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XChildNode;

        // Signals

        connect<K extends keyof XChildNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XChildNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XChildNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XChildNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XChildNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XChildNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        remove(): void;
        vfunc_remove(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XNonDocumentChildNode {
        // Signal signatures
        interface SignalSignatures extends XChildNode.SignalSignatures {
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::previous-element-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::next-element-sibling': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XChildNode.ConstructorProps, DomNonDocumentTypeChildNode.ConstructorProps {}
    }

    class XNonDocumentChildNode extends XChildNode implements DomNonDocumentTypeChildNode {
        static $gtype: GObject.GType<XNonDocumentChildNode>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XNonDocumentChildNode.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XNonDocumentChildNode.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XNonDocumentChildNode;

        // Signals

        connect<K extends keyof XNonDocumentChildNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XNonDocumentChildNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XNonDocumentChildNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XNonDocumentChildNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XNonDocumentChildNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XNonDocumentChildNode.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get previous_element_sibling(): DomElement;
        get previousElementSibling(): DomElement;
        get next_element_sibling(): DomElement;
        get nextElementSibling(): DomElement;

        // Inherited methods
        get_previous_element_sibling(): DomElement | null;
        get_next_element_sibling(): DomElement | null;
        vfunc_get_previous_element_sibling(): DomElement | null;
        vfunc_get_next_element_sibling(): DomElement | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XComment {
        // Signal signatures
        interface SignalSignatures extends XCharacterData.SignalSignatures {
            'notify::str': (pspec: GObject.ParamSpec) => void;
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::data': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XCharacterData.ConstructorProps, DomComment.ConstructorProps {}
    }

    class XComment extends XCharacterData implements DomComment {
        static $gtype: GObject.GType<XComment>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XComment.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XComment.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XComment;
        // Conflicted with GXml.XCharacterData.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof XComment.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XComment.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XComment.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XComment.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XComment.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XComment.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get data(): string;
        set data(val: string);

        // Inherited methods
        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
    }

    namespace XDocument {
        // Signal signatures
        interface SignalSignatures extends XNode.SignalSignatures {
            'notify::indent': (pspec: GObject.ParamSpec) => void;
            'notify::ns-top': (pspec: GObject.ParamSpec) => void;
            'notify::prefix-default-ns': (pspec: GObject.ParamSpec) => void;
            'notify::backup': (pspec: GObject.ParamSpec) => void;
            'notify::file': (pspec: GObject.ParamSpec) => void;
            'notify::root': (pspec: GObject.ParamSpec) => void;
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::children': (pspec: GObject.ParamSpec) => void;
            'notify::first-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::last-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::child-element-count': (pspec: GObject.ParamSpec) => void;
            'notify::implementation': (pspec: GObject.ParamSpec) => void;
            'notify::url': (pspec: GObject.ParamSpec) => void;
            'notify::document-uri': (pspec: GObject.ParamSpec) => void;
            'notify::origin': (pspec: GObject.ParamSpec) => void;
            'notify::compat-mode': (pspec: GObject.ParamSpec) => void;
            'notify::character-set': (pspec: GObject.ParamSpec) => void;
            'notify::content-type': (pspec: GObject.ParamSpec) => void;
            'notify::doctype': (pspec: GObject.ParamSpec) => void;
            'notify::document-element': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends XNode.ConstructorProps,
                DomParentNode.ConstructorProps,
                DomNonElementParentNode.ConstructorProps,
                DomDocument.ConstructorProps,
                DomXMLDocument.ConstructorProps,
                XPathContext.ConstructorProps {
            indent: boolean;
            ns_top: boolean;
            nsTop: boolean;
            prefix_default_ns: boolean;
            prefixDefaultNs: boolean;
            backup: boolean;
            file: Gio.File;
            root: DomNode;
        }
    }

    class XDocument
        extends XNode
        implements DomParentNode, DomNonElementParentNode, DomDocument, DomXMLDocument, XPathContext
    {
        static $gtype: GObject.GType<XDocument>;

        // Properties

        get indent(): boolean;
        set indent(val: boolean);
        get ns_top(): boolean;
        set ns_top(val: boolean);
        get nsTop(): boolean;
        set nsTop(val: boolean);
        get prefix_default_ns(): boolean;
        set prefix_default_ns(val: boolean);
        get prefixDefaultNs(): boolean;
        set prefixDefaultNs(val: boolean);
        get backup(): boolean;
        set backup(val: boolean);
        get file(): Gio.File;
        set file(val: Gio.File);
        get root(): DomNode;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XDocument.SignalSignatures;

        // Fields

        doc: any | null;

        // Constructors

        constructor(properties?: Partial<XDocument.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XDocument;

        static from_path(path: string, options: number): XDocument;

        static from_uri(uri: string, options: number): XDocument;

        static from_file(file: Gio.File, options: number, cancel?: Gio.Cancellable | null): XDocument;

        static from_string(str: string, options: number): XDocument;

        static from_stream(istream: Gio.InputStream): XDocument;

        static from_doc(doc: libxml2.Doc): XDocument;

        // Signals

        connect<K extends keyof XDocument.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XDocument.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XDocument.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XDocument.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XDocument.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XDocument.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_save(cancellable?: Gio.Cancellable | null): boolean;
        vfunc_save_as(f: Gio.File, cancellable?: Gio.Cancellable | null): boolean;

        // Methods

        get_indent(): boolean;
        set_indent(value: boolean): void;
        get_ns_top(): boolean;
        set_ns_top(value: boolean): void;
        get_prefix_default_ns(): boolean;
        set_prefix_default_ns(value: boolean): void;
        get_backup(): boolean;
        set_backup(value: boolean): void;
        get_file(): Gio.File;
        set_file(value: Gio.File): void;
        get_root(): DomNode;
        create_pi(target: string, data: string): DomNode;
        create_text(text: string): DomNode;
        libxml_to_string(): string;
        save(cancellable?: Gio.Cancellable | null): boolean;
        save_as(f: Gio.File, cancellable?: Gio.Cancellable | null): boolean;

        // Inherited properties
        get children(): DomHTMLCollection;
        get first_element_child(): DomElement;
        get firstElementChild(): DomElement;
        get last_element_child(): DomElement;
        get lastElementChild(): DomElement;
        get child_element_count(): number;
        get childElementCount(): number;
        get implementation(): DomImplementation;
        get url(): string;
        get document_uri(): string;
        get documentUri(): string;
        get origin(): string;
        get compat_mode(): string;
        get compatMode(): string;
        get character_set(): string;
        get characterSet(): string;
        get content_type(): string;
        get contentType(): string;
        get doctype(): DomDocumentType;
        get document_element(): DomElement;
        get documentElement(): DomElement;

        // Inherited methods
        get_children(): DomHTMLCollection;
        get_first_element_child(): DomElement | null;
        get_last_element_child(): DomElement | null;
        get_child_element_count(): number;
        query_selector(selectors: string): DomElement | null;
        query_selector_all(selectors: string): DomNodeList;
        get_elements_by_property_value(property: string, value: string): DomElementList;
        vfunc_get_children(): DomHTMLCollection;
        vfunc_get_first_element_child(): DomElement | null;
        vfunc_get_last_element_child(): DomElement | null;
        vfunc_get_child_element_count(): number;
        vfunc_query_selector(selectors: string): DomElement | null;
        vfunc_query_selector_all(selectors: string): DomNodeList;
        vfunc_get_elements_by_property_value(property: string, value: string): DomElementList;
        get_element_by_id(element_id: string): DomElement | null;
        vfunc_get_element_by_id(element_id: string): DomElement | null;
        get_implementation(): DomImplementation;
        get_url(): string;
        get_document_uri(): string;
        get_origin(): string;
        get_compat_mode(): string;
        get_character_set(): string;
        get_content_type(): string;
        get_doctype(): DomDocumentType | null;
        get_document_element(): DomElement | null;
        get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        get_elements_by_class_name(classNames: string): DomHTMLCollection;
        create_element(local_name: string): DomElement;
        create_element_ns(namespace: string | null, qualified_name: string): DomElement;
        create_document_fragment(): DomDocumentFragment;
        create_text_node(data: string): DomText;
        create_comment(data: string): DomComment;
        create_processing_instruction(target: string, data: string): DomProcessingInstruction;
        import_node(node: DomNode, deep: boolean): DomNode;
        adopt_node(node: DomNode): DomNode;
        create_event(_interface: string): DomEvent;
        create_range(): DomRange;
        create_node_iterator(root: DomNode, whatToShow: number): DomNodeIterator;
        create_tree_walker(root: DomNode, what_to_show: number): DomTreeWalker;
        write_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        write_file_async(file: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_file_async(
            file: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_stream(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): void;
        write_stream_async(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<Gio.InputStream>;
        create_stream_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        write_string(cancellable?: Gio.Cancellable | null): string;
        write_string_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<string>;
        write_string_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        read_from_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        read_from_file_async(file: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_file_async(
            file: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_file_finish(_res_: Gio.AsyncResult): void;
        read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        read_from_string_async(str: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_string_async(
            str: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_string_finish(_res_: Gio.AsyncResult): void;
        read_from_stream(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        read_from_stream_async(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_stream_async(
            stream: Gio.InputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_stream_async(
            stream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_stream_finish(_res_: Gio.AsyncResult): void;
        get_xml_parser(): Parser;
        set_xml_parser(parser: Parser): void;
        vfunc_get_implementation(): DomImplementation;
        vfunc_get_url(): string;
        vfunc_get_document_uri(): string;
        vfunc_get_origin(): string;
        vfunc_get_compat_mode(): string;
        vfunc_get_character_set(): string;
        vfunc_get_content_type(): string;
        vfunc_get_doctype(): DomDocumentType | null;
        vfunc_get_document_element(): DomElement | null;
        vfunc_get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_class_name(classNames: string): DomHTMLCollection;
        vfunc_create_element(local_name: string): DomElement;
        vfunc_create_element_ns(namespace: string | null, qualified_name: string): DomElement;
        vfunc_create_document_fragment(): DomDocumentFragment;
        vfunc_create_text_node(data: string): DomText;
        vfunc_create_comment(data: string): DomComment;
        vfunc_create_processing_instruction(target: string, data: string): DomProcessingInstruction;
        vfunc_import_node(node: DomNode, deep: boolean): DomNode;
        vfunc_adopt_node(node: DomNode): DomNode;
        vfunc_create_event(_interface: string): DomEvent;
        vfunc_create_range(): DomRange;
        vfunc_create_node_iterator(root: DomNode, whatToShow: number): DomNodeIterator;
        vfunc_create_tree_walker(root: DomNode, what_to_show: number): DomTreeWalker;
        vfunc_write_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_stream(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        vfunc_write_string(cancellable?: Gio.Cancellable | null): string;
        vfunc_write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_read_from_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_stream(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_stream_async(
            stream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_get_xml_parser(): Parser;
        vfunc_set_xml_parser(parser: Parser): void;
        evaluate(expression: string, resolver?: Gee.Map | null): XPathObject;
        vfunc_evaluate(expression: string, resolver?: Gee.Map | null): XPathObject;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XElement {
        // Signal signatures
        interface SignalSignatures extends XNonDocumentChildNode.SignalSignatures {
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::children': (pspec: GObject.ParamSpec) => void;
            'notify::first-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::last-element-child': (pspec: GObject.ParamSpec) => void;
            'notify::child-element-count': (pspec: GObject.ParamSpec) => void;
            'notify::namespace-uri': (pspec: GObject.ParamSpec) => void;
            'notify::prefix': (pspec: GObject.ParamSpec) => void;
            'notify::local-name': (pspec: GObject.ParamSpec) => void;
            'notify::tag-name': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::class-name': (pspec: GObject.ParamSpec) => void;
            'notify::class-list': (pspec: GObject.ParamSpec) => void;
            'notify::attributes': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends XNonDocumentChildNode.ConstructorProps,
                DomParentNode.ConstructorProps,
                DomElement.ConstructorProps,
                XPathContext.ConstructorProps {
            content: string;
        }
    }

    class XElement extends XNonDocumentChildNode implements DomParentNode, DomElement, XPathContext {
        static $gtype: GObject.GType<XElement>;

        // Properties

        get content(): string;
        set content(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XElement.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XElement.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XElement;
        // Conflicted with GXml.XNonDocumentChildNode.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof XElement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XElement.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XElement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XElement.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XElement.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XElement.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        set_attr(aname: string, avalue: string): void;
        get_attr(name: string): DomNode | null;
        set_ns_attr(ns: string, aname: string, value: string): void;
        get_ns_attr(name: string, uri: string): DomNode | null;
        normalize(): void;
        get_content(): string;
        set_content(value: string): void;
        remove_attr(name: string): void;
        remove_ns_attr(name: string, uri: string): void;

        // Inherited properties
        get children(): DomHTMLCollection;
        get first_element_child(): DomElement;
        get firstElementChild(): DomElement;
        get last_element_child(): DomElement;
        get lastElementChild(): DomElement;
        get child_element_count(): number;
        get childElementCount(): number;
        get namespace_uri(): string;
        get namespaceUri(): string;
        get prefix(): string;
        get local_name(): string;
        get localName(): string;
        get tag_name(): string;
        get tagName(): string;
        get id(): string;
        set id(val: string);
        get class_name(): string;
        set class_name(val: string);
        get className(): string;
        set className(val: string);
        get class_list(): DomTokenList;
        get classList(): DomTokenList;
        get attributes(): DomNamedNodeMap;

        // Inherited methods
        get_children(): DomHTMLCollection;
        get_first_element_child(): DomElement | null;
        get_last_element_child(): DomElement | null;
        get_child_element_count(): number;
        query_selector(selectors: string): DomElement | null;
        query_selector_all(selectors: string): DomNodeList;
        get_elements_by_property_value(property: string, value: string): DomElementList;
        vfunc_get_children(): DomHTMLCollection;
        vfunc_get_first_element_child(): DomElement | null;
        vfunc_get_last_element_child(): DomElement | null;
        vfunc_get_child_element_count(): number;
        vfunc_query_selector(selectors: string): DomElement | null;
        vfunc_query_selector_all(selectors: string): DomNodeList;
        vfunc_get_elements_by_property_value(property: string, value: string): DomElementList;
        get_namespace_uri(): string | null;
        get_prefix(): string | null;
        get_local_name(): string;
        get_tag_name(): string;
        get_id(): string | null;
        set_id(value?: string | null): void;
        get_class_name(): string | null;
        set_class_name(value?: string | null): void;
        get_class_list(): DomTokenList;
        get_attributes(): DomNamedNodeMap;
        get_attribute(name: string): string | null;
        get_attribute_ns(namespace: string | null, local_name: string): string | null;
        set_attribute(name: string, value: string): void;
        set_attribute_ns(namespace: string | null, name: string, value: string): void;
        remove_attribute(name: string): void;
        remove_attribute_ns(namespace: string | null, local_name: string): void;
        has_attribute(name: string): boolean;
        has_attribute_ns(namespace: string | null, local_name: string): boolean;
        get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        get_elements_by_class_name(class_names: string): DomHTMLCollection;
        matches(selectors: string): boolean;
        read_from_uri(uri: string): void;
        read_from_uri_async(uri: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_uri_async(
            uri: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_uri_async(
            uri: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_uri_finish(_res_: Gio.AsyncResult): void;
        read_from_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        read_from_file_async(f: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_file_async(
            f: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_file_finish(_res_: Gio.AsyncResult): void;
        read_from_stream(istream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
        ): globalThis.Promise<void>;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_stream_finish(_res_: Gio.AsyncResult): void;
        read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        read_from_string_async(str: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_string_async(
            str: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_string_finish(_res_: Gio.AsyncResult): void;
        write_string(cancellable?: Gio.Cancellable | null): string;
        write_string_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<string>;
        write_string_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        write_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        write_file_async(f: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_file_async(
            f: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_stream(stream: Gio.OutputStream): void;
        write_stream_async(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<Gio.InputStream>;
        create_stream_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        vfunc_get_namespace_uri(): string | null;
        vfunc_get_prefix(): string | null;
        vfunc_get_local_name(): string;
        vfunc_get_tag_name(): string;
        vfunc_get_id(): string | null;
        vfunc_set_id(value?: string | null): void;
        vfunc_get_class_name(): string | null;
        vfunc_set_class_name(value?: string | null): void;
        vfunc_get_class_list(): DomTokenList;
        vfunc_get_attributes(): DomNamedNodeMap;
        vfunc_get_attribute(name: string): string | null;
        vfunc_get_attribute_ns(namespace: string | null, local_name: string): string | null;
        vfunc_set_attribute(name: string, value: string): void;
        vfunc_set_attribute_ns(namespace: string | null, name: string, value: string): void;
        vfunc_remove_attribute(name: string): void;
        vfunc_remove_attribute_ns(namespace: string | null, local_name: string): void;
        vfunc_has_attribute(name: string): boolean;
        vfunc_has_attribute_ns(namespace: string | null, local_name: string): boolean;
        vfunc_get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_class_name(class_names: string): DomHTMLCollection;
        vfunc_matches(selectors: string): boolean;
        vfunc_read_from_uri(uri: string): void;
        vfunc_read_from_uri_async(
            uri: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_uri_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_stream(istream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_string(cancellable?: Gio.Cancellable | null): string;
        vfunc_write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_write_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_stream(stream: Gio.OutputStream): void;
        vfunc_write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        evaluate(expression: string, resolver?: Gee.Map | null): XPathObject;
        vfunc_evaluate(expression: string, resolver?: Gee.Map | null): XPathObject;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XHashMapAttr {
        // Signal signatures
        interface SignalSignatures extends Gee.AbstractMap.SignalSignatures {
            'notify::k-type': (pspec: GObject.ParamSpec) => void;
            'notify::k-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::k-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::v-type': (pspec: GObject.ParamSpec) => void;
            'notify::v-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::v-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
            'notify::keys': (pspec: GObject.ParamSpec) => void;
            'notify::values': (pspec: GObject.ParamSpec) => void;
            'notify::entries': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gee.AbstractMap.ConstructorProps, DomNamedNodeMap.ConstructorProps {}
    }

    class XHashMapAttr extends Gee.AbstractMap implements DomNamedNodeMap {
        static $gtype: GObject.GType<XHashMapAttr>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XHashMapAttr.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XHashMapAttr.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XHashMapAttr;

        // Signals

        connect<K extends keyof XHashMapAttr.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHashMapAttr.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XHashMapAttr.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHashMapAttr.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XHashMapAttr.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XHashMapAttr.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get length(): number;

        // Inherited methods
        get_length(): number;
        item(index: number): DomNode | null;
        get_named_item(name: string): DomNode | null;
        set_named_item(node: DomNode): DomNode | null;
        remove_named_item(name: string): DomNode | null;
        remove_named_item_ns(namespace_uri: string, localName: string): DomNode | null;
        get_named_item_ns(namespace_uri: string, local_name: string): DomNode | null;
        set_named_item_ns(node: DomNode): DomNode | null;
        vfunc_get_length(): number;
        vfunc_item(index: number): DomNode | null;
        vfunc_get_named_item(name: string): DomNode | null;
        vfunc_set_named_item(node: DomNode): DomNode | null;
        vfunc_remove_named_item(name: string): DomNode | null;
        vfunc_remove_named_item_ns(namespace_uri: string, localName: string): DomNode | null;
        vfunc_get_named_item_ns(namespace_uri: string, local_name: string): DomNode | null;
        vfunc_set_named_item_ns(node: DomNode): DomNode | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractMap.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XHashMapAttrEntry {
        // Signal signatures
        interface SignalSignatures extends Gee.MapEntry.SignalSignatures {
            'notify::k-type': (pspec: GObject.ParamSpec) => void;
            'notify::k-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::k-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::v-type': (pspec: GObject.ParamSpec) => void;
            'notify::v-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::v-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::key': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gee.MapEntry.ConstructorProps {}
    }

    class XHashMapAttrEntry extends Gee.MapEntry {
        static $gtype: GObject.GType<XHashMapAttrEntry>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XHashMapAttrEntry.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XHashMapAttrEntry.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, attr?: any | null): XHashMapAttrEntry;

        // Signals

        connect<K extends keyof XHashMapAttrEntry.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHashMapAttrEntry.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XHashMapAttrEntry.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHashMapAttrEntry.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XHashMapAttrEntry.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XHashMapAttrEntry.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XHashMapAttrIterator {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::valid': (pspec: GObject.ParamSpec) => void;
            'notify::mutable': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Gee.MapIterator.ConstructorProps {}
    }

    class XHashMapAttrIterator extends GObject.Object implements Gee.MapIterator {
        static $gtype: GObject.GType<XHashMapAttrIterator>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XHashMapAttrIterator.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XHashMapAttrIterator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XHashMapAttrIterator;

        // Signals

        connect<K extends keyof XHashMapAttrIterator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHashMapAttrIterator.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XHashMapAttrIterator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHashMapAttrIterator.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XHashMapAttrIterator.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XHashMapAttrIterator.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get valid(): boolean;
        get mutable(): boolean;
        get read_only(): boolean;
        get readOnly(): boolean;

        // Inherited methods
        next(): boolean;
        has_next(): boolean;
        get_key(): any;
        get_value(): any;
        set_value(value: any): void;
        unset(): void;
        fold(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldMapFunc, seed: any): any;
        foreach(f: Gee.ForallMapFunc): boolean;
        get_valid(): boolean;
        get_mutable(): boolean;
        get_read_only(): boolean;
        vfunc_next(): boolean;
        vfunc_has_next(): boolean;
        vfunc_get_key(): any;
        vfunc_get_value(): any;
        vfunc_set_value(value: any): void;
        vfunc_unset(): void;
        vfunc_fold(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldMapFunc, seed: any): any;
        vfunc_foreach(f: Gee.ForallMapFunc): boolean;
        vfunc_get_valid(): boolean;
        vfunc_get_mutable(): boolean;
        vfunc_get_read_only(): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XHtmlDocument {
        // Signal signatures
        interface SignalSignatures extends XDocument.SignalSignatures {
            'notify::indent': (pspec: GObject.ParamSpec) => void;
            'notify::ns-top': (pspec: GObject.ParamSpec) => void;
            'notify::prefix-default-ns': (pspec: GObject.ParamSpec) => void;
            'notify::backup': (pspec: GObject.ParamSpec) => void;
            'notify::file': (pspec: GObject.ParamSpec) => void;
            'notify::root': (pspec: GObject.ParamSpec) => void;
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XDocument.ConstructorProps, DomHtmlDocument.ConstructorProps {}
    }

    class XHtmlDocument extends XDocument implements DomHtmlDocument {
        static $gtype: GObject.GType<XHtmlDocument>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XHtmlDocument.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XHtmlDocument.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static from_path(path: string, options: number): XHtmlDocument;

        static from_uri(uri: string, options: number): XHtmlDocument;

        static from_file(file: Gio.File, options: number, cancel?: Gio.Cancellable | null): XHtmlDocument;

        static from_string(html: string, options: number): XHtmlDocument;

        static from_string_context(html: string, options: number): XHtmlDocument;

        static from_string_doc(html: string, options: number): XHtmlDocument;

        static ['new'](): XHtmlDocument;

        // Signals

        connect<K extends keyof XHtmlDocument.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHtmlDocument.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XHtmlDocument.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XHtmlDocument.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XHtmlDocument.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XHtmlDocument.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static get_default_options(): number;

        // Inherited methods
        read_from_string(str: string): void;
        read_from_string_tolerant(str: string): void;
        to_html(): string;
        vfunc_read_from_string(str: string): void;
        vfunc_read_from_string_tolerant(str: string): void;
        vfunc_to_html(): string;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XListChildren {
        // Signal signatures
        interface SignalSignatures extends Gee.AbstractBidirList.SignalSignatures {
            'notify::g-type': (pspec: GObject.ParamSpec) => void;
            'notify::g-dup-func': (pspec: GObject.ParamSpec) => void;
            'notify::g-destroy-func': (pspec: GObject.ParamSpec) => void;
            'notify::read-only-view': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gee.AbstractBidirList.ConstructorProps,
                DomNodeList.ConstructorProps,
                DomHTMLCollection.ConstructorProps {}
    }

    class XListChildren extends Gee.AbstractBidirList implements DomNodeList, DomHTMLCollection {
        static $gtype: GObject.GType<XListChildren>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XListChildren.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XListChildren.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XListChildren;

        // Signals

        connect<K extends keyof XListChildren.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XListChildren.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XListChildren.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XListChildren.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XListChildren.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XListChildren.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get length(): number;

        // Inherited methods
        item(index: number): DomNode | null;
        // Conflicted with GXml.DomHTMLCollection.item
        item(...args: never[]): any;
        get_length(): number;
        vfunc_item(index: number): DomNode | null;
        // Conflicted with GXml.DomHTMLCollection.vfunc_item
        vfunc_item(...args: never[]): any;
        vfunc_get_length(): number;
        get_element(index: number): DomElement | null;
        to_array(): DomElement[];
        // Conflicted with Gee.Collection.to_array
        to_array(...args: never[]): any;
        named_item(name: string): DomElement | null;
        vfunc_get_element(index: number): DomElement | null;
        vfunc_to_array(): DomElement[];
        // Conflicted with Gee.Collection.vfunc_to_array
        vfunc_to_array(...args: never[]): any;
        vfunc_named_item(name: string): DomElement | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        // Conflicted with Gee.AbstractList.set
        set(...args: never[]): any;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XListChildrenIterator {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::valid': (pspec: GObject.ParamSpec) => void;
            'notify::read-only': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                Gee.Traversable.ConstructorProps,
                Gee.Iterator.ConstructorProps,
                Gee.BidirIterator.ConstructorProps,
                Gee.ListIterator.ConstructorProps,
                Gee.BidirListIterator.ConstructorProps {}
    }

    class XListChildrenIterator
        extends GObject.Object
        implements Gee.Traversable, Gee.Iterator, Gee.BidirIterator, Gee.ListIterator, Gee.BidirListIterator
    {
        static $gtype: GObject.GType<XListChildrenIterator>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XListChildrenIterator.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XListChildrenIterator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XListChildrenIterator;

        // Signals

        connect<K extends keyof XListChildrenIterator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XListChildrenIterator.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XListChildrenIterator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XListChildrenIterator.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XListChildrenIterator.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XListChildrenIterator.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get valid(): boolean;
        get read_only(): boolean;
        get readOnly(): boolean;

        // Inherited methods
        foreach(f: Gee.ForallFunc): boolean;
        stream(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.StreamFunc): Gee.Iterator;
        fold(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): any;
        map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.MapFunc): Gee.Iterator;
        scan(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): Gee.Iterator;
        filter(pred: Gee.Predicate): Gee.Iterator;
        chop(offset: number, length: number): Gee.Iterator;
        flat_map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FlatMapFunc): Gee.Iterator;
        tee(forks: number): Gee.Iterator[];
        first_match(pred: Gee.Predicate): any | null;
        any_match(pred: Gee.Predicate): boolean;
        all_match(pred: Gee.Predicate): boolean;
        max(compare: GLib.CompareDataFunc): any;
        min(compare: GLib.CompareDataFunc): any;
        order_by(compare?: GLib.CompareDataFunc | null): Gee.Iterator;
        get_element_type(): GObject.GType;
        vfunc_foreach(f: Gee.ForallFunc): boolean;
        vfunc_stream(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.StreamFunc): Gee.Iterator;
        vfunc_fold(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): any;
        vfunc_map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.MapFunc): Gee.Iterator;
        vfunc_scan(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FoldFunc, seed: any): Gee.Iterator;
        vfunc_filter(pred: Gee.Predicate): Gee.Iterator;
        vfunc_chop(offset: number, length: number): Gee.Iterator;
        vfunc_flat_map(a_type: GObject.GType, a_dup_func: GObject.BoxedCopyFunc, f: Gee.FlatMapFunc): Gee.Iterator;
        vfunc_tee(forks: number): Gee.Iterator[];
        vfunc_first_match(pred: Gee.Predicate): any | null;
        vfunc_any_match(pred: Gee.Predicate): boolean;
        vfunc_all_match(pred: Gee.Predicate): boolean;
        vfunc_max(compare: GLib.CompareDataFunc): any;
        vfunc_min(compare: GLib.CompareDataFunc): any;
        vfunc_order_by(compare?: GLib.CompareDataFunc | null): Gee.Iterator;
        vfunc_get_element_type(): GObject.GType;
        next(): boolean;
        has_next(): boolean;
        get(): any;
        remove(): void;
        get_valid(): boolean;
        get_read_only(): boolean;
        vfunc_next(): boolean;
        vfunc_has_next(): boolean;
        vfunc_get(): any;
        vfunc_remove(): void;
        vfunc_get_valid(): boolean;
        vfunc_get_read_only(): boolean;
        previous(): boolean;
        has_previous(): boolean;
        first(): boolean;
        last(): boolean;
        vfunc_previous(): boolean;
        vfunc_has_previous(): boolean;
        vfunc_first(): boolean;
        vfunc_last(): boolean;
        set(item: any): void;
        // Conflicted with GObject.Object.set
        set(...args: never[]): any;
        add(item: any): void;
        index(): number;
        vfunc_set(item: any): void;
        vfunc_add(item: any): void;
        vfunc_index(): number;
        insert(item: any): void;
        vfunc_insert(item: any): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XNode {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::node-type': (pspec: GObject.ParamSpec) => void;
            'notify::node-name': (pspec: GObject.ParamSpec) => void;
            'notify::base-uri': (pspec: GObject.ParamSpec) => void;
            'notify::owner-document': (pspec: GObject.ParamSpec) => void;
            'notify::parent-node': (pspec: GObject.ParamSpec) => void;
            'notify::parent-element': (pspec: GObject.ParamSpec) => void;
            'notify::child-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::previous-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::next-sibling': (pspec: GObject.ParamSpec) => void;
            'notify::node-value': (pspec: GObject.ParamSpec) => void;
            'notify::text-content': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                DomEventTarget.ConstructorProps,
                DomNode.ConstructorProps {
            attrs: Gee.Map;
            children_nodes: Gee.BidirList;
            childrenNodes: Gee.BidirList;
            document: DomDocument;
            parent: DomNode;
            type_node: NodeType;
            typeNode: NodeType;
            name: string;
            value: string;
        }
    }

    abstract class XNode extends GObject.Object implements DomEventTarget, DomNode {
        static $gtype: GObject.GType<XNode>;

        // Properties

        get attrs(): Gee.Map;
        get children_nodes(): Gee.BidirList;
        get childrenNodes(): Gee.BidirList;
        get document(): DomDocument;
        get parent(): DomNode;
        get type_node(): NodeType;
        get typeNode(): NodeType;
        get name(): string;
        get value(): string;
        set value(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XNode.SignalSignatures;

        // Fields

        owned_node: boolean;

        // Constructors

        constructor(properties?: Partial<XNode.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof XNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        static to_gnode(doc: XDocument, node: any | null, take_node: boolean): DomNode;

        // Virtual methods

        vfunc_set_namespace(uri: string, prefix?: string | null): boolean;
        vfunc_get_attrs(): Gee.Map;
        vfunc_get_children_nodes(): Gee.BidirList;
        vfunc_get_document(): DomDocument;
        vfunc_get_parent(): DomNode;
        vfunc_get_type_node(): NodeType;
        vfunc_get_name(): string;
        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
        vfunc_to_string(): string;

        // Methods

        set_namespace(uri: string, prefix?: string | null): boolean;
        get_attrs(): Gee.Map;
        get_children_nodes(): Gee.BidirList;
        get_document(): DomDocument;
        get_parent(): DomNode;
        get_type_node(): NodeType;
        get_name(): string;
        get_value(): string;
        set_value(value: string): void;
        to_string(): string;
        get_internal_node(): any | null;
        clone_node(deep: boolean): DomNode;

        // Inherited properties
        get node_type(): DomNodeNodeType;
        get nodeType(): DomNodeNodeType;
        get node_name(): string;
        get nodeName(): string;
        get base_uri(): string;
        get baseUri(): string;
        get owner_document(): DomDocument;
        set owner_document(val: DomDocument);
        get ownerDocument(): DomDocument;
        set ownerDocument(val: DomDocument);
        get parent_node(): DomNode;
        get parentNode(): DomNode;
        get parent_element(): DomElement;
        get parentElement(): DomElement;
        get child_nodes(): DomNodeList;
        get childNodes(): DomNodeList;
        get first_child(): DomNode;
        get firstChild(): DomNode;
        get last_child(): DomNode;
        get lastChild(): DomNode;
        get previous_sibling(): DomNode;
        get previousSibling(): DomNode;
        get next_sibling(): DomNode;
        get nextSibling(): DomNode;
        get node_value(): string;
        set node_value(val: string);
        get nodeValue(): string;
        set nodeValue(val: string);
        get text_content(): string;
        set text_content(val: string);
        get textContent(): string;
        set textContent(val: string);

        // Inherited methods
        add_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        remove_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        dispatch_event(event: DomEvent): boolean;
        vfunc_add_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        vfunc_remove_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        vfunc_dispatch_event(event: DomEvent): boolean;
        get_node_type(): DomNodeNodeType;
        get_node_name(): string;
        get_base_uri(): string | null;
        get_owner_document(): DomDocument | null;
        set_owner_document(value?: DomDocument | null): void;
        get_parent_node(): DomNode | null;
        get_parent_element(): DomElement | null;
        get_child_nodes(): DomNodeList;
        get_first_child(): DomNode | null;
        get_last_child(): DomNode | null;
        get_previous_sibling(): DomNode | null;
        get_next_sibling(): DomNode | null;
        get_node_value(): string | null;
        set_node_value(value?: string | null): void;
        get_text_content(): string | null;
        set_text_content(value?: string | null): void;
        has_child_nodes(): boolean;
        normalize(): void;
        is_equal_node(node?: DomNode | null): boolean;
        compare_document_position(other: DomNode): DomNodeDocumentPosition;
        contains(other?: DomNode | null): boolean;
        lookup_prefix(nspace?: string | null): string | null;
        lookup_namespace_uri(prefix?: string | null): string | null;
        is_default_namespace(nspace?: string | null): boolean;
        insert_before(node: DomNode, child?: DomNode | null): DomNode;
        append_child(node: DomNode): DomNode;
        replace_child(node: DomNode, child: DomNode): DomNode;
        remove_child(child: DomNode): DomNode;
        vfunc_get_node_type(): DomNodeNodeType;
        vfunc_get_node_name(): string;
        vfunc_get_base_uri(): string | null;
        vfunc_get_owner_document(): DomDocument | null;
        vfunc_set_owner_document(value?: DomDocument | null): void;
        vfunc_get_parent_node(): DomNode | null;
        vfunc_get_parent_element(): DomElement | null;
        vfunc_get_child_nodes(): DomNodeList;
        vfunc_get_first_child(): DomNode | null;
        vfunc_get_last_child(): DomNode | null;
        vfunc_get_previous_sibling(): DomNode | null;
        vfunc_get_next_sibling(): DomNode | null;
        vfunc_get_node_value(): string | null;
        vfunc_set_node_value(value?: string | null): void;
        vfunc_get_text_content(): string | null;
        vfunc_set_text_content(value?: string | null): void;
        vfunc_has_child_nodes(): boolean;
        vfunc_normalize(): void;
        vfunc_is_equal_node(node?: DomNode | null): boolean;
        vfunc_compare_document_position(other: DomNode): DomNodeDocumentPosition;
        vfunc_contains(other?: DomNode | null): boolean;
        vfunc_lookup_prefix(nspace?: string | null): string | null;
        vfunc_lookup_namespace_uri(prefix?: string | null): string | null;
        vfunc_is_default_namespace(nspace?: string | null): boolean;
        vfunc_insert_before(node: DomNode, child?: DomNode | null): DomNode;
        vfunc_append_child(node: DomNode): DomNode;
        vfunc_replace_child(node: DomNode, child: DomNode): DomNode;
        vfunc_remove_child(child: DomNode): DomNode;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XParser {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::backup': (pspec: GObject.ParamSpec) => void;
            'notify::indent': (pspec: GObject.ParamSpec) => void;
            'notify::cancellable': (pspec: GObject.ParamSpec) => void;
            'notify::node': (pspec: GObject.ParamSpec) => void;
            'notify::types': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Parser.ConstructorProps {}
    }

    class XParser extends GObject.Object implements Parser {
        static $gtype: GObject.GType<XParser>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XParser.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XParser.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](node: DomNode): XParser;

        // Signals

        connect<K extends keyof XParser.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XParser.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XParser.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XParser.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XParser.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XParser.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        read_node(node: DomNode): void;
        read_child_nodes_stream_async(istream: Gio.InputStream): globalThis.Promise<void>;
        read_child_nodes_stream_async(istream: Gio.InputStream, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_child_nodes_stream_async(
            istream: Gio.InputStream,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_child_nodes_stream_finish(_res_: Gio.AsyncResult): void;

        // Inherited properties
        get backup(): boolean;
        set backup(val: boolean);
        get indent(): boolean;
        set indent(val: boolean);
        get cancellable(): Gio.Cancellable;
        set cancellable(val: Gio.Cancellable);
        get node(): DomNode;
        get types(): GLib.HashTable<GObject.GType, GLib.HashTable>;

        // Inherited methods
        get_backup(): boolean;
        set_backup(value: boolean): void;
        get_indent(): boolean;
        set_indent(value: boolean): void;
        get_cancellable(): Gio.Cancellable | null;
        set_cancellable(value?: Gio.Cancellable | null): void;
        get_node(): DomNode;
        get_types(): GLib.HashTable<GObject.GType, GLib.HashTable>;
        write_file(file: Gio.File): void;
        write_file_async(file: Gio.File): globalThis.Promise<void>;
        write_file_async(file: Gio.File, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_file_async(
            file: Gio.File,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_string(): string;
        write_string_async(): globalThis.Promise<string>;
        write_string_async(_callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(_callback_?: Gio.AsyncReadyCallback<this> | null): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        write_stream(stream: Gio.OutputStream): void;
        write_stream_async(stream: Gio.OutputStream): globalThis.Promise<void>;
        write_stream_async(stream: Gio.OutputStream, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_stream_async(
            stream: Gio.OutputStream,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        read_file(file: Gio.File): void;
        read_file_async(file: Gio.File): globalThis.Promise<void>;
        read_file_async(file: Gio.File, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_file_async(
            file: Gio.File,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_file_finish(_res_: Gio.AsyncResult): void;
        read_stream(stream: Gio.InputStream): void;
        read_stream_async(stream: Gio.InputStream): globalThis.Promise<void>;
        read_stream_async(stream: Gio.InputStream, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_stream_async(
            stream: Gio.InputStream,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_stream_finish(_res_: Gio.AsyncResult): void;
        read_string(str: string): void;
        read_string_async(str: string): globalThis.Promise<void>;
        read_string_async(str: string, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_string_async(
            str: string,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_string_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(): globalThis.Promise<Gio.InputStream>;
        create_stream_async(_callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        read_child_nodes(parent: DomNode): void;
        read_child_nodes_async(parent: DomNode): globalThis.Promise<void>;
        read_child_nodes_async(parent: DomNode, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_child_nodes_async(
            parent: DomNode,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_child_nodes_finish(_res_: Gio.AsyncResult): void;
        read_child_node(parent: DomNode): boolean;
        read_child_element(parent: DomNode): boolean;
        read_element_property(parent: DomNode): [boolean, DomNode];
        add_element_collection(parent: DomNode): [boolean, DomNode];
        read_child_nodes_stream(istream: Gio.InputStream): void;
        read_child_nodes_string(str: string): void;
        read_unparsed(): string;
        move_next_node(): boolean;
        current_is_empty_element(): boolean;
        current_is_element(): boolean;
        current_is_document(): boolean;
        current_node_name(): string;
        create_element(parent: DomNode): DomElement | null;
        read_element(element: DomElement): void;
        vfunc_get_backup(): boolean;
        vfunc_set_backup(value: boolean): void;
        vfunc_get_indent(): boolean;
        vfunc_set_indent(value: boolean): void;
        vfunc_get_cancellable(): Gio.Cancellable | null;
        vfunc_set_cancellable(value?: Gio.Cancellable | null): void;
        vfunc_get_node(): DomNode;
        vfunc_get_types(): GLib.HashTable<GObject.GType, GLib.HashTable>;
        vfunc_write_file(file: Gio.File): void;
        vfunc_write_file_async(file: Gio.File, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_string(): string;
        vfunc_write_string_async(_callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_write_stream(stream: Gio.OutputStream): void;
        vfunc_write_stream_async(stream: Gio.OutputStream, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_file(file: Gio.File): void;
        vfunc_read_file_async(file: Gio.File, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_stream(stream: Gio.InputStream): void;
        vfunc_read_stream_async(stream: Gio.InputStream, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_string(str: string): void;
        vfunc_read_string_async(str: string, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(_callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        vfunc_read_child_nodes(parent: DomNode): void;
        vfunc_read_child_nodes_async(parent: DomNode, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_child_nodes_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_child_node(parent: DomNode): boolean;
        vfunc_read_child_element(parent: DomNode): boolean;
        vfunc_read_element_property(parent: DomNode): [boolean, DomNode];
        vfunc_add_element_collection(parent: DomNode): [boolean, DomNode];
        vfunc_read_child_nodes_stream(istream: Gio.InputStream): void;
        vfunc_read_child_nodes_string(str: string): void;
        vfunc_read_unparsed(): string;
        vfunc_move_next_node(): boolean;
        vfunc_current_is_empty_element(): boolean;
        vfunc_current_is_element(): boolean;
        vfunc_current_is_document(): boolean;
        vfunc_current_node_name(): string;
        vfunc_create_element(parent: DomNode): DomElement | null;
        vfunc_read_element(element: DomElement): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace XProcessingInstruction {
        // Signal signatures
        interface SignalSignatures extends XCharacterData.SignalSignatures {
            'notify::data': (pspec: GObject.ParamSpec) => void;
            'notify::str': (pspec: GObject.ParamSpec) => void;
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::target': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XCharacterData.ConstructorProps, DomProcessingInstruction.ConstructorProps {
            data: string;
        }
    }

    class XProcessingInstruction extends XCharacterData implements DomProcessingInstruction {
        static $gtype: GObject.GType<XProcessingInstruction>;

        // Properties

        get data(): string;
        set data(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XProcessingInstruction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XProcessingInstruction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XProcessingInstruction;
        // Conflicted with GXml.XCharacterData.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof XProcessingInstruction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XProcessingInstruction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XProcessingInstruction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XProcessingInstruction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XProcessingInstruction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XProcessingInstruction.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;

        // Inherited properties
        get target(): string;

        // Inherited methods
        get_target(): string;
        vfunc_get_target(): string;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
    }

    namespace XsdSchema {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::element-definitions': (pspec: GObject.ParamSpec) => void;
            'notify::simple-type-definitions': (pspec: GObject.ParamSpec) => void;
            'notify::complex-type-definitions': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            element_definitions: XsdListElements;
            elementDefinitions: XsdListElements;
            simple_type_definitions: XsdListSimpleTypes;
            simpleTypeDefinitions: XsdListSimpleTypes;
            complex_type_definitions: XsdListComplexTypes;
            complexTypeDefinitions: XsdListComplexTypes;
        }
    }

    class XsdSchema extends Element {
        static $gtype: GObject.GType<XsdSchema>;

        // Properties

        get element_definitions(): XsdListElements;
        set element_definitions(val: XsdListElements);
        get elementDefinitions(): XsdListElements;
        set elementDefinitions(val: XsdListElements);
        get simple_type_definitions(): XsdListSimpleTypes;
        set simple_type_definitions(val: XsdListSimpleTypes);
        get simpleTypeDefinitions(): XsdListSimpleTypes;
        set simpleTypeDefinitions(val: XsdListSimpleTypes);
        get complex_type_definitions(): XsdListComplexTypes;
        set complex_type_definitions(val: XsdListComplexTypes);
        get complexTypeDefinitions(): XsdListComplexTypes;
        set complexTypeDefinitions(val: XsdListComplexTypes);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdSchema.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdSchema.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdSchema;

        // Signals

        connect<K extends keyof XsdSchema.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdSchema.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdSchema.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdSchema.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdSchema.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdSchema.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_element_definitions(): XsdListElements;
        set_element_definitions(value: XsdListElements): void;
        get_simple_type_definitions(): XsdListSimpleTypes;
        set_simple_type_definitions(value: XsdListSimpleTypes): void;
        get_complex_type_definitions(): XsdListComplexTypes;
        set_complex_type_definitions(value: XsdListComplexTypes): void;
    }

    namespace XsdSimpleType {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::final': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::list': (pspec: GObject.ParamSpec) => void;
            'notify::union': (pspec: GObject.ParamSpec) => void;
            'notify::restriction': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            final: string;
            name: string;
            annotation: XsdAnnotation;
            list: XsdTypeList;
            union: XsdTypeUnion;
            restriction: XsdTypeRestriction;
        }
    }

    class XsdSimpleType extends Element {
        static $gtype: GObject.GType<XsdSimpleType>;

        // Properties

        get final(): string;
        set final(val: string);
        get name(): string;
        set name(val: string);
        get annotation(): XsdAnnotation;
        set annotation(val: XsdAnnotation);
        get list(): XsdTypeList;
        set list(val: XsdTypeList);
        get union(): XsdTypeUnion;
        set union(val: XsdTypeUnion);
        get restriction(): XsdTypeRestriction;
        set restriction(val: XsdTypeRestriction);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdSimpleType.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdSimpleType.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdSimpleType;

        // Signals

        connect<K extends keyof XsdSimpleType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdSimpleType.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdSimpleType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdSimpleType.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdSimpleType.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdSimpleType.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_final(): string;
        set_final(value: string): void;
        get_name(): string;
        set_name(value: string): void;
        get_annotation(): XsdAnnotation;
        set_annotation(value: XsdAnnotation): void;
        get_list(): XsdTypeList;
        set_list(value: XsdTypeList): void;
        get_union(): XsdTypeUnion;
        set_union(value: XsdTypeUnion): void;
        get_restriction(): XsdTypeRestriction;
        set_restriction(value: XsdTypeRestriction): void;
    }

    namespace XsdTypeDefinition {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            annotation: XsdAnnotation;
        }
    }

    class XsdTypeDefinition extends Element {
        static $gtype: GObject.GType<XsdTypeDefinition>;

        // Properties

        get annotation(): XsdAnnotation;
        set annotation(val: XsdAnnotation);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeDefinition.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeDefinition.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeDefinition;

        // Signals

        connect<K extends keyof XsdTypeDefinition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeDefinition.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeDefinition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeDefinition.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeDefinition.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeDefinition.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_annotation(): XsdAnnotation;
        set_annotation(value: XsdAnnotation): void;
    }

    namespace XsdTypeList {
        // Signal signatures
        interface SignalSignatures extends XsdTypeDefinition.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeDefinition.ConstructorProps {}
    }

    class XsdTypeList extends XsdTypeDefinition {
        static $gtype: GObject.GType<XsdTypeList>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeList.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeList;

        // Signals

        connect<K extends keyof XsdTypeList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeList.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeList.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeList.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeList.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeUnion {
        // Signal signatures
        interface SignalSignatures extends XsdTypeDefinition.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeDefinition.ConstructorProps {}
    }

    class XsdTypeUnion extends XsdTypeDefinition {
        static $gtype: GObject.GType<XsdTypeUnion>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeUnion.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeUnion.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeUnion;

        // Signals

        connect<K extends keyof XsdTypeUnion.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeUnion.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeUnion.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeUnion.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeUnion.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeUnion.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestriction {
        // Signal signatures
        interface SignalSignatures extends XsdTypeDefinition.SignalSignatures {
            'notify::base': (pspec: GObject.ParamSpec) => void;
            'notify::simple-type': (pspec: GObject.ParamSpec) => void;
            'notify::enumerations': (pspec: GObject.ParamSpec) => void;
            'notify::white-spaces': (pspec: GObject.ParamSpec) => void;
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeDefinition.ConstructorProps {
            base: string;
            simple_type: XsdSimpleType;
            simpleType: XsdSimpleType;
            enumerations: XsdListTypeRestrictionEnumerations;
            white_spaces: XsdListTypeRestrictionWhiteSpaces;
            whiteSpaces: XsdListTypeRestrictionWhiteSpaces;
        }
    }

    class XsdTypeRestriction extends XsdTypeDefinition {
        static $gtype: GObject.GType<XsdTypeRestriction>;

        // Properties

        get base(): string;
        set base(val: string);
        get simple_type(): XsdSimpleType;
        set simple_type(val: XsdSimpleType);
        get simpleType(): XsdSimpleType;
        set simpleType(val: XsdSimpleType);
        get enumerations(): XsdListTypeRestrictionEnumerations;
        set enumerations(val: XsdListTypeRestrictionEnumerations);
        get white_spaces(): XsdListTypeRestrictionWhiteSpaces;
        set white_spaces(val: XsdListTypeRestrictionWhiteSpaces);
        get whiteSpaces(): XsdListTypeRestrictionWhiteSpaces;
        set whiteSpaces(val: XsdListTypeRestrictionWhiteSpaces);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestriction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestriction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestriction;

        // Signals

        connect<K extends keyof XsdTypeRestriction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestriction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestriction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestriction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestriction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestriction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_base(): string;
        set_base(value: string): void;
        get_simple_type(): XsdSimpleType;
        set_simple_type(value: XsdSimpleType): void;
        get_enumerations(): XsdListTypeRestrictionEnumerations;
        set_enumerations(value: XsdListTypeRestrictionEnumerations): void;
        get_white_spaces(): XsdListTypeRestrictionWhiteSpaces;
        set_white_spaces(value: XsdListTypeRestrictionWhiteSpaces): void;
    }

    namespace XsdTypeRestrictionDef {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            annotation: XsdAnnotation;
        }
    }

    class XsdTypeRestrictionDef extends Element {
        static $gtype: GObject.GType<XsdTypeRestrictionDef>;

        // Properties

        get annotation(): XsdAnnotation;
        set annotation(val: XsdAnnotation);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionDef.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionDef.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionDef;

        // Signals

        connect<K extends keyof XsdTypeRestrictionDef.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionDef.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionDef.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionDef.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionDef.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionDef.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_annotation(): XsdAnnotation;
        set_annotation(value: XsdAnnotation): void;
    }

    namespace XsdTypeRestrictionMinExclusive {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionMinExclusive extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionMinExclusive>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionMinExclusive.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionMinExclusive.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionMinExclusive;

        // Signals

        connect<K extends keyof XsdTypeRestrictionMinExclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMinExclusive.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionMinExclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMinExclusive.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionMinExclusive.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionMinExclusive.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionMinInclusive {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionMinInclusive extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionMinInclusive>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionMinInclusive.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionMinInclusive.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionMinInclusive;

        // Signals

        connect<K extends keyof XsdTypeRestrictionMinInclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMinInclusive.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionMinInclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMinInclusive.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionMinInclusive.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionMinInclusive.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionMaxExclusive {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionMaxExclusive extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionMaxExclusive>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionMaxExclusive.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionMaxExclusive.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionMaxExclusive;

        // Signals

        connect<K extends keyof XsdTypeRestrictionMaxExclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMaxExclusive.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionMaxExclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMaxExclusive.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionMaxExclusive.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionMaxExclusive.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionMaxInclusive {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionMaxInclusive extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionMaxInclusive>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionMaxInclusive.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionMaxInclusive.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionMaxInclusive;

        // Signals

        connect<K extends keyof XsdTypeRestrictionMaxInclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMaxInclusive.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionMaxInclusive.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMaxInclusive.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionMaxInclusive.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionMaxInclusive.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionTotalDigits {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionTotalDigits extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionTotalDigits>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionTotalDigits.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionTotalDigits.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionTotalDigits;

        // Signals

        connect<K extends keyof XsdTypeRestrictionTotalDigits.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionTotalDigits.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionTotalDigits.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionTotalDigits.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionTotalDigits.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionTotalDigits.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionFractionDigits {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionFractionDigits extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionFractionDigits>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionFractionDigits.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionFractionDigits.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionFractionDigits;

        // Signals

        connect<K extends keyof XsdTypeRestrictionFractionDigits.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionFractionDigits.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionFractionDigits.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionFractionDigits.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionFractionDigits.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionFractionDigits.SignalSignatures[K]> extends [
                any,
                ...infer Q,
            ]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionLength {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionLength extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionLength>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionLength.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionLength.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionLength;

        // Signals

        connect<K extends keyof XsdTypeRestrictionLength.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionLength.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionLength.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionLength.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionLength.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionLength.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionMinLength {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionMinLength extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionMinLength>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionMinLength.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionMinLength.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionMinLength;

        // Signals

        connect<K extends keyof XsdTypeRestrictionMinLength.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMinLength.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionMinLength.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMinLength.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionMinLength.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionMinLength.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionMaxLength {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionMaxLength extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionMaxLength>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionMaxLength.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionMaxLength.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionMaxLength;

        // Signals

        connect<K extends keyof XsdTypeRestrictionMaxLength.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMaxLength.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionMaxLength.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionMaxLength.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionMaxLength.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionMaxLength.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionEnumeration {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {
            value: string;
        }
    }

    class XsdTypeRestrictionEnumeration extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionEnumeration>;

        // Properties

        get value(): string;
        set value(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionEnumeration.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionEnumeration.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionEnumeration;

        // Signals

        connect<K extends keyof XsdTypeRestrictionEnumeration.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionEnumeration.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionEnumeration.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionEnumeration.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionEnumeration.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionEnumeration.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_value(): string;
        set_value(value: string): void;
    }

    namespace XsdTypeRestrictionWhiteSpace {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::fixed': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {
            fixed: XsdTypeRestrictionWhiteSpaceFixed;
            value: string;
        }
    }

    class XsdTypeRestrictionWhiteSpace extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionWhiteSpace>;

        // Properties

        get fixed(): XsdTypeRestrictionWhiteSpaceFixed;
        set fixed(val: XsdTypeRestrictionWhiteSpaceFixed);
        get value(): string;
        set value(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionWhiteSpace.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionWhiteSpace.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionWhiteSpace;

        // Signals

        connect<K extends keyof XsdTypeRestrictionWhiteSpace.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionWhiteSpace.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionWhiteSpace.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionWhiteSpace.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionWhiteSpace.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionWhiteSpace.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_fixed(): XsdTypeRestrictionWhiteSpaceFixed;
        set_fixed(value: XsdTypeRestrictionWhiteSpaceFixed): void;
        get_value(): string;
        set_value(value: string): void;
    }

    namespace XsdTypeRestrictionWhiteSpaceFixed {
        // Signal signatures
        interface SignalSignatures extends Boolean.SignalSignatures {
            'notify::value': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Boolean.ConstructorProps {}
    }

    class XsdTypeRestrictionWhiteSpaceFixed extends Boolean {
        static $gtype: GObject.GType<XsdTypeRestrictionWhiteSpaceFixed>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionWhiteSpaceFixed.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionWhiteSpaceFixed.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionWhiteSpaceFixed;

        // Signals

        connect<K extends keyof XsdTypeRestrictionWhiteSpaceFixed.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionWhiteSpaceFixed.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionWhiteSpaceFixed.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionWhiteSpaceFixed.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionWhiteSpaceFixed.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionWhiteSpaceFixed.SignalSignatures[K]> extends [
                any,
                ...infer Q,
            ]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionPattern {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionPattern extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionPattern>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionPattern.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionPattern.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionPattern;

        // Signals

        connect<K extends keyof XsdTypeRestrictionPattern.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionPattern.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionPattern.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionPattern.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionPattern.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionPattern.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionAssertion {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionAssertion extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionAssertion>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionAssertion.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionAssertion.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionAssertion;

        // Signals

        connect<K extends keyof XsdTypeRestrictionAssertion.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionAssertion.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionAssertion.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionAssertion.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionAssertion.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionAssertion.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdTypeRestrictionExplicitTimezone {
        // Signal signatures
        interface SignalSignatures extends XsdTypeRestrictionDef.SignalSignatures {
            'notify::annotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdTypeRestrictionDef.ConstructorProps {}
    }

    class XsdTypeRestrictionExplicitTimezone extends XsdTypeRestrictionDef {
        static $gtype: GObject.GType<XsdTypeRestrictionExplicitTimezone>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdTypeRestrictionExplicitTimezone.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdTypeRestrictionExplicitTimezone.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdTypeRestrictionExplicitTimezone;

        // Signals

        connect<K extends keyof XsdTypeRestrictionExplicitTimezone.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionExplicitTimezone.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdTypeRestrictionExplicitTimezone.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdTypeRestrictionExplicitTimezone.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdTypeRestrictionExplicitTimezone.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdTypeRestrictionExplicitTimezone.SignalSignatures[K]> extends [
                any,
                ...infer Q,
            ]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdComplexType {
        // Signal signatures
        interface SignalSignatures extends XsdBaseType.SignalSignatures {
            'notify::abstract': (pspec: GObject.ParamSpec) => void;
            'notify::block': (pspec: GObject.ParamSpec) => void;
            'notify::final': (pspec: GObject.ParamSpec) => void;
            'notify::mixed': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::default-attributes-apply': (pspec: GObject.ParamSpec) => void;
            'notify::content-type': (pspec: GObject.ParamSpec) => void;
            'notify::type-attributes': (pspec: GObject.ParamSpec) => void;
            'notify::group-attributes': (pspec: GObject.ParamSpec) => void;
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdBaseType.ConstructorProps {
            abstract: boolean;
            block: string;
            final: string;
            mixed: boolean;
            name: string;
            default_attributes_apply: boolean;
            defaultAttributesApply: boolean;
            content_type: XsdBaseContent;
            contentType: XsdBaseContent;
            type_attributes: XsdList;
            typeAttributes: XsdList;
            group_attributes: XsdList;
            groupAttributes: XsdList;
        }
    }

    class XsdComplexType extends XsdBaseType {
        static $gtype: GObject.GType<XsdComplexType>;

        // Properties

        get abstract(): boolean;
        set abstract(val: boolean);
        get block(): string;
        set block(val: string);
        get final(): string;
        set final(val: string);
        get mixed(): boolean;
        set mixed(val: boolean);
        get name(): string;
        set name(val: string);
        get default_attributes_apply(): boolean;
        set default_attributes_apply(val: boolean);
        get defaultAttributesApply(): boolean;
        set defaultAttributesApply(val: boolean);
        get content_type(): XsdBaseContent;
        set content_type(val: XsdBaseContent);
        get contentType(): XsdBaseContent;
        set contentType(val: XsdBaseContent);
        get type_attributes(): XsdList;
        get typeAttributes(): XsdList;
        get group_attributes(): XsdList;
        get groupAttributes(): XsdList;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdComplexType.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdComplexType.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdComplexType;

        // Signals

        connect<K extends keyof XsdComplexType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdComplexType.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdComplexType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdComplexType.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdComplexType.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdComplexType.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_abstract(): boolean;
        set_abstract(value: boolean): void;
        get_block(): string;
        set_block(value: string): void;
        get_final(): string;
        set_final(value: string): void;
        get_mixed(): boolean;
        set_mixed(value: boolean): void;
        get_name(): string;
        set_name(value: string): void;
        get_default_attributes_apply(): boolean;
        set_default_attributes_apply(value: boolean): void;
        get_content_type(): XsdBaseContent;
        set_content_type(value: XsdBaseContent): void;
        get_type_attributes(): XsdList;
        get_group_attributes(): XsdList;
    }

    namespace XsdExtension {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::base': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            base: string;
        }
    }

    class XsdExtension extends Element {
        static $gtype: GObject.GType<XsdExtension>;

        // Properties

        get base(): string;
        set base(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdExtension.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdExtension.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdExtension;

        // Signals

        connect<K extends keyof XsdExtension.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdExtension.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdExtension.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdExtension.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdExtension.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdExtension.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_base(): string;
        set_base(value: string): void;
    }

    namespace XsdElement {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::abstract': (pspec: GObject.ParamSpec) => void;
            'notify::block': (pspec: GObject.ParamSpec) => void;
            'notify::default': (pspec: GObject.ParamSpec) => void;
            'notify::final': (pspec: GObject.ParamSpec) => void;
            'notify::fixed': (pspec: GObject.ParamSpec) => void;
            'notify::form': (pspec: GObject.ParamSpec) => void;
            'notify::max-occurs': (pspec: GObject.ParamSpec) => void;
            'notify::min-occurs': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::nillable': (pspec: GObject.ParamSpec) => void;
            'notify::ref': (pspec: GObject.ParamSpec) => void;
            'notify::substitution-group': (pspec: GObject.ParamSpec) => void;
            'notify::target-namespace': (pspec: GObject.ParamSpec) => void;
            'notify::object-type': (pspec: GObject.ParamSpec) => void;
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::simple-type': (pspec: GObject.ParamSpec) => void;
            'notify::complex-type': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            abstract: boolean;
            block: string;
            default: string;
            final: string;
            fixed: string;
            form: string;
            max_occurs: string;
            maxOccurs: string;
            min_occurs: string;
            minOccurs: string;
            name: string;
            nillable: boolean;
            ref: string | any;
            substitution_group: DomTokenList;
            substitutionGroup: DomTokenList;
            target_namespace: string;
            targetNamespace: string;
            object_type: string;
            objectType: string;
            anotation: XsdAnnotation;
            simple_type: XsdSimpleType;
            simpleType: XsdSimpleType;
            complex_type: XsdComplexType;
            complexType: XsdComplexType;
        }
    }

    class XsdElement extends Element {
        static $gtype: GObject.GType<XsdElement>;

        // Properties

        get abstract(): boolean;
        set abstract(val: boolean);
        get block(): string;
        set block(val: string);
        get default(): string;
        set default(val: string);
        get final(): string;
        set final(val: string);
        get fixed(): string;
        set fixed(val: string);
        get form(): string;
        set form(val: string);
        get max_occurs(): string;
        set max_occurs(val: string);
        get maxOccurs(): string;
        set maxOccurs(val: string);
        get min_occurs(): string;
        set min_occurs(val: string);
        get minOccurs(): string;
        set minOccurs(val: string);
        get name(): string;
        set name(val: string);
        get nillable(): boolean;
        set nillable(val: boolean);
        // This accessor conflicts with a field or function name in a parent class or interface.
        ref: string | any;
        get substitution_group(): DomTokenList;
        set substitution_group(val: DomTokenList);
        get substitutionGroup(): DomTokenList;
        set substitutionGroup(val: DomTokenList);
        get target_namespace(): string;
        set target_namespace(val: string);
        get targetNamespace(): string;
        set targetNamespace(val: string);
        get object_type(): string;
        set object_type(val: string);
        get objectType(): string;
        set objectType(val: string);
        get anotation(): XsdAnnotation;
        set anotation(val: XsdAnnotation);
        get simple_type(): XsdSimpleType;
        set simple_type(val: XsdSimpleType);
        get simpleType(): XsdSimpleType;
        set simpleType(val: XsdSimpleType);
        get complex_type(): XsdComplexType;
        set complex_type(val: XsdComplexType);
        get complexType(): XsdComplexType;
        set complexType(val: XsdComplexType);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdElement.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdElement.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdElement;

        // Signals

        connect<K extends keyof XsdElement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdElement.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdElement.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdElement.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdElement.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdElement.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_abstract(): boolean;
        set_abstract(value: boolean): void;
        get_block(): string;
        set_block(value: string): void;
        get_default(): string;
        set_default(value: string): void;
        get_final(): string;
        set_final(value: string): void;
        get_fixed(): string;
        set_fixed(value: string): void;
        get_form(): string;
        set_form(value: string): void;
        get_max_occurs(): string;
        set_max_occurs(value: string): void;
        get_min_occurs(): string;
        set_min_occurs(value: string): void;
        get_name(): string;
        set_name(value: string): void;
        get_nillable(): boolean;
        set_nillable(value: boolean): void;
        get_ref(): string;
        set_ref(value: string): void;
        get_substitution_group(): DomTokenList;
        set_substitution_group(value: DomTokenList): void;
        get_target_namespace(): string;
        set_target_namespace(value: string): void;
        get_object_type(): string;
        set_object_type(value: string): void;
        get_anotation(): XsdAnnotation;
        set_anotation(value: XsdAnnotation): void;
        get_simple_type(): XsdSimpleType;
        set_simple_type(value: XsdSimpleType): void;
        get_complex_type(): XsdComplexType;
        set_complex_type(value: XsdComplexType): void;
    }

    namespace XsdAnnotation {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {}
    }

    class XsdAnnotation extends Element {
        static $gtype: GObject.GType<XsdAnnotation>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdAnnotation.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdAnnotation.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdAnnotation;

        // Signals

        connect<K extends keyof XsdAnnotation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdAnnotation.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdAnnotation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdAnnotation.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdAnnotation.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdAnnotation.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdBaseType {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            anotation: XsdAnnotation;
        }
    }

    class XsdBaseType extends Element {
        static $gtype: GObject.GType<XsdBaseType>;

        // Properties

        get anotation(): XsdAnnotation;
        set anotation(val: XsdAnnotation);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdBaseType.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdBaseType.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdBaseType;

        // Signals

        connect<K extends keyof XsdBaseType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdBaseType.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdBaseType.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdBaseType.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdBaseType.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdBaseType.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_anotation(): XsdAnnotation;
        set_anotation(value: XsdAnnotation): void;
    }

    namespace XsdBaseContent {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            anotation: XsdAnnotation;
        }
    }

    class XsdBaseContent extends Element {
        static $gtype: GObject.GType<XsdBaseContent>;

        // Properties

        get anotation(): XsdAnnotation;
        set anotation(val: XsdAnnotation);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdBaseContent.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdBaseContent.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdBaseContent;

        // Signals

        connect<K extends keyof XsdBaseContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdBaseContent.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdBaseContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdBaseContent.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdBaseContent.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdBaseContent.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_anotation(): XsdAnnotation;
        set_anotation(value: XsdAnnotation): void;
    }

    namespace XsdSimpleContent {
        // Signal signatures
        interface SignalSignatures extends XsdBaseContent.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdBaseContent.ConstructorProps {}
    }

    class XsdSimpleContent extends XsdBaseContent {
        static $gtype: GObject.GType<XsdSimpleContent>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdSimpleContent.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdSimpleContent.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdSimpleContent;

        // Signals

        connect<K extends keyof XsdSimpleContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdSimpleContent.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdSimpleContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdSimpleContent.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdSimpleContent.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdSimpleContent.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdComplexContent {
        // Signal signatures
        interface SignalSignatures extends XsdBaseContent.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdBaseContent.ConstructorProps {}
    }

    class XsdComplexContent extends XsdBaseContent {
        static $gtype: GObject.GType<XsdComplexContent>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdComplexContent.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdComplexContent.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdComplexContent;

        // Signals

        connect<K extends keyof XsdComplexContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdComplexContent.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdComplexContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdComplexContent.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdComplexContent.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdComplexContent.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdOpenContent {
        // Signal signatures
        interface SignalSignatures extends XsdBaseContent.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdBaseContent.ConstructorProps {}
    }

    class XsdOpenContent extends XsdBaseContent {
        static $gtype: GObject.GType<XsdOpenContent>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdOpenContent.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdOpenContent.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdOpenContent;

        // Signals

        connect<K extends keyof XsdOpenContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdOpenContent.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdOpenContent.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdOpenContent.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdOpenContent.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdOpenContent.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdBaseAttribute {
        // Signal signatures
        interface SignalSignatures extends Element.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Element.ConstructorProps {
            anotation: XsdAnnotation;
        }
    }

    class XsdBaseAttribute extends Element {
        static $gtype: GObject.GType<XsdBaseAttribute>;

        // Properties

        get anotation(): XsdAnnotation;
        set anotation(val: XsdAnnotation);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdBaseAttribute.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdBaseAttribute.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdBaseAttribute;

        // Signals

        connect<K extends keyof XsdBaseAttribute.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdBaseAttribute.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdBaseAttribute.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdBaseAttribute.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdBaseAttribute.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdBaseAttribute.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_anotation(): XsdAnnotation;
        set_anotation(value: XsdAnnotation): void;
    }

    namespace XsdAttribute {
        // Signal signatures
        interface SignalSignatures extends XsdBaseAttribute.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdBaseAttribute.ConstructorProps {}
    }

    class XsdAttribute extends XsdBaseAttribute {
        static $gtype: GObject.GType<XsdAttribute>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdAttribute.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdAttribute.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdAttribute;

        // Signals

        connect<K extends keyof XsdAttribute.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdAttribute.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdAttribute.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdAttribute.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdAttribute.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdAttribute.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdAttributeGroup {
        // Signal signatures
        interface SignalSignatures extends XsdBaseAttribute.SignalSignatures {
            'notify::anotation': (pspec: GObject.ParamSpec) => void;
            'notify::parse-children': (pspec: GObject.ParamSpec) => void;
            'notify::unparsed': (pspec: GObject.ParamSpec) => void;
            'notify::read-buffer': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdBaseAttribute.ConstructorProps {}
    }

    class XsdAttributeGroup extends XsdBaseAttribute {
        static $gtype: GObject.GType<XsdAttributeGroup>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdAttributeGroup.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdAttributeGroup.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdAttributeGroup;

        // Signals

        connect<K extends keyof XsdAttributeGroup.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdAttributeGroup.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdAttributeGroup.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdAttributeGroup.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdAttributeGroup.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdAttributeGroup.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdList {
        // Signal signatures
        interface SignalSignatures extends ArrayList.SignalSignatures {
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends ArrayList.ConstructorProps {
            length: number;
        }
    }

    class XsdList extends ArrayList {
        static $gtype: GObject.GType<XsdList>;

        // Properties

        get length(): number;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdList.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdList;

        // Signals

        connect<K extends keyof XsdList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdList.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdList.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdList.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdList.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdList.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        get_length(): number;
        remove(index: number): void;
        index_of(element: DomElement): number;
    }

    namespace XsdListElements {
        // Signal signatures
        interface SignalSignatures extends XsdList.SignalSignatures {
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdList.ConstructorProps {}
    }

    class XsdListElements extends XsdList {
        static $gtype: GObject.GType<XsdListElements>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdListElements.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdListElements.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdListElements;

        // Signals

        connect<K extends keyof XsdListElements.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListElements.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdListElements.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListElements.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdListElements.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdListElements.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdListSimpleTypes {
        // Signal signatures
        interface SignalSignatures extends XsdList.SignalSignatures {
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdList.ConstructorProps {}
    }

    class XsdListSimpleTypes extends XsdList {
        static $gtype: GObject.GType<XsdListSimpleTypes>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdListSimpleTypes.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdListSimpleTypes.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdListSimpleTypes;

        // Signals

        connect<K extends keyof XsdListSimpleTypes.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListSimpleTypes.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdListSimpleTypes.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListSimpleTypes.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdListSimpleTypes.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdListSimpleTypes.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdListComplexTypes {
        // Signal signatures
        interface SignalSignatures extends XsdList.SignalSignatures {
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdList.ConstructorProps {}
    }

    class XsdListComplexTypes extends XsdList {
        static $gtype: GObject.GType<XsdListComplexTypes>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdListComplexTypes.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdListComplexTypes.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdListComplexTypes;

        // Signals

        connect<K extends keyof XsdListComplexTypes.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListComplexTypes.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdListComplexTypes.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListComplexTypes.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdListComplexTypes.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdListComplexTypes.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdListTypeRestrictionEnumerations {
        // Signal signatures
        interface SignalSignatures extends XsdList.SignalSignatures {
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdList.ConstructorProps {}
    }

    class XsdListTypeRestrictionEnumerations extends XsdList {
        static $gtype: GObject.GType<XsdListTypeRestrictionEnumerations>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdListTypeRestrictionEnumerations.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdListTypeRestrictionEnumerations.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdListTypeRestrictionEnumerations;

        // Signals

        connect<K extends keyof XsdListTypeRestrictionEnumerations.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListTypeRestrictionEnumerations.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdListTypeRestrictionEnumerations.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListTypeRestrictionEnumerations.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdListTypeRestrictionEnumerations.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdListTypeRestrictionEnumerations.SignalSignatures[K]> extends [
                any,
                ...infer Q,
            ]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XsdListTypeRestrictionWhiteSpaces {
        // Signal signatures
        interface SignalSignatures extends XsdList.SignalSignatures {
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XsdList.ConstructorProps {}
    }

    class XsdListTypeRestrictionWhiteSpaces extends XsdList {
        static $gtype: GObject.GType<XsdListTypeRestrictionWhiteSpaces>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XsdListTypeRestrictionWhiteSpaces.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XsdListTypeRestrictionWhiteSpaces.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): XsdListTypeRestrictionWhiteSpaces;

        // Signals

        connect<K extends keyof XsdListTypeRestrictionWhiteSpaces.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListTypeRestrictionWhiteSpaces.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XsdListTypeRestrictionWhiteSpaces.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XsdListTypeRestrictionWhiteSpaces.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XsdListTypeRestrictionWhiteSpaces.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XsdListTypeRestrictionWhiteSpaces.SignalSignatures[K]> extends [
                any,
                ...infer Q,
            ]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace XText {
        // Signal signatures
        interface SignalSignatures extends XCharacterData.SignalSignatures {
            'notify::str': (pspec: GObject.ParamSpec) => void;
            'notify::attrs': (pspec: GObject.ParamSpec) => void;
            'notify::children-nodes': (pspec: GObject.ParamSpec) => void;
            'notify::document': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::type-node': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::value': (pspec: GObject.ParamSpec) => void;
            'notify::data': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends XCharacterData.ConstructorProps, DomText.ConstructorProps {}
    }

    class XText extends XCharacterData implements DomText {
        static $gtype: GObject.GType<XText>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: XText.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<XText.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](doc: XDocument, node?: any | null): XText;
        // Conflicted with GXml.XCharacterData.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof XText.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XText.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof XText.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, XText.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof XText.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<XText.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get data(): string;
        set data(val: string);

        // Inherited methods
        split_text(offset: number): DomText;
        get_whole_text(): string;
        vfunc_split_text(offset: number): DomText;
        vfunc_get_whole_text(): string;
        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;
        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
    }

    type ArrayListClass = typeof ArrayList;
    abstract class ArrayListPrivate {
        static $gtype: GObject.GType<ArrayListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AttrClass = typeof Attr;
    abstract class AttrPrivate {
        static $gtype: GObject.GType<AttrPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BaseCollectionClass = typeof BaseCollection;
    abstract class BaseCollectionPrivate {
        static $gtype: GObject.GType<BaseCollectionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CssSelectorClass = typeof CssSelector;
    abstract class CssSelectorPrivate {
        static $gtype: GObject.GType<CssSelectorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CssElementSelectorClass = typeof CssElementSelector;
    abstract class CssElementSelectorPrivate {
        static $gtype: GObject.GType<CssElementSelectorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CssAttributeSelectorClass = typeof CssAttributeSelector;
    abstract class CssAttributeSelectorPrivate {
        static $gtype: GObject.GType<CssAttributeSelectorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CssNotSelectorClass = typeof CssNotSelector;
    abstract class CssNotSelectorPrivate {
        static $gtype: GObject.GType<CssNotSelectorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CssSelectorParserClass = typeof CssSelectorParser;
    abstract class CssSelectorParserPrivate {
        static $gtype: GObject.GType<CssSelectorParserPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DocumentClass = typeof Document;
    abstract class DocumentPrivate {
        static $gtype: GObject.GType<DocumentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ImplementationClass = typeof Implementation;
    abstract class ImplementationPrivate {
        static $gtype: GObject.GType<ImplementationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DocumentTypeClass = typeof DocumentType;
    abstract class DocumentTypePrivate {
        static $gtype: GObject.GType<DocumentTypePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DocumentFragmentClass = typeof DocumentFragment;
    abstract class DocumentFragmentPrivate {
        static $gtype: GObject.GType<DocumentFragmentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DomNodeFilterClass = typeof DomNodeFilter;
    abstract class DomNodeFilterPrivate {
        static $gtype: GObject.GType<DomNodeFilterPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DomElementListClass = typeof DomElementList;
    abstract class DomElementListPrivate {
        static $gtype: GObject.GType<DomElementListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DomEventInitClass = typeof DomEventInit;
    abstract class DomEventInitPrivate {
        static $gtype: GObject.GType<DomEventInitPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DomCustomEventInitClass = typeof DomCustomEventInit;
    abstract class DomCustomEventInitPrivate {
        static $gtype: GObject.GType<DomCustomEventInitPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DomTimeStampClass = typeof DomTimeStamp;
    abstract class DomTimeStampPrivate {
        static $gtype: GObject.GType<DomTimeStampPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DomMutationObserverInitClass = typeof DomMutationObserverInit;
    abstract class DomMutationObserverInitPrivate {
        static $gtype: GObject.GType<DomMutationObserverInitPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DomErrorNameClass = typeof DomErrorName;
    abstract class DomErrorNamePrivate {
        static $gtype: GObject.GType<DomErrorNamePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ElementClass = typeof Element;
    abstract class ElementPrivate {
        static $gtype: GObject.GType<ElementPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ElementAttributesClass = typeof ElementAttributes;
    abstract class ElementAttributesPrivate {
        static $gtype: GObject.GType<ElementAttributesPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type EnumerationClass = typeof Enumeration;
    abstract class EnumerationPrivate {
        static $gtype: GObject.GType<EnumerationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type EventClass = typeof Event;
    abstract class EventPrivate {
        static $gtype: GObject.GType<EventPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CustomEventClass = typeof CustomEvent;
    abstract class CustomEventPrivate {
        static $gtype: GObject.GType<CustomEventPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type HashMapClass = typeof HashMap;
    abstract class HashMapPrivate {
        static $gtype: GObject.GType<HashMapPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type HashPairedMapClass = typeof HashPairedMap;
    abstract class HashPairedMapPrivate {
        static $gtype: GObject.GType<HashPairedMapPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type HashThreeMapClass = typeof HashThreeMap;
    abstract class HashThreeMapPrivate {
        static $gtype: GObject.GType<HashThreeMapPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type HTMLCollectionClass = typeof HTMLCollection;
    abstract class HTMLCollectionPrivate {
        static $gtype: GObject.GType<HTMLCollectionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type HtmlDocumentClass = typeof HtmlDocument;
    abstract class HtmlDocumentPrivate {
        static $gtype: GObject.GType<HtmlDocumentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type HtmlElementClass = typeof HtmlElement;
    abstract class HtmlElementPrivate {
        static $gtype: GObject.GType<HtmlElementPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type LXPathObjectClass = typeof LXPathObject;
    abstract class LXPathObjectPrivate {
        static $gtype: GObject.GType<LXPathObjectPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type NodeClass = typeof Node;
    abstract class NodePrivate {
        static $gtype: GObject.GType<NodePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type NodeListClass = typeof NodeList;
    abstract class NodeListPrivate {
        static $gtype: GObject.GType<NodeListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type NodeIteratorClass = typeof NodeIterator;
    abstract class NodeIteratorPrivate {
        static $gtype: GObject.GType<NodeIteratorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BasePropertyClass = typeof BaseProperty;
    abstract class BasePropertyPrivate {
        static $gtype: GObject.GType<BasePropertyPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type StringClass = typeof String;
    abstract class StringPrivate {
        static $gtype: GObject.GType<StringPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ArrayStringClass = typeof ArrayString;
    abstract class ArrayStringPrivate {
        static $gtype: GObject.GType<ArrayStringPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdArrayStringClass = typeof XsdArrayString;
    abstract class XsdArrayStringPrivate {
        static $gtype: GObject.GType<XsdArrayStringPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DoubleClass = typeof Double;
    abstract class DoublePrivate {
        static $gtype: GObject.GType<DoublePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FloatClass = typeof Float;
    abstract class FloatPrivate {
        static $gtype: GObject.GType<FloatPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type IntClass = typeof Int;
    abstract class IntPrivate {
        static $gtype: GObject.GType<IntPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BooleanClass = typeof Boolean;
    abstract class BooleanPrivate {
        static $gtype: GObject.GType<BooleanPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type EnumClass = typeof Enum;
    abstract class EnumPrivate {
        static $gtype: GObject.GType<EnumPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DateClass = typeof Date;
    abstract class DatePrivate {
        static $gtype: GObject.GType<DatePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DateTimeClass = typeof DateTime;
    abstract class DateTimePrivate {
        static $gtype: GObject.GType<DateTimePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type RangeClass = typeof Range;
    abstract class RangePrivate {
        static $gtype: GObject.GType<RangePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SettableTokenListClass = typeof SettableTokenList;
    abstract class SettableTokenListPrivate {
        static $gtype: GObject.GType<SettableTokenListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type StringRefClass = typeof StringRef;
    abstract class StringRefPrivate {
        static $gtype: GObject.GType<StringRefPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CharacterDataClass = typeof CharacterData;
    abstract class CharacterDataPrivate {
        static $gtype: GObject.GType<CharacterDataPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TextClass = typeof Text;
    abstract class TextPrivate {
        static $gtype: GObject.GType<TextPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ProcessingInstructionClass = typeof ProcessingInstruction;
    abstract class ProcessingInstructionPrivate {
        static $gtype: GObject.GType<ProcessingInstructionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CommentClass = typeof Comment;
    abstract class CommentPrivate {
        static $gtype: GObject.GType<CommentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TokenListClass = typeof TokenList;
    abstract class TokenListPrivate {
        static $gtype: GObject.GType<TokenListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TreeWalkerClass = typeof TreeWalker;
    abstract class TreeWalkerPrivate {
        static $gtype: GObject.GType<TreeWalkerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XAttributeClass = typeof XAttribute;
    abstract class XAttributePrivate {
        static $gtype: GObject.GType<XAttributePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XCharacterDataClass = typeof XCharacterData;
    abstract class XCharacterDataPrivate {
        static $gtype: GObject.GType<XCharacterDataPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XChildNodeClass = typeof XChildNode;
    abstract class XChildNodePrivate {
        static $gtype: GObject.GType<XChildNodePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XNonDocumentChildNodeClass = typeof XNonDocumentChildNode;
    abstract class XNonDocumentChildNodePrivate {
        static $gtype: GObject.GType<XNonDocumentChildNodePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XCommentClass = typeof XComment;
    abstract class XCommentPrivate {
        static $gtype: GObject.GType<XCommentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XDocumentClass = typeof XDocument;
    abstract class XDocumentPrivate {
        static $gtype: GObject.GType<XDocumentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XElementClass = typeof XElement;
    abstract class XElementPrivate {
        static $gtype: GObject.GType<XElementPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XHashMapAttrClass = typeof XHashMapAttr;
    abstract class XHashMapAttrPrivate {
        static $gtype: GObject.GType<XHashMapAttrPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XHashMapAttrEntryClass = typeof XHashMapAttrEntry;
    abstract class XHashMapAttrEntryPrivate {
        static $gtype: GObject.GType<XHashMapAttrEntryPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XHashMapAttrIteratorClass = typeof XHashMapAttrIterator;
    abstract class XHashMapAttrIteratorPrivate {
        static $gtype: GObject.GType<XHashMapAttrIteratorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XHtmlDocumentClass = typeof XHtmlDocument;
    abstract class XHtmlDocumentPrivate {
        static $gtype: GObject.GType<XHtmlDocumentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XListChildrenClass = typeof XListChildren;
    abstract class XListChildrenPrivate {
        static $gtype: GObject.GType<XListChildrenPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XListChildrenIteratorClass = typeof XListChildrenIterator;
    abstract class XListChildrenIteratorPrivate {
        static $gtype: GObject.GType<XListChildrenIteratorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XNodeClass = typeof XNode;
    abstract class XNodePrivate {
        static $gtype: GObject.GType<XNodePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XParserClass = typeof XParser;
    abstract class XParserPrivate {
        static $gtype: GObject.GType<XParserPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XProcessingInstructionClass = typeof XProcessingInstruction;
    abstract class XProcessingInstructionPrivate {
        static $gtype: GObject.GType<XProcessingInstructionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdSchemaClass = typeof XsdSchema;
    abstract class XsdSchemaPrivate {
        static $gtype: GObject.GType<XsdSchemaPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdSimpleTypeClass = typeof XsdSimpleType;
    abstract class XsdSimpleTypePrivate {
        static $gtype: GObject.GType<XsdSimpleTypePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeDefinitionClass = typeof XsdTypeDefinition;
    abstract class XsdTypeDefinitionPrivate {
        static $gtype: GObject.GType<XsdTypeDefinitionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeListClass = typeof XsdTypeList;
    abstract class XsdTypeListPrivate {
        static $gtype: GObject.GType<XsdTypeListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeUnionClass = typeof XsdTypeUnion;
    abstract class XsdTypeUnionPrivate {
        static $gtype: GObject.GType<XsdTypeUnionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionClass = typeof XsdTypeRestriction;
    abstract class XsdTypeRestrictionPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionDefClass = typeof XsdTypeRestrictionDef;
    abstract class XsdTypeRestrictionDefPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionDefPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionMinExclusiveClass = typeof XsdTypeRestrictionMinExclusive;
    abstract class XsdTypeRestrictionMinExclusivePrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionMinExclusivePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionMinInclusiveClass = typeof XsdTypeRestrictionMinInclusive;
    abstract class XsdTypeRestrictionMinInclusivePrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionMinInclusivePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionMaxExclusiveClass = typeof XsdTypeRestrictionMaxExclusive;
    abstract class XsdTypeRestrictionMaxExclusivePrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionMaxExclusivePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionMaxInclusiveClass = typeof XsdTypeRestrictionMaxInclusive;
    abstract class XsdTypeRestrictionMaxInclusivePrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionMaxInclusivePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionTotalDigitsClass = typeof XsdTypeRestrictionTotalDigits;
    abstract class XsdTypeRestrictionTotalDigitsPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionTotalDigitsPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionFractionDigitsClass = typeof XsdTypeRestrictionFractionDigits;
    abstract class XsdTypeRestrictionFractionDigitsPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionFractionDigitsPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionLengthClass = typeof XsdTypeRestrictionLength;
    abstract class XsdTypeRestrictionLengthPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionLengthPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionMinLengthClass = typeof XsdTypeRestrictionMinLength;
    abstract class XsdTypeRestrictionMinLengthPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionMinLengthPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionMaxLengthClass = typeof XsdTypeRestrictionMaxLength;
    abstract class XsdTypeRestrictionMaxLengthPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionMaxLengthPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionEnumerationClass = typeof XsdTypeRestrictionEnumeration;
    abstract class XsdTypeRestrictionEnumerationPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionEnumerationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionWhiteSpaceClass = typeof XsdTypeRestrictionWhiteSpace;
    abstract class XsdTypeRestrictionWhiteSpacePrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionWhiteSpacePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionWhiteSpaceFixedClass = typeof XsdTypeRestrictionWhiteSpaceFixed;
    abstract class XsdTypeRestrictionWhiteSpaceFixedPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionWhiteSpaceFixedPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionPatternClass = typeof XsdTypeRestrictionPattern;
    abstract class XsdTypeRestrictionPatternPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionPatternPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionAssertionClass = typeof XsdTypeRestrictionAssertion;
    abstract class XsdTypeRestrictionAssertionPrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionAssertionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdTypeRestrictionExplicitTimezoneClass = typeof XsdTypeRestrictionExplicitTimezone;
    abstract class XsdTypeRestrictionExplicitTimezonePrivate {
        static $gtype: GObject.GType<XsdTypeRestrictionExplicitTimezonePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdComplexTypeClass = typeof XsdComplexType;
    abstract class XsdComplexTypePrivate {
        static $gtype: GObject.GType<XsdComplexTypePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdExtensionClass = typeof XsdExtension;
    abstract class XsdExtensionPrivate {
        static $gtype: GObject.GType<XsdExtensionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdElementClass = typeof XsdElement;
    abstract class XsdElementPrivate {
        static $gtype: GObject.GType<XsdElementPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdAnnotationClass = typeof XsdAnnotation;
    abstract class XsdAnnotationPrivate {
        static $gtype: GObject.GType<XsdAnnotationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdBaseTypeClass = typeof XsdBaseType;
    abstract class XsdBaseTypePrivate {
        static $gtype: GObject.GType<XsdBaseTypePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdBaseContentClass = typeof XsdBaseContent;
    abstract class XsdBaseContentPrivate {
        static $gtype: GObject.GType<XsdBaseContentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdSimpleContentClass = typeof XsdSimpleContent;
    abstract class XsdSimpleContentPrivate {
        static $gtype: GObject.GType<XsdSimpleContentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdComplexContentClass = typeof XsdComplexContent;
    abstract class XsdComplexContentPrivate {
        static $gtype: GObject.GType<XsdComplexContentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdOpenContentClass = typeof XsdOpenContent;
    abstract class XsdOpenContentPrivate {
        static $gtype: GObject.GType<XsdOpenContentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdBaseAttributeClass = typeof XsdBaseAttribute;
    abstract class XsdBaseAttributePrivate {
        static $gtype: GObject.GType<XsdBaseAttributePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdAttributeClass = typeof XsdAttribute;
    abstract class XsdAttributePrivate {
        static $gtype: GObject.GType<XsdAttributePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdAttributeGroupClass = typeof XsdAttributeGroup;
    abstract class XsdAttributeGroupPrivate {
        static $gtype: GObject.GType<XsdAttributeGroupPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdListClass = typeof XsdList;
    abstract class XsdListPrivate {
        static $gtype: GObject.GType<XsdListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdListElementsClass = typeof XsdListElements;
    abstract class XsdListElementsPrivate {
        static $gtype: GObject.GType<XsdListElementsPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdListSimpleTypesClass = typeof XsdListSimpleTypes;
    abstract class XsdListSimpleTypesPrivate {
        static $gtype: GObject.GType<XsdListSimpleTypesPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdListComplexTypesClass = typeof XsdListComplexTypes;
    abstract class XsdListComplexTypesPrivate {
        static $gtype: GObject.GType<XsdListComplexTypesPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdListTypeRestrictionEnumerationsClass = typeof XsdListTypeRestrictionEnumerations;
    abstract class XsdListTypeRestrictionEnumerationsPrivate {
        static $gtype: GObject.GType<XsdListTypeRestrictionEnumerationsPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XsdListTypeRestrictionWhiteSpacesClass = typeof XsdListTypeRestrictionWhiteSpaces;
    abstract class XsdListTypeRestrictionWhiteSpacesPrivate {
        static $gtype: GObject.GType<XsdListTypeRestrictionWhiteSpacesPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type XTextClass = typeof XText;
    abstract class XTextPrivate {
        static $gtype: GObject.GType<XTextPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CollectionIface = typeof Collection;
    type ListIface = typeof List;
    type MappeableElementIface = typeof MappeableElement;
    type MapIface = typeof Map;
    type MappeableElementPairKeyIface = typeof MappeableElementPairKey;
    type PairedMapIface = typeof PairedMap;
    type MappeableElementThreeKeyIface = typeof MappeableElementThreeKey;
    type ThreeMapIface = typeof ThreeMap;
    type CollectionParentIface = typeof CollectionParent;
    type DomAttrIface = typeof DomAttr;
    type DomCharacterDataIface = typeof DomCharacterData;
    type DomTextIface = typeof DomText;
    type DomProcessingInstructionIface = typeof DomProcessingInstruction;
    type DomCommentIface = typeof DomComment;
    type DomNonElementParentNodeIface = typeof DomNonElementParentNode;
    type DomParentNodeIface = typeof DomParentNode;
    type DomNonDocumentTypeChildNodeIface = typeof DomNonDocumentTypeChildNode;
    type DomChildNodeIface = typeof DomChildNode;
    type DomNodeListIface = typeof DomNodeList;
    type DomHTMLCollectionIface = typeof DomHTMLCollection;
    type DomNodeIteratorIface = typeof DomNodeIterator;
    type DomTreeWalkerIface = typeof DomTreeWalker;
    type DomNamedNodeMapIface = typeof DomNamedNodeMap;
    type DomTokenListIface = typeof DomTokenList;
    type DomSettableTokenListIface = typeof DomSettableTokenList;
    type DomDocumentIface = typeof DomDocument;
    type DomXMLDocumentIface = typeof DomXMLDocument;
    type DomImplementationIface = typeof DomImplementation;
    type DomDocumentFragmentIface = typeof DomDocumentFragment;
    type DomDocumentTypeIface = typeof DomDocumentType;
    type DomHtmlDocumentIface = typeof DomHtmlDocument;
    type DomElementIface = typeof DomElement;
    type DomEventTargetIface = typeof DomEventTarget;
    type DomEventListenerIface = typeof DomEventListener;
    type DomEventIface = typeof DomEvent;
    type DomCustomEventIface = typeof DomCustomEvent;
    type DomMutationObserverIface = typeof DomMutationObserver;
    type DomMutationRecordIface = typeof DomMutationRecord;
    type DomNodeIface = typeof DomNode;
    type DomRangeIface = typeof DomRange;
    type IXsdSchemaIface = typeof IXsdSchema;
    type IXsdBaseTypeIface = typeof IXsdBaseType;
    type IXsdSimpleTypeIface = typeof IXsdSimpleType;
    type IXsdTypeDefIface = typeof IXsdTypeDef;
    type IXsdTypeRestrictionIface = typeof IXsdTypeRestriction;
    type IXsdTypeListIface = typeof IXsdTypeList;
    type IXsdTypeUnionIface = typeof IXsdTypeUnion;
    type IXsdTypeRestrictionDefIface = typeof IXsdTypeRestrictionDef;
    type IXsdTypeRestrictionMinExclusiveIface = typeof IXsdTypeRestrictionMinExclusive;
    type IXsdTypeRestrictionMinInclusiveIface = typeof IXsdTypeRestrictionMinInclusive;
    type IXsdTypeRestrictionMaxExclusiveIface = typeof IXsdTypeRestrictionMaxExclusive;
    type IXsdTypeRestrictionMaxInclusiveIface = typeof IXsdTypeRestrictionMaxInclusive;
    type IXsdTypeRestrictionTotalDigitsIface = typeof IXsdTypeRestrictionTotalDigits;
    type IXsdTypeRestrictionFractionDigitsIface = typeof IXsdTypeRestrictionFractionDigits;
    type IXsdTypeRestrictionLengthIface = typeof IXsdTypeRestrictionLength;
    type IXsdTypeRestrictionMinLengthIface = typeof IXsdTypeRestrictionMinLength;
    type IXsdTypeRestrictionMaxLengthIface = typeof IXsdTypeRestrictionMaxLength;
    type IXsdTypeRestrictionEnumerationIface = typeof IXsdTypeRestrictionEnumeration;
    type IXsdTypeRestrictionWhiteSpaceIface = typeof IXsdTypeRestrictionWhiteSpace;
    type IXsdTypeRestrictionPatternIface = typeof IXsdTypeRestrictionPattern;
    type IXsdTypeRestrictionAssertionIface = typeof IXsdTypeRestrictionAssertion;
    type IXsdTypeRestrictionExplicitTimezoneIface = typeof IXsdTypeRestrictionExplicitTimezone;
    type IXsdComplexTypeIface = typeof IXsdComplexType;
    type IXsdExtensionIface = typeof IXsdExtension;
    type IXsdElementIface = typeof IXsdElement;
    type IXsdAnnotationIface = typeof IXsdAnnotation;
    type IXsdBaseContentIface = typeof IXsdBaseContent;
    type IXsdSimpleContentIface = typeof IXsdSimpleContent;
    type IXsdComplexContentIface = typeof IXsdComplexContent;
    type IXsdOpenContentIface = typeof IXsdOpenContent;
    type IXsdBaseAttributeIface = typeof IXsdBaseAttribute;
    type IXsdAttributeIface = typeof IXsdAttribute;
    type IXsdAttributeGroupIface = typeof IXsdAttributeGroup;
    type IXsdListIface = typeof IXsdList;
    type IXsdListElementsIface = typeof IXsdListElements;
    type IXsdListSimpleTypesIface = typeof IXsdListSimpleTypes;
    type IXsdListComplexTypesIface = typeof IXsdListComplexTypes;
    type IXsdListAttributesIface = typeof IXsdListAttributes;
    type IXsdListAttributesGroupIface = typeof IXsdListAttributesGroup;
    type IXsdListTypeRestrictionEnumerationsIface = typeof IXsdListTypeRestrictionEnumerations;
    type IXsdListTypeRestrictionWhiteSpacesIface = typeof IXsdListTypeRestrictionWhiteSpaces;
    type ObjectIface = typeof Object;
    type ParserIface = typeof Parser;
    type PropertyIface = typeof Property;
    type XPathContextIface = typeof XPathContext;
    type XPathObjectIface = typeof XPathObject;
    namespace Collection {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            nodes_index: GLib.Queue;
            nodesIndex: GLib.Queue;
            element: DomElement;
            items_name: string;
            itemsName: string;
            items_type: GObject.GType;
            itemsType: GObject.GType;
        }
    }

    export interface CollectionNamespace {
        $gtype: GObject.GType<Collection>;
        prototype: Collection;
    }
    interface Collection extends GObject.Object {
        // Properties

        get nodes_index(): GLib.Queue;
        get nodesIndex(): GLib.Queue;
        get element(): DomElement;
        set element(val: DomElement);
        get items_name(): string;
        get itemsName(): string;
        get items_type(): GObject.GType;
        set items_type(val: GObject.GType);
        get itemsType(): GObject.GType;
        set itemsType(val: GObject.GType);

        // Methods

        get_nodes_index(): GLib.Queue;
        get_element(): DomElement;
        set_element(value: DomElement): void;
        get_items_name(): string;
        get_items_type(): GObject.GType;
        set_items_type(value: GObject.GType): void;
        search(): void;
        get_item(index: number): DomElement | null;
        append(node: DomElement): void;
        get_length(): number;
        initialize(t: GObject.GType): void;
        create_item(): DomElement | null;
        validate_append(index: number, element: DomElement): boolean;
        clear(): void;

        // Virtual methods

        vfunc_get_nodes_index(): GLib.Queue;
        vfunc_get_element(): DomElement;
        vfunc_set_element(value: DomElement): void;
        vfunc_get_items_name(): string;
        vfunc_get_items_type(): GObject.GType;
        vfunc_set_items_type(value: GObject.GType): void;
        vfunc_search(): void;
        vfunc_get_item(index: number): DomElement | null;
        vfunc_append(node: DomElement): void;
        vfunc_get_length(): number;
        vfunc_initialize(t: GObject.GType): void;
        vfunc_create_item(): DomElement | null;
        vfunc_validate_append(index: number, element: DomElement): boolean;
        vfunc_clear(): void;
    }

    export const Collection: CollectionNamespace & {
        new (): Collection; // This allows `obj instanceof Collection`
    };

    namespace List {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ListNamespace {
        $gtype: GObject.GType<List>;
        prototype: List;
    }
    interface List extends GObject.Object {}

    export const List: ListNamespace & {
        new (): List; // This allows `obj instanceof List`
    };

    namespace MappeableElement {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface MappeableElementNamespace {
        $gtype: GObject.GType<MappeableElement>;
        prototype: MappeableElement;
    }
    interface MappeableElement extends GObject.Object {
        // Methods

        get_map_key(): string;

        // Virtual methods

        vfunc_get_map_key(): string;
    }

    export const MappeableElement: MappeableElementNamespace & {
        new (): MappeableElement; // This allows `obj instanceof MappeableElement`
    };

    namespace Map {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            attribute_key: string;
            attributeKey: string;
            keys_set: Gee.Set;
            keysSet: Gee.Set;
        }
    }

    export interface MapNamespace {
        $gtype: GObject.GType<Map>;
        prototype: Map;
    }
    interface Map extends GObject.Object {
        // Properties

        get attribute_key(): string;
        set attribute_key(val: string);
        get attributeKey(): string;
        set attributeKey(val: string);
        get keys_set(): Gee.Set;
        get keysSet(): Gee.Set;

        // Methods

        get_attribute_key(): string;
        set_attribute_key(value: string): void;
        item(key: string): DomElement | null;
        has_key(key: string): boolean;
        get_keys_set(): Gee.Set;

        // Virtual methods

        vfunc_get_attribute_key(): string;
        vfunc_set_attribute_key(value: string): void;
        vfunc_item(key: string): DomElement | null;
        vfunc_has_key(key: string): boolean;
        vfunc_get_keys_set(): Gee.Set;
    }

    export const Map: MapNamespace & {
        new (): Map; // This allows `obj instanceof Map`
    };

    namespace MappeableElementPairKey {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface MappeableElementPairKeyNamespace {
        $gtype: GObject.GType<MappeableElementPairKey>;
        prototype: MappeableElementPairKey;
    }
    interface MappeableElementPairKey extends GObject.Object {
        // Methods

        get_map_primary_key(): string;
        get_map_secondary_key(): string;

        // Virtual methods

        vfunc_get_map_primary_key(): string;
        vfunc_get_map_secondary_key(): string;
    }

    export const MappeableElementPairKey: MappeableElementPairKeyNamespace & {
        new (): MappeableElementPairKey; // This allows `obj instanceof MappeableElementPairKey`
    };

    namespace PairedMap {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            attribute_primary_key: string;
            attributePrimaryKey: string;
            attribute_secondary_key: string;
            attributeSecondaryKey: string;
            primary_keys_set: Gee.Set;
            primaryKeysSet: Gee.Set;
        }
    }

    export interface PairedMapNamespace {
        $gtype: GObject.GType<PairedMap>;
        prototype: PairedMap;
    }
    interface PairedMap extends GObject.Object {
        // Properties

        get attribute_primary_key(): string;
        set attribute_primary_key(val: string);
        get attributePrimaryKey(): string;
        set attributePrimaryKey(val: string);
        get attribute_secondary_key(): string;
        set attribute_secondary_key(val: string);
        get attributeSecondaryKey(): string;
        set attributeSecondaryKey(val: string);
        get primary_keys_set(): Gee.Set;
        get primaryKeysSet(): Gee.Set;

        // Methods

        get_attribute_primary_key(): string;
        set_attribute_primary_key(value: string): void;
        get_attribute_secondary_key(): string;
        set_attribute_secondary_key(value: string): void;
        get_primary_keys_set(): Gee.Set;
        item(primary_key: string, secondary_key: string): DomElement | null;
        has_primary_key(key: string): boolean;
        has_secondary_key(pkey: string, key: string): boolean;
        secondary_keys_set(pkey: string): Gee.Set;

        // Virtual methods

        vfunc_get_attribute_primary_key(): string;
        vfunc_set_attribute_primary_key(value: string): void;
        vfunc_get_attribute_secondary_key(): string;
        vfunc_set_attribute_secondary_key(value: string): void;
        vfunc_get_primary_keys_set(): Gee.Set;
        vfunc_item(primary_key: string, secondary_key: string): DomElement | null;
        vfunc_has_primary_key(key: string): boolean;
        vfunc_has_secondary_key(pkey: string, key: string): boolean;
        vfunc_secondary_keys_set(pkey: string): Gee.Set;
    }

    export const PairedMap: PairedMapNamespace & {
        new (): PairedMap; // This allows `obj instanceof PairedMap`
    };

    namespace MappeableElementThreeKey {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface MappeableElementThreeKeyNamespace {
        $gtype: GObject.GType<MappeableElementThreeKey>;
        prototype: MappeableElementThreeKey;
    }
    interface MappeableElementThreeKey extends GObject.Object {
        // Methods

        get_map_pkey(): string;
        get_map_skey(): string;
        get_map_tkey(): string;

        // Virtual methods

        vfunc_get_map_pkey(): string;
        vfunc_get_map_skey(): string;
        vfunc_get_map_tkey(): string;
    }

    export const MappeableElementThreeKey: MappeableElementThreeKeyNamespace & {
        new (): MappeableElementThreeKey; // This allows `obj instanceof MappeableElementThreeKey`
    };

    namespace ThreeMap {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            attribute_primary_key: string;
            attributePrimaryKey: string;
            attribute_secondary_key: string;
            attributeSecondaryKey: string;
            attribute_third_key: string;
            attributeThirdKey: string;
            primary_keys_set: Gee.Set;
            primaryKeysSet: Gee.Set;
        }
    }

    export interface ThreeMapNamespace {
        $gtype: GObject.GType<ThreeMap>;
        prototype: ThreeMap;
    }
    interface ThreeMap extends GObject.Object {
        // Properties

        get attribute_primary_key(): string;
        set attribute_primary_key(val: string);
        get attributePrimaryKey(): string;
        set attributePrimaryKey(val: string);
        get attribute_secondary_key(): string;
        set attribute_secondary_key(val: string);
        get attributeSecondaryKey(): string;
        set attributeSecondaryKey(val: string);
        get attribute_third_key(): string;
        set attribute_third_key(val: string);
        get attributeThirdKey(): string;
        set attributeThirdKey(val: string);
        get primary_keys_set(): Gee.Set;
        get primaryKeysSet(): Gee.Set;

        // Methods

        get_attribute_primary_key(): string;
        set_attribute_primary_key(value: string): void;
        get_attribute_secondary_key(): string;
        set_attribute_secondary_key(value: string): void;
        get_attribute_third_key(): string;
        set_attribute_third_key(value: string): void;
        get_primary_keys_set(): Gee.Set;
        item(primary_key: string, secondary_key: string, third_key: string): DomElement | null;
        has_primary_key(key: string): boolean;
        has_secondary_key(pkey: string, key: string): boolean;
        has_third_key(pkey: string, skey: string, key: string): boolean;
        secondary_keys_set(pkey: string): Gee.Set;
        third_keys_set(pkey: string, skey: string): Gee.Set;

        // Virtual methods

        vfunc_get_attribute_primary_key(): string;
        vfunc_set_attribute_primary_key(value: string): void;
        vfunc_get_attribute_secondary_key(): string;
        vfunc_set_attribute_secondary_key(value: string): void;
        vfunc_get_attribute_third_key(): string;
        vfunc_set_attribute_third_key(value: string): void;
        vfunc_get_primary_keys_set(): Gee.Set;
        vfunc_item(primary_key: string, secondary_key: string, third_key: string): DomElement | null;
        vfunc_has_primary_key(key: string): boolean;
        vfunc_has_secondary_key(pkey: string, key: string): boolean;
        vfunc_has_third_key(pkey: string, skey: string, key: string): boolean;
        vfunc_secondary_keys_set(pkey: string): Gee.Set;
        vfunc_third_keys_set(pkey: string, skey: string): Gee.Set;
    }

    export const ThreeMap: ThreeMapNamespace & {
        new (): ThreeMap; // This allows `obj instanceof ThreeMap`
    };

    namespace CollectionParent {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface CollectionParentNamespace {
        $gtype: GObject.GType<CollectionParent>;
        prototype: CollectionParent;

        add_supported_type(
            types: { [key: string]: any } | GLib.HashTable<string, GObject.GType>,
            parent_type: GObject.GType,
            type: GObject.GType,
        ): void;
        add_supported_types(
            table: { [key: string]: any } | GLib.HashTable<string, GObject.GType>,
            parent_type: GObject.GType,
            types: GObject.GType[],
        ): void;
    }
    interface CollectionParent extends GObject.Object {
        // Methods

        get_types(): GLib.HashTable<string, GObject.GType>;

        // Virtual methods

        vfunc_get_types(): GLib.HashTable<string, GObject.GType>;
    }

    export const CollectionParent: CollectionParentNamespace & {
        new (): CollectionParent; // This allows `obj instanceof CollectionParent`
    };

    namespace DomAttr {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            namespace_uri: string;
            namespaceUri: string;
            prefix: string;
            local_name: string;
            localName: string;
            name: string;
            value: string;
        }
    }

    export interface DomAttrNamespace {
        $gtype: GObject.GType<DomAttr>;
        prototype: DomAttr;
    }
    interface DomAttr extends GObject.Object {
        // Properties

        get namespace_uri(): string;
        get namespaceUri(): string;
        get prefix(): string;
        get local_name(): string;
        get localName(): string;
        get name(): string;
        get value(): string;
        set value(val: string);

        // Methods

        get_namespace_uri(): string | null;
        get_prefix(): string | null;
        get_local_name(): string;
        get_name(): string;
        get_value(): string;
        set_value(value: string): void;
        get_specified(): boolean;

        // Virtual methods

        vfunc_get_namespace_uri(): string | null;
        vfunc_get_prefix(): string | null;
        vfunc_get_local_name(): string;
        vfunc_get_name(): string;
        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
        vfunc_get_specified(): boolean;
    }

    export const DomAttr: DomAttrNamespace & {
        new (): DomAttr; // This allows `obj instanceof DomAttr`
    };

    namespace DomCharacterData {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            data: string;
        }
    }

    export interface DomCharacterDataNamespace {
        $gtype: GObject.GType<DomCharacterData>;
        prototype: DomCharacterData;
    }
    interface DomCharacterData extends GObject.Object {
        // Properties

        get data(): string;
        set data(val: string);

        // Methods

        get_data(): string;
        // Conflicted with GObject.Object.get_data
        get_data(...args: never[]): any;
        set_data(value: string): void;
        get_length(): number;
        substring_data(offset: number, count: number): string;
        append_data(data: string): void;
        insert_data(offset: number, data: string): void;
        delete_data(offset: number, count: number): void;
        replace_data(offset: number, count: number, data: string): void;

        // Virtual methods

        vfunc_get_data(): string;
        vfunc_set_data(value: string): void;
        vfunc_get_length(): number;
        vfunc_substring_data(offset: number, count: number): string;
        vfunc_append_data(data: string): void;
        vfunc_insert_data(offset: number, data: string): void;
        vfunc_delete_data(offset: number, count: number): void;
        vfunc_replace_data(offset: number, count: number, data: string): void;
    }

    export const DomCharacterData: DomCharacterDataNamespace & {
        new (): DomCharacterData; // This allows `obj instanceof DomCharacterData`
    };

    namespace DomText {
        // Constructor properties interface

        interface ConstructorProps extends DomCharacterData.ConstructorProps {}
    }

    export interface DomTextNamespace {
        $gtype: GObject.GType<DomText>;
        prototype: DomText;
    }
    interface DomText extends DomCharacterData {
        // Methods

        split_text(offset: number): DomText;
        get_whole_text(): string;

        // Virtual methods

        vfunc_split_text(offset: number): DomText;
        vfunc_get_whole_text(): string;
    }

    export const DomText: DomTextNamespace & {
        new (): DomText; // This allows `obj instanceof DomText`
    };

    namespace DomProcessingInstruction {
        // Constructor properties interface

        interface ConstructorProps extends DomCharacterData.ConstructorProps {
            target: string;
        }
    }

    export interface DomProcessingInstructionNamespace {
        $gtype: GObject.GType<DomProcessingInstruction>;
        prototype: DomProcessingInstruction;
    }
    interface DomProcessingInstruction extends DomCharacterData {
        // Properties

        get target(): string;

        // Methods

        get_target(): string;

        // Virtual methods

        vfunc_get_target(): string;
    }

    export const DomProcessingInstruction: DomProcessingInstructionNamespace & {
        new (): DomProcessingInstruction; // This allows `obj instanceof DomProcessingInstruction`
    };

    namespace DomComment {
        // Constructor properties interface

        interface ConstructorProps extends DomCharacterData.ConstructorProps {}
    }

    export interface DomCommentNamespace {
        $gtype: GObject.GType<DomComment>;
        prototype: DomComment;
    }
    interface DomComment extends DomCharacterData {}

    export const DomComment: DomCommentNamespace & {
        new (): DomComment; // This allows `obj instanceof DomComment`
    };

    namespace DomNonElementParentNode {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomNonElementParentNodeNamespace {
        $gtype: GObject.GType<DomNonElementParentNode>;
        prototype: DomNonElementParentNode;
    }
    interface DomNonElementParentNode extends GObject.Object {
        // Methods

        get_element_by_id(element_id: string): DomElement | null;

        // Virtual methods

        vfunc_get_element_by_id(element_id: string): DomElement | null;
    }

    export const DomNonElementParentNode: DomNonElementParentNodeNamespace & {
        new (): DomNonElementParentNode; // This allows `obj instanceof DomNonElementParentNode`
    };

    namespace DomParentNode {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            children: DomHTMLCollection;
            first_element_child: DomElement;
            firstElementChild: DomElement;
            last_element_child: DomElement;
            lastElementChild: DomElement;
            child_element_count: number;
            childElementCount: number;
        }
    }

    export interface DomParentNodeNamespace {
        $gtype: GObject.GType<DomParentNode>;
        prototype: DomParentNode;
    }
    interface DomParentNode extends GObject.Object {
        // Properties

        get children(): DomHTMLCollection;
        get first_element_child(): DomElement;
        get firstElementChild(): DomElement;
        get last_element_child(): DomElement;
        get lastElementChild(): DomElement;
        get child_element_count(): number;
        get childElementCount(): number;

        // Methods

        get_children(): DomHTMLCollection;
        get_first_element_child(): DomElement | null;
        get_last_element_child(): DomElement | null;
        get_child_element_count(): number;
        query_selector(selectors: string): DomElement | null;
        query_selector_all(selectors: string): DomNodeList;
        get_elements_by_property_value(property: string, value: string): DomElementList;

        // Virtual methods

        vfunc_get_children(): DomHTMLCollection;
        vfunc_get_first_element_child(): DomElement | null;
        vfunc_get_last_element_child(): DomElement | null;
        vfunc_get_child_element_count(): number;
        vfunc_query_selector(selectors: string): DomElement | null;
        vfunc_query_selector_all(selectors: string): DomNodeList;
        vfunc_get_elements_by_property_value(property: string, value: string): DomElementList;
    }

    export const DomParentNode: DomParentNodeNamespace & {
        new (): DomParentNode; // This allows `obj instanceof DomParentNode`
    };

    namespace DomNonDocumentTypeChildNode {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            previous_element_sibling: DomElement;
            previousElementSibling: DomElement;
            next_element_sibling: DomElement;
            nextElementSibling: DomElement;
        }
    }

    export interface DomNonDocumentTypeChildNodeNamespace {
        $gtype: GObject.GType<DomNonDocumentTypeChildNode>;
        prototype: DomNonDocumentTypeChildNode;
    }
    interface DomNonDocumentTypeChildNode extends GObject.Object {
        // Properties

        get previous_element_sibling(): DomElement;
        get previousElementSibling(): DomElement;
        get next_element_sibling(): DomElement;
        get nextElementSibling(): DomElement;

        // Methods

        get_previous_element_sibling(): DomElement | null;
        get_next_element_sibling(): DomElement | null;

        // Virtual methods

        vfunc_get_previous_element_sibling(): DomElement | null;
        vfunc_get_next_element_sibling(): DomElement | null;
    }

    export const DomNonDocumentTypeChildNode: DomNonDocumentTypeChildNodeNamespace & {
        new (): DomNonDocumentTypeChildNode; // This allows `obj instanceof DomNonDocumentTypeChildNode`
    };

    namespace DomChildNode {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomChildNodeNamespace {
        $gtype: GObject.GType<DomChildNode>;
        prototype: DomChildNode;
    }
    interface DomChildNode extends GObject.Object {
        // Methods

        remove(): void;

        // Virtual methods

        vfunc_remove(): void;
    }

    export const DomChildNode: DomChildNodeNamespace & {
        new (): DomChildNode; // This allows `obj instanceof DomChildNode`
    };

    namespace DomNodeList {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            length: number;
        }
    }

    export interface DomNodeListNamespace {
        $gtype: GObject.GType<DomNodeList>;
        prototype: DomNodeList;
    }
    interface DomNodeList extends GObject.Object {
        // Properties

        get length(): number;

        // Methods

        item(index: number): DomNode | null;
        get_length(): number;

        // Virtual methods

        vfunc_item(index: number): DomNode | null;
        vfunc_get_length(): number;
    }

    export const DomNodeList: DomNodeListNamespace & {
        new (): DomNodeList; // This allows `obj instanceof DomNodeList`
    };

    namespace DomHTMLCollection {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomHTMLCollectionNamespace {
        $gtype: GObject.GType<DomHTMLCollection>;
        prototype: DomHTMLCollection;
    }
    interface DomHTMLCollection extends GObject.Object {
        // Methods

        get_element(index: number): DomElement | null;
        to_array(): DomElement[];
        get_length(): number;
        item(index: number): DomElement | null;
        named_item(name: string): DomElement | null;

        // Virtual methods

        vfunc_get_element(index: number): DomElement | null;
        vfunc_to_array(): DomElement[];
        vfunc_get_length(): number;
        vfunc_item(index: number): DomElement | null;
        vfunc_named_item(name: string): DomElement | null;
    }

    export const DomHTMLCollection: DomHTMLCollectionNamespace & {
        new (): DomHTMLCollection; // This allows `obj instanceof DomHTMLCollection`
    };

    namespace DomNodeIterator {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            root: DomNode;
            reference_node: DomNode;
            referenceNode: DomNode;
            pointer_before_reference_node: boolean;
            pointerBeforeReferenceNode: boolean;
            what_to_show: number;
            whatToShow: number;
        }
    }

    export interface DomNodeIteratorNamespace {
        $gtype: GObject.GType<DomNodeIterator>;
        prototype: DomNodeIterator;
    }
    interface DomNodeIterator extends GObject.Object {
        // Properties

        get root(): DomNode;
        get reference_node(): DomNode;
        get referenceNode(): DomNode;
        get pointer_before_reference_node(): boolean;
        get pointerBeforeReferenceNode(): boolean;
        get what_to_show(): number;
        get whatToShow(): number;

        // Methods

        get_root(): DomNode;
        get_reference_node(): DomNode;
        get_pointer_before_reference_node(): boolean;
        get_what_to_show(): number;
        next_node(): DomNode | null;
        previous_node(): DomNode | null;
        detach(): void;

        // Virtual methods

        vfunc_get_root(): DomNode;
        vfunc_get_reference_node(): DomNode;
        vfunc_get_pointer_before_reference_node(): boolean;
        vfunc_get_what_to_show(): number;
        vfunc_next_node(): DomNode | null;
        vfunc_previous_node(): DomNode | null;
        vfunc_detach(): void;
    }

    export const DomNodeIterator: DomNodeIteratorNamespace & {
        new (): DomNodeIterator; // This allows `obj instanceof DomNodeIterator`
    };

    namespace DomTreeWalker {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            root: DomNode;
            what_to_show: number;
            whatToShow: number;
            current_node: DomNode;
            currentNode: DomNode;
        }
    }

    export interface DomTreeWalkerNamespace {
        $gtype: GObject.GType<DomTreeWalker>;
        prototype: DomTreeWalker;
    }
    interface DomTreeWalker extends GObject.Object {
        // Properties

        get root(): DomNode;
        get what_to_show(): number;
        get whatToShow(): number;
        get current_node(): DomNode;
        get currentNode(): DomNode;

        // Methods

        get_root(): DomNode;
        get_what_to_show(): number;
        get_current_node(): DomNode;
        parent_node(): DomNode | null;
        first_child(): DomNode | null;
        last_child(): DomNode | null;
        previous_sibling(): DomNode | null;
        next_sibling(): DomNode | null;
        previous_node(): DomNode | null;
        next_node(): DomNode | null;

        // Virtual methods

        vfunc_get_root(): DomNode;
        vfunc_get_what_to_show(): number;
        vfunc_get_current_node(): DomNode;
        vfunc_parent_node(): DomNode | null;
        vfunc_first_child(): DomNode | null;
        vfunc_last_child(): DomNode | null;
        vfunc_previous_sibling(): DomNode | null;
        vfunc_next_sibling(): DomNode | null;
        vfunc_previous_node(): DomNode | null;
        vfunc_next_node(): DomNode | null;
    }

    export const DomTreeWalker: DomTreeWalkerNamespace & {
        new (): DomTreeWalker; // This allows `obj instanceof DomTreeWalker`
    };

    namespace DomNamedNodeMap {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            length: number;
        }
    }

    export interface DomNamedNodeMapNamespace {
        $gtype: GObject.GType<DomNamedNodeMap>;
        prototype: DomNamedNodeMap;
    }
    interface DomNamedNodeMap extends GObject.Object {
        // Properties

        get length(): number;

        // Methods

        get_length(): number;
        item(index: number): DomNode | null;
        get_named_item(name: string): DomNode | null;
        set_named_item(node: DomNode): DomNode | null;
        remove_named_item(name: string): DomNode | null;
        remove_named_item_ns(namespace_uri: string, localName: string): DomNode | null;
        get_named_item_ns(namespace_uri: string, local_name: string): DomNode | null;
        set_named_item_ns(node: DomNode): DomNode | null;

        // Virtual methods

        vfunc_get_length(): number;
        vfunc_item(index: number): DomNode | null;
        vfunc_get_named_item(name: string): DomNode | null;
        vfunc_set_named_item(node: DomNode): DomNode | null;
        vfunc_remove_named_item(name: string): DomNode | null;
        vfunc_remove_named_item_ns(namespace_uri: string, localName: string): DomNode | null;
        vfunc_get_named_item_ns(namespace_uri: string, local_name: string): DomNode | null;
        vfunc_set_named_item_ns(node: DomNode): DomNode | null;
    }

    export const DomNamedNodeMap: DomNamedNodeMapNamespace & {
        new (): DomNamedNodeMap; // This allows `obj instanceof DomNamedNodeMap`
    };

    namespace DomTokenList {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            length: number;
        }
    }

    export interface DomTokenListNamespace {
        $gtype: GObject.GType<DomTokenList>;
        prototype: DomTokenList;
    }
    interface DomTokenList extends GObject.Object {
        // Properties

        get length(): number;

        // Methods

        get_length(): number;
        item(index: number): string | null;
        contains(token: string): boolean;
        add(tokens: string[]): void;
        remove(tokens: string[]): void;
        toggle(token: string, force: boolean, _auto_: boolean): boolean;
        to_string(): string;

        // Virtual methods

        vfunc_get_length(): number;
        vfunc_item(index: number): string | null;
        vfunc_contains(token: string): boolean;
        vfunc_add(tokens: string[]): void;
        vfunc_remove(tokens: string[]): void;
        vfunc_toggle(token: string, force: boolean, _auto_: boolean): boolean;
        vfunc_to_string(): string;
    }

    export const DomTokenList: DomTokenListNamespace & {
        new (): DomTokenList; // This allows `obj instanceof DomTokenList`
    };

    namespace DomSettableTokenList {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            value: string;
        }
    }

    export interface DomSettableTokenListNamespace {
        $gtype: GObject.GType<DomSettableTokenList>;
        prototype: DomSettableTokenList;
    }
    interface DomSettableTokenList extends GObject.Object {
        // Properties

        get value(): string;
        set value(val: string);

        // Methods

        get_value(): string;
        set_value(value: string): void;

        // Virtual methods

        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
    }

    export const DomSettableTokenList: DomSettableTokenListNamespace & {
        new (): DomSettableTokenList; // This allows `obj instanceof DomSettableTokenList`
    };

    namespace DomDocument {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            implementation: DomImplementation;
            url: string;
            document_uri: string;
            documentUri: string;
            origin: string;
            compat_mode: string;
            compatMode: string;
            character_set: string;
            characterSet: string;
            content_type: string;
            contentType: string;
            doctype: DomDocumentType;
            document_element: DomElement;
            documentElement: DomElement;
        }
    }

    export interface DomDocumentNamespace {
        $gtype: GObject.GType<DomDocument>;
        prototype: DomDocument;
    }
    interface DomDocument extends GObject.Object {
        // Properties

        get implementation(): DomImplementation;
        get url(): string;
        get document_uri(): string;
        get documentUri(): string;
        get origin(): string;
        get compat_mode(): string;
        get compatMode(): string;
        get character_set(): string;
        get characterSet(): string;
        get content_type(): string;
        get contentType(): string;
        get doctype(): DomDocumentType;
        get document_element(): DomElement;
        get documentElement(): DomElement;

        // Methods

        get_implementation(): DomImplementation;
        get_url(): string;
        get_document_uri(): string;
        get_origin(): string;
        get_compat_mode(): string;
        get_character_set(): string;
        get_content_type(): string;
        get_doctype(): DomDocumentType | null;
        get_document_element(): DomElement | null;
        get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        get_elements_by_class_name(classNames: string): DomHTMLCollection;
        create_element(local_name: string): DomElement;
        create_element_ns(namespace: string | null, qualified_name: string): DomElement;
        create_document_fragment(): DomDocumentFragment;
        create_text_node(data: string): DomText;
        create_comment(data: string): DomComment;
        create_processing_instruction(target: string, data: string): DomProcessingInstruction;
        import_node(node: DomNode, deep: boolean): DomNode;
        adopt_node(node: DomNode): DomNode;
        create_event(_interface: string): DomEvent;
        create_range(): DomRange;
        create_node_iterator(root: DomNode, whatToShow: number): DomNodeIterator;
        create_tree_walker(root: DomNode, what_to_show: number): DomTreeWalker;
        write_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        write_file_async(file: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_file_async(
            file: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_stream(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): void;
        write_stream_async(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<Gio.InputStream>;
        create_stream_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        write_string(cancellable?: Gio.Cancellable | null): string;
        write_string_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<string>;
        write_string_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        read_from_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        read_from_file_async(file: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_file_async(
            file: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_file_finish(_res_: Gio.AsyncResult): void;
        read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        read_from_string_async(str: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_string_async(
            str: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_string_finish(_res_: Gio.AsyncResult): void;
        read_from_stream(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        read_from_stream_async(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_stream_async(
            stream: Gio.InputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_stream_async(
            stream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_stream_finish(_res_: Gio.AsyncResult): void;
        get_xml_parser(): Parser;
        set_xml_parser(parser: Parser): void;

        // Virtual methods

        vfunc_get_implementation(): DomImplementation;
        vfunc_get_url(): string;
        vfunc_get_document_uri(): string;
        vfunc_get_origin(): string;
        vfunc_get_compat_mode(): string;
        vfunc_get_character_set(): string;
        vfunc_get_content_type(): string;
        vfunc_get_doctype(): DomDocumentType | null;
        vfunc_get_document_element(): DomElement | null;
        vfunc_get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_class_name(classNames: string): DomHTMLCollection;
        vfunc_create_element(local_name: string): DomElement;
        vfunc_create_element_ns(namespace: string | null, qualified_name: string): DomElement;
        vfunc_create_document_fragment(): DomDocumentFragment;
        vfunc_create_text_node(data: string): DomText;
        vfunc_create_comment(data: string): DomComment;
        vfunc_create_processing_instruction(target: string, data: string): DomProcessingInstruction;
        vfunc_import_node(node: DomNode, deep: boolean): DomNode;
        vfunc_adopt_node(node: DomNode): DomNode;
        vfunc_create_event(_interface: string): DomEvent;
        vfunc_create_range(): DomRange;
        vfunc_create_node_iterator(root: DomNode, whatToShow: number): DomNodeIterator;
        vfunc_create_tree_walker(root: DomNode, what_to_show: number): DomTreeWalker;
        vfunc_write_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_stream(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        vfunc_write_string(cancellable?: Gio.Cancellable | null): string;
        vfunc_write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_read_from_file(file: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_file_async(
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_stream(stream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_stream_async(
            stream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_get_xml_parser(): Parser;
        vfunc_set_xml_parser(parser: Parser): void;
    }

    export const DomDocument: DomDocumentNamespace & {
        new (): DomDocument; // This allows `obj instanceof DomDocument`
    };

    namespace DomXMLDocument {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomXMLDocumentNamespace {
        $gtype: GObject.GType<DomXMLDocument>;
        prototype: DomXMLDocument;
    }
    interface DomXMLDocument extends GObject.Object {}

    export const DomXMLDocument: DomXMLDocumentNamespace & {
        new (): DomXMLDocument; // This allows `obj instanceof DomXMLDocument`
    };

    namespace DomImplementation {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomImplementationNamespace {
        $gtype: GObject.GType<DomImplementation>;
        prototype: DomImplementation;
    }
    interface DomImplementation extends GObject.Object {
        // Methods

        create_document_type(qualified_name: string, public_id: string, system_id: string): DomDocumentType;
        create_document(
            nspace?: string | null,
            qualified_name?: string | null,
            doctype?: DomDocumentType | null,
        ): DomXMLDocument;
        create_html_document(title: string): DomDocument;
        has_feature(): boolean;

        // Virtual methods

        vfunc_create_document_type(qualified_name: string, public_id: string, system_id: string): DomDocumentType;
        vfunc_create_document(
            nspace?: string | null,
            qualified_name?: string | null,
            doctype?: DomDocumentType | null,
        ): DomXMLDocument;
        vfunc_create_html_document(title: string): DomDocument;
        vfunc_has_feature(): boolean;
    }

    export const DomImplementation: DomImplementationNamespace & {
        new (): DomImplementation; // This allows `obj instanceof DomImplementation`
    };

    namespace DomDocumentFragment {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomDocumentFragmentNamespace {
        $gtype: GObject.GType<DomDocumentFragment>;
        prototype: DomDocumentFragment;
    }
    interface DomDocumentFragment extends GObject.Object {}

    export const DomDocumentFragment: DomDocumentFragmentNamespace & {
        new (): DomDocumentFragment; // This allows `obj instanceof DomDocumentFragment`
    };

    namespace DomDocumentType {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            name: string;
            public_id: string;
            publicId: string;
            system_id: string;
            systemId: string;
        }
    }

    export interface DomDocumentTypeNamespace {
        $gtype: GObject.GType<DomDocumentType>;
        prototype: DomDocumentType;
    }
    interface DomDocumentType extends GObject.Object {
        // Properties

        get name(): string;
        get public_id(): string;
        get publicId(): string;
        get system_id(): string;
        get systemId(): string;

        // Methods

        get_name(): string;
        get_public_id(): string;
        get_system_id(): string;

        // Virtual methods

        vfunc_get_name(): string;
        vfunc_get_public_id(): string;
        vfunc_get_system_id(): string;
    }

    export const DomDocumentType: DomDocumentTypeNamespace & {
        new (): DomDocumentType; // This allows `obj instanceof DomDocumentType`
    };

    namespace DomHtmlDocument {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomHtmlDocumentNamespace {
        $gtype: GObject.GType<DomHtmlDocument>;
        prototype: DomHtmlDocument;
    }
    interface DomHtmlDocument extends GObject.Object {
        // Methods

        read_from_string(str: string): void;
        read_from_string_tolerant(str: string): void;
        to_html(): string;

        // Virtual methods

        vfunc_read_from_string(str: string): void;
        vfunc_read_from_string_tolerant(str: string): void;
        vfunc_to_html(): string;
    }

    export const DomHtmlDocument: DomHtmlDocumentNamespace & {
        new (): DomHtmlDocument; // This allows `obj instanceof DomHtmlDocument`
    };

    namespace DomElement {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            namespace_uri: string;
            namespaceUri: string;
            prefix: string;
            local_name: string;
            localName: string;
            tag_name: string;
            tagName: string;
            id: string;
            class_name: string;
            className: string;
            class_list: DomTokenList;
            classList: DomTokenList;
            attributes: DomNamedNodeMap;
        }
    }

    export interface DomElementNamespace {
        $gtype: GObject.GType<DomElement>;
        prototype: DomElement;
    }
    interface DomElement extends GObject.Object {
        // Properties

        get namespace_uri(): string;
        get namespaceUri(): string;
        get prefix(): string;
        get local_name(): string;
        get localName(): string;
        get tag_name(): string;
        get tagName(): string;
        get id(): string;
        set id(val: string);
        get class_name(): string;
        set class_name(val: string);
        get className(): string;
        set className(val: string);
        get class_list(): DomTokenList;
        get classList(): DomTokenList;
        get attributes(): DomNamedNodeMap;

        // Methods

        get_namespace_uri(): string | null;
        get_prefix(): string | null;
        get_local_name(): string;
        get_tag_name(): string;
        get_id(): string | null;
        set_id(value?: string | null): void;
        get_class_name(): string | null;
        set_class_name(value?: string | null): void;
        get_class_list(): DomTokenList;
        get_attributes(): DomNamedNodeMap;
        get_attribute(name: string): string | null;
        get_attribute_ns(namespace: string | null, local_name: string): string | null;
        set_attribute(name: string, value: string): void;
        set_attribute_ns(namespace: string | null, name: string, value: string): void;
        remove_attribute(name: string): void;
        remove_attribute_ns(namespace: string | null, local_name: string): void;
        has_attribute(name: string): boolean;
        has_attribute_ns(namespace: string | null, local_name: string): boolean;
        get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        get_elements_by_class_name(class_names: string): DomHTMLCollection;
        matches(selectors: string): boolean;
        read_from_uri(uri: string): void;
        read_from_uri_async(uri: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_uri_async(
            uri: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_uri_async(
            uri: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_uri_finish(_res_: Gio.AsyncResult): void;
        read_from_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        read_from_file_async(f: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_file_async(
            f: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_file_finish(_res_: Gio.AsyncResult): void;
        read_from_stream(istream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
        ): globalThis.Promise<void>;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_stream_finish(_res_: Gio.AsyncResult): void;
        read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        read_from_string_async(str: string, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        read_from_string_async(
            str: string,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_from_string_finish(_res_: Gio.AsyncResult): void;
        write_string(cancellable?: Gio.Cancellable | null): string;
        write_string_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<string>;
        write_string_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        write_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        write_file_async(f: Gio.File, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_file_async(
            f: Gio.File,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_stream(stream: Gio.OutputStream): void;
        write_stream_async(stream: Gio.OutputStream, cancellable?: Gio.Cancellable | null): globalThis.Promise<void>;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable: Gio.Cancellable | null,
            _callback_: Gio.AsyncReadyCallback<this> | null,
        ): void;
        write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(cancellable?: Gio.Cancellable | null): globalThis.Promise<Gio.InputStream>;
        create_stream_async(cancellable: Gio.Cancellable | null, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;

        // Virtual methods

        vfunc_get_namespace_uri(): string | null;
        vfunc_get_prefix(): string | null;
        vfunc_get_local_name(): string;
        vfunc_get_tag_name(): string;
        vfunc_get_id(): string | null;
        vfunc_set_id(value?: string | null): void;
        vfunc_get_class_name(): string | null;
        vfunc_set_class_name(value?: string | null): void;
        vfunc_get_class_list(): DomTokenList;
        vfunc_get_attributes(): DomNamedNodeMap;
        vfunc_get_attribute(name: string): string | null;
        vfunc_get_attribute_ns(namespace: string | null, local_name: string): string | null;
        vfunc_set_attribute(name: string, value: string): void;
        vfunc_set_attribute_ns(namespace: string | null, name: string, value: string): void;
        vfunc_remove_attribute(name: string): void;
        vfunc_remove_attribute_ns(namespace: string | null, local_name: string): void;
        vfunc_has_attribute(name: string): boolean;
        vfunc_has_attribute_ns(namespace: string | null, local_name: string): boolean;
        vfunc_get_elements_by_tag_name(local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_tag_name_ns(namespace: string | null, local_name: string): DomHTMLCollection;
        vfunc_get_elements_by_class_name(class_names: string): DomHTMLCollection;
        vfunc_matches(selectors: string): boolean;
        vfunc_read_from_uri(uri: string): void;
        vfunc_read_from_uri_async(
            uri: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_uri_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_stream(istream: Gio.InputStream, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_stream_async(
            istream: Gio.InputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_from_string(str: string, cancellable?: Gio.Cancellable | null): void;
        vfunc_read_from_string_async(
            str: string,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_read_from_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_string(cancellable?: Gio.Cancellable | null): string;
        vfunc_write_string_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_write_file(f: Gio.File, cancellable?: Gio.Cancellable | null): void;
        vfunc_write_file_async(
            f: Gio.File,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_stream(stream: Gio.OutputStream): void;
        vfunc_write_stream_async(
            stream: Gio.OutputStream,
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(
            cancellable?: Gio.Cancellable | null,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
    }

    export const DomElement: DomElementNamespace & {
        new (): DomElement; // This allows `obj instanceof DomElement`
    };

    namespace DomEventTarget {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomEventTargetNamespace {
        $gtype: GObject.GType<DomEventTarget>;
        prototype: DomEventTarget;
    }
    interface DomEventTarget extends GObject.Object {
        // Methods

        add_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        remove_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        dispatch_event(event: DomEvent): boolean;

        // Virtual methods

        vfunc_add_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        vfunc_remove_event_listener(type: string, callback: DomEventListener | null, capture: boolean): void;
        vfunc_dispatch_event(event: DomEvent): boolean;
    }

    export const DomEventTarget: DomEventTargetNamespace & {
        new (): DomEventTarget; // This allows `obj instanceof DomEventTarget`
    };

    namespace DomEventListener {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomEventListenerNamespace {
        $gtype: GObject.GType<DomEventListener>;
        prototype: DomEventListener;
    }
    interface DomEventListener extends GObject.Object {
        // Methods

        handle_event(event: DomEvent): void;

        // Virtual methods

        vfunc_handle_event(event: DomEvent): void;
    }

    export const DomEventListener: DomEventListenerNamespace & {
        new (): DomEventListener; // This allows `obj instanceof DomEventListener`
    };

    namespace DomEvent {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            etype: string;
            event_target: DomEventTarget;
            eventTarget: DomEventTarget;
            current_target: DomEventTarget;
            currentTarget: DomEventTarget;
            bubbles: boolean;
            cancelable: boolean;
            is_trusted: boolean;
            isTrusted: boolean;
            time_stamp: DomTimeStamp;
            timeStamp: DomTimeStamp;
            default_prevented: boolean;
            defaultPrevented: boolean;
            event_phase: DomEventPhase;
            eventPhase: DomEventPhase;
        }
    }

    export interface DomEventNamespace {
        $gtype: GObject.GType<DomEvent>;
        prototype: DomEvent;
    }
    interface DomEvent extends GObject.Object {
        // Properties

        get etype(): string;
        get event_target(): DomEventTarget;
        get eventTarget(): DomEventTarget;
        get current_target(): DomEventTarget;
        get currentTarget(): DomEventTarget;
        get bubbles(): boolean;
        get cancelable(): boolean;
        get is_trusted(): boolean;
        get isTrusted(): boolean;
        get time_stamp(): DomTimeStamp;
        get timeStamp(): DomTimeStamp;
        get default_prevented(): boolean;
        get defaultPrevented(): boolean;
        get event_phase(): DomEventPhase;
        get eventPhase(): DomEventPhase;

        // Methods

        get_etype(): string;
        get_event_target(): DomEventTarget | null;
        get_current_target(): DomEventTarget | null;
        get_bubbles(): boolean;
        get_cancelable(): boolean;
        get_is_trusted(): boolean;
        get_time_stamp(): DomTimeStamp;
        get_default_prevented(): boolean;
        get_event_phase(): DomEventPhase;
        stop_propagation(): void;
        stop_immediate_propagation(): void;
        prevent_default(): void;
        init_event(type: string, bubbles: boolean, cancelable: boolean): void;

        // Virtual methods

        vfunc_get_etype(): string;
        vfunc_get_event_target(): DomEventTarget | null;
        vfunc_get_current_target(): DomEventTarget | null;
        vfunc_get_bubbles(): boolean;
        vfunc_get_cancelable(): boolean;
        vfunc_get_is_trusted(): boolean;
        vfunc_get_time_stamp(): DomTimeStamp;
        vfunc_get_default_prevented(): boolean;
        vfunc_get_event_phase(): DomEventPhase;
        vfunc_stop_propagation(): void;
        vfunc_stop_immediate_propagation(): void;
        vfunc_prevent_default(): void;
        vfunc_init_event(type: string, bubbles: boolean, cancelable: boolean): void;
    }

    export const DomEvent: DomEventNamespace & {
        new (): DomEvent; // This allows `obj instanceof DomEvent`
    };

    namespace DomCustomEvent {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            detail: GObject.Value;
        }
    }

    export interface DomCustomEventNamespace {
        $gtype: GObject.GType<DomCustomEvent>;
        prototype: DomCustomEvent;
    }
    interface DomCustomEvent extends GObject.Object {
        // Properties

        get detail(): GObject.Value;

        // Methods

        get_detail(): unknown;
        init_custom_event(type: string, bubbles: boolean, cancelable: boolean, detail: GObject.Value | any): void;

        // Virtual methods

        vfunc_get_detail(): unknown;
        vfunc_init_custom_event(type: string, bubbles: boolean, cancelable: boolean, detail: GObject.Value | any): void;
    }

    export const DomCustomEvent: DomCustomEventNamespace & {
        new (): DomCustomEvent; // This allows `obj instanceof DomCustomEvent`
    };

    namespace DomMutationObserver {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DomMutationObserverNamespace {
        $gtype: GObject.GType<DomMutationObserver>;
        prototype: DomMutationObserver;
    }
    interface DomMutationObserver extends GObject.Object {
        // Methods

        observe(target: Node, options: DomMutationObserverInit): void;
        disconnect(): void;
        take_records(): Gee.List;

        // Virtual methods

        vfunc_observe(target: Node, options: DomMutationObserverInit): void;
        vfunc_disconnect(): void;
        vfunc_take_records(): Gee.List;
    }

    export const DomMutationObserver: DomMutationObserverNamespace & {
        new (): DomMutationObserver; // This allows `obj instanceof DomMutationObserver`
    };

    namespace DomMutationRecord {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            mtype: string;
            target: DomNode;
            added_nodes: DomNodeList;
            addedNodes: DomNodeList;
            removed_nodes: DomNodeList;
            removedNodes: DomNodeList;
            previous_sibling: DomNode;
            previousSibling: DomNode;
            next_sibling: DomNode;
            nextSibling: DomNode;
            attribute_name: string;
            attributeName: string;
            attribute_namespace: string;
            attributeNamespace: string;
            old_value: string;
            oldValue: string;
        }
    }

    export interface DomMutationRecordNamespace {
        $gtype: GObject.GType<DomMutationRecord>;
        prototype: DomMutationRecord;
    }
    interface DomMutationRecord extends GObject.Object {
        // Properties

        get mtype(): string;
        get target(): DomNode;
        get added_nodes(): DomNodeList;
        set added_nodes(val: DomNodeList);
        get addedNodes(): DomNodeList;
        set addedNodes(val: DomNodeList);
        get removed_nodes(): DomNodeList;
        set removed_nodes(val: DomNodeList);
        get removedNodes(): DomNodeList;
        set removedNodes(val: DomNodeList);
        get previous_sibling(): DomNode;
        get previousSibling(): DomNode;
        get next_sibling(): DomNode;
        get nextSibling(): DomNode;
        get attribute_name(): string;
        get attributeName(): string;
        get attribute_namespace(): string;
        get attributeNamespace(): string;
        get old_value(): string;
        get oldValue(): string;

        // Methods

        get_mtype(): string;
        get_target(): DomNode;
        get_added_nodes(): DomNodeList;
        set_added_nodes(value: DomNodeList): void;
        get_removed_nodes(): DomNodeList;
        set_removed_nodes(value: DomNodeList): void;
        get_previous_sibling(): DomNode | null;
        get_next_sibling(): DomNode | null;
        get_attribute_name(): string | null;
        get_attribute_namespace(): string | null;
        get_old_value(): string | null;

        // Virtual methods

        vfunc_get_mtype(): string;
        vfunc_get_target(): DomNode;
        vfunc_get_added_nodes(): DomNodeList;
        vfunc_set_added_nodes(value: DomNodeList): void;
        vfunc_get_removed_nodes(): DomNodeList;
        vfunc_set_removed_nodes(value: DomNodeList): void;
        vfunc_get_previous_sibling(): DomNode | null;
        vfunc_get_next_sibling(): DomNode | null;
        vfunc_get_attribute_name(): string | null;
        vfunc_get_attribute_namespace(): string | null;
        vfunc_get_old_value(): string | null;
    }

    export const DomMutationRecord: DomMutationRecordNamespace & {
        new (): DomMutationRecord; // This allows `obj instanceof DomMutationRecord`
    };

    namespace DomNode {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            node_type: DomNodeNodeType;
            nodeType: DomNodeNodeType;
            node_name: string;
            nodeName: string;
            base_uri: string;
            baseUri: string;
            owner_document: DomDocument;
            ownerDocument: DomDocument;
            parent_node: DomNode;
            parentNode: DomNode;
            parent_element: DomElement;
            parentElement: DomElement;
            child_nodes: DomNodeList;
            childNodes: DomNodeList;
            first_child: DomNode;
            firstChild: DomNode;
            last_child: DomNode;
            lastChild: DomNode;
            previous_sibling: DomNode;
            previousSibling: DomNode;
            next_sibling: DomNode;
            nextSibling: DomNode;
            node_value: string;
            nodeValue: string;
            text_content: string;
            textContent: string;
        }
    }

    export interface DomNodeNamespace {
        $gtype: GObject.GType<DomNode>;
        prototype: DomNode;

        copy(doc: DomDocument, node: DomNode, source: DomNode, deep: boolean): boolean;
    }
    interface DomNode extends GObject.Object {
        // Properties

        get node_type(): DomNodeNodeType;
        get nodeType(): DomNodeNodeType;
        get node_name(): string;
        get nodeName(): string;
        get base_uri(): string;
        get baseUri(): string;
        get owner_document(): DomDocument;
        set owner_document(val: DomDocument);
        get ownerDocument(): DomDocument;
        set ownerDocument(val: DomDocument);
        get parent_node(): DomNode;
        get parentNode(): DomNode;
        get parent_element(): DomElement;
        get parentElement(): DomElement;
        get child_nodes(): DomNodeList;
        get childNodes(): DomNodeList;
        get first_child(): DomNode;
        get firstChild(): DomNode;
        get last_child(): DomNode;
        get lastChild(): DomNode;
        get previous_sibling(): DomNode;
        get previousSibling(): DomNode;
        get next_sibling(): DomNode;
        get nextSibling(): DomNode;
        get node_value(): string;
        set node_value(val: string);
        get nodeValue(): string;
        set nodeValue(val: string);
        get text_content(): string;
        set text_content(val: string);
        get textContent(): string;
        set textContent(val: string);

        // Methods

        get_node_type(): DomNodeNodeType;
        get_node_name(): string;
        get_base_uri(): string | null;
        get_owner_document(): DomDocument | null;
        set_owner_document(value?: DomDocument | null): void;
        get_parent_node(): DomNode | null;
        get_parent_element(): DomElement | null;
        get_child_nodes(): DomNodeList;
        get_first_child(): DomNode | null;
        get_last_child(): DomNode | null;
        get_previous_sibling(): DomNode | null;
        get_next_sibling(): DomNode | null;
        get_node_value(): string | null;
        set_node_value(value?: string | null): void;
        get_text_content(): string | null;
        set_text_content(value?: string | null): void;
        has_child_nodes(): boolean;
        normalize(): void;
        is_equal_node(node?: DomNode | null): boolean;
        compare_document_position(other: DomNode): DomNodeDocumentPosition;
        contains(other?: DomNode | null): boolean;
        lookup_prefix(nspace?: string | null): string | null;
        lookup_namespace_uri(prefix?: string | null): string | null;
        is_default_namespace(nspace?: string | null): boolean;
        insert_before(node: DomNode, child?: DomNode | null): DomNode;
        append_child(node: DomNode): DomNode;
        replace_child(node: DomNode, child: DomNode): DomNode;
        remove_child(child: DomNode): DomNode;

        // Virtual methods

        vfunc_get_node_type(): DomNodeNodeType;
        vfunc_get_node_name(): string;
        vfunc_get_base_uri(): string | null;
        vfunc_get_owner_document(): DomDocument | null;
        vfunc_set_owner_document(value?: DomDocument | null): void;
        vfunc_get_parent_node(): DomNode | null;
        vfunc_get_parent_element(): DomElement | null;
        vfunc_get_child_nodes(): DomNodeList;
        vfunc_get_first_child(): DomNode | null;
        vfunc_get_last_child(): DomNode | null;
        vfunc_get_previous_sibling(): DomNode | null;
        vfunc_get_next_sibling(): DomNode | null;
        vfunc_get_node_value(): string | null;
        vfunc_set_node_value(value?: string | null): void;
        vfunc_get_text_content(): string | null;
        vfunc_set_text_content(value?: string | null): void;
        vfunc_has_child_nodes(): boolean;
        vfunc_normalize(): void;
        vfunc_is_equal_node(node?: DomNode | null): boolean;
        vfunc_compare_document_position(other: DomNode): DomNodeDocumentPosition;
        vfunc_contains(other?: DomNode | null): boolean;
        vfunc_lookup_prefix(nspace?: string | null): string | null;
        vfunc_lookup_namespace_uri(prefix?: string | null): string | null;
        vfunc_is_default_namespace(nspace?: string | null): boolean;
        vfunc_insert_before(node: DomNode, child?: DomNode | null): DomNode;
        vfunc_append_child(node: DomNode): DomNode;
        vfunc_replace_child(node: DomNode, child: DomNode): DomNode;
        vfunc_remove_child(child: DomNode): DomNode;
    }

    export const DomNode: DomNodeNamespace & {
        new (): DomNode; // This allows `obj instanceof DomNode`
    };

    namespace DomRange {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            start_container: DomNode;
            startContainer: DomNode;
            start_offset: number;
            startOffset: number;
            end_container: DomNode;
            endContainer: DomNode;
            end_offset: number;
            endOffset: number;
            collapsed: boolean;
            common_ancestor_container: DomNode;
            commonAncestorContainer: DomNode;
        }
    }

    export interface DomRangeNamespace {
        $gtype: GObject.GType<DomRange>;
        prototype: DomRange;
    }
    interface DomRange extends GObject.Object {
        // Properties

        get start_container(): DomNode;
        get startContainer(): DomNode;
        get start_offset(): number;
        get startOffset(): number;
        get end_container(): DomNode;
        get endContainer(): DomNode;
        get end_offset(): number;
        get endOffset(): number;
        get collapsed(): boolean;
        get common_ancestor_container(): DomNode;
        get commonAncestorContainer(): DomNode;

        // Methods

        get_start_container(): DomNode;
        get_start_offset(): number;
        get_end_container(): DomNode;
        get_end_offset(): number;
        get_collapsed(): boolean;
        get_common_ancestor_container(): DomNode;
        set_start(node: DomNode, offset: number): void;
        set_end(node: DomNode, offset: number): void;
        set_start_before(node: DomNode): void;
        set_start_after(node: DomNode): void;
        set_end_before(node: DomNode): void;
        set_end_after(node: DomNode): void;
        collapse(to_start: boolean): void;
        select_node(node: DomNode): void;
        select_node_contents(node: DomNode): void;
        compare_boundary_points(how: DomRangeBoundaryPoints | null, sourceRange: DomRange): number;
        delete_contents(): void;
        extract_contents(): DomDocumentFragment | null;
        clone_contents(): DomDocumentFragment | null;
        insert_node(node: DomNode): void;
        surround_contents(newParent: DomNode): void;
        clone_range(): DomRange;
        detach(): void;
        is_point_in_range(node: DomNode, offset: number): boolean;
        compare_point(node: DomNode, offset: number): number;
        intersects_node(node: DomNode): boolean;
        to_string(): string;

        // Virtual methods

        vfunc_get_start_container(): DomNode;
        vfunc_get_start_offset(): number;
        vfunc_get_end_container(): DomNode;
        vfunc_get_end_offset(): number;
        vfunc_get_collapsed(): boolean;
        vfunc_get_common_ancestor_container(): DomNode;
        vfunc_set_start(node: DomNode, offset: number): void;
        vfunc_set_end(node: DomNode, offset: number): void;
        vfunc_set_start_before(node: DomNode): void;
        vfunc_set_start_after(node: DomNode): void;
        vfunc_set_end_before(node: DomNode): void;
        vfunc_set_end_after(node: DomNode): void;
        vfunc_collapse(to_start: boolean): void;
        vfunc_select_node(node: DomNode): void;
        vfunc_select_node_contents(node: DomNode): void;
        vfunc_compare_boundary_points(how: DomRangeBoundaryPoints, sourceRange: DomRange): number;
        vfunc_delete_contents(): void;
        vfunc_extract_contents(): DomDocumentFragment | null;
        vfunc_clone_contents(): DomDocumentFragment | null;
        vfunc_insert_node(node: DomNode): void;
        vfunc_surround_contents(newParent: DomNode): void;
        vfunc_clone_range(): DomRange;
        vfunc_detach(): void;
        vfunc_is_point_in_range(node: DomNode, offset: number): boolean;
        vfunc_compare_point(node: DomNode, offset: number): number;
        vfunc_intersects_node(node: DomNode): boolean;
        vfunc_to_string(): string;
    }

    export const DomRange: DomRangeNamespace & {
        new (): DomRange; // This allows `obj instanceof DomRange`
    };

    namespace IXsdSchema {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            element_definitions: IXsdListElements;
            elementDefinitions: IXsdListElements;
            simple_type_definitions: IXsdListSimpleTypes;
            simpleTypeDefinitions: IXsdListSimpleTypes;
            complex_type_definitions: IXsdListComplexTypes;
            complexTypeDefinitions: IXsdListComplexTypes;
        }
    }

    export interface IXsdSchemaNamespace {
        $gtype: GObject.GType<IXsdSchema>;
        prototype: IXsdSchema;
    }
    interface IXsdSchema extends GObject.Object {
        // Properties

        get element_definitions(): IXsdListElements;
        set element_definitions(val: IXsdListElements);
        get elementDefinitions(): IXsdListElements;
        set elementDefinitions(val: IXsdListElements);
        get simple_type_definitions(): IXsdListSimpleTypes;
        set simple_type_definitions(val: IXsdListSimpleTypes);
        get simpleTypeDefinitions(): IXsdListSimpleTypes;
        set simpleTypeDefinitions(val: IXsdListSimpleTypes);
        get complex_type_definitions(): IXsdListComplexTypes;
        set complex_type_definitions(val: IXsdListComplexTypes);
        get complexTypeDefinitions(): IXsdListComplexTypes;
        set complexTypeDefinitions(val: IXsdListComplexTypes);

        // Methods

        get_element_definitions(): IXsdListElements;
        set_element_definitions(value: IXsdListElements): void;
        get_simple_type_definitions(): IXsdListSimpleTypes;
        set_simple_type_definitions(value: IXsdListSimpleTypes): void;
        get_complex_type_definitions(): IXsdListComplexTypes;
        set_complex_type_definitions(value: IXsdListComplexTypes): void;

        // Virtual methods

        vfunc_get_element_definitions(): IXsdListElements;
        vfunc_set_element_definitions(value: IXsdListElements): void;
        vfunc_get_simple_type_definitions(): IXsdListSimpleTypes;
        vfunc_set_simple_type_definitions(value: IXsdListSimpleTypes): void;
        vfunc_get_complex_type_definitions(): IXsdListComplexTypes;
        vfunc_set_complex_type_definitions(value: IXsdListComplexTypes): void;
    }

    export const IXsdSchema: IXsdSchemaNamespace & {
        new (): IXsdSchema; // This allows `obj instanceof IXsdSchema`
    };

    namespace IXsdBaseType {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            anotation: IXsdAnnotation;
        }
    }

    export interface IXsdBaseTypeNamespace {
        $gtype: GObject.GType<IXsdBaseType>;
        prototype: IXsdBaseType;
    }
    interface IXsdBaseType extends GObject.Object {
        // Properties

        get anotation(): IXsdAnnotation;
        set anotation(val: IXsdAnnotation);

        // Methods

        get_anotation(): IXsdAnnotation;
        set_anotation(value: IXsdAnnotation): void;

        // Virtual methods

        vfunc_get_anotation(): IXsdAnnotation;
        vfunc_set_anotation(value: IXsdAnnotation): void;
    }

    export const IXsdBaseType: IXsdBaseTypeNamespace & {
        new (): IXsdBaseType; // This allows `obj instanceof IXsdBaseType`
    };

    namespace IXsdSimpleType {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            final: string;
            id: string;
            name: string;
            annotation: IXsdAnnotation;
            list: IXsdTypeList;
            union: IXsdTypeUnion;
            restriction: IXsdTypeRestriction;
        }
    }

    export interface IXsdSimpleTypeNamespace {
        $gtype: GObject.GType<IXsdSimpleType>;
        prototype: IXsdSimpleType;
    }
    interface IXsdSimpleType extends GObject.Object {
        // Properties

        get 'final'(): string;
        set 'final'(val: string);
        get id(): string;
        set id(val: string);
        get name(): string;
        set name(val: string);
        get annotation(): IXsdAnnotation;
        set annotation(val: IXsdAnnotation);
        get list(): IXsdTypeList;
        set list(val: IXsdTypeList);
        get union(): IXsdTypeUnion;
        set union(val: IXsdTypeUnion);
        get restriction(): IXsdTypeRestriction;
        set restriction(val: IXsdTypeRestriction);

        // Methods

        get_final(): string;
        set_final(value: string): void;
        get_id(): string;
        set_id(value: string): void;
        get_name(): string;
        set_name(value: string): void;
        get_annotation(): IXsdAnnotation;
        set_annotation(value: IXsdAnnotation): void;
        get_list(): IXsdTypeList;
        set_list(value: IXsdTypeList): void;
        get_union(): IXsdTypeUnion;
        set_union(value: IXsdTypeUnion): void;
        get_restriction(): IXsdTypeRestriction;
        set_restriction(value: IXsdTypeRestriction): void;

        // Virtual methods

        vfunc_get_final(): string;
        vfunc_set_final(value: string): void;
        vfunc_get_id(): string;
        vfunc_set_id(value: string): void;
        vfunc_get_name(): string;
        vfunc_set_name(value: string): void;
        vfunc_get_annotation(): IXsdAnnotation;
        vfunc_set_annotation(value: IXsdAnnotation): void;
        vfunc_get_list(): IXsdTypeList;
        vfunc_set_list(value: IXsdTypeList): void;
        vfunc_get_union(): IXsdTypeUnion;
        vfunc_set_union(value: IXsdTypeUnion): void;
        vfunc_get_restriction(): IXsdTypeRestriction;
        vfunc_set_restriction(value: IXsdTypeRestriction): void;
    }

    export const IXsdSimpleType: IXsdSimpleTypeNamespace & {
        new (): IXsdSimpleType; // This allows `obj instanceof IXsdSimpleType`
    };

    namespace IXsdTypeDef {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeDefNamespace {
        $gtype: GObject.GType<IXsdTypeDef>;
        prototype: IXsdTypeDef;
    }
    interface IXsdTypeDef extends GObject.Object {}

    export const IXsdTypeDef: IXsdTypeDefNamespace & {
        new (): IXsdTypeDef; // This allows `obj instanceof IXsdTypeDef`
    };

    namespace IXsdTypeRestriction {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            base: string;
            id: string;
            simple_type: IXsdSimpleType;
            simpleType: IXsdSimpleType;
            enumerations: IXsdListTypeRestrictionEnumerations;
            white_spaces: IXsdListTypeRestrictionWhiteSpaces;
            whiteSpaces: IXsdListTypeRestrictionWhiteSpaces;
        }
    }

    export interface IXsdTypeRestrictionNamespace {
        $gtype: GObject.GType<IXsdTypeRestriction>;
        prototype: IXsdTypeRestriction;
    }
    interface IXsdTypeRestriction extends GObject.Object {
        // Properties

        get base(): string;
        set base(val: string);
        get id(): string;
        set id(val: string);
        get simple_type(): IXsdSimpleType;
        set simple_type(val: IXsdSimpleType);
        get simpleType(): IXsdSimpleType;
        set simpleType(val: IXsdSimpleType);
        get enumerations(): IXsdListTypeRestrictionEnumerations;
        set enumerations(val: IXsdListTypeRestrictionEnumerations);
        get white_spaces(): IXsdListTypeRestrictionWhiteSpaces;
        set white_spaces(val: IXsdListTypeRestrictionWhiteSpaces);
        get whiteSpaces(): IXsdListTypeRestrictionWhiteSpaces;
        set whiteSpaces(val: IXsdListTypeRestrictionWhiteSpaces);

        // Methods

        get_base(): string;
        set_base(value: string): void;
        get_id(): string;
        set_id(value: string): void;
        get_simple_type(): IXsdSimpleType;
        set_simple_type(value: IXsdSimpleType): void;
        get_enumerations(): IXsdListTypeRestrictionEnumerations;
        set_enumerations(value: IXsdListTypeRestrictionEnumerations): void;
        get_white_spaces(): IXsdListTypeRestrictionWhiteSpaces;
        set_white_spaces(value: IXsdListTypeRestrictionWhiteSpaces): void;

        // Virtual methods

        vfunc_get_base(): string;
        vfunc_set_base(value: string): void;
        vfunc_get_id(): string;
        vfunc_set_id(value: string): void;
        vfunc_get_simple_type(): IXsdSimpleType;
        vfunc_set_simple_type(value: IXsdSimpleType): void;
        vfunc_get_enumerations(): IXsdListTypeRestrictionEnumerations;
        vfunc_set_enumerations(value: IXsdListTypeRestrictionEnumerations): void;
        vfunc_get_white_spaces(): IXsdListTypeRestrictionWhiteSpaces;
        vfunc_set_white_spaces(value: IXsdListTypeRestrictionWhiteSpaces): void;
    }

    export const IXsdTypeRestriction: IXsdTypeRestrictionNamespace & {
        new (): IXsdTypeRestriction; // This allows `obj instanceof IXsdTypeRestriction`
    };

    namespace IXsdTypeList {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeListNamespace {
        $gtype: GObject.GType<IXsdTypeList>;
        prototype: IXsdTypeList;
    }
    interface IXsdTypeList extends GObject.Object {}

    export const IXsdTypeList: IXsdTypeListNamespace & {
        new (): IXsdTypeList; // This allows `obj instanceof IXsdTypeList`
    };

    namespace IXsdTypeUnion {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeUnionNamespace {
        $gtype: GObject.GType<IXsdTypeUnion>;
        prototype: IXsdTypeUnion;
    }
    interface IXsdTypeUnion extends GObject.Object {}

    export const IXsdTypeUnion: IXsdTypeUnionNamespace & {
        new (): IXsdTypeUnion; // This allows `obj instanceof IXsdTypeUnion`
    };

    namespace IXsdTypeRestrictionDef {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            annotation: IXsdAnnotation;
        }
    }

    export interface IXsdTypeRestrictionDefNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionDef>;
        prototype: IXsdTypeRestrictionDef;
    }
    interface IXsdTypeRestrictionDef extends GObject.Object {
        // Properties

        get annotation(): IXsdAnnotation;
        set annotation(val: IXsdAnnotation);

        // Methods

        get_annotation(): IXsdAnnotation;
        set_annotation(value: IXsdAnnotation): void;

        // Virtual methods

        vfunc_get_annotation(): IXsdAnnotation;
        vfunc_set_annotation(value: IXsdAnnotation): void;
    }

    export const IXsdTypeRestrictionDef: IXsdTypeRestrictionDefNamespace & {
        new (): IXsdTypeRestrictionDef; // This allows `obj instanceof IXsdTypeRestrictionDef`
    };

    namespace IXsdTypeRestrictionMinExclusive {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionMinExclusiveNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionMinExclusive>;
        prototype: IXsdTypeRestrictionMinExclusive;
    }
    interface IXsdTypeRestrictionMinExclusive extends GObject.Object {}

    export const IXsdTypeRestrictionMinExclusive: IXsdTypeRestrictionMinExclusiveNamespace & {
        new (): IXsdTypeRestrictionMinExclusive; // This allows `obj instanceof IXsdTypeRestrictionMinExclusive`
    };

    namespace IXsdTypeRestrictionMinInclusive {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionMinInclusiveNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionMinInclusive>;
        prototype: IXsdTypeRestrictionMinInclusive;
    }
    interface IXsdTypeRestrictionMinInclusive extends GObject.Object {}

    export const IXsdTypeRestrictionMinInclusive: IXsdTypeRestrictionMinInclusiveNamespace & {
        new (): IXsdTypeRestrictionMinInclusive; // This allows `obj instanceof IXsdTypeRestrictionMinInclusive`
    };

    namespace IXsdTypeRestrictionMaxExclusive {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionMaxExclusiveNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionMaxExclusive>;
        prototype: IXsdTypeRestrictionMaxExclusive;
    }
    interface IXsdTypeRestrictionMaxExclusive extends GObject.Object {}

    export const IXsdTypeRestrictionMaxExclusive: IXsdTypeRestrictionMaxExclusiveNamespace & {
        new (): IXsdTypeRestrictionMaxExclusive; // This allows `obj instanceof IXsdTypeRestrictionMaxExclusive`
    };

    namespace IXsdTypeRestrictionMaxInclusive {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionMaxInclusiveNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionMaxInclusive>;
        prototype: IXsdTypeRestrictionMaxInclusive;
    }
    interface IXsdTypeRestrictionMaxInclusive extends GObject.Object {}

    export const IXsdTypeRestrictionMaxInclusive: IXsdTypeRestrictionMaxInclusiveNamespace & {
        new (): IXsdTypeRestrictionMaxInclusive; // This allows `obj instanceof IXsdTypeRestrictionMaxInclusive`
    };

    namespace IXsdTypeRestrictionTotalDigits {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionTotalDigitsNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionTotalDigits>;
        prototype: IXsdTypeRestrictionTotalDigits;
    }
    interface IXsdTypeRestrictionTotalDigits extends GObject.Object {}

    export const IXsdTypeRestrictionTotalDigits: IXsdTypeRestrictionTotalDigitsNamespace & {
        new (): IXsdTypeRestrictionTotalDigits; // This allows `obj instanceof IXsdTypeRestrictionTotalDigits`
    };

    namespace IXsdTypeRestrictionFractionDigits {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionFractionDigitsNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionFractionDigits>;
        prototype: IXsdTypeRestrictionFractionDigits;
    }
    interface IXsdTypeRestrictionFractionDigits extends GObject.Object {}

    export const IXsdTypeRestrictionFractionDigits: IXsdTypeRestrictionFractionDigitsNamespace & {
        new (): IXsdTypeRestrictionFractionDigits; // This allows `obj instanceof IXsdTypeRestrictionFractionDigits`
    };

    namespace IXsdTypeRestrictionLength {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionLengthNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionLength>;
        prototype: IXsdTypeRestrictionLength;
    }
    interface IXsdTypeRestrictionLength extends GObject.Object {}

    export const IXsdTypeRestrictionLength: IXsdTypeRestrictionLengthNamespace & {
        new (): IXsdTypeRestrictionLength; // This allows `obj instanceof IXsdTypeRestrictionLength`
    };

    namespace IXsdTypeRestrictionMinLength {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionMinLengthNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionMinLength>;
        prototype: IXsdTypeRestrictionMinLength;
    }
    interface IXsdTypeRestrictionMinLength extends GObject.Object {}

    export const IXsdTypeRestrictionMinLength: IXsdTypeRestrictionMinLengthNamespace & {
        new (): IXsdTypeRestrictionMinLength; // This allows `obj instanceof IXsdTypeRestrictionMinLength`
    };

    namespace IXsdTypeRestrictionMaxLength {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionMaxLengthNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionMaxLength>;
        prototype: IXsdTypeRestrictionMaxLength;
    }
    interface IXsdTypeRestrictionMaxLength extends GObject.Object {}

    export const IXsdTypeRestrictionMaxLength: IXsdTypeRestrictionMaxLengthNamespace & {
        new (): IXsdTypeRestrictionMaxLength; // This allows `obj instanceof IXsdTypeRestrictionMaxLength`
    };

    namespace IXsdTypeRestrictionEnumeration {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            id: string;
            value: string;
        }
    }

    export interface IXsdTypeRestrictionEnumerationNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionEnumeration>;
        prototype: IXsdTypeRestrictionEnumeration;
    }
    interface IXsdTypeRestrictionEnumeration extends GObject.Object {
        // Properties

        get id(): string;
        set id(val: string);
        get value(): string;
        set value(val: string);

        // Methods

        get_id(): string;
        set_id(value: string): void;
        get_value(): string;
        set_value(value: string): void;

        // Virtual methods

        vfunc_get_id(): string;
        vfunc_set_id(value: string): void;
        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
    }

    export const IXsdTypeRestrictionEnumeration: IXsdTypeRestrictionEnumerationNamespace & {
        new (): IXsdTypeRestrictionEnumeration; // This allows `obj instanceof IXsdTypeRestrictionEnumeration`
    };

    namespace IXsdTypeRestrictionWhiteSpace {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            fixed: boolean;
            id: string;
            value: string;
        }
    }

    export interface IXsdTypeRestrictionWhiteSpaceNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionWhiteSpace>;
        prototype: IXsdTypeRestrictionWhiteSpace;
    }
    interface IXsdTypeRestrictionWhiteSpace extends GObject.Object {
        // Properties

        get fixed(): boolean;
        set fixed(val: boolean);
        get id(): string;
        set id(val: string);
        get value(): string;
        set value(val: string);

        // Methods

        get_fixed(): boolean;
        set_fixed(value: boolean): void;
        get_id(): string;
        set_id(value: string): void;
        get_value(): string;
        set_value(value: string): void;

        // Virtual methods

        vfunc_get_fixed(): boolean;
        vfunc_set_fixed(value: boolean): void;
        vfunc_get_id(): string;
        vfunc_set_id(value: string): void;
        vfunc_get_value(): string;
        vfunc_set_value(value: string): void;
    }

    export const IXsdTypeRestrictionWhiteSpace: IXsdTypeRestrictionWhiteSpaceNamespace & {
        new (): IXsdTypeRestrictionWhiteSpace; // This allows `obj instanceof IXsdTypeRestrictionWhiteSpace`
    };

    namespace IXsdTypeRestrictionPattern {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionPatternNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionPattern>;
        prototype: IXsdTypeRestrictionPattern;
    }
    interface IXsdTypeRestrictionPattern extends GObject.Object {}

    export const IXsdTypeRestrictionPattern: IXsdTypeRestrictionPatternNamespace & {
        new (): IXsdTypeRestrictionPattern; // This allows `obj instanceof IXsdTypeRestrictionPattern`
    };

    namespace IXsdTypeRestrictionAssertion {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionAssertionNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionAssertion>;
        prototype: IXsdTypeRestrictionAssertion;
    }
    interface IXsdTypeRestrictionAssertion extends GObject.Object {}

    export const IXsdTypeRestrictionAssertion: IXsdTypeRestrictionAssertionNamespace & {
        new (): IXsdTypeRestrictionAssertion; // This allows `obj instanceof IXsdTypeRestrictionAssertion`
    };

    namespace IXsdTypeRestrictionExplicitTimezone {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdTypeRestrictionExplicitTimezoneNamespace {
        $gtype: GObject.GType<IXsdTypeRestrictionExplicitTimezone>;
        prototype: IXsdTypeRestrictionExplicitTimezone;
    }
    interface IXsdTypeRestrictionExplicitTimezone extends GObject.Object {}

    export const IXsdTypeRestrictionExplicitTimezone: IXsdTypeRestrictionExplicitTimezoneNamespace & {
        new (): IXsdTypeRestrictionExplicitTimezone; // This allows `obj instanceof IXsdTypeRestrictionExplicitTimezone`
    };

    namespace IXsdComplexType {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            abstract: boolean;
            block: string;
            final: string;
            mixed: boolean;
            name: string;
            default_attributes_apply: boolean;
            defaultAttributesApply: boolean;
            content_type: IXsdBaseContent;
            contentType: IXsdBaseContent;
            type_attributes: IXsdListAttributes;
            typeAttributes: IXsdListAttributes;
            group_attributes: IXsdListAttributesGroup;
            groupAttributes: IXsdListAttributesGroup;
        }
    }

    export interface IXsdComplexTypeNamespace {
        $gtype: GObject.GType<IXsdComplexType>;
        prototype: IXsdComplexType;
    }
    interface IXsdComplexType extends GObject.Object {
        // Properties

        get 'abstract'(): boolean;
        set 'abstract'(val: boolean);
        get block(): string;
        set block(val: string);
        get 'final'(): string;
        set 'final'(val: string);
        get mixed(): boolean;
        set mixed(val: boolean);
        get name(): string;
        set name(val: string);
        get default_attributes_apply(): boolean;
        set default_attributes_apply(val: boolean);
        get defaultAttributesApply(): boolean;
        set defaultAttributesApply(val: boolean);
        get content_type(): IXsdBaseContent;
        set content_type(val: IXsdBaseContent);
        get contentType(): IXsdBaseContent;
        set contentType(val: IXsdBaseContent);
        get type_attributes(): IXsdListAttributes;
        get typeAttributes(): IXsdListAttributes;
        get group_attributes(): IXsdListAttributesGroup;
        get groupAttributes(): IXsdListAttributesGroup;

        // Methods

        get_abstract(): boolean;
        set_abstract(value: boolean): void;
        get_block(): string;
        set_block(value: string): void;
        get_final(): string;
        set_final(value: string): void;
        get_mixed(): boolean;
        set_mixed(value: boolean): void;
        get_name(): string;
        set_name(value: string): void;
        get_default_attributes_apply(): boolean;
        set_default_attributes_apply(value: boolean): void;
        get_content_type(): IXsdBaseContent;
        set_content_type(value: IXsdBaseContent): void;
        get_type_attributes(): IXsdListAttributes;
        get_group_attributes(): IXsdListAttributesGroup;

        // Virtual methods

        vfunc_get_abstract(): boolean;
        vfunc_set_abstract(value: boolean): void;
        vfunc_get_block(): string;
        vfunc_set_block(value: string): void;
        vfunc_get_final(): string;
        vfunc_set_final(value: string): void;
        vfunc_get_mixed(): boolean;
        vfunc_set_mixed(value: boolean): void;
        vfunc_get_name(): string;
        vfunc_set_name(value: string): void;
        vfunc_get_default_attributes_apply(): boolean;
        vfunc_set_default_attributes_apply(value: boolean): void;
        vfunc_get_content_type(): IXsdBaseContent;
        vfunc_set_content_type(value: IXsdBaseContent): void;
        vfunc_get_type_attributes(): IXsdListAttributes;
        vfunc_get_group_attributes(): IXsdListAttributesGroup;
    }

    export const IXsdComplexType: IXsdComplexTypeNamespace & {
        new (): IXsdComplexType; // This allows `obj instanceof IXsdComplexType`
    };

    namespace IXsdExtension {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            base: string;
        }
    }

    export interface IXsdExtensionNamespace {
        $gtype: GObject.GType<IXsdExtension>;
        prototype: IXsdExtension;
    }
    interface IXsdExtension extends GObject.Object {
        // Properties

        get base(): string;
        set base(val: string);

        // Methods

        get_base(): string;
        set_base(value: string): void;

        // Virtual methods

        vfunc_get_base(): string;
        vfunc_set_base(value: string): void;
    }

    export const IXsdExtension: IXsdExtensionNamespace & {
        new (): IXsdExtension; // This allows `obj instanceof IXsdExtension`
    };

    namespace IXsdElement {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            abstract: boolean;
            block: string;
            default: string;
            final: string;
            fixed: string;
            form: string;
            id: string;
            maxOccurs: string;
            minOccurs: string;
            name: string;
            nillable: boolean;
            ref: string | any;
            substitution_group: DomTokenList;
            substitutionGroup: DomTokenList;
            target_namespace: string;
            targetNamespace: string;
            object_type: string;
            objectType: string;
            anotation: IXsdAnnotation;
            simple_type: IXsdSimpleType;
            simpleType: IXsdSimpleType;
            complex_type: IXsdComplexType;
            complexType: IXsdComplexType;
        }
    }

    export interface IXsdElementNamespace {
        $gtype: GObject.GType<IXsdElement>;
        prototype: IXsdElement;
    }
    interface IXsdElement extends GObject.Object {
        // Properties

        get 'abstract'(): boolean;
        set 'abstract'(val: boolean);
        get block(): string;
        set block(val: string);
        get 'default'(): string;
        set 'default'(val: string);
        get 'final'(): string;
        set 'final'(val: string);
        get fixed(): string;
        set fixed(val: string);
        get form(): string;
        set form(val: string);
        get id(): string;
        set id(val: string);
        get maxOccurs(): string;
        set maxOccurs(val: string);
        get minOccurs(): string;
        set minOccurs(val: string);
        get name(): string;
        set name(val: string);
        get nillable(): boolean;
        set nillable(val: boolean);
        // This accessor conflicts with a field or function name in a parent class or interface.
        ref: string | any;
        get substitution_group(): DomTokenList;
        set substitution_group(val: DomTokenList);
        get substitutionGroup(): DomTokenList;
        set substitutionGroup(val: DomTokenList);
        get target_namespace(): string;
        set target_namespace(val: string);
        get targetNamespace(): string;
        set targetNamespace(val: string);
        get object_type(): string;
        set object_type(val: string);
        get objectType(): string;
        set objectType(val: string);
        get anotation(): IXsdAnnotation;
        set anotation(val: IXsdAnnotation);
        get simple_type(): IXsdSimpleType;
        set simple_type(val: IXsdSimpleType);
        get simpleType(): IXsdSimpleType;
        set simpleType(val: IXsdSimpleType);
        get complex_type(): IXsdComplexType;
        set complex_type(val: IXsdComplexType);
        get complexType(): IXsdComplexType;
        set complexType(val: IXsdComplexType);

        // Methods

        get_abstract(): boolean;
        set_abstract(value: boolean): void;
        get_block(): string;
        set_block(value: string): void;
        get_default(): string;
        set_default(value: string): void;
        get_final(): string;
        set_final(value: string): void;
        get_fixed(): string;
        set_fixed(value: string): void;
        get_form(): string;
        set_form(value: string): void;
        get_id(): string | null;
        set_id(value?: string | null): void;
        get_maxOccurs(): string;
        set_maxOccurs(value: string): void;
        get_minOccurs(): string;
        set_minOccurs(value: string): void;
        get_name(): string;
        set_name(value: string): void;
        get_nillable(): boolean;
        set_nillable(value: boolean): void;
        get_ref(): string;
        set_ref(value: string): void;
        get_substitution_group(): DomTokenList;
        set_substitution_group(value: DomTokenList): void;
        get_target_namespace(): string;
        set_target_namespace(value: string): void;
        get_object_type(): string;
        set_object_type(value: string): void;
        get_anotation(): IXsdAnnotation;
        set_anotation(value: IXsdAnnotation): void;
        get_simple_type(): IXsdSimpleType;
        set_simple_type(value: IXsdSimpleType): void;
        get_complex_type(): IXsdComplexType;
        set_complex_type(value: IXsdComplexType): void;

        // Virtual methods

        vfunc_get_abstract(): boolean;
        vfunc_set_abstract(value: boolean): void;
        vfunc_get_block(): string;
        vfunc_set_block(value: string): void;
        vfunc_get_default(): string;
        vfunc_set_default(value: string): void;
        vfunc_get_final(): string;
        vfunc_set_final(value: string): void;
        vfunc_get_fixed(): string;
        vfunc_set_fixed(value: string): void;
        vfunc_get_form(): string;
        vfunc_set_form(value: string): void;
        vfunc_get_id(): string | null;
        vfunc_set_id(value?: string | null): void;
        vfunc_get_maxOccurs(): string;
        vfunc_set_maxOccurs(value: string): void;
        vfunc_get_minOccurs(): string;
        vfunc_set_minOccurs(value: string): void;
        vfunc_get_name(): string;
        vfunc_set_name(value: string): void;
        vfunc_get_nillable(): boolean;
        vfunc_set_nillable(value: boolean): void;
        vfunc_get_ref(): string;
        vfunc_set_ref(value: string): void;
        vfunc_get_substitution_group(): DomTokenList;
        vfunc_set_substitution_group(value: DomTokenList): void;
        vfunc_get_target_namespace(): string;
        vfunc_set_target_namespace(value: string): void;
        vfunc_get_object_type(): string;
        vfunc_set_object_type(value: string): void;
        vfunc_get_anotation(): IXsdAnnotation;
        vfunc_set_anotation(value: IXsdAnnotation): void;
        vfunc_get_simple_type(): IXsdSimpleType;
        vfunc_set_simple_type(value: IXsdSimpleType): void;
        vfunc_get_complex_type(): IXsdComplexType;
        vfunc_set_complex_type(value: IXsdComplexType): void;
    }

    export const IXsdElement: IXsdElementNamespace & {
        new (): IXsdElement; // This allows `obj instanceof IXsdElement`
    };

    namespace IXsdAnnotation {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdAnnotationNamespace {
        $gtype: GObject.GType<IXsdAnnotation>;
        prototype: IXsdAnnotation;
    }
    interface IXsdAnnotation extends GObject.Object {}

    export const IXsdAnnotation: IXsdAnnotationNamespace & {
        new (): IXsdAnnotation; // This allows `obj instanceof IXsdAnnotation`
    };

    namespace IXsdBaseContent {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            anotation: IXsdAnnotation;
        }
    }

    export interface IXsdBaseContentNamespace {
        $gtype: GObject.GType<IXsdBaseContent>;
        prototype: IXsdBaseContent;
    }
    interface IXsdBaseContent extends GObject.Object {
        // Properties

        get anotation(): IXsdAnnotation;
        set anotation(val: IXsdAnnotation);

        // Methods

        get_anotation(): IXsdAnnotation;
        set_anotation(value: IXsdAnnotation): void;

        // Virtual methods

        vfunc_get_anotation(): IXsdAnnotation;
        vfunc_set_anotation(value: IXsdAnnotation): void;
    }

    export const IXsdBaseContent: IXsdBaseContentNamespace & {
        new (): IXsdBaseContent; // This allows `obj instanceof IXsdBaseContent`
    };

    namespace IXsdSimpleContent {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdSimpleContentNamespace {
        $gtype: GObject.GType<IXsdSimpleContent>;
        prototype: IXsdSimpleContent;
    }
    interface IXsdSimpleContent extends GObject.Object {}

    export const IXsdSimpleContent: IXsdSimpleContentNamespace & {
        new (): IXsdSimpleContent; // This allows `obj instanceof IXsdSimpleContent`
    };

    namespace IXsdComplexContent {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdComplexContentNamespace {
        $gtype: GObject.GType<IXsdComplexContent>;
        prototype: IXsdComplexContent;
    }
    interface IXsdComplexContent extends GObject.Object {}

    export const IXsdComplexContent: IXsdComplexContentNamespace & {
        new (): IXsdComplexContent; // This allows `obj instanceof IXsdComplexContent`
    };

    namespace IXsdOpenContent {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdOpenContentNamespace {
        $gtype: GObject.GType<IXsdOpenContent>;
        prototype: IXsdOpenContent;
    }
    interface IXsdOpenContent extends GObject.Object {}

    export const IXsdOpenContent: IXsdOpenContentNamespace & {
        new (): IXsdOpenContent; // This allows `obj instanceof IXsdOpenContent`
    };

    namespace IXsdBaseAttribute {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            anotation: IXsdAnnotation;
        }
    }

    export interface IXsdBaseAttributeNamespace {
        $gtype: GObject.GType<IXsdBaseAttribute>;
        prototype: IXsdBaseAttribute;
    }
    interface IXsdBaseAttribute extends GObject.Object {
        // Properties

        get anotation(): IXsdAnnotation;
        set anotation(val: IXsdAnnotation);

        // Methods

        get_anotation(): IXsdAnnotation;
        set_anotation(value: IXsdAnnotation): void;

        // Virtual methods

        vfunc_get_anotation(): IXsdAnnotation;
        vfunc_set_anotation(value: IXsdAnnotation): void;
    }

    export const IXsdBaseAttribute: IXsdBaseAttributeNamespace & {
        new (): IXsdBaseAttribute; // This allows `obj instanceof IXsdBaseAttribute`
    };

    namespace IXsdAttribute {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdAttributeNamespace {
        $gtype: GObject.GType<IXsdAttribute>;
        prototype: IXsdAttribute;
    }
    interface IXsdAttribute extends GObject.Object {}

    export const IXsdAttribute: IXsdAttributeNamespace & {
        new (): IXsdAttribute; // This allows `obj instanceof IXsdAttribute`
    };

    namespace IXsdAttributeGroup {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdAttributeGroupNamespace {
        $gtype: GObject.GType<IXsdAttributeGroup>;
        prototype: IXsdAttributeGroup;
    }
    interface IXsdAttributeGroup extends GObject.Object {}

    export const IXsdAttributeGroup: IXsdAttributeGroupNamespace & {
        new (): IXsdAttributeGroup; // This allows `obj instanceof IXsdAttributeGroup`
    };

    namespace IXsdList {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            element: DomElement;
            items_type: GObject.GType;
            itemsType: GObject.GType;
            items_name: GObject.GType;
            itemsName: GObject.GType;
            length: number;
        }
    }

    export interface IXsdListNamespace {
        $gtype: GObject.GType<IXsdList>;
        prototype: IXsdList;
    }
    interface IXsdList extends GObject.Object {
        // Properties

        get element(): DomElement;
        set element(val: DomElement);
        get items_type(): GObject.GType;
        set items_type(val: GObject.GType);
        get itemsType(): GObject.GType;
        set itemsType(val: GObject.GType);
        get items_name(): GObject.GType;
        set items_name(val: GObject.GType);
        get itemsName(): GObject.GType;
        set itemsName(val: GObject.GType);
        get length(): number;

        // Methods

        get_element(): DomElement;
        set_element(value: DomElement): void;
        get_items_type(): GObject.GType;
        set_items_type(value: GObject.GType): void;
        get_items_name(): GObject.GType;
        set_items_name(value: GObject.GType): void;
        get_length(): number;
        get_item(index: number): DomElement | null;
        append(element: DomElement): void;
        remove(index: number): void;
        index_of(element: DomElement): number;

        // Virtual methods

        vfunc_get_element(): DomElement;
        vfunc_set_element(value: DomElement): void;
        vfunc_get_items_type(): GObject.GType;
        vfunc_set_items_type(value: GObject.GType): void;
        vfunc_get_items_name(): GObject.GType;
        vfunc_set_items_name(value: GObject.GType): void;
        vfunc_get_length(): number;
        vfunc_get_item(index: number): DomElement | null;
        vfunc_append(element: DomElement): void;
        vfunc_remove(index: number): void;
        vfunc_index_of(element: DomElement): number;
    }

    export const IXsdList: IXsdListNamespace & {
        new (): IXsdList; // This allows `obj instanceof IXsdList`
    };

    namespace IXsdListElements {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdListElementsNamespace {
        $gtype: GObject.GType<IXsdListElements>;
        prototype: IXsdListElements;
    }
    interface IXsdListElements extends GObject.Object {}

    export const IXsdListElements: IXsdListElementsNamespace & {
        new (): IXsdListElements; // This allows `obj instanceof IXsdListElements`
    };

    namespace IXsdListSimpleTypes {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdListSimpleTypesNamespace {
        $gtype: GObject.GType<IXsdListSimpleTypes>;
        prototype: IXsdListSimpleTypes;
    }
    interface IXsdListSimpleTypes extends GObject.Object {}

    export const IXsdListSimpleTypes: IXsdListSimpleTypesNamespace & {
        new (): IXsdListSimpleTypes; // This allows `obj instanceof IXsdListSimpleTypes`
    };

    namespace IXsdListComplexTypes {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdListComplexTypesNamespace {
        $gtype: GObject.GType<IXsdListComplexTypes>;
        prototype: IXsdListComplexTypes;
    }
    interface IXsdListComplexTypes extends GObject.Object {}

    export const IXsdListComplexTypes: IXsdListComplexTypesNamespace & {
        new (): IXsdListComplexTypes; // This allows `obj instanceof IXsdListComplexTypes`
    };

    namespace IXsdListAttributes {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdListAttributesNamespace {
        $gtype: GObject.GType<IXsdListAttributes>;
        prototype: IXsdListAttributes;
    }
    interface IXsdListAttributes extends GObject.Object {}

    export const IXsdListAttributes: IXsdListAttributesNamespace & {
        new (): IXsdListAttributes; // This allows `obj instanceof IXsdListAttributes`
    };

    namespace IXsdListAttributesGroup {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdListAttributesGroupNamespace {
        $gtype: GObject.GType<IXsdListAttributesGroup>;
        prototype: IXsdListAttributesGroup;
    }
    interface IXsdListAttributesGroup extends GObject.Object {}

    export const IXsdListAttributesGroup: IXsdListAttributesGroupNamespace & {
        new (): IXsdListAttributesGroup; // This allows `obj instanceof IXsdListAttributesGroup`
    };

    namespace IXsdListTypeRestrictionEnumerations {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdListTypeRestrictionEnumerationsNamespace {
        $gtype: GObject.GType<IXsdListTypeRestrictionEnumerations>;
        prototype: IXsdListTypeRestrictionEnumerations;
    }
    interface IXsdListTypeRestrictionEnumerations extends GObject.Object {}

    export const IXsdListTypeRestrictionEnumerations: IXsdListTypeRestrictionEnumerationsNamespace & {
        new (): IXsdListTypeRestrictionEnumerations; // This allows `obj instanceof IXsdListTypeRestrictionEnumerations`
    };

    namespace IXsdListTypeRestrictionWhiteSpaces {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface IXsdListTypeRestrictionWhiteSpacesNamespace {
        $gtype: GObject.GType<IXsdListTypeRestrictionWhiteSpaces>;
        prototype: IXsdListTypeRestrictionWhiteSpaces;
    }
    interface IXsdListTypeRestrictionWhiteSpaces extends GObject.Object {}

    export const IXsdListTypeRestrictionWhiteSpaces: IXsdListTypeRestrictionWhiteSpacesNamespace & {
        new (): IXsdListTypeRestrictionWhiteSpaces; // This allows `obj instanceof IXsdListTypeRestrictionWhiteSpaces`
    };

    namespace Object {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ObjectNamespace {
        $gtype: GObject.GType<Object>;
        prototype: Object;
    }
    interface Object extends GObject.Object {
        // Methods

        get_properties_list(): GObject.ParamSpec[];
        find_property_name(nick: string): GObject.ParamSpec | null;
        find_object_property_name(pname: string): GObject.ParamSpec | null;
        get_property_element_list(): GObject.ParamSpec[];
        get_property_string(prop: GObject.ParamSpec): string | null;
        get_attribute(name: string): string | null;
        find_property(name: string): Property | null;
        set_attribute(name: string, val: string): boolean;
        get_child(name: string): DomElement | null;
        find_elements(name: string): DomElementList;
        remove_attribute(name: string): boolean;
        set_instance_property(name: string): boolean;
        clean_property_elements(name: string): void;

        // Virtual methods

        vfunc_get_properties_list(): GObject.ParamSpec[];
        vfunc_find_property_name(nick: string): GObject.ParamSpec | null;
        vfunc_find_object_property_name(pname: string): GObject.ParamSpec | null;
        vfunc_get_property_element_list(): GObject.ParamSpec[];
        vfunc_get_property_string(prop: GObject.ParamSpec): string | null;
        vfunc_get_attribute(name: string): string | null;
        vfunc_find_property(name: string): Property | null;
        vfunc_set_attribute(name: string, val: string): boolean;
        vfunc_get_child(name: string): DomElement | null;
        vfunc_find_elements(name: string): DomElementList;
        vfunc_remove_attribute(name: string): boolean;
        vfunc_set_instance_property(name: string): boolean;
        vfunc_clean_property_elements(name: string): void;
    }

    export const Object: ObjectNamespace & {
        new (): Object; // This allows `obj instanceof Object`
    };

    namespace Parser {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            backup: boolean;
            indent: boolean;
            cancellable: Gio.Cancellable;
            node: DomNode;
            types: GLib.HashTable<GObject.GType, GLib.HashTable>;
        }
    }

    export interface ParserNamespace {
        $gtype: GObject.GType<Parser>;
        prototype: Parser;
    }
    interface Parser extends GObject.Object {
        // Properties

        get backup(): boolean;
        set backup(val: boolean);
        get indent(): boolean;
        set indent(val: boolean);
        get cancellable(): Gio.Cancellable;
        set cancellable(val: Gio.Cancellable);
        get node(): DomNode;
        get types(): GLib.HashTable<GObject.GType, GLib.HashTable>;

        // Methods

        get_backup(): boolean;
        set_backup(value: boolean): void;
        get_indent(): boolean;
        set_indent(value: boolean): void;
        get_cancellable(): Gio.Cancellable | null;
        set_cancellable(value?: Gio.Cancellable | null): void;
        get_node(): DomNode;
        get_types(): GLib.HashTable<GObject.GType, GLib.HashTable>;
        write_file(file: Gio.File): void;
        write_file_async(file: Gio.File): globalThis.Promise<void>;
        write_file_async(file: Gio.File, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_file_async(
            file: Gio.File,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_file_finish(_res_: Gio.AsyncResult): void;
        write_string(): string;
        write_string_async(): globalThis.Promise<string>;
        write_string_async(_callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_string_async(_callback_?: Gio.AsyncReadyCallback<this> | null): globalThis.Promise<string> | void;
        write_string_finish(_res_: Gio.AsyncResult): string;
        write_stream(stream: Gio.OutputStream): void;
        write_stream_async(stream: Gio.OutputStream): globalThis.Promise<void>;
        write_stream_async(stream: Gio.OutputStream, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        write_stream_async(
            stream: Gio.OutputStream,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        write_stream_finish(_res_: Gio.AsyncResult): void;
        read_file(file: Gio.File): void;
        read_file_async(file: Gio.File): globalThis.Promise<void>;
        read_file_async(file: Gio.File, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_file_async(
            file: Gio.File,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_file_finish(_res_: Gio.AsyncResult): void;
        read_stream(stream: Gio.InputStream): void;
        read_stream_async(stream: Gio.InputStream): globalThis.Promise<void>;
        read_stream_async(stream: Gio.InputStream, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_stream_async(
            stream: Gio.InputStream,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_stream_finish(_res_: Gio.AsyncResult): void;
        read_string(str: string): void;
        read_string_async(str: string): globalThis.Promise<void>;
        read_string_async(str: string, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_string_async(
            str: string,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_string_finish(_res_: Gio.AsyncResult): void;
        create_stream(): Gio.InputStream;
        create_stream_async(): globalThis.Promise<Gio.InputStream>;
        create_stream_async(_callback_: Gio.AsyncReadyCallback<this> | null): void;
        create_stream_async(
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<Gio.InputStream> | void;
        create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        read_child_nodes(parent: DomNode): void;
        read_child_nodes_async(parent: DomNode): globalThis.Promise<void>;
        read_child_nodes_async(parent: DomNode, _callback_: Gio.AsyncReadyCallback<this> | null): void;
        read_child_nodes_async(
            parent: DomNode,
            _callback_?: Gio.AsyncReadyCallback<this> | null,
        ): globalThis.Promise<void> | void;
        read_child_nodes_finish(_res_: Gio.AsyncResult): void;
        read_child_node(parent: DomNode): boolean;
        read_child_element(parent: DomNode): boolean;
        read_element_property(parent: DomNode): [boolean, DomNode];
        add_element_collection(parent: DomNode): [boolean, DomNode];
        read_child_nodes_stream(istream: Gio.InputStream): void;
        read_child_nodes_string(str: string): void;
        read_unparsed(): string;
        move_next_node(): boolean;
        current_is_empty_element(): boolean;
        current_is_element(): boolean;
        current_is_document(): boolean;
        current_node_name(): string;
        create_element(parent: DomNode): DomElement | null;
        read_element(element: DomElement): void;

        // Virtual methods

        vfunc_get_backup(): boolean;
        vfunc_set_backup(value: boolean): void;
        vfunc_get_indent(): boolean;
        vfunc_set_indent(value: boolean): void;
        vfunc_get_cancellable(): Gio.Cancellable | null;
        vfunc_set_cancellable(value?: Gio.Cancellable | null): void;
        vfunc_get_node(): DomNode;
        vfunc_get_types(): GLib.HashTable<GObject.GType, GLib.HashTable>;
        vfunc_write_file(file: Gio.File): void;
        vfunc_write_file_async(file: Gio.File, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_write_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_write_string(): string;
        vfunc_write_string_async(_callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_write_string_finish(_res_: Gio.AsyncResult): string;
        vfunc_write_stream(stream: Gio.OutputStream): void;
        vfunc_write_stream_async(stream: Gio.OutputStream, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_write_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_file(file: Gio.File): void;
        vfunc_read_file_async(file: Gio.File, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_file_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_stream(stream: Gio.InputStream): void;
        vfunc_read_stream_async(stream: Gio.InputStream, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_stream_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_string(str: string): void;
        vfunc_read_string_async(str: string, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_string_finish(_res_: Gio.AsyncResult): void;
        vfunc_create_stream(): Gio.InputStream;
        vfunc_create_stream_async(_callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_create_stream_finish(_res_: Gio.AsyncResult): Gio.InputStream;
        vfunc_read_child_nodes(parent: DomNode): void;
        vfunc_read_child_nodes_async(parent: DomNode, _callback_?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_read_child_nodes_finish(_res_: Gio.AsyncResult): void;
        vfunc_read_child_node(parent: DomNode): boolean;
        vfunc_read_child_element(parent: DomNode): boolean;
        vfunc_read_element_property(parent: DomNode): [boolean, DomNode];
        vfunc_add_element_collection(parent: DomNode): [boolean, DomNode];
        vfunc_read_child_nodes_stream(istream: Gio.InputStream): void;
        vfunc_read_child_nodes_string(str: string): void;
        vfunc_read_unparsed(): string;
        vfunc_move_next_node(): boolean;
        vfunc_current_is_empty_element(): boolean;
        vfunc_current_is_element(): boolean;
        vfunc_current_is_document(): boolean;
        vfunc_current_node_name(): string;
        vfunc_create_element(parent: DomNode): DomElement | null;
        vfunc_read_element(element: DomElement): void;
    }

    export const Parser: ParserNamespace & {
        new (): Parser; // This allows `obj instanceof Parser`
    };

    namespace Property {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            value: string;
        }
    }

    export interface PropertyNamespace {
        $gtype: GObject.GType<Property>;
        prototype: Property;
    }
    interface Property extends GObject.Object {
        // Properties

        get value(): string;
        set value(val: string);

        // Methods

        get_value(): string | null;
        set_value(value?: string | null): void;
        validate_value(val?: string | null): boolean;

        // Virtual methods

        vfunc_get_value(): string | null;
        vfunc_set_value(value?: string | null): void;
        vfunc_validate_value(val?: string | null): boolean;
    }

    export const Property: PropertyNamespace & {
        new (): Property; // This allows `obj instanceof Property`
    };

    namespace XPathContext {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface XPathContextNamespace {
        $gtype: GObject.GType<XPathContext>;
        prototype: XPathContext;
    }
    interface XPathContext extends GObject.Object {
        // Methods

        evaluate(expression: string, resolver?: Gee.Map | null): XPathObject;

        // Virtual methods

        vfunc_evaluate(expression: string, resolver?: Gee.Map | null): XPathObject;
    }

    export const XPathContext: XPathContextNamespace & {
        new (): XPathContext; // This allows `obj instanceof XPathContext`
    };

    namespace XPathObject {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            object_type: XPathObjectType;
            objectType: XPathObjectType;
            boolean_value: boolean;
            booleanValue: boolean;
            string_value: string;
            stringValue: string;
            number_value: number;
            numberValue: number;
            nodeset: DomHTMLCollection;
        }
    }

    export interface XPathObjectNamespace {
        $gtype: GObject.GType<XPathObject>;
        prototype: XPathObject;
    }
    interface XPathObject extends GObject.Object {
        // Properties

        get object_type(): XPathObjectType;
        get objectType(): XPathObjectType;
        get boolean_value(): boolean;
        get booleanValue(): boolean;
        get string_value(): string;
        get stringValue(): string;
        get number_value(): number;
        get numberValue(): number;
        get nodeset(): DomHTMLCollection;

        // Methods

        get_object_type(): XPathObjectType;
        get_boolean_value(): boolean;
        get_string_value(): string;
        get_number_value(): number;
        get_nodeset(): DomHTMLCollection;

        // Virtual methods

        vfunc_get_object_type(): XPathObjectType;
        vfunc_get_boolean_value(): boolean;
        vfunc_get_string_value(): string;
        vfunc_get_number_value(): number;
        vfunc_get_nodeset(): DomHTMLCollection;
    }

    export const XPathObject: XPathObjectNamespace & {
        new (): XPathObject; // This allows `obj instanceof XPathObject`
    };

    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default GXml;

// END
