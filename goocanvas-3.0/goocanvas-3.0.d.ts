/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

import '@girs/gjs';

// Module dependencies
import type Gtk from '@girs/gtk-3.0';
import type xlib from '@girs/xlib-2.0';
import type Gdk from '@girs/gdk-3.0';
import type cairo from 'cairo';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type Pango from '@girs/pango-1.0';
import type HarfBuzz from '@girs/harfbuzz-0.0';
import type freetype2 from '@girs/freetype2-2.0';
import type Gio from '@girs/gio-2.0';
import type GModule from '@girs/gmodule-2.0';
import type GdkPixbuf from '@girs/gdkpixbuf-2.0';
import type Atk from '@girs/atk-1.0';

export namespace GooCanvas {
    /**
     * GooCanvas-3.0
     */

    /**
     * #GooCairoAntialias is simply a wrapper for the #cairo_antialias_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_antialias_t documentation.
     */

    /**
     * #GooCairoAntialias is simply a wrapper for the #cairo_antialias_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_antialias_t documentation.
     */
    export namespace CairoAntialias {
        export const $gtype: GObject.GType<CairoAntialias>;
    }

    enum CairoAntialias {
        DEFAULT,
        NONE,
        GRAY,
        SUBPIXEL,
    }
    /**
     * #GooCairoFillRule is simply a wrapper for the #cairo_fill_rule_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_fill_rule_t documentation.
     */

    /**
     * #GooCairoFillRule is simply a wrapper for the #cairo_fill_rule_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_fill_rule_t documentation.
     */
    export namespace CairoFillRule {
        export const $gtype: GObject.GType<CairoFillRule>;
    }

    enum CairoFillRule {
        WINDING,
        EVEN_ODD,
    }
    /**
     * #GooCairoHintMetrics is simply a wrapper for the #cairo_hint_metrics_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_hint_metrics_t documentation.
     */

    /**
     * #GooCairoHintMetrics is simply a wrapper for the #cairo_hint_metrics_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_hint_metrics_t documentation.
     */
    export namespace CairoHintMetrics {
        export const $gtype: GObject.GType<CairoHintMetrics>;
    }

    enum CairoHintMetrics {
        DEFAULT,
        OFF,
        ON,
    }
    /**
     * #GooCairoLineCap is simply a wrapper for the #cairo_line_cap_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_line_cap_t documentation.
     */

    /**
     * #GooCairoLineCap is simply a wrapper for the #cairo_line_cap_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_line_cap_t documentation.
     */
    export namespace CairoLineCap {
        export const $gtype: GObject.GType<CairoLineCap>;
    }

    enum CairoLineCap {
        BUTT,
        ROUND,
        SQUARE,
    }
    /**
     * #GooCairoLineJoin is simply a wrapper for the #cairo_line_join_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_line_join_t documentation.
     */

    /**
     * #GooCairoLineJoin is simply a wrapper for the #cairo_line_join_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_line_join_t documentation.
     */
    export namespace CairoLineJoin {
        export const $gtype: GObject.GType<CairoLineJoin>;
    }

    enum CairoLineJoin {
        MITER,
        ROUND,
        BEVEL,
    }
    /**
     * #GooCairoOperator is simply a wrapper for the #cairo_operator_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_operator_t documentation.
     */

    /**
     * #GooCairoOperator is simply a wrapper for the #cairo_operator_t type,
     * allowing it to be used for #GObject properties.
     *
     * See the #cairo_operator_t documentation.
     */
    export namespace CairoOperator {
        export const $gtype: GObject.GType<CairoOperator>;
    }

    enum CairoOperator {
        CLEAR,
        SOURCE,
        OVER,
        IN,
        OUT,
        ATOP,
        DEST,
        DEST_OVER,
        DEST_IN,
        DEST_OUT,
        DEST_ATOP,
        XOR,
        ADD,
        SATURATE,
    }
    /**
     * GooCanvasAnchorType is used to specify the positions of objects relative to
     * a particular anchor point.
     */

    /**
     * GooCanvasAnchorType is used to specify the positions of objects relative to
     * a particular anchor point.
     */
    export namespace CanvasAnchorType {
        export const $gtype: GObject.GType<CanvasAnchorType>;
    }

    enum CanvasAnchorType {
        /**
         * the anchor is in the center of the object.
         */
        CENTER,
        /**
         * the anchor is at the top of the object, centered horizontally.
         */
        NORTH,
        /**
         * the anchor is at the top-left of the object.
         */
        NORTH_WEST,
        /**
         * the anchor is at the top-right of the object.
         */
        NORTH_EAST,
        /**
         * the anchor is at the bottom of the object, centered horizontally.
         */
        SOUTH,
        /**
         * the anchor is at the bottom-left of the object.
         */
        SOUTH_WEST,
        /**
         * the anchor is at the bottom-right of the object.
         */
        SOUTH_EAST,
        /**
         * the anchor is on the left of the object, centered vertically.
         */
        WEST,
        /**
         * the anchor is on the right of the object, centered vertically.
         */
        EAST,
        /**
         * see GOO_CANVAS_ANCHOR_NORTH.
         */
        N,
        /**
         * see GOO_CANVAS_ANCHOR_NORTH_WEST.
         */
        NW,
        /**
         * see GOO_CANVAS_ANCHOR_NORTH_EAST.
         */
        NE,
        /**
         * see GOO_CANVAS_ANCHOR_SOUTH.
         */
        S,
        /**
         * see GOO_CANVAS_ANCHOR_SOUTH_WEST.
         */
        SW,
        /**
         * see GOO_CANVAS_ANCHOR_SOUTH_EAST.
         */
        SE,
        /**
         * see GOO_CANVAS_ANCHOR_WEST.
         */
        W,
        /**
         * see GOO_CANVAS_ANCHOR_EAST.
         */
        E,
    }
    /**
     * #GooCanvasAnimateType is used to specify what happens when the end of an
     * animation is reached.
     */

    /**
     * #GooCanvasAnimateType is used to specify what happens when the end of an
     * animation is reached.
     */
    export namespace CanvasAnimateType {
        export const $gtype: GObject.GType<CanvasAnimateType>;
    }

    enum CanvasAnimateType {
        /**
         * the item remains in the final position.
         */
        FREEZE,
        /**
         * the item is moved back to the initial position.
         */
        RESET,
        /**
         * the animation is restarted from the initial
         *  position.
         */
        RESTART,
        /**
         * the animation bounces back and forth between the
         *  start and end positions.
         */
        BOUNCE,
    }
    /**
     * The #GooCanvasItemVisibility enumeration is used to specify when a canvas
     * item is visible.
     */

    /**
     * The #GooCanvasItemVisibility enumeration is used to specify when a canvas
     * item is visible.
     */
    export namespace CanvasItemVisibility {
        export const $gtype: GObject.GType<CanvasItemVisibility>;
    }

    enum CanvasItemVisibility {
        /**
         * the item is invisible, and is not allocated any
         *  space in layout container items such as #GooCanvasTable.
         */
        HIDDEN,
        /**
         * the item is invisible, but it is still allocated
         *  space in layout container items.
         */
        INVISIBLE,
        /**
         * the item is visible.
         */
        VISIBLE,
        /**
         * the item is visible when the
         *  canvas scale setting is greater than or equal to the item's visibility
         *  threshold setting.
         */
        VISIBLE_ABOVE_THRESHOLD,
    }
    /**
     * GooCanvasPathCommandType specifies the type of each command in the path.
     * See the path element in the <ulink url="http://www.w3.org/Graphics/SVG/">
     * Scalable Vector Graphics (SVG) specification</ulink> for more details.
     */

    /**
     * GooCanvasPathCommandType specifies the type of each command in the path.
     * See the path element in the <ulink url="http://www.w3.org/Graphics/SVG/">
     * Scalable Vector Graphics (SVG) specification</ulink> for more details.
     */
    export namespace CanvasPathCommandType {
        export const $gtype: GObject.GType<CanvasPathCommandType>;
    }

    enum CanvasPathCommandType {
        /**
         * move to the given point.
         */
        MOVE_TO,
        /**
         * close the current path, drawing a line from the
         *  current position to the start of the path.
         */
        CLOSE_PATH,
        /**
         * draw a line to the given point.
         */
        LINE_TO,
        /**
         * draw a horizontal line to the given
         *  x coordinate.
         */
        HORIZONTAL_LINE_TO,
        /**
         * draw a vertical line to the given y
         *  coordinate.
         */
        VERTICAL_LINE_TO,
        /**
         * draw a bezier curve using two control
         *  points to the given point.
         */
        CURVE_TO,
        /**
         * draw a bezier curve using a reflection
         *  of the last control point of the last curve as the first control point,
         *  and one new control point, to the given point.
         */
        SMOOTH_CURVE_TO,
        /**
         * draw a quadratic bezier curve using
         *  a single control point to the given point.
         */
        QUADRATIC_CURVE_TO,
        /**
         * draw a quadratic bezier curve
         *  using a reflection of the control point from the previous curve as the
         *  control point, to the given point.
         */
        SMOOTH_QUADRATIC_CURVE_TO,
        /**
         * draw an elliptical arc, using the given
         *  2 radii, the x axis rotation, and the 2 flags to disambiguate the arc,
         *  to the given point.
         */
        ELLIPTICAL_ARC,
    }
    const CANVAS_POLYLINE_NUM_ARROW_POINTS: number;
    function cairo_matrix_copy(matrix: cairo.Matrix): cairo.Matrix;
    function cairo_matrix_free(matrix: cairo.Matrix): void;
    /**
     * This function is only intended to be used when implementing new canvas
     * items, specifically layout container items such as #GooCanvasTable.
     *
     * It finds a child property of a canvas item class by name.
     * @param iclass a #GObjectClass
     * @param property_name the name of the child property to find
     * @returns the #GParamSpec of the  child property or %NULL if @class has no child property with that name.
     */
    function canvas_item_class_find_child_property(
        iclass: typeof GObject.Object,
        property_name: string,
    ): GObject.ParamSpec;
    /**
     * This function is only intended to be used when implementing new canvas
     * items, specifically layout container items such as #GooCanvasTable.
     *
     * It installs a child property on a canvas item class.
     * @param iclass a #GObjectClass
     * @param property_id the id for the property
     * @param pspec the #GParamSpec for the property
     */
    function canvas_item_class_install_child_property(
        iclass: typeof GObject.Object,
        property_id: number,
        pspec: GObject.ParamSpec,
    ): void;
    /**
     * This function is only intended to be used when implementing new canvas
     * items, specifically layout container items such as #GooCanvasTable.
     *
     * It returns all child properties of a canvas item class.
     * @param iclass a #GObjectClass
     * @returns a newly allocated  array of #GParamSpec*. The array must be freed with g_free().
     */
    function canvas_item_class_list_child_properties(iclass: typeof GObject.Object): GObject.ParamSpec[];
    /**
     * This function is only intended to be used when implementing new canvas
     * item models, specifically layout container item models such as
     * #GooCanvasTableModel.
     *
     * It finds a child property of a canvas item class by name.
     * @param mclass a #GObjectClass
     * @param property_name the name of the child property to find
     * @returns The #GParamSpec of the child  property or %NULL if @class has no child property with that name.
     */
    function canvas_item_model_class_find_child_property(
        mclass: typeof GObject.Object,
        property_name: string,
    ): GObject.ParamSpec;
    /**
     * This function is only intended to be used when implementing new canvas
     * item models, specifically layout container item models such as
     * #GooCanvasTableModel.
     *
     * It installs a child property on a canvas item class.
     * @param mclass a #GObjectClass
     * @param property_id the id for the property
     * @param pspec the #GParamSpec for the property
     */
    function canvas_item_model_class_install_child_property(
        mclass: typeof GObject.Object,
        property_id: number,
        pspec: GObject.ParamSpec,
    ): void;
    /**
     * This function is only intended to be used when implementing new canvas
     * item models, specifically layout container item models such as
     * #GooCanvasTableModel.
     *
     * It returns all child properties of a canvas item class.
     * @param mclass a #GObjectClass
     * @returns a newly allocated array of #GParamSpec*. The array must be freed with g_free().
     */
    function canvas_item_model_class_list_child_properties(mclass: typeof GObject.Object): GObject.ParamSpec[];
    type CairoMatrix = object | null;
    type CairoPattern = object | null;
    /**
     * Specifies when an item receives pointer events such as mouse clicks.
     */

    /**
     * Specifies when an item receives pointer events such as mouse clicks.
     */
    export namespace CanvasPointerEvents {
        export const $gtype: GObject.GType<CanvasPointerEvents>;
    }

    enum CanvasPointerEvents {
        /**
         * a mask indicating that the item only
         *  receives events when it is visible.
         */
        VISIBLE_MASK,
        /**
         * a mask indicating that the item only
         *  receives events when the specified parts of it are painted.
         */
        PAINTED_MASK,
        /**
         * a mask indicating that the filled part of
         *  the item receives events.
         */
        FILL_MASK,
        /**
         * a mask indicating that the stroked part
         *  of the item receives events.
         */
        STROKE_MASK,
        /**
         * the item doesn't receive events at all.
         */
        NONE,
        /**
         * the item receives events in its
         *  painted areas when it is visible (the default).
         */
        VISIBLE_PAINTED,
        /**
         * the item's interior receives events
         *  when it is visible.
         */
        VISIBLE_FILL,
        /**
         * the item's perimeter receives
         *  events when it is visible.
         */
        VISIBLE_STROKE,
        /**
         * the item receives events when it is visible,
         *  whether it is painted or not.
         */
        VISIBLE,
        /**
         * the item receives events in its painted areas,
         *  whether it is visible or not.
         */
        PAINTED,
        /**
         * the item's interior receives events, whether it
         *  is visible or painted or not.
         */
        FILL,
        /**
         * the item's perimeter receives events, whether
         *  it is visible or painted or not.
         */
        STROKE,
        /**
         * the item's perimeter and interior receive events,
         *  whether it is visible or painted or not.
         */
        ALL,
    }
    namespace Canvas {
        // Signal signatures
        interface SignalSignatures extends Gtk.Container.SignalSignatures {
            'item-created': (arg0: CanvasItem, arg1: CanvasItemModel) => void;
            'notify::anchor': (pspec: GObject.ParamSpec) => void;
            'notify::automatic-bounds': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-rgb': (pspec: GObject.ParamSpec) => void;
            'notify::bounds-from-origin': (pspec: GObject.ParamSpec) => void;
            'notify::bounds-padding': (pspec: GObject.ParamSpec) => void;
            'notify::clear-background': (pspec: GObject.ParamSpec) => void;
            'notify::integer-layout': (pspec: GObject.ParamSpec) => void;
            'notify::redraw-when-scrolled': (pspec: GObject.ParamSpec) => void;
            'notify::resolution-x': (pspec: GObject.ParamSpec) => void;
            'notify::resolution-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::units': (pspec: GObject.ParamSpec) => void;
            'notify::x1': (pspec: GObject.ParamSpec) => void;
            'notify::x2': (pspec: GObject.ParamSpec) => void;
            'notify::y1': (pspec: GObject.ParamSpec) => void;
            'notify::y2': (pspec: GObject.ParamSpec) => void;
            'notify::border-width': (pspec: GObject.ParamSpec) => void;
            'notify::child': (pspec: GObject.ParamSpec) => void;
            'notify::resize-mode': (pspec: GObject.ParamSpec) => void;
            'notify::app-paintable': (pspec: GObject.ParamSpec) => void;
            'notify::can-default': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::composite-child': (pspec: GObject.ParamSpec) => void;
            'notify::double-buffered': (pspec: GObject.ParamSpec) => void;
            'notify::events': (pspec: GObject.ParamSpec) => void;
            'notify::expand': (pspec: GObject.ParamSpec) => void;
            'notify::focus-on-click': (pspec: GObject.ParamSpec) => void;
            'notify::halign': (pspec: GObject.ParamSpec) => void;
            'notify::has-default': (pspec: GObject.ParamSpec) => void;
            'notify::has-focus': (pspec: GObject.ParamSpec) => void;
            'notify::has-tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::height-request': (pspec: GObject.ParamSpec) => void;
            'notify::hexpand': (pspec: GObject.ParamSpec) => void;
            'notify::hexpand-set': (pspec: GObject.ParamSpec) => void;
            'notify::is-focus': (pspec: GObject.ParamSpec) => void;
            'notify::margin': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-end': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-start': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::no-show-all': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::receives-default': (pspec: GObject.ParamSpec) => void;
            'notify::scale-factor': (pspec: GObject.ParamSpec) => void;
            'notify::sensitive': (pspec: GObject.ParamSpec) => void;
            'notify::style': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip-markup': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip-text': (pspec: GObject.ParamSpec) => void;
            'notify::valign': (pspec: GObject.ParamSpec) => void;
            'notify::vexpand': (pspec: GObject.ParamSpec) => void;
            'notify::vexpand-set': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width-request': (pspec: GObject.ParamSpec) => void;
            'notify::window': (pspec: GObject.ParamSpec) => void;
            'notify::hscroll-policy': (pspec: GObject.ParamSpec) => void;
            'notify::vscroll-policy': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Container.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Scrollable.ConstructorProps {
            anchor: CanvasAnchorType;
            automatic_bounds: boolean;
            automaticBounds: boolean;
            background_color: string;
            backgroundColor: string;
            background_color_gdk_rgba: Gdk.RGBA;
            backgroundColorGdkRgba: Gdk.RGBA;
            background_color_rgb: number;
            backgroundColorRgb: number;
            bounds_from_origin: boolean;
            boundsFromOrigin: boolean;
            bounds_padding: number;
            boundsPadding: number;
            clear_background: boolean;
            clearBackground: boolean;
            integer_layout: boolean;
            integerLayout: boolean;
            redraw_when_scrolled: boolean;
            redrawWhenScrolled: boolean;
            resolution_x: number;
            resolutionX: number;
            resolution_y: number;
            resolutionY: number;
            scale: number;
            scale_x: number;
            scaleX: number;
            scale_y: number;
            scaleY: number;
            units: Gtk.Unit;
            x1: number;
            x2: number;
            y1: number;
            y2: number;
        }
    }

    /**
     * #GooCanvas is the main widget containing a number of canvas items.
     *
     * Here is a simple example:
     *
     * <informalexample><programlisting>
     *  &num;include &lt;goocanvas.h&gt;
     *
     *  static gboolean on_rect_button_press (GooCanvasItem  *view,
     *                                        GooCanvasItem  *target,
     *                                        GdkEventButton *event,
     *                                        gpointer        data);
     *
     *  int
     *  main (int argc, char *argv[])
     *  {
     *    GtkWidget *window, *scrolled_win, *canvas;
     *    GooCanvasItem *root, *rect_item, *text_item;
     *
     *    /&ast; Initialize GTK+. &ast;/
     *    gtk_init (&amp;argc, &amp;argv);
     *
     *    /&ast; Create the window and widgets. &ast;/
     *    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
     *    gtk_window_set_default_size (GTK_WINDOW (window), 640, 600);
     *    gtk_widget_show (window);
     *    g_signal_connect (window, "delete_event", G_CALLBACK (on_delete_event),
     *                      NULL);
     *
     *    scrolled_win = gtk_scrolled_window_new (NULL, NULL);
     *    gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolled_win),
     *                                         GTK_SHADOW_IN);
     *    gtk_widget_show (scrolled_win);
     *    gtk_container_add (GTK_CONTAINER (window), scrolled_win);
     *
     *    canvas = goo_canvas_new&nbsp;();
     *    gtk_widget_set_size_request (canvas, 600, 450);
     *    goo_canvas_set_bounds (GOO_CANVAS (canvas), 0, 0, 1000, 1000);
     *    gtk_widget_show (canvas);
     *    gtk_container_add (GTK_CONTAINER (scrolled_win), canvas);
     *
     *    root = goo_canvas_get_root_item (GOO_CANVAS (canvas));
     *
     *    /&ast; Add a few simple items. &ast;/
     *    rect_item = goo_canvas_rect_new (root, 100, 100, 400, 400,
     *                                     "line-width", 10.0,
     *                                     "radius-x", 20.0,
     *                                     "radius-y", 10.0,
     *                                     "stroke-color", "yellow",
     *                                     "fill-color", "red",
     *                                     NULL);
     *
     *    text_item = goo_canvas_text_new (root, "Hello World", 300, 300, -1,
     *                                     GOO_CANVAS_ANCHOR_CENTER,
     *                                     "font", "Sans 24",
     *                                     NULL);
     *    goo_canvas_item_rotate (text_item, 45, 300, 300);
     *
     *    /&ast; Connect a signal handler for the rectangle item. &ast;/
     *    g_signal_connect (rect_item, "button_press_event",
     *                      G_CALLBACK (on_rect_button_press), NULL);
     *
     *    /&ast; Pass control to the GTK+ main event loop. &ast;/
     *    gtk_main&nbsp;();
     *
     *    return 0;
     *  }
     *
     *
     *  /&ast; This handles button presses in item views. We simply output a message to
     *     the console. &ast;/
     *  static gboolean
     *  on_rect_button_press (GooCanvasItem  *item,
     *                        GooCanvasItem  *target,
     *                        GdkEventButton *event,
     *                        gpointer        data)
     *  {
     *    g_print ("rect item received button press event\n");
     *    return TRUE;
     *  }
     *
     * </programlisting></informalexample>
     *
     * A #GooCanvas widget is usually placed inside a #GtkScrolledWindow widget
     * and can be scrolled with the scrollbar or with the scroll wheel on a mouse.
     * To disable mouse wheel scrolling, do this:
     * <informalexample><programlisting>
     *  g_signal_connect (canvas, "scroll-event", G_CALLBACK (gtk_true), NULL);
     * </programlisting></informalexample>
     */
    class Canvas extends Gtk.Container implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Scrollable {
        static $gtype: GObject.GType<Canvas>;

        // Properties

        get anchor(): CanvasAnchorType;
        set anchor(val: CanvasAnchorType);
        get automatic_bounds(): boolean;
        set automatic_bounds(val: boolean);
        get automaticBounds(): boolean;
        set automaticBounds(val: boolean);
        set background_color(val: string);
        set backgroundColor(val: string);
        /**
         * The color to use for the canvas background, specified as a GdkRGBA.
         */
        set background_color_gdk_rgba(val: Gdk.RGBA);
        /**
         * The color to use for the canvas background, specified as a GdkRGBA.
         */
        set backgroundColorGdkRgba(val: Gdk.RGBA);
        set background_color_rgb(val: number);
        set backgroundColorRgb(val: number);
        get bounds_from_origin(): boolean;
        set bounds_from_origin(val: boolean);
        get boundsFromOrigin(): boolean;
        set boundsFromOrigin(val: boolean);
        get bounds_padding(): number;
        set bounds_padding(val: number);
        get boundsPadding(): number;
        set boundsPadding(val: number);
        get clear_background(): boolean;
        set clear_background(val: boolean);
        get clearBackground(): boolean;
        set clearBackground(val: boolean);
        get integer_layout(): boolean;
        set integer_layout(val: boolean);
        get integerLayout(): boolean;
        set integerLayout(val: boolean);
        get redraw_when_scrolled(): boolean;
        set redraw_when_scrolled(val: boolean);
        get redrawWhenScrolled(): boolean;
        set redrawWhenScrolled(val: boolean);
        get resolution_x(): number;
        set resolution_x(val: number);
        get resolutionX(): number;
        set resolutionX(val: number);
        get resolution_y(): number;
        set resolution_y(val: number);
        get resolutionY(): number;
        set resolutionY(val: number);
        get scale(): number;
        set scale(val: number);
        get scale_x(): number;
        set scale_x(val: number);
        get scaleX(): number;
        set scaleX(val: number);
        get scale_y(): number;
        set scale_y(val: number);
        get scaleY(): number;
        set scaleY(val: number);
        get units(): Gtk.Unit;
        set units(val: Gtk.Unit);
        get x1(): number;
        set x1(val: number);
        get x2(): number;
        set x2(val: number);
        get y1(): number;
        set y1(val: number);
        get y2(): number;
        set y2(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Canvas.SignalSignatures;

        // Fields

        container: Gtk.Container;
        root_item_model: CanvasItemModel;
        root_item: CanvasItem;
        bounds: CanvasBounds;
        idle_id: number;
        need_update: number;
        need_entire_subtree_update: number;
        before_initial_draw: number;
        hscroll_policy: number;
        vscroll_policy: number;
        pointer_item: CanvasItem;
        pointer_grab_item: CanvasItem;
        pointer_grab_initial_item: CanvasItem;
        pointer_grab_button: number;
        focused_item: CanvasItem;
        keyboard_grab_item: CanvasItem;
        canvas_window: Gdk.Window;
        canvas_x_offset: number;
        canvas_y_offset: number;
        hadjustment: Gtk.Adjustment;
        vadjustment: Gtk.Adjustment;
        freeze_count: number;
        tmp_window: Gdk.Window;
        device_to_pixels_x: number;
        device_to_pixels_y: number;
        widget_items: any[];

        // Constructors

        constructor(properties?: Partial<Canvas.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Canvas;

        // Signals

        connect<K extends keyof Canvas.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Canvas.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Canvas.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Canvas.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Canvas.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Canvas.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates the path specified by the given #GooCanvasPathCommand array.
         * @param commands an array of  #GooCanvasPathCommand.
         * @param cr a cairo context.
         */
        static create_path(commands: CanvasPathCommand[], cr: cairo.Context): void;
        static marshal_BOOLEAN__BOXED(
            closure: GObject.Closure,
            return_value: GObject.Value | any,
            n_param_values: number,
            param_values: GObject.Value | any,
            invocation_hint?: any | null,
            marshal_data?: any | null,
        ): void;
        static marshal_BOOLEAN__DOUBLE_DOUBLE_BOOLEAN_OBJECT(
            closure: GObject.Closure,
            return_value: GObject.Value | any,
            n_param_values: number,
            param_values: GObject.Value | any,
            invocation_hint?: any | null,
            marshal_data?: any | null,
        ): void;
        static marshal_BOOLEAN__OBJECT_BOXED(
            closure: GObject.Closure,
            return_value: GObject.Value | any,
            n_param_values: number,
            param_values: GObject.Value | any,
            invocation_hint?: any | null,
            marshal_data?: any | null,
        ): void;
        static marshal_VOID__INT_INT(
            closure: GObject.Closure,
            return_value: GObject.Value | any,
            n_param_values: number,
            param_values: GObject.Value | any,
            invocation_hint?: any | null,
            marshal_data?: any | null,
        ): void;
        static marshal_VOID__OBJECT_OBJECT(
            closure: GObject.Closure,
            return_value: GObject.Value | any,
            n_param_values: number,
            param_values: GObject.Value | any,
            invocation_hint?: any | null,
            marshal_data?: any | null,
        ): void;
        /**
         * Parses the given SVG path specification string.
         * @param path_data the sequence of path commands, specified as a string using the  same syntax as in the <ulink url="http://www.w3.org/Graphics/SVG/">Scalable  Vector Graphics (SVG)</ulink> path element.
         */
        static parse_path_data(path_data: string): CanvasPathCommand[];

        // Virtual methods

        /**
         * This function is only intended to be used when implementing new canvas
         * items, typically container items such as #GooCanvasGroup.
         *
         * It creates a new canvas item for the given item model, and recursively
         * creates items for any children.
         *
         * It uses the create_item() virtual method if it has been set.
         * Subclasses of #GooCanvas can define this method if they want to use
         * custom views for items.
         *
         * It emits the #GooCanvas::item-created signal after creating the view, so
         * application code can connect signal handlers to the new view if desired.
         * @param model the item model to create a canvas item for.
         */
        vfunc_create_item(model: CanvasItemModel): CanvasItem;
        vfunc_item_created(item: CanvasItem, model: CanvasItemModel): void;

        // Methods

        /**
         * Converts the given bounds in the canvas coordinate space to a bounding box
         * in item space. This is useful in the item paint() methods to convert the
         * bounds to be painted to the item's coordinate space.
         * @param item a #GooCanvasItem.
         * @param bounds the bounds in canvas coordinate space, to be converted.
         */
        convert_bounds_to_item_space(item: CanvasItem, bounds: CanvasBounds): void;
        /**
         * Converts a coordinate from the given item's coordinate space to the canvas
         * coordinate space, applying all transformation matrices including the
         * item's own transformation matrix, if it has one.
         * @param item a #GooCanvasItem.
         * @param x a pointer to the x coordinate to convert.
         * @param y a pointer to the y coordinate to convert.
         */
        convert_from_item_space(item: CanvasItem, x: number, y: number): [number, number];
        /**
         * Converts a coordinate from pixels to the canvas coordinate space.
         *
         * The pixel coordinate space specifies pixels from the top-left of the entire
         * canvas window, according to the current scale setting.
         * See goo_canvas_set_scale().
         *
         * The canvas coordinate space is specified in the call to
         * goo_canvas_set_bounds().
         * @param x a pointer to the x coordinate to convert.
         * @param y a pointer to the y coordinate to convert.
         */
        convert_from_pixels(x: number, y: number): [number, number];
        /**
         * Converts a coordinate from the canvas coordinate space to the given
         * item's coordinate space, applying all transformation matrices including the
         * item's own transformation matrix, if it has one.
         * @param item a #GooCanvasItem.
         * @param x a pointer to the x coordinate to convert.
         * @param y a pointer to the y coordinate to convert.
         */
        convert_to_item_space(item: CanvasItem, x: number, y: number): [number, number];
        /**
         * Converts a coordinate from the canvas coordinate space to pixels.
         *
         * The canvas coordinate space is specified in the call to
         * goo_canvas_set_bounds().
         *
         * The pixel coordinate space specifies pixels from the top-left of the entire
         * canvas window, according to the current scale setting.
         * See goo_canvas_set_scale().
         * @param x a pointer to the x coordinate to convert.
         * @param y a pointer to the y coordinate to convert.
         */
        convert_to_pixels(x: number, y: number): [number, number];
        /**
         * Converts a coordinate from pixels to the canvas's units,
         * ignoring scaling and ignoring the coordinate space specified
         * in the call to goo_canvas_set_bounds().
         * @param x a pointer to the x coordinate to convert.
         * @param y a pointer to the y coordinate to convert.
         */
        convert_units_from_pixels(x: number, y: number): [number, number];
        /**
         * Converts a coordinate from the canvas's units to pixels,
         * ignoring scaling and ignoring the coordinate space specified
         * in the call to goo_canvas_set_bounds().
         * @param x a pointer to the x coordinate to convert.
         * @param y a pointer to the y coordinate to convert.
         */
        convert_units_to_pixels(x: number, y: number): [number, number];
        /**
         * Creates a cairo context, initialized with the default canvas settings.
         * Note that this context should not be used for drawing. It should only be
         * used for calculating bounds of items.
         * @returns a new cairo context. It should be freed with cairo_destroy().
         */
        create_cairo_context(): cairo.Context;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, typically container items such as #GooCanvasGroup.
         *
         * It creates a new canvas item for the given item model, and recursively
         * creates items for any children.
         *
         * It uses the create_item() virtual method if it has been set.
         * Subclasses of #GooCanvas can define this method if they want to use
         * custom views for items.
         *
         * It emits the #GooCanvas::item-created signal after creating the view, so
         * application code can connect signal handlers to the new view if desired.
         * @param model the item model to create a canvas item for.
         * @returns a new canvas item.
         */
        create_item(model: CanvasItemModel): CanvasItem;
        /**
         * Gets the bounds of the canvas, in canvas units.
         *
         * By default, canvas units are pixels, though the #GooCanvas:units property
         * can be used to change the units to points, inches or millimeters.
         */
        get_bounds(): [number, number, number, number];
        /**
         * Gets the default line width, which depends on the current units setting.
         * @returns the default line width of the canvas.
         */
        get_default_line_width(): number;
        /**
         * Gets the canvas item associated with the given #GooCanvasItemModel.
         * This is only useful when goo_canvas_set_root_item_model() has been used to
         * set a model for the canvas.
         *
         * For simple applications you can use goo_canvas_get_item() to set up
         * signal handlers for your items, e.g.
         *
         * <informalexample><programlisting>
         *    item = goo_canvas_get_item (GOO_CANVAS (canvas), my_item);
         *    g_signal_connect (item, "button_press_event",
         *                      (GtkSignalFunc) on_my_item_button_press, NULL);
         * </programlisting></informalexample>
         *
         * More complex applications may want to use the #GooCanvas::item-created
         * signal to hook up their signal handlers.
         * @param model a #GooCanvasItemModel.
         * @returns the canvas item corresponding to the given  #GooCanvasItemModel, or %NULL if no canvas item has been created for it yet.
         */
        get_item(model: CanvasItemModel): CanvasItem;
        /**
         * Gets the item at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point
         * @param is_pointer_event %TRUE if the "pointer-events" property of  items should be used to determine which parts of the item are tested.
         * @returns the item found at the given point, or %NULL if no  item was found.
         */
        get_item_at(x: number, y: number, is_pointer_event: boolean): CanvasItem;
        /**
         * Gets all items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point
         * @param is_pointer_event %TRUE if the "pointer-events" property of  items should be used to determine which parts of the item are tested.
         * @returns a list of  items found at the given point, with the top item at the start of the list,  or %NULL if no items were found. The list must be freed with g_list_free().
         */
        get_items_at(x: number, y: number, is_pointer_event: boolean): CanvasItem[];
        /**
         * Gets a list of items inside or outside a given area.
         * @param area the area to compare with each item's bounds.
         * @param inside_area %TRUE if items inside @area should be returned, or %FALSE if  items outside @area should be returned.
         * @param allow_overlaps %TRUE if items which are partly inside and partly outside  should be returned.
         * @param include_containers %TRUE if containers should be checked as well as  normal items.
         * @returns a list of  items in the given area, or %NULL if no items are found.  The list should be freed with g_list_free().
         */
        get_items_in_area(
            area: CanvasBounds,
            inside_area: boolean,
            allow_overlaps: boolean,
            include_containers: boolean,
        ): CanvasItem[];
        /**
         * Gets the root item of the canvas, usually a #GooCanvasGroup.
         * @returns the root item, or %NULL if there is no root item.
         */
        get_root_item(): CanvasItem;
        /**
         * Gets the root item model of the canvas.
         * @returns the root item model, or %NULL if there is no root item model.
         */
        get_root_item_model(): CanvasItemModel;
        /**
         * Gets the current scale of the canvas.
         *
         * The scale specifies the magnification factor of the canvas, e.g. if an item
         * has a width of 2 pixels and the scale is set to 3, it will be displayed with
         * a width of 2 x 3 = 6 pixels.
         * @returns the current scale setting.
         */
        get_scale(): number;
        /**
         * Gets the static root item of the canvas.
         *
         * Static items are exactly the same as ordinary canvas items, except that
         * they do not move or change size when the canvas is scrolled or the scale
         * changes.
         *
         * Static items are added to the static root item in exactly the same way that
         * ordinary items are added to the root item.
         * @returns the static root item, or %NULL.
         */
        get_static_root_item(): CanvasItem;
        /**
         * Gets the static root item model of the canvas.
         *
         * Static item models are exactly the same as ordinary item models, except that
         * the corresponding items do not move or change size when the canvas is
         * scrolled or the scale changes.
         *
         * Static items models are added to the static root item model in exactly the
         * same way that ordinary item models are added to the root item model.
         * @returns the static root item model, or %NULL.
         */
        get_static_root_item_model(): CanvasItemModel;
        /**
         * Grabs the keyboard focus for the given item.
         * @param item the item to grab the focus.
         */
        grab_focus(item: CanvasItem): void;
        // Conflicted with Gtk.Widget.grab_focus
        grab_focus(...args: never[]): any;
        /**
         * Attempts to grab the keyboard for the given item.
         * @param item the item to grab the keyboard for.
         * @param owner_events %TRUE if keyboard events for this application will be  reported normally, or %FALSE if all keyboard events will be reported with  respect to the grab item.
         * @param time the time of the event that lead to the keyboard grab. This should  come from the relevant #GdkEvent.
         * @returns %GDK_GRAB_SUCCESS if the grab succeeded.
         */
        keyboard_grab(item: CanvasItem, owner_events: boolean, time: number): Gdk.GrabStatus;
        /**
         * Ungrabs the keyboard, if the given item has the keyboard grab.
         * @param item the item that has the keyboard grab.
         * @param time the time of the event that lead to the keyboard ungrab. This should  come from the relevant #GdkEvent.
         */
        keyboard_ungrab(item: CanvasItem, time: number): void;
        /**
         * Attempts to grab the pointer for the given item.
         * @param item the item to grab the pointer for.
         * @param event_mask the events to receive during the grab.
         * @param cursor the cursor to display during the grab, or NULL.
         * @param time the time of the event that lead to the pointer grab. This should  come from the relevant #GdkEvent.
         * @returns %GDK_GRAB_SUCCESS if the grab succeeded.
         */
        pointer_grab(
            item: CanvasItem,
            event_mask: Gdk.EventMask | null,
            cursor: Gdk.Cursor | null,
            time: number,
        ): Gdk.GrabStatus;
        /**
         * Ungrabs the pointer, if the given item has the pointer grab.
         * @param item the item that has the grab.
         * @param time the time of the event that lead to the pointer ungrab. This should  come from the relevant #GdkEvent.
         */
        pointer_ungrab(item: CanvasItem, time: number): void;
        /**
         * This function should only be used by #GooCanvasWidget and subclass
         * implementations.
         *
         * It registers a widget item with the canvas, so that the canvas can do the
         * necessary actions to move and resize the widget as needed.
         * @param witem a #GooCanvasWidget item.
         */
        register_widget_item(witem: CanvasWidget): void;
        /**
         * Renders all or part of a canvas to the given cairo context.
         *
         * This example code could be used in a #GtkPrintOperation
         * #GtkPrintOperation::draw-page callback to print each page in a multi-page
         * document (assuming the pages appear one after the other vertically in the
         * canvas). Note the call to cairo_translate() to translate the output to
         * the correct position on the printed page.
         *
         * <informalexample><programlisting>
         *    GooCanvasBounds bounds;
         *    bounds.x1 = 0;
         *    bounds.x2 = A4_PAGE_WIDTH;
         *    bounds.y1 = A4_PAGE_HEIGHT * page_num;
         *    bounds.y2 = A4_PAGE_HEIGHT * (page_num + 1);
         *
         *    cr = gtk_print_context_get_cairo_context (print_context);
         *    cairo_translate (cr, 0, -A4_PAGE_HEIGHT * page_num);
         *    goo_canvas_render (GOO_CANVAS (canvas), cr, &bounds, 0.0);
         * </programlisting></informalexample>
         * @param cr a cairo context.
         * @param bounds the area to render, or %NULL to render the entire canvas.
         * @param scale the scale to compare with each item's visibility threshold to see if they should be rendered. This only affects items that have their visibility set to %GOO_CANVAS_ITEM_VISIBLE_ABOVE_THRESHOLD.
         */
        render(cr: cairo.Context, bounds: CanvasBounds | null, scale: number): void;
        /**
         * This function is only intended to be used by subclasses of #GooCanvas or
         * #GooCanvasItem implementations.
         *
         * Requests that the given bounds be redrawn. If `is_static` is %TRUE the bounds
         * are assumed to be in the static item coordinate space, otherwise they are
         * assumed to be in the canvas coordinate space.
         *
         * If `is_static` is %FALSE this function behaves the same as
         * goo_canvas_request_redraw().
         * @param bounds the bounds of the item to redraw.
         * @param is_static if the item is static.
         */
        request_item_redraw(bounds: CanvasBounds, is_static: boolean): void;
        /**
         * This function is only intended to be used by subclasses of #GooCanvas or
         * #GooCanvasItem implementations.
         *
         * Requests that the given bounds be redrawn. The bounds must be in the canvas
         * coordinate space.
         * @param bounds the bounds to redraw, in device space.
         */
        request_redraw(bounds: CanvasBounds): void;
        /**
         * This function is only intended to be used by subclasses of #GooCanvas or
         * #GooCanvasItem implementations.
         *
         * It schedules an update of the #GooCanvas. This will be performed in
         * the idle loop, after all pending events have been handled, but before
         * the canvas has been repainted.
         */
        request_update(): void;
        /**
         * Scrolls the canvas, placing the given point as close to the top-left of
         * the view as possible.
         * @param left the x coordinate to scroll to.
         * @param top the y coordinate to scroll to.
         */
        scroll_to(left: number, top: number): void;
        /**
         * Sets the bounds of the #GooCanvas, in canvas units.
         *
         * By default, canvas units are pixels, though the #GooCanvas:units property
         * can be used to change the units to points, inches or millimeters.
         * @param left the left edge.
         * @param top the top edge.
         * @param right the right edge.
         * @param bottom the bottom edge.
         */
        set_bounds(left: number, top: number, right: number, bottom: number): void;
        /**
         * Sets the root item of the canvas. Any existing canvas items are removed.
         * @param item the root canvas item.
         */
        set_root_item(item: CanvasItem): void;
        /**
         * Sets the root item model of the canvas.
         *
         * A hierarchy of canvas items will be created, corresponding to the hierarchy
         * of items in the model. Any current canvas items will be removed.
         * @param model a #GooCanvasItemModel.
         */
        set_root_item_model(model: CanvasItemModel): void;
        /**
         * Sets the scale of the canvas.
         *
         * The scale specifies the magnification factor of the canvas, e.g. if an item
         * has a width of 2 pixels and the scale is set to 3, it will be displayed with
         * a width of 2 x 3 = 6 pixels.
         * @param scale the new scale setting.
         */
        set_scale(scale: number): void;
        /**
         * Sets the static root item. Any existing static items are removed.
         *
         * Static items are exactly the same as ordinary canvas items, except that
         * they do not move or change size when the canvas is scrolled or the scale
         * changes.
         *
         * Static items are added to the static root item in exactly the same way that
         * ordinary items are added to the root item.
         * @param item the static root item.
         */
        set_static_root_item(item: CanvasItem): void;
        /**
         * Sets the static root item model. Any existing static item models are
         * removed.
         *
         * Static item models are exactly the same as ordinary item models, except that
         * the corresponding items do not move or change size when the canvas is
         * scrolled or the scale changes.
         *
         * Static items models are added to the static root item model in exactly the
         *  same way that ordinary item models are added to the root item model.
         * @param model the static root item model.
         */
        set_static_root_item_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It should be called in the finalize method of #GooCanvasItem
         * objects, to remove the canvas item from the #GooCanvas's hash table.
         * @param model the item model whose canvas item is being finalized.
         */
        unregister_item(model: CanvasItemModel): void;
        /**
         * This function should only be used by #GooCanvasWidget and subclass
         * implementations.
         *
         * It unregisters a widget item from the canvas, when the item is no longer in
         * the canvas.
         * @param witem a #GooCanvasWidget item.
         */
        unregister_widget_item(witem: CanvasWidget): void;
        /**
         * This function is only intended to be used by subclasses of #GooCanvas or
         * #GooCanvasItem implementations.
         *
         * It updates any items that need updating.
         *
         * If the bounds of items change, they will request a redraw of the old and
         * new bounds so the display is updated correctly.
         */
        update(): void;

        // Inherited properties
        /**
         * Determines whether horizontal scrolling should start once the scrollable
         * widget is allocated less than its minimum width or less than its natural width.
         */
        get hscrollPolicy(): Gtk.ScrollablePolicy;
        set hscrollPolicy(val: Gtk.ScrollablePolicy);
        /**
         * Determines whether vertical scrolling should start once the scrollable
         * widget is allocated less than its minimum height or less than its natural height.
         */
        get vscrollPolicy(): Gtk.ScrollablePolicy;
        set vscrollPolicy(val: Gtk.ScrollablePolicy);

        // Inherited methods
        /**
         * Returns the size of a non-scrolling border around the
         * outside of the scrollable. An example for this would
         * be treeview headers. GTK+ can use this information to
         * display overlayed graphics, like the overshoot indication,
         * at the right position.
         * @returns %TRUE if @border has been set
         */
        get_border(): [boolean, Gtk.Border];
        /**
         * Retrieves the #GtkAdjustment used for horizontal scrolling.
         * @returns horizontal #GtkAdjustment.
         */
        get_hadjustment(): Gtk.Adjustment;
        /**
         * Gets the horizontal #GtkScrollablePolicy.
         * @returns The horizontal #GtkScrollablePolicy.
         */
        get_hscroll_policy(): Gtk.ScrollablePolicy;
        /**
         * Retrieves the #GtkAdjustment used for vertical scrolling.
         * @returns vertical #GtkAdjustment.
         */
        get_vadjustment(): Gtk.Adjustment;
        /**
         * Gets the vertical #GtkScrollablePolicy.
         * @returns The vertical #GtkScrollablePolicy.
         */
        get_vscroll_policy(): Gtk.ScrollablePolicy;
        /**
         * Sets the horizontal adjustment of the #GtkScrollable.
         * @param hadjustment a #GtkAdjustment
         */
        set_hadjustment(hadjustment?: Gtk.Adjustment | null): void;
        /**
         * Sets the #GtkScrollablePolicy to determine whether
         * horizontal scrolling should start below the minimum width or
         * below the natural width.
         * @param policy the horizontal #GtkScrollablePolicy
         */
        set_hscroll_policy(policy: Gtk.ScrollablePolicy | null): void;
        /**
         * Sets the vertical adjustment of the #GtkScrollable.
         * @param vadjustment a #GtkAdjustment
         */
        set_vadjustment(vadjustment?: Gtk.Adjustment | null): void;
        /**
         * Sets the #GtkScrollablePolicy to determine whether
         * vertical scrolling should start below the minimum height or
         * below the natural height.
         * @param policy the vertical #GtkScrollablePolicy
         */
        set_vscroll_policy(policy: Gtk.ScrollablePolicy | null): void;
        /**
         * Returns the size of a non-scrolling border around the
         * outside of the scrollable. An example for this would
         * be treeview headers. GTK+ can use this information to
         * display overlayed graphics, like the overshoot indication,
         * at the right position.
         */
        vfunc_get_border(): [boolean, Gtk.Border];
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasAccessibleFactory {
        // Signal signatures
        interface SignalSignatures extends Atk.ObjectFactory.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends Atk.ObjectFactory.ConstructorProps {}
    }

    class CanvasAccessibleFactory extends Atk.ObjectFactory {
        static $gtype: GObject.GType<CanvasAccessibleFactory>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasAccessibleFactory.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CanvasAccessibleFactory.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasAccessibleFactory.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasAccessibleFactory.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasAccessibleFactory.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasAccessibleFactory.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasAccessibleFactory.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasAccessibleFactory.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace CanvasEllipse {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::center-x': (pspec: GObject.ParamSpec) => void;
            'notify::center-y': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::radius-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-y': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            center_x: number;
            centerX: number;
            center_y: number;
            centerY: number;
            height: number;
            radius_x: number;
            radiusX: number;
            radius_y: number;
            radiusY: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasEllipse represents an ellipse item.
     *
     * It is a subclass of #GooCanvasItemSimple and so inherits all of the style
     * properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItem interface, so you can use the
     * #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate().
     *
     * To create a #GooCanvasEllipse use goo_canvas_ellipse_new().
     *
     * To get or set the properties of an existing #GooCanvasEllipse, use
     * g_object_get() and g_object_set().
     *
     * The ellipse can be specified either with the "center-x", "center-y",
     * "radius-x" and "radius-y" properties, or with the "x", "y", "width" and
     * "height" properties.
     */
    class CanvasEllipse extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasEllipse>;

        // Properties

        get center_x(): number;
        set center_x(val: number);
        get centerX(): number;
        set centerX(val: number);
        get center_y(): number;
        set center_y(val: number);
        get centerY(): number;
        set centerY(val: number);
        get height(): number;
        set height(val: number);
        get radius_x(): number;
        set radius_x(val: number);
        get radiusX(): number;
        set radiusX(val: number);
        get radius_y(): number;
        set radius_y(val: number);
        get radiusY(): number;
        set radiusY(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasEllipse.SignalSignatures;

        // Fields

        parent_object: CanvasItemSimple;
        ellipse_data: CanvasEllipseData;

        // Constructors

        constructor(properties?: Partial<CanvasEllipse.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasEllipse.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasEllipse.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasEllipse.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasEllipse.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasEllipse.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasEllipse.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasEllipseModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::center-x': (pspec: GObject.ParamSpec) => void;
            'notify::center-y': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::radius-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-y': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            center_x: number;
            centerX: number;
            center_y: number;
            centerY: number;
            height: number;
            radius_x: number;
            radiusX: number;
            radius_y: number;
            radiusY: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasEllipseModel represents a model for ellipse items.
     *
     * It is a subclass of #GooCanvasItemModelSimple and so inherits all of the
     * style properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItemModel interface, so you can use the
     * #GooCanvasItemModel functions such as goo_canvas_item_model_raise() and
     * goo_canvas_item_model_rotate().
     *
     * To create a #GooCanvasEllipseModel use goo_canvas_ellipse_model_new().
     *
     * To get or set the properties of an existing #GooCanvasEllipseModel, use
     * g_object_get() and g_object_set().
     *
     * The ellipse can be specified either with the "center-x", "center-y",
     * "radius-x" and "radius-y" properties, or with the "x", "y", "width" and
     * "height" properties.
     *
     * To respond to events such as mouse clicks on the ellipse you must connect
     * to the signal handlers of the corresponding #GooCanvasEllipse objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     */
    class CanvasEllipseModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasEllipseModel>;

        // Properties

        get center_x(): number;
        set center_x(val: number);
        get centerX(): number;
        set centerX(val: number);
        get center_y(): number;
        set center_y(val: number);
        get centerY(): number;
        set centerY(val: number);
        get height(): number;
        set height(val: number);
        get radius_x(): number;
        set radius_x(val: number);
        get radiusX(): number;
        set radiusX(val: number);
        get radius_y(): number;
        set radius_y(val: number);
        get radiusY(): number;
        set radiusY(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasEllipseModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;
        ellipse_data: CanvasEllipseData;

        // Constructors

        constructor(properties?: Partial<CanvasEllipseModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasEllipseModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasEllipseModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasEllipseModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasEllipseModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasEllipseModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasEllipseModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasGrid {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::border-color': (pspec: GObject.ParamSpec) => void;
            'notify::border-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::border-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::border-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::border-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::border-width': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-color': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::show-horz-grid-lines': (pspec: GObject.ParamSpec) => void;
            'notify::show-vert-grid-lines': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-color': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-lines-on-top': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-offset': (pspec: GObject.ParamSpec) => void;
            'notify::x-step': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-offset': (pspec: GObject.ParamSpec) => void;
            'notify::y-step': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            border_color: string;
            borderColor: string;
            border_color_gdk_rgba: Gdk.RGBA;
            borderColorGdkRgba: Gdk.RGBA;
            border_color_rgba: number;
            borderColorRgba: number;
            border_pattern: CairoPattern;
            borderPattern: CairoPattern;
            border_pixbuf: GdkPixbuf.Pixbuf;
            borderPixbuf: GdkPixbuf.Pixbuf;
            border_width: number;
            borderWidth: number;
            height: number;
            horz_grid_line_color: string;
            horzGridLineColor: string;
            horz_grid_line_color_gdk_rgba: Gdk.RGBA;
            horzGridLineColorGdkRgba: Gdk.RGBA;
            horz_grid_line_color_rgba: number;
            horzGridLineColorRgba: number;
            horz_grid_line_pattern: CairoPattern;
            horzGridLinePattern: CairoPattern;
            horz_grid_line_pixbuf: GdkPixbuf.Pixbuf;
            horzGridLinePixbuf: GdkPixbuf.Pixbuf;
            horz_grid_line_width: number;
            horzGridLineWidth: number;
            show_horz_grid_lines: boolean;
            showHorzGridLines: boolean;
            show_vert_grid_lines: boolean;
            showVertGridLines: boolean;
            vert_grid_line_color: string;
            vertGridLineColor: string;
            vert_grid_line_color_gdk_rgba: Gdk.RGBA;
            vertGridLineColorGdkRgba: Gdk.RGBA;
            vert_grid_line_color_rgba: number;
            vertGridLineColorRgba: number;
            vert_grid_line_pattern: CairoPattern;
            vertGridLinePattern: CairoPattern;
            vert_grid_line_pixbuf: GdkPixbuf.Pixbuf;
            vertGridLinePixbuf: GdkPixbuf.Pixbuf;
            vert_grid_line_width: number;
            vertGridLineWidth: number;
            vert_grid_lines_on_top: boolean;
            vertGridLinesOnTop: boolean;
            width: number;
            x: number;
            x_offset: number;
            xOffset: number;
            x_step: number;
            xStep: number;
            y: number;
            y_offset: number;
            yOffset: number;
            y_step: number;
            yStep: number;
        }
    }

    /**
     * GooCanvasGrid represents a grid item.
     * A grid consists of a number of equally-spaced horizontal and vertical
     * grid lines, plus an optional border.
     *
     * It is a subclass of #GooCanvasItemSimple and so inherits all of the style
     * properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItem interface, so you can use the
     * #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate().
     *
     * To create a #GooCanvasGrid use goo_canvas_grid_new().
     *
     * To get or set the properties of an existing #GooCanvasGrid, use
     * g_object_get() and g_object_set().
     *
     * The grid's position and size is specified with the #GooCanvasGrid:x,
     * #GooCanvasGrid:y, #GooCanvasGrid:width and #GooCanvasGrid:height properties.
     *
     * The #GooCanvasGrid:x-step and #GooCanvasGrid:y-step properties specify the
     * distance between grid lines. The  #GooCanvasGrid:x-offset and
     * #GooCanvasGrid:y-offset properties specify the distance before the first
     * grid lines.
     *
     * The horizontal or vertical grid lines can be hidden using the
     * #GooCanvasGrid:show-horz-grid-lines and #GooCanvasGrid:show-vert-grid-lines
     * properties.
     *
     * The width of the border can be set using the #GooCanvasGrid:border-width
     * property. The border is drawn outside the area specified with the
     * #GooCanvasGrid:x, #GooCanvasGrid:y, #GooCanvasGrid:width and
     * #GooCanvasGrid:height properties.
     *
     * Other properties allow the colors and widths of the grid lines to be set.
     * The grid line color and width properties override the standard
     * #GooCanvasItemSimple:stroke-color and #GooCanvasItemSimple:line-width
     * properties, enabling different styles for horizontal and vertical grid lines.
     */
    class CanvasGrid extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasGrid>;

        // Properties

        set border_color(val: string);
        set borderColor(val: string);
        /**
         * The color to use for the border, specified as a GdkRGBA.
         */
        get border_color_gdk_rgba(): Gdk.RGBA;
        set border_color_gdk_rgba(val: Gdk.RGBA);
        /**
         * The color to use for the border, specified as a GdkRGBA.
         */
        get borderColorGdkRgba(): Gdk.RGBA;
        set borderColorGdkRgba(val: Gdk.RGBA);
        get border_color_rgba(): number;
        set border_color_rgba(val: number);
        get borderColorRgba(): number;
        set borderColorRgba(val: number);
        get border_pattern(): CairoPattern;
        set border_pattern(val: CairoPattern);
        get borderPattern(): CairoPattern;
        set borderPattern(val: CairoPattern);
        set border_pixbuf(val: GdkPixbuf.Pixbuf);
        set borderPixbuf(val: GdkPixbuf.Pixbuf);
        get border_width(): number;
        set border_width(val: number);
        get borderWidth(): number;
        set borderWidth(val: number);
        get height(): number;
        set height(val: number);
        set horz_grid_line_color(val: string);
        set horzGridLineColor(val: string);
        /**
         * The color to use for the horizontal grid lines, specified as a GdkRGBA.
         */
        get horz_grid_line_color_gdk_rgba(): Gdk.RGBA;
        set horz_grid_line_color_gdk_rgba(val: Gdk.RGBA);
        /**
         * The color to use for the horizontal grid lines, specified as a GdkRGBA.
         */
        get horzGridLineColorGdkRgba(): Gdk.RGBA;
        set horzGridLineColorGdkRgba(val: Gdk.RGBA);
        get horz_grid_line_color_rgba(): number;
        set horz_grid_line_color_rgba(val: number);
        get horzGridLineColorRgba(): number;
        set horzGridLineColorRgba(val: number);
        get horz_grid_line_pattern(): CairoPattern;
        set horz_grid_line_pattern(val: CairoPattern);
        get horzGridLinePattern(): CairoPattern;
        set horzGridLinePattern(val: CairoPattern);
        set horz_grid_line_pixbuf(val: GdkPixbuf.Pixbuf);
        set horzGridLinePixbuf(val: GdkPixbuf.Pixbuf);
        get horz_grid_line_width(): number;
        set horz_grid_line_width(val: number);
        get horzGridLineWidth(): number;
        set horzGridLineWidth(val: number);
        get show_horz_grid_lines(): boolean;
        set show_horz_grid_lines(val: boolean);
        get showHorzGridLines(): boolean;
        set showHorzGridLines(val: boolean);
        get show_vert_grid_lines(): boolean;
        set show_vert_grid_lines(val: boolean);
        get showVertGridLines(): boolean;
        set showVertGridLines(val: boolean);
        set vert_grid_line_color(val: string);
        set vertGridLineColor(val: string);
        /**
         * The color to use for the vertical grid lines, specified as a GdkRGBA.
         */
        get vert_grid_line_color_gdk_rgba(): Gdk.RGBA;
        set vert_grid_line_color_gdk_rgba(val: Gdk.RGBA);
        /**
         * The color to use for the vertical grid lines, specified as a GdkRGBA.
         */
        get vertGridLineColorGdkRgba(): Gdk.RGBA;
        set vertGridLineColorGdkRgba(val: Gdk.RGBA);
        get vert_grid_line_color_rgba(): number;
        set vert_grid_line_color_rgba(val: number);
        get vertGridLineColorRgba(): number;
        set vertGridLineColorRgba(val: number);
        get vert_grid_line_pattern(): CairoPattern;
        set vert_grid_line_pattern(val: CairoPattern);
        get vertGridLinePattern(): CairoPattern;
        set vertGridLinePattern(val: CairoPattern);
        set vert_grid_line_pixbuf(val: GdkPixbuf.Pixbuf);
        set vertGridLinePixbuf(val: GdkPixbuf.Pixbuf);
        get vert_grid_line_width(): number;
        set vert_grid_line_width(val: number);
        get vertGridLineWidth(): number;
        set vertGridLineWidth(val: number);
        get vert_grid_lines_on_top(): boolean;
        set vert_grid_lines_on_top(val: boolean);
        get vertGridLinesOnTop(): boolean;
        set vertGridLinesOnTop(val: boolean);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get x_offset(): number;
        set x_offset(val: number);
        get xOffset(): number;
        set xOffset(val: number);
        get x_step(): number;
        set x_step(val: number);
        get xStep(): number;
        set xStep(val: number);
        get y(): number;
        set y(val: number);
        get y_offset(): number;
        set y_offset(val: number);
        get yOffset(): number;
        set yOffset(val: number);
        get y_step(): number;
        set y_step(val: number);
        get yStep(): number;
        set yStep(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasGrid.SignalSignatures;

        // Fields

        parent_object: CanvasItemSimple;

        // Constructors

        constructor(properties?: Partial<CanvasGrid.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasGrid.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGrid.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasGrid.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGrid.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasGrid.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasGrid.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasGridModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::border-color': (pspec: GObject.ParamSpec) => void;
            'notify::border-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::border-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::border-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::border-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::border-width': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-color': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::show-horz-grid-lines': (pspec: GObject.ParamSpec) => void;
            'notify::show-vert-grid-lines': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-color': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-lines-on-top': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-offset': (pspec: GObject.ParamSpec) => void;
            'notify::x-step': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-offset': (pspec: GObject.ParamSpec) => void;
            'notify::y-step': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            border_color: string;
            borderColor: string;
            border_color_gdk_rgba: Gdk.RGBA;
            borderColorGdkRgba: Gdk.RGBA;
            border_color_rgba: number;
            borderColorRgba: number;
            border_pattern: CairoPattern;
            borderPattern: CairoPattern;
            border_pixbuf: GdkPixbuf.Pixbuf;
            borderPixbuf: GdkPixbuf.Pixbuf;
            border_width: number;
            borderWidth: number;
            height: number;
            horz_grid_line_color: string;
            horzGridLineColor: string;
            horz_grid_line_color_gdk_rgba: Gdk.RGBA;
            horzGridLineColorGdkRgba: Gdk.RGBA;
            horz_grid_line_color_rgba: number;
            horzGridLineColorRgba: number;
            horz_grid_line_pattern: CairoPattern;
            horzGridLinePattern: CairoPattern;
            horz_grid_line_pixbuf: GdkPixbuf.Pixbuf;
            horzGridLinePixbuf: GdkPixbuf.Pixbuf;
            horz_grid_line_width: number;
            horzGridLineWidth: number;
            show_horz_grid_lines: boolean;
            showHorzGridLines: boolean;
            show_vert_grid_lines: boolean;
            showVertGridLines: boolean;
            vert_grid_line_color: string;
            vertGridLineColor: string;
            vert_grid_line_color_gdk_rgba: Gdk.RGBA;
            vertGridLineColorGdkRgba: Gdk.RGBA;
            vert_grid_line_color_rgba: number;
            vertGridLineColorRgba: number;
            vert_grid_line_pattern: CairoPattern;
            vertGridLinePattern: CairoPattern;
            vert_grid_line_pixbuf: GdkPixbuf.Pixbuf;
            vertGridLinePixbuf: GdkPixbuf.Pixbuf;
            vert_grid_line_width: number;
            vertGridLineWidth: number;
            vert_grid_lines_on_top: boolean;
            vertGridLinesOnTop: boolean;
            width: number;
            x: number;
            x_offset: number;
            xOffset: number;
            x_step: number;
            xStep: number;
            y: number;
            y_offset: number;
            yOffset: number;
            y_step: number;
            yStep: number;
        }
    }

    /**
     * GooCanvasGridModel represents a model for grid items.
     * A grid consists of a number of equally-spaced horizontal and vertical
     * grid lines, plus an optional border.
     *
     * It is a subclass of #GooCanvasItemModelSimple and so inherits all of the
     * style properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItemModel interface, so you can use the
     * #GooCanvasItemModel functions such as goo_canvas_item_model_raise() and
     * goo_canvas_item_model_rotate().
     *
     * To create a #GooCanvasGridModel use goo_canvas_grid_model_new().
     *
     * To get or set the properties of an existing #GooCanvasGridModel, use
     * g_object_get() and g_object_set().
     *
     * To respond to events such as mouse clicks on the grid you must connect
     * to the signal handlers of the corresponding #GooCanvasGrid objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     *
     * The grid's position and size is specified with the #GooCanvasGridModel:x,
     * #GooCanvasGridModel:y, #GooCanvasGridModel:width and
     * #GooCanvasGridModel:height properties.
     *
     * The #GooCanvasGridModel:x-step and #GooCanvasGridModel:y-step properties
     * specify the distance between grid lines. The  #GooCanvasGridModel:x-offset
     * and #GooCanvasGridModel:y-offset properties specify the distance before the
     * first grid lines.
     *
     * The horizontal or vertical grid lines can be hidden using the
     * #GooCanvasGridModel:show-horz-grid-lines and
     * #GooCanvasGridModel:show-vert-grid-lines properties.
     *
     * The width of the border can be set using the #GooCanvasGridModel:border-width
     * property. The border is drawn outside the area specified with the
     * #GooCanvasGridModel:x, #GooCanvasGridModel:y, #GooCanvasGridModel:width and
     * #GooCanvasGridModel:height properties.
     *
     * Other properties allow the colors and widths of the grid lines to be set.
     * The grid line color and width properties override the standard
     * #GooCanvasItemModelSimple:stroke-color and
     * #GooCanvasItemModelSimple:line-width properties, enabling different styles
     * for horizontal and vertical grid lines.
     */
    class CanvasGridModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasGridModel>;

        // Properties

        set border_color(val: string);
        set borderColor(val: string);
        get border_color_gdk_rgba(): Gdk.RGBA;
        set border_color_gdk_rgba(val: Gdk.RGBA);
        get borderColorGdkRgba(): Gdk.RGBA;
        set borderColorGdkRgba(val: Gdk.RGBA);
        get border_color_rgba(): number;
        set border_color_rgba(val: number);
        get borderColorRgba(): number;
        set borderColorRgba(val: number);
        get border_pattern(): CairoPattern;
        set border_pattern(val: CairoPattern);
        get borderPattern(): CairoPattern;
        set borderPattern(val: CairoPattern);
        set border_pixbuf(val: GdkPixbuf.Pixbuf);
        set borderPixbuf(val: GdkPixbuf.Pixbuf);
        get border_width(): number;
        set border_width(val: number);
        get borderWidth(): number;
        set borderWidth(val: number);
        get height(): number;
        set height(val: number);
        set horz_grid_line_color(val: string);
        set horzGridLineColor(val: string);
        get horz_grid_line_color_gdk_rgba(): Gdk.RGBA;
        set horz_grid_line_color_gdk_rgba(val: Gdk.RGBA);
        get horzGridLineColorGdkRgba(): Gdk.RGBA;
        set horzGridLineColorGdkRgba(val: Gdk.RGBA);
        get horz_grid_line_color_rgba(): number;
        set horz_grid_line_color_rgba(val: number);
        get horzGridLineColorRgba(): number;
        set horzGridLineColorRgba(val: number);
        get horz_grid_line_pattern(): CairoPattern;
        set horz_grid_line_pattern(val: CairoPattern);
        get horzGridLinePattern(): CairoPattern;
        set horzGridLinePattern(val: CairoPattern);
        set horz_grid_line_pixbuf(val: GdkPixbuf.Pixbuf);
        set horzGridLinePixbuf(val: GdkPixbuf.Pixbuf);
        get horz_grid_line_width(): number;
        set horz_grid_line_width(val: number);
        get horzGridLineWidth(): number;
        set horzGridLineWidth(val: number);
        get show_horz_grid_lines(): boolean;
        set show_horz_grid_lines(val: boolean);
        get showHorzGridLines(): boolean;
        set showHorzGridLines(val: boolean);
        get show_vert_grid_lines(): boolean;
        set show_vert_grid_lines(val: boolean);
        get showVertGridLines(): boolean;
        set showVertGridLines(val: boolean);
        set vert_grid_line_color(val: string);
        set vertGridLineColor(val: string);
        get vert_grid_line_color_gdk_rgba(): Gdk.RGBA;
        set vert_grid_line_color_gdk_rgba(val: Gdk.RGBA);
        get vertGridLineColorGdkRgba(): Gdk.RGBA;
        set vertGridLineColorGdkRgba(val: Gdk.RGBA);
        get vert_grid_line_color_rgba(): number;
        set vert_grid_line_color_rgba(val: number);
        get vertGridLineColorRgba(): number;
        set vertGridLineColorRgba(val: number);
        get vert_grid_line_pattern(): CairoPattern;
        set vert_grid_line_pattern(val: CairoPattern);
        get vertGridLinePattern(): CairoPattern;
        set vertGridLinePattern(val: CairoPattern);
        set vert_grid_line_pixbuf(val: GdkPixbuf.Pixbuf);
        set vertGridLinePixbuf(val: GdkPixbuf.Pixbuf);
        get vert_grid_line_width(): number;
        set vert_grid_line_width(val: number);
        get vertGridLineWidth(): number;
        set vertGridLineWidth(val: number);
        get vert_grid_lines_on_top(): boolean;
        set vert_grid_lines_on_top(val: boolean);
        get vertGridLinesOnTop(): boolean;
        set vertGridLinesOnTop(val: boolean);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get x_offset(): number;
        set x_offset(val: number);
        get xOffset(): number;
        set xOffset(val: number);
        get x_step(): number;
        set x_step(val: number);
        get xStep(): number;
        set xStep(val: number);
        get y(): number;
        set y(val: number);
        get y_offset(): number;
        set y_offset(val: number);
        get yOffset(): number;
        set yOffset(val: number);
        get y_step(): number;
        set y_step(val: number);
        get yStep(): number;
        set yStep(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasGridModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;

        // Constructors

        constructor(properties?: Partial<CanvasGridModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasGridModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGridModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasGridModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGridModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasGridModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasGridModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasGroup {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            height: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * #GooCanvasGroup represents a group of items. Groups can be nested to
     * any depth, to create a hierarchy of items. Items are ordered within each
     * group, with later items being displayed above earlier items.
     *
     * #GooCanvasGroup is a subclass of #GooCanvasItemSimple and so
     * inherits all of the style properties such as "stroke-color", "fill-color"
     * and "line-width". Setting a style property on a #GooCanvasGroup will affect
     * all children of the #GooCanvasGroup (unless the children override the
     * property setting).
     *
     * #GooCanvasGroup implements the #GooCanvasItem interface, so you can use
     * the #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate(), and the properties such as "visibility" and
     * "pointer-events".
     *
     * If the #GooCanvasGroup:width and #GooCanvasGroup:height properties are
     * set to positive values then the group is clipped to the given size.
     *
     * To create a #GooCanvasGroup use goo_canvas_group_new().
     *
     * To get or set the properties of an existing #GooCanvasGroup, use
     * g_object_get() and g_object_set().
     */
    class CanvasGroup extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasGroup>;

        // Properties

        get height(): number;
        set height(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasGroup.SignalSignatures;

        // Fields

        parent_object: CanvasItemSimple;
        items: any[];

        // Constructors

        constructor(properties?: Partial<CanvasGroup.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasGroup.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGroup.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasGroup.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGroup.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasGroup.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasGroup.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasGroupModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            height: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * #GooCanvasGroupModel represents a group of items. Groups can be nested to
     * any depth, to create a hierarchy of items. Items are ordered within each
     * group, with later items being displayed above earlier items.
     *
     * #GooCanvasGroupModel is a subclass of #GooCanvasItemModelSimple and so
     * inherits all of the style properties such as "stroke-color", "fill-color"
     * and "line-width". Setting a style property on a #GooCanvasGroupModel will
     * affect all children of the #GooCanvasGroupModel (unless the children
     * override the property setting).
     *
     * #GooCanvasGroupModel implements the #GooCanvasItemModel interface, so you
     * can use the #GooCanvasItemModel functions such as
     * goo_canvas_item_model_raise() and goo_canvas_item_model_rotate(), and the
     * properties such as "visibility" and "pointer-events".
     *
     * To create a #GooCanvasGroupModel use goo_canvas_group_model_new().
     *
     * To get or set the properties of an existing #GooCanvasGroupModel, use
     * g_object_get() and g_object_set().
     *
     * To respond to events such as mouse clicks on the group you must connect
     * to the signal handlers of the corresponding #GooCanvasGroup objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     */
    class CanvasGroupModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasGroupModel>;

        // Properties

        get height(): number;
        set height(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasGroupModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;
        children: any[];

        // Constructors

        constructor(properties?: Partial<CanvasGroupModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasGroupModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGroupModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasGroupModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasGroupModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasGroupModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasGroupModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasImage {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::pattern': (pspec: GObject.ParamSpec) => void;
            'notify::pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::scale-to-fit': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            alpha: number;
            height: number;
            pattern: CairoPattern;
            pixbuf: GdkPixbuf.Pixbuf;
            scale_to_fit: boolean;
            scaleToFit: boolean;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasImage represents an image item.
     *
     * <note><para>
     * It is usually necessary to set the "scale-to-fit" property to %TRUE to
     * scale the image to fit the given rectangle.
     * </para></note>
     *
     * It is a subclass of #GooCanvasItemSimple and so inherits all of the style
     * properties such as "operator" and "pointer-events".
     *
     * It also implements the #GooCanvasItem interface, so you can use the
     * #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate().
     *
     * To create a #GooCanvasImage use goo_canvas_image_new().
     *
     * To get or set the properties of an existing #GooCanvasImage, use
     * g_object_get() and g_object_set().
     */
    class CanvasImage extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasImage>;

        // Properties

        get alpha(): number;
        set alpha(val: number);
        get height(): number;
        set height(val: number);
        get pattern(): CairoPattern;
        set pattern(val: CairoPattern);
        set pixbuf(val: GdkPixbuf.Pixbuf);
        get scale_to_fit(): boolean;
        set scale_to_fit(val: boolean);
        get scaleToFit(): boolean;
        set scaleToFit(val: boolean);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasImage.SignalSignatures;

        // Fields

        parent_object: CanvasItemSimple;

        // Constructors

        constructor(properties?: Partial<CanvasImage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasImage.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasImage.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasImage.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasImage.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasImage.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasImage.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasImageModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::pattern': (pspec: GObject.ParamSpec) => void;
            'notify::pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::scale-to-fit': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            alpha: number;
            height: number;
            pattern: CairoPattern;
            pixbuf: GdkPixbuf.Pixbuf;
            scale_to_fit: boolean;
            scaleToFit: boolean;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasImageModel represent a model for image items.
     *
     * <note><para>
     * It is usually necessary to set the "scale-to-fit" property to %TRUE to
     * scale the image to fit the given rectangle. When using units other than
     * %GTK_UNIT_PIXEL it is also necessary to set the "width" and "height"
     * properties to set the desired size.
     * </para></note>
     *
     * It is a subclass of #GooCanvasItemModelSimple and so inherits all of the
     * style properties such as "operator" and "pointer-events".
     *
     * It also implements the #GooCanvasItemModel interface, so you can use the
     * #GooCanvasItemModel functions such as goo_canvas_item_model_raise() and
     * goo_canvas_item_model_rotate().
     *
     * To create a #GooCanvasImageModel use goo_canvas_image_model_new().
     *
     * To get or set the properties of an existing #GooCanvasImageModel, use
     * g_object_get() and g_object_set().
     *
     * To respond to events such as mouse clicks on the image you must connect
     * to the signal handlers of the corresponding #GooCanvasImage objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     */
    class CanvasImageModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasImageModel>;

        // Properties

        get alpha(): number;
        set alpha(val: number);
        get height(): number;
        set height(val: number);
        get pattern(): CairoPattern;
        set pattern(val: CairoPattern);
        set pixbuf(val: GdkPixbuf.Pixbuf);
        get scale_to_fit(): boolean;
        set scale_to_fit(val: boolean);
        get scaleToFit(): boolean;
        set scaleToFit(val: boolean);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasImageModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;

        // Constructors

        constructor(properties?: Partial<CanvasImageModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasImageModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasImageModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasImageModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasImageModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasImageModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasImageModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasItemAccessibleFactory {
        // Signal signatures
        interface SignalSignatures extends Atk.ObjectFactory.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends Atk.ObjectFactory.ConstructorProps {}
    }

    class CanvasItemAccessibleFactory extends Atk.ObjectFactory {
        static $gtype: GObject.GType<CanvasItemAccessibleFactory>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasItemAccessibleFactory.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CanvasItemAccessibleFactory.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasItemAccessibleFactory.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasItemAccessibleFactory.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasItemAccessibleFactory.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasItemAccessibleFactory.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasItemAccessibleFactory.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasItemAccessibleFactory.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace CanvasItemModelSimple {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, CanvasItemModel.ConstructorProps {
            antialias: CairoAntialias;
            clip_fill_rule: CairoFillRule;
            clipFillRule: CairoFillRule;
            clip_path: string;
            clipPath: string;
            fill_color: string;
            fillColor: string;
            fill_color_gdk_rgba: Gdk.RGBA;
            fillColorGdkRgba: Gdk.RGBA;
            fill_color_rgba: number;
            fillColorRgba: number;
            fill_pattern: CairoPattern;
            fillPattern: CairoPattern;
            fill_pixbuf: GdkPixbuf.Pixbuf;
            fillPixbuf: GdkPixbuf.Pixbuf;
            fill_rule: CairoFillRule;
            fillRule: CairoFillRule;
            font: string;
            font_desc: Pango.FontDescription;
            fontDesc: Pango.FontDescription;
            hint_metrics: CairoHintMetrics;
            hintMetrics: CairoHintMetrics;
            line_cap: CairoLineCap;
            lineCap: CairoLineCap;
            line_dash: CanvasLineDash;
            lineDash: CanvasLineDash;
            line_join: CairoLineJoin;
            lineJoin: CairoLineJoin;
            line_join_miter_limit: number;
            lineJoinMiterLimit: number;
            line_width: number;
            lineWidth: number;
            operator: CairoOperator;
            stroke_color: string;
            strokeColor: string;
            stroke_color_gdk_rgba: Gdk.RGBA;
            strokeColorGdkRgba: Gdk.RGBA;
            stroke_color_rgba: number;
            strokeColorRgba: number;
            stroke_pattern: CairoPattern;
            strokePattern: CairoPattern;
            stroke_pixbuf: GdkPixbuf.Pixbuf;
            strokePixbuf: GdkPixbuf.Pixbuf;
        }
    }

    /**
     * #GooCanvasItemModelSimple is used as a base class for the standard canvas
     * item models. It can also be used as the base class for new custom canvas
     * item models.
     *
     * <note><para>
     * 	The Model/View canvas feature may be removed in a future version of
     * 	GooCanvas.
     * </para></note>
     *
     * It provides default implementations for many of the #GooCanvasItemModel
     * methods.
     *
     * Subclasses of #GooCanvasItemModelSimple only need to implement the
     * create_item() method of the #GooCanvasItemModel interface, to create
     * the default canvas item to view the item model.
     */
    class CanvasItemModelSimple extends GObject.Object implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasItemModelSimple>;

        // Properties

        get antialias(): CairoAntialias;
        set antialias(val: CairoAntialias);
        get clip_fill_rule(): CairoFillRule;
        set clip_fill_rule(val: CairoFillRule);
        get clipFillRule(): CairoFillRule;
        set clipFillRule(val: CairoFillRule);
        /**
         * The sequence of commands describing the clip path of the item, specified
         * as a string using the same syntax
         * as in the <ulink url="http://www.w3.org/Graphics/SVG/">Scalable Vector
         * Graphics (SVG)</ulink> path element.
         */
        set clip_path(val: string);
        /**
         * The sequence of commands describing the clip path of the item, specified
         * as a string using the same syntax
         * as in the <ulink url="http://www.w3.org/Graphics/SVG/">Scalable Vector
         * Graphics (SVG)</ulink> path element.
         */
        set clipPath(val: string);
        set fill_color(val: string);
        set fillColor(val: string);
        get fill_color_gdk_rgba(): Gdk.RGBA;
        set fill_color_gdk_rgba(val: Gdk.RGBA);
        get fillColorGdkRgba(): Gdk.RGBA;
        set fillColorGdkRgba(val: Gdk.RGBA);
        get fill_color_rgba(): number;
        set fill_color_rgba(val: number);
        get fillColorRgba(): number;
        set fillColorRgba(val: number);
        get fill_pattern(): CairoPattern;
        set fill_pattern(val: CairoPattern);
        get fillPattern(): CairoPattern;
        set fillPattern(val: CairoPattern);
        set fill_pixbuf(val: GdkPixbuf.Pixbuf);
        set fillPixbuf(val: GdkPixbuf.Pixbuf);
        get fill_rule(): CairoFillRule;
        set fill_rule(val: CairoFillRule);
        get fillRule(): CairoFillRule;
        set fillRule(val: CairoFillRule);
        get font(): string;
        set font(val: string);
        get font_desc(): Pango.FontDescription;
        set font_desc(val: Pango.FontDescription);
        get fontDesc(): Pango.FontDescription;
        set fontDesc(val: Pango.FontDescription);
        get hint_metrics(): CairoHintMetrics;
        set hint_metrics(val: CairoHintMetrics);
        get hintMetrics(): CairoHintMetrics;
        set hintMetrics(val: CairoHintMetrics);
        get line_cap(): CairoLineCap;
        set line_cap(val: CairoLineCap);
        get lineCap(): CairoLineCap;
        set lineCap(val: CairoLineCap);
        get line_dash(): CanvasLineDash;
        set line_dash(val: CanvasLineDash);
        get lineDash(): CanvasLineDash;
        set lineDash(val: CanvasLineDash);
        get line_join(): CairoLineJoin;
        set line_join(val: CairoLineJoin);
        get lineJoin(): CairoLineJoin;
        set lineJoin(val: CairoLineJoin);
        get line_join_miter_limit(): number;
        set line_join_miter_limit(val: number);
        get lineJoinMiterLimit(): number;
        set lineJoinMiterLimit(val: number);
        get line_width(): number;
        set line_width(val: number);
        get lineWidth(): number;
        set lineWidth(val: number);
        get operator(): CairoOperator;
        set operator(val: CairoOperator);
        set stroke_color(val: string);
        set strokeColor(val: string);
        get stroke_color_gdk_rgba(): Gdk.RGBA;
        set stroke_color_gdk_rgba(val: Gdk.RGBA);
        get strokeColorGdkRgba(): Gdk.RGBA;
        set strokeColorGdkRgba(val: Gdk.RGBA);
        get stroke_color_rgba(): number;
        set stroke_color_rgba(val: number);
        get strokeColorRgba(): number;
        set strokeColorRgba(val: number);
        get stroke_pattern(): CairoPattern;
        set stroke_pattern(val: CairoPattern);
        get strokePattern(): CairoPattern;
        set strokePattern(val: CairoPattern);
        set stroke_pixbuf(val: GdkPixbuf.Pixbuf);
        set strokePixbuf(val: GdkPixbuf.Pixbuf);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasItemModelSimple.SignalSignatures;

        // Fields

        parent_object: GObject.Object;

        // Constructors

        constructor(properties?: Partial<CanvasItemModelSimple.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasItemModelSimple.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasItemModelSimple.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasItemModelSimple.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasItemModelSimple.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasItemModelSimple.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasItemModelSimple.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasItemSimple {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, CanvasItem.ConstructorProps {
            antialias: CairoAntialias;
            clip_fill_rule: CairoFillRule;
            clipFillRule: CairoFillRule;
            clip_path: string;
            clipPath: string;
            fill_color: string;
            fillColor: string;
            fill_color_gdk_rgba: Gdk.RGBA;
            fillColorGdkRgba: Gdk.RGBA;
            fill_color_rgba: number;
            fillColorRgba: number;
            fill_pattern: CairoPattern;
            fillPattern: CairoPattern;
            fill_pixbuf: GdkPixbuf.Pixbuf;
            fillPixbuf: GdkPixbuf.Pixbuf;
            fill_rule: CairoFillRule;
            fillRule: CairoFillRule;
            font: string;
            font_desc: Pango.FontDescription;
            fontDesc: Pango.FontDescription;
            hint_metrics: CairoHintMetrics;
            hintMetrics: CairoHintMetrics;
            line_cap: CairoLineCap;
            lineCap: CairoLineCap;
            line_dash: CanvasLineDash;
            lineDash: CanvasLineDash;
            line_join: CairoLineJoin;
            lineJoin: CairoLineJoin;
            line_join_miter_limit: number;
            lineJoinMiterLimit: number;
            line_width: number;
            lineWidth: number;
            operator: CairoOperator;
            stroke_color: string;
            strokeColor: string;
            stroke_color_gdk_rgba: Gdk.RGBA;
            strokeColorGdkRgba: Gdk.RGBA;
            stroke_color_rgba: number;
            strokeColorRgba: number;
            stroke_pattern: CairoPattern;
            strokePattern: CairoPattern;
            stroke_pixbuf: GdkPixbuf.Pixbuf;
            strokePixbuf: GdkPixbuf.Pixbuf;
        }
    }

    /**
     * #GooCanvasItemSimple is used as a base class for all of the standard canvas
     * items. It can also be used as the base class for new custom canvas items.
     *
     * It provides default implementations for many of the #GooCanvasItem
     * methods.
     *
     * For very simple items, all that is needed is to implement the create_path()
     * method. (#GooCanvasEllipse, #GooCanvasRect and #GooCanvasPath do this.)
     *
     * More complicated items need to implement the update(), paint() and
     * is_item_at() methods instead. (#GooCanvasImage, #GooCanvasPolyline,
     * #GooCanvasText and #GooCanvasWidget do this.) They may also need to
     * override some of the other GooCanvasItem methods such as set_canvas(),
     * set_parent() or allocate_area() if special code is needed. (#GooCanvasWidget
     * does this to make sure the #GtkWidget is embedded in the #GooCanvas widget
     * correctly.)
     */
    class CanvasItemSimple extends GObject.Object implements CanvasItem {
        static $gtype: GObject.GType<CanvasItemSimple>;

        // Properties

        get antialias(): CairoAntialias;
        set antialias(val: CairoAntialias);
        get clip_fill_rule(): CairoFillRule;
        set clip_fill_rule(val: CairoFillRule);
        get clipFillRule(): CairoFillRule;
        set clipFillRule(val: CairoFillRule);
        /**
         * The sequence of commands describing the clip path of the item, specified
         * as a string using the same syntax
         * as in the <ulink url="http://www.w3.org/Graphics/SVG/">Scalable Vector
         * Graphics (SVG)</ulink> path element.
         */
        set clip_path(val: string);
        /**
         * The sequence of commands describing the clip path of the item, specified
         * as a string using the same syntax
         * as in the <ulink url="http://www.w3.org/Graphics/SVG/">Scalable Vector
         * Graphics (SVG)</ulink> path element.
         */
        set clipPath(val: string);
        set fill_color(val: string);
        set fillColor(val: string);
        /**
         * The color to use to paint the interior of the item, specified as a GdkRGBA. To disable painting set the 'fill-pattern' property to NULL.
         */
        get fill_color_gdk_rgba(): Gdk.RGBA;
        set fill_color_gdk_rgba(val: Gdk.RGBA);
        /**
         * The color to use to paint the interior of the item, specified as a GdkRGBA. To disable painting set the 'fill-pattern' property to NULL.
         */
        get fillColorGdkRgba(): Gdk.RGBA;
        set fillColorGdkRgba(val: Gdk.RGBA);
        get fill_color_rgba(): number;
        set fill_color_rgba(val: number);
        get fillColorRgba(): number;
        set fillColorRgba(val: number);
        get fill_pattern(): CairoPattern;
        set fill_pattern(val: CairoPattern);
        get fillPattern(): CairoPattern;
        set fillPattern(val: CairoPattern);
        set fill_pixbuf(val: GdkPixbuf.Pixbuf);
        set fillPixbuf(val: GdkPixbuf.Pixbuf);
        get fill_rule(): CairoFillRule;
        set fill_rule(val: CairoFillRule);
        get fillRule(): CairoFillRule;
        set fillRule(val: CairoFillRule);
        get font(): string;
        set font(val: string);
        get font_desc(): Pango.FontDescription;
        set font_desc(val: Pango.FontDescription);
        get fontDesc(): Pango.FontDescription;
        set fontDesc(val: Pango.FontDescription);
        get hint_metrics(): CairoHintMetrics;
        set hint_metrics(val: CairoHintMetrics);
        get hintMetrics(): CairoHintMetrics;
        set hintMetrics(val: CairoHintMetrics);
        get line_cap(): CairoLineCap;
        set line_cap(val: CairoLineCap);
        get lineCap(): CairoLineCap;
        set lineCap(val: CairoLineCap);
        get line_dash(): CanvasLineDash;
        set line_dash(val: CanvasLineDash);
        get lineDash(): CanvasLineDash;
        set lineDash(val: CanvasLineDash);
        get line_join(): CairoLineJoin;
        set line_join(val: CairoLineJoin);
        get lineJoin(): CairoLineJoin;
        set lineJoin(val: CairoLineJoin);
        get line_join_miter_limit(): number;
        set line_join_miter_limit(val: number);
        get lineJoinMiterLimit(): number;
        set lineJoinMiterLimit(val: number);
        get line_width(): number;
        set line_width(val: number);
        get lineWidth(): number;
        set lineWidth(val: number);
        get operator(): CairoOperator;
        set operator(val: CairoOperator);
        set stroke_color(val: string);
        set strokeColor(val: string);
        /**
         * The color to use for the item's perimeter, specified as a GdkRGBA. To disable painting set the 'stroke-pattern' property to NULL.
         */
        get stroke_color_gdk_rgba(): Gdk.RGBA;
        set stroke_color_gdk_rgba(val: Gdk.RGBA);
        /**
         * The color to use for the item's perimeter, specified as a GdkRGBA. To disable painting set the 'stroke-pattern' property to NULL.
         */
        get strokeColorGdkRgba(): Gdk.RGBA;
        set strokeColorGdkRgba(val: Gdk.RGBA);
        get stroke_color_rgba(): number;
        set stroke_color_rgba(val: number);
        get strokeColorRgba(): number;
        set strokeColorRgba(val: number);
        get stroke_pattern(): CairoPattern;
        set stroke_pattern(val: CairoPattern);
        get strokePattern(): CairoPattern;
        set strokePattern(val: CairoPattern);
        set stroke_pixbuf(val: GdkPixbuf.Pixbuf);
        set strokePixbuf(val: GdkPixbuf.Pixbuf);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasItemSimple.SignalSignatures;

        // Fields

        canvas: Canvas;
        model: CanvasItemModelSimple;
        bounds: CanvasBounds;
        need_update: number;
        need_entire_subtree_update: number;

        // Constructors

        constructor(properties?: Partial<CanvasItemSimple.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasItemSimple.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasItemSimple.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasItemSimple.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasItemSimple.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasItemSimple.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasItemSimple.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_simple_create_path(cr: cairo.Context): void;
        vfunc_simple_is_item_at(x: number, y: number, cr: cairo.Context, is_pointer_event: boolean): boolean;
        vfunc_simple_paint(cr: cairo.Context, bounds: CanvasBounds): void;
        vfunc_simple_update(cr: cairo.Context): void;

        // Methods

        /**
         * This function is intended to be used by subclasses of #GooCanvasItemSimple.
         *
         * It is used as a callback for the "changed" signal of the item models.
         * It requests an update or redraw of the item as appropriate.
         * @param recompute_bounds if the item's bounds need to be recomputed.
         */
        changed(recompute_bounds: boolean): void;
        /**
         * This function is intended to be used by subclasses of #GooCanvasItemSimple.
         *
         * It checks if the given point is in the current path, using the item's
         * style settings.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo context.
         * @param pointer_events specifies which parts of the path to check.
         * @returns %TRUE if the given point is in the current path.
         */
        check_in_path(x: number, y: number, cr: cairo.Context, pointer_events: CanvasPointerEvents | null): boolean;
        /**
         * This function is intended to be used by subclasses of #GooCanvasItemSimple,
         * typically in their update() or get_requested_area() methods.
         *
         * It ensures that the item's style is setup correctly. If the item has its
         * own #GooCanvasStyle it makes sure the parent is set correctly. If it
         * doesn't have its own style it uses the parent item's style.
         */
        check_style(): void;
        /**
         * Gets the item's line width.
         * @returns the item's line width.
         */
        get_line_width(): number;
        /**
         * This function is intended to be used by subclasses of #GooCanvasItemSimple,
         * typically in their update() or get_requested_area() methods.
         *
         * It calculates the bounds of the current path, using the item's style
         * settings, and stores the results in the given #GooCanvasBounds struct.
         *
         * The returned bounds contains the bounding box of the path in device space,
         * converted to user space coordinates. To calculate the bounds completely in
         * user space, use cairo_identity_matrix() to temporarily reset the current
         * transformation matrix to the identity matrix.
         * @param cr a cairo context.
         * @param bounds the #GooCanvasBounds struct to store the resulting bounding box.
         */
        get_path_bounds(cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * This function is intended to be used by subclasses of #GooCanvasItemSimple.
         *
         * It paints the current path, using the item's style settings.
         * @param cr a cairo context.
         */
        paint_path(cr: cairo.Context): void;
        /**
         * This function should be called by subclasses of #GooCanvasItemSimple
         * in their set_model() method.
         * @param model the model that @item will view.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is intended to be used by subclasses of #GooCanvasItemSimple,
         * typically in their update() or get_requested_area() methods.
         *
         * It converts the item's bounds to a bounding box in the canvas (device)
         * coordinate space.
         * @param cr a cairo context.
         * @param bounds the bounds of the item, in the item's coordinate space.
         */
        user_bounds_to_device(cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * This function is intended to be used by subclasses of #GooCanvasItemSimple,
         * typically in their get_requested_area() method.
         *
         * It converts the item's bounds to a bounding box in its parent's coordinate
         * space. If the item has no transformation matrix set then no conversion is
         * needed.
         * @param cr a cairo context.
         * @param bounds the bounds of the item, in the item's coordinate space.
         */
        user_bounds_to_parent(cr: cairo.Context, bounds: CanvasBounds): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasPath {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::data': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            data: string;
            height: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasPath represents a path item, which is a series of one or more
     * lines, bezier curves, or elliptical arcs.
     *
     * It is a subclass of #GooCanvasItemSimple and so inherits all of the style
     * properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItem interface, so you can use the
     * #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate().
     *
     * #GooCanvasPath uses the same path specification strings as the Scalable
     * Vector Graphics (SVG) path element. For details see the
     * <ulink url="http://www.w3.org/Graphics/SVG/">SVG specification</ulink>.
     *
     * To create a #GooCanvasPath use goo_canvas_path_new().
     *
     * To get or set the properties of an existing #GooCanvasPath, use
     * g_object_get() and g_object_set().
     */
    class CanvasPath extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasPath>;

        // Properties

        /**
         * The sequence of path commands, specified as a string using the same syntax
         * as in the <ulink url="http://www.w3.org/Graphics/SVG/">Scalable Vector
         * Graphics (SVG)</ulink> path element.
         */
        set data(val: string);
        get height(): number;
        set height(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasPath.SignalSignatures;

        // Fields

        path_data: CanvasPathData;

        // Constructors

        constructor(properties?: Partial<CanvasPath.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasPath.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPath.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasPath.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPath.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasPath.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasPath.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasPathModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::data': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            data: string;
            height: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasPathModel represents a model for path items, which are a series of
     * one or more lines, bezier curves, or elliptical arcs.
     *
     * It is a subclass of #GooCanvasItemModelSimple and so inherits all of the
     * style properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItemModel interface, so you can use the
     * #GooCanvasItemModel functions such as goo_canvas_item_model_raise() and
     * goo_canvas_item_model_rotate().
     *
     * #GooCanvasPathModel uses the same path specification strings as the Scalable
     * Vector Graphics (SVG) path element. For details see the
     * <ulink url="http://www.w3.org/Graphics/SVG/">SVG specification</ulink>.
     *
     * To create a #GooCanvasPathModel use goo_canvas_path_model_new().
     *
     * To get or set the properties of an existing #GooCanvasPathModel, use
     * g_object_get() and g_object_set().
     *
     * To respond to events such as mouse clicks on the path you must connect
     * to the signal handlers of the corresponding #GooCanvasPath objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     */
    class CanvasPathModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasPathModel>;

        // Properties

        set data(val: string);
        get height(): number;
        set height(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasPathModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;
        path_data: CanvasPathData;

        // Constructors

        constructor(properties?: Partial<CanvasPathModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasPathModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPathModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasPathModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPathModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasPathModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasPathModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasPolyline {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::arrow-length': (pspec: GObject.ParamSpec) => void;
            'notify::arrow-tip-length': (pspec: GObject.ParamSpec) => void;
            'notify::arrow-width': (pspec: GObject.ParamSpec) => void;
            'notify::close-path': (pspec: GObject.ParamSpec) => void;
            'notify::end-arrow': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::points': (pspec: GObject.ParamSpec) => void;
            'notify::start-arrow': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            arrow_length: number;
            arrowLength: number;
            arrow_tip_length: number;
            arrowTipLength: number;
            arrow_width: number;
            arrowWidth: number;
            close_path: boolean;
            closePath: boolean;
            end_arrow: boolean;
            endArrow: boolean;
            height: number;
            points: CanvasPoints;
            start_arrow: boolean;
            startArrow: boolean;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasPolyline represents a polyline item, which is a series of one or
     * more lines, with optional arrows at either end.
     *
     * It is a subclass of #GooCanvasItemSimple and so inherits all of the style
     * properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItem interface, so you can use the
     * #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate().
     *
     * To create a #GooCanvasPolyline use goo_canvas_polyline_new(), or
     * goo_canvas_polyline_new_line() for a simple line between two points.
     *
     * To get or set the properties of an existing #GooCanvasPolyline, use
     * g_object_get() and g_object_set().
     */
    class CanvasPolyline extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasPolyline>;

        // Properties

        get arrow_length(): number;
        set arrow_length(val: number);
        get arrowLength(): number;
        set arrowLength(val: number);
        get arrow_tip_length(): number;
        set arrow_tip_length(val: number);
        get arrowTipLength(): number;
        set arrowTipLength(val: number);
        get arrow_width(): number;
        set arrow_width(val: number);
        get arrowWidth(): number;
        set arrowWidth(val: number);
        get close_path(): boolean;
        set close_path(val: boolean);
        get closePath(): boolean;
        set closePath(val: boolean);
        get end_arrow(): boolean;
        set end_arrow(val: boolean);
        get endArrow(): boolean;
        set endArrow(val: boolean);
        get height(): number;
        set height(val: number);
        get points(): CanvasPoints;
        set points(val: CanvasPoints);
        get start_arrow(): boolean;
        set start_arrow(val: boolean);
        get startArrow(): boolean;
        set startArrow(val: boolean);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasPolyline.SignalSignatures;

        // Fields

        polyline_data: CanvasPolylineData;

        // Constructors

        constructor(properties?: Partial<CanvasPolyline.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasPolyline.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPolyline.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasPolyline.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPolyline.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasPolyline.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasPolyline.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasPolylineModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::arrow-length': (pspec: GObject.ParamSpec) => void;
            'notify::arrow-tip-length': (pspec: GObject.ParamSpec) => void;
            'notify::arrow-width': (pspec: GObject.ParamSpec) => void;
            'notify::close-path': (pspec: GObject.ParamSpec) => void;
            'notify::end-arrow': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::points': (pspec: GObject.ParamSpec) => void;
            'notify::start-arrow': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            arrow_length: number;
            arrowLength: number;
            arrow_tip_length: number;
            arrowTipLength: number;
            arrow_width: number;
            arrowWidth: number;
            close_path: boolean;
            closePath: boolean;
            end_arrow: boolean;
            endArrow: boolean;
            height: number;
            points: CanvasPoints;
            start_arrow: boolean;
            startArrow: boolean;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasPolylineModel represents a model for polyline items, which are a
     * series of one or more lines, with optional arrows at either end.
     *
     * It is a subclass of #GooCanvasItemModelSimple and so inherits all of the
     * style properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItemModel interface, so you can use the
     * #GooCanvasItemModel functions such as goo_canvas_item_model_raise() and
     * goo_canvas_item_model_rotate().
     *
     * To create a #GooCanvasPolylineModel use goo_canvas_polyline_model_new(), or
     * goo_canvas_polyline_model_new_line() for a simple line between two points.
     *
     * To get or set the properties of an existing #GooCanvasPolylineModel, use
     * g_object_get() and g_object_set().
     *
     * To respond to events such as mouse clicks on the polyline you must connect
     * to the signal handlers of the corresponding #GooCanvasPolyline objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     */
    class CanvasPolylineModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasPolylineModel>;

        // Properties

        get arrow_length(): number;
        set arrow_length(val: number);
        get arrowLength(): number;
        set arrowLength(val: number);
        get arrow_tip_length(): number;
        set arrow_tip_length(val: number);
        get arrowTipLength(): number;
        set arrowTipLength(val: number);
        get arrow_width(): number;
        set arrow_width(val: number);
        get arrowWidth(): number;
        set arrowWidth(val: number);
        get close_path(): boolean;
        set close_path(val: boolean);
        get closePath(): boolean;
        set closePath(val: boolean);
        get end_arrow(): boolean;
        set end_arrow(val: boolean);
        get endArrow(): boolean;
        set endArrow(val: boolean);
        get height(): number;
        set height(val: number);
        get points(): CanvasPoints;
        set points(val: CanvasPoints);
        get start_arrow(): boolean;
        set start_arrow(val: boolean);
        get startArrow(): boolean;
        set startArrow(val: boolean);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasPolylineModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;
        polyline_data: CanvasPolylineData;

        // Constructors

        constructor(properties?: Partial<CanvasPolylineModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasPolylineModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPolylineModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasPolylineModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasPolylineModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasPolylineModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasPolylineModel.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasRect {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-left-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-left-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-right-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-right-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-left-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-left-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-right-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-right-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-y': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            height: number;
            radius_bottom_left_x: number;
            radiusBottomLeftX: number;
            radius_bottom_left_y: number;
            radiusBottomLeftY: number;
            radius_bottom_right_x: number;
            radiusBottomRightX: number;
            radius_bottom_right_y: number;
            radiusBottomRightY: number;
            radius_top_left_x: number;
            radiusTopLeftX: number;
            radius_top_left_y: number;
            radiusTopLeftY: number;
            radius_top_right_x: number;
            radiusTopRightX: number;
            radius_top_right_y: number;
            radiusTopRightY: number;
            radius_x: number;
            radiusX: number;
            radius_y: number;
            radiusY: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasRect represents a rectangle item.
     *
     * It is a subclass of #GooCanvasItemSimple and so inherits all of the style
     * properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItem interface, so you can use the
     * #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate().
     *
     * To create a #GooCanvasRect use goo_canvas_rect_new().
     *
     * To get or set the properties of an existing #GooCanvasRect, use
     * g_object_get() and g_object_set().
     */
    class CanvasRect extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasRect>;

        // Properties

        get height(): number;
        set height(val: number);
        get radius_bottom_left_x(): number;
        set radius_bottom_left_x(val: number);
        get radiusBottomLeftX(): number;
        set radiusBottomLeftX(val: number);
        get radius_bottom_left_y(): number;
        set radius_bottom_left_y(val: number);
        get radiusBottomLeftY(): number;
        set radiusBottomLeftY(val: number);
        get radius_bottom_right_x(): number;
        set radius_bottom_right_x(val: number);
        get radiusBottomRightX(): number;
        set radiusBottomRightX(val: number);
        get radius_bottom_right_y(): number;
        set radius_bottom_right_y(val: number);
        get radiusBottomRightY(): number;
        set radiusBottomRightY(val: number);
        get radius_top_left_x(): number;
        set radius_top_left_x(val: number);
        get radiusTopLeftX(): number;
        set radiusTopLeftX(val: number);
        get radius_top_left_y(): number;
        set radius_top_left_y(val: number);
        get radiusTopLeftY(): number;
        set radiusTopLeftY(val: number);
        get radius_top_right_x(): number;
        set radius_top_right_x(val: number);
        get radiusTopRightX(): number;
        set radiusTopRightX(val: number);
        get radius_top_right_y(): number;
        set radius_top_right_y(val: number);
        get radiusTopRightY(): number;
        set radiusTopRightY(val: number);
        get radius_x(): number;
        set radius_x(val: number);
        get radiusX(): number;
        set radiusX(val: number);
        get radius_y(): number;
        set radius_y(val: number);
        get radiusY(): number;
        set radiusY(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasRect.SignalSignatures;

        // Fields

        rect_data: CanvasRectData;

        // Constructors

        constructor(properties?: Partial<CanvasRect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasRect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasRect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasRect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasRect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasRect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasRect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasRectModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-left-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-left-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-right-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-bottom-right-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-left-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-left-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-right-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-top-right-y': (pspec: GObject.ParamSpec) => void;
            'notify::radius-x': (pspec: GObject.ParamSpec) => void;
            'notify::radius-y': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            height: number;
            radius_bottom_left_x: number;
            radiusBottomLeftX: number;
            radius_bottom_left_y: number;
            radiusBottomLeftY: number;
            radius_bottom_right_x: number;
            radiusBottomRightX: number;
            radius_bottom_right_y: number;
            radiusBottomRightY: number;
            radius_top_left_x: number;
            radiusTopLeftX: number;
            radius_top_left_y: number;
            radiusTopLeftY: number;
            radius_top_right_x: number;
            radiusTopRightX: number;
            radius_top_right_y: number;
            radiusTopRightY: number;
            radius_x: number;
            radiusX: number;
            radius_y: number;
            radiusY: number;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasRectModel represents a model for rectangle items.
     *
     * It is a subclass of #GooCanvasItemModelSimple and so inherits all of the
     * style properties such as "stroke-color", "fill-color" and "line-width".
     *
     * It also implements the #GooCanvasItemModel interface, so you can use the
     * #GooCanvasItemModel functions such as goo_canvas_item_model_raise() and
     * goo_canvas_item_model_rotate().
     *
     * To create a #GooCanvasRectModel use goo_canvas_rect_model_new().
     *
     * To get or set the properties of an existing #GooCanvasRectModel, use
     * g_object_get() and g_object_set().
     *
     * To respond to events such as mouse clicks on the rectangle you must connect
     * to the signal handlers of the corresponding #GooCanvasRect objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     */
    class CanvasRectModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasRectModel>;

        // Properties

        get height(): number;
        set height(val: number);
        get radius_bottom_left_x(): number;
        set radius_bottom_left_x(val: number);
        get radiusBottomLeftX(): number;
        set radiusBottomLeftX(val: number);
        get radius_bottom_left_y(): number;
        set radius_bottom_left_y(val: number);
        get radiusBottomLeftY(): number;
        set radiusBottomLeftY(val: number);
        get radius_bottom_right_x(): number;
        set radius_bottom_right_x(val: number);
        get radiusBottomRightX(): number;
        set radiusBottomRightX(val: number);
        get radius_bottom_right_y(): number;
        set radius_bottom_right_y(val: number);
        get radiusBottomRightY(): number;
        set radiusBottomRightY(val: number);
        get radius_top_left_x(): number;
        set radius_top_left_x(val: number);
        get radiusTopLeftX(): number;
        set radiusTopLeftX(val: number);
        get radius_top_left_y(): number;
        set radius_top_left_y(val: number);
        get radiusTopLeftY(): number;
        set radiusTopLeftY(val: number);
        get radius_top_right_x(): number;
        set radius_top_right_x(val: number);
        get radiusTopRightX(): number;
        set radiusTopRightX(val: number);
        get radius_top_right_y(): number;
        set radius_top_right_y(val: number);
        get radiusTopRightY(): number;
        set radiusTopRightY(val: number);
        get radius_x(): number;
        set radius_x(val: number);
        get radiusX(): number;
        set radiusX(val: number);
        get radius_y(): number;
        set radius_y(val: number);
        get radiusY(): number;
        set radiusY(val: number);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasRectModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;
        rect_data: CanvasRectData;

        // Constructors

        constructor(properties?: Partial<CanvasRectModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasRectModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasRectModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasRectModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasRectModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasRectModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasRectModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasStyle {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * #GooCanvasStyle provides support for cascading style properties for canvas
     * items. It is intended to be used when implementing new canvas items.
     *
     * <note><para>
     * 	The cascading styles canvas feature may be removed in a future version
     *      of GooCanvas.
     * </para></note>
     *
     * Style properties are identified by a unique #GQuark, and contain
     * arbitrary data stored in a #GValue.
     *
     * #GooCanvasStyle also provides a few convenience functions such as
     * goo_canvas_style_set_stroke_options() and
     * goo_canvas_style_set_fill_options() which efficiently apply an item's
     * standard style properties to the given cairo_t.
     */
    class CanvasStyle extends GObject.Object {
        static $gtype: GObject.GType<CanvasStyle>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasStyle.SignalSignatures;

        // Fields

        properties: any[];

        // Constructors

        constructor(properties?: Partial<CanvasStyle.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): CanvasStyle;

        // Signals

        connect<K extends keyof CanvasStyle.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasStyle.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasStyle.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasStyle.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasStyle.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasStyle.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Copies the given #GooCanvasStyle, by copying all of its properties.
         * Though the parent of the new style is left unset.
         * @returns a copy of the given #GooCanvasStyle.
         */
        copy(): CanvasStyle;
        /**
         * Gets the parent of the style.
         * @returns the parent of the given style, or %NULL.
         */
        get_parent(): CanvasStyle;
        /**
         * Gets the value of a property.
         *
         * This searches though all the #GooCanvasStyle's own list of property settings
         * and also all ancestor #GooCanvasStyle objects.
         *
         * Note that it returns a pointer to the internal #GValue setting, which should
         * not be changed.
         * @param property_id the property identifier.
         * @returns the property value, or %NULL if it isn't set.
         */
        get_property(property_id: GLib.Quark): unknown;
        // Conflicted with GObject.Object.get_property
        get_property(...args: never[]): any;
        /**
         * Sets the standard cairo fill options using the given style.
         * @param cr a cairo context.
         * @returns %TRUE if a paint source is set, or %FALSE if the fill should be skipped.
         */
        set_fill_options(cr: cairo.Context): boolean;
        /**
         * Sets the parent of the style.
         * @param parent the new parent.
         */
        set_parent(parent: CanvasStyle): void;
        /**
         * Sets a property in the style, replacing any current setting.
         *
         * Note that this will override the property setting in ancestor
         * #GooCanvasStyle objects.
         * @param property_id the property identifier.
         * @param value the value of the property.
         */
        set_property(property_id: GLib.Quark, value: GObject.Value | any): void;
        // Conflicted with GObject.Object.set_property
        set_property(...args: never[]): any;
        /**
         * Sets the standard cairo stroke options using the given style.
         * @param cr a cairo context.
         * @returns %TRUE if a paint source is set, or %FALSE if the stroke should be skipped.
         */
        set_stroke_options(cr: cairo.Context): boolean;
    }

    namespace CanvasTable {
        // Signal signatures
        interface SignalSignatures extends CanvasGroup.SignalSignatures {
            'notify::column-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::homogeneous-columns': (pspec: GObject.ParamSpec) => void;
            'notify::homogeneous-rows': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::row-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::x-border-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::y-border-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasGroup.ConstructorProps, CanvasItem.ConstructorProps {
            column_spacing: number;
            columnSpacing: number;
            homogeneous_columns: boolean;
            homogeneousColumns: boolean;
            homogeneous_rows: boolean;
            homogeneousRows: boolean;
            horz_grid_line_width: number;
            horzGridLineWidth: number;
            row_spacing: number;
            rowSpacing: number;
            vert_grid_line_width: number;
            vertGridLineWidth: number;
            x_border_spacing: number;
            xBorderSpacing: number;
            y_border_spacing: number;
            yBorderSpacing: number;
        }
    }

    /**
     * #GooCanvasTable is a table container used to lay out other canvas items.
     * It is used in a similar way to how the GtkTable widget is used to lay out
     * GTK+ widgets.
     *
     * Items are added to the table using the normal methods, then
     * goo_canvas_item_set_child_properties() is used to specify how each child
     * item is to be positioned within the table (i.e. which row and column it is
     * in, how much padding it should have and whether it should expand or
     * shrink).
     *
     * #GooCanvasTable is a subclass of #GooCanvasItemSimple and so
     * inherits all of the style properties such as "stroke-color", "fill-color"
     * and "line-width". Setting a style property on a #GooCanvasTable will affect
     * all children of the #GooCanvasTable (unless the children override the
     * property setting).
     *
     * #GooCanvasTable implements the #GooCanvasItem interface, so you can use
     * the #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate(), and the properties such as "visibility" and
     * "pointer-events".
     *
     * To create a #GooCanvasTable use goo_canvas_table_new().
     *
     * To get or set the properties of an existing #GooCanvasTable, use
     * g_object_get() and g_object_set().
     */
    class CanvasTable extends CanvasGroup implements CanvasItem {
        static $gtype: GObject.GType<CanvasTable>;

        // Properties

        get column_spacing(): number;
        set column_spacing(val: number);
        get columnSpacing(): number;
        set columnSpacing(val: number);
        get homogeneous_columns(): boolean;
        set homogeneous_columns(val: boolean);
        get homogeneousColumns(): boolean;
        set homogeneousColumns(val: boolean);
        get homogeneous_rows(): boolean;
        set homogeneous_rows(val: boolean);
        get homogeneousRows(): boolean;
        set homogeneousRows(val: boolean);
        get horz_grid_line_width(): number;
        set horz_grid_line_width(val: number);
        get horzGridLineWidth(): number;
        set horzGridLineWidth(val: number);
        get row_spacing(): number;
        set row_spacing(val: number);
        get rowSpacing(): number;
        set rowSpacing(val: number);
        get vert_grid_line_width(): number;
        set vert_grid_line_width(val: number);
        get vertGridLineWidth(): number;
        set vertGridLineWidth(val: number);
        get x_border_spacing(): number;
        set x_border_spacing(val: number);
        get xBorderSpacing(): number;
        set xBorderSpacing(val: number);
        get y_border_spacing(): number;
        set y_border_spacing(val: number);
        get yBorderSpacing(): number;
        set yBorderSpacing(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasTable.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CanvasTable.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasTable.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasTable.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasTable.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasTable.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasTable.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasTable.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasTableModel {
        // Signal signatures
        interface SignalSignatures extends CanvasGroupModel.SignalSignatures {
            'notify::column-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::homogeneous-columns': (pspec: GObject.ParamSpec) => void;
            'notify::homogeneous-rows': (pspec: GObject.ParamSpec) => void;
            'notify::horz-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::row-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::vert-grid-line-width': (pspec: GObject.ParamSpec) => void;
            'notify::x-border-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::y-border-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasGroupModel.ConstructorProps, CanvasItemModel.ConstructorProps {
            column_spacing: number;
            columnSpacing: number;
            homogeneous_columns: boolean;
            homogeneousColumns: boolean;
            homogeneous_rows: boolean;
            homogeneousRows: boolean;
            horz_grid_line_width: number;
            horzGridLineWidth: number;
            row_spacing: number;
            rowSpacing: number;
            vert_grid_line_width: number;
            vertGridLineWidth: number;
            x_border_spacing: number;
            xBorderSpacing: number;
            y_border_spacing: number;
            yBorderSpacing: number;
        }
    }

    /**
     * #GooCanvasTableModel is a model for a table container used to lay out other
     * canvas items. It is used in a similar way to how the GtkTable widget is used
     * to lay out GTK+ widgets.
     *
     * Item models are added to the table using the normal methods, then
     * goo_canvas_item_model_set_child_properties() is used to specify how each
     * child item is to be positioned within the table (i.e. which row and column
     * it is in, how much padding it should have and whether it should expand or
     * shrink).
     *
     * #GooCanvasTableModel is a subclass of #GooCanvasItemModelSimple and so
     * inherits all of the style properties such as "stroke-color", "fill-color"
     * and "line-width". Setting a style property on a #GooCanvasTableModel will
     * affect all children of the #GooCanvasTableModel (unless the children
     * override the property setting).
     *
     * #GooCanvasTableModel implements the #GooCanvasItemModel interface, so you
     * can use the #GooCanvasItemModel functions such as
     * goo_canvas_item_model_raise() and goo_canvas_item_rotate(), and the
     * properties such as "visibility" and "pointer-events".
     *
     * To create a #GooCanvasTableModel use goo_canvas_table_model_new().
     *
     * To get or set the properties of an existing #GooCanvasTableModel, use
     * g_object_get() and g_object_set().
     */
    class CanvasTableModel extends CanvasGroupModel implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasTableModel>;

        // Properties

        get column_spacing(): number;
        set column_spacing(val: number);
        get columnSpacing(): number;
        set columnSpacing(val: number);
        get homogeneous_columns(): boolean;
        set homogeneous_columns(val: boolean);
        get homogeneousColumns(): boolean;
        set homogeneousColumns(val: boolean);
        get homogeneous_rows(): boolean;
        set homogeneous_rows(val: boolean);
        get homogeneousRows(): boolean;
        set homogeneousRows(val: boolean);
        get horz_grid_line_width(): number;
        set horz_grid_line_width(val: number);
        get horzGridLineWidth(): number;
        set horzGridLineWidth(val: number);
        get row_spacing(): number;
        set row_spacing(val: number);
        get rowSpacing(): number;
        set rowSpacing(val: number);
        get vert_grid_line_width(): number;
        set vert_grid_line_width(val: number);
        get vertGridLineWidth(): number;
        set vertGridLineWidth(val: number);
        get x_border_spacing(): number;
        set x_border_spacing(val: number);
        get xBorderSpacing(): number;
        set xBorderSpacing(val: number);
        get y_border_spacing(): number;
        set y_border_spacing(val: number);
        get yBorderSpacing(): number;
        set yBorderSpacing(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasTableModel.SignalSignatures;

        // Fields

        parent_object: CanvasGroupModel;

        // Constructors

        constructor(properties?: Partial<CanvasTableModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasTableModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasTableModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasTableModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasTableModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasTableModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasTableModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasText {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::alignment': (pspec: GObject.ParamSpec) => void;
            'notify::anchor': (pspec: GObject.ParamSpec) => void;
            'notify::ellipsize': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::text': (pspec: GObject.ParamSpec) => void;
            'notify::use-markup': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::wrap': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            alignment: Pango.Alignment;
            anchor: CanvasAnchorType;
            ellipsize: Pango.EllipsizeMode;
            height: number;
            text: string;
            use_markup: boolean;
            useMarkup: boolean;
            width: number;
            wrap: Pango.WrapMode;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasText represents a text item.
     *
     * It is a subclass of #GooCanvasItemSimple and so inherits all of the style
     * properties such as "fill-color".
     *
     * It also implements the #GooCanvasItem interface, so you can use the
     * #GooCanvasItem functions such as goo_canvas_item_raise() and
     * goo_canvas_item_rotate().
     *
     * The #GooCanvasText:width and #GooCanvasText:height properties specify the
     * area of the item. If it exceeds that area because there is too much text,
     * it is clipped. The properties can be set to -1 to disable clipping.
     *
     * To create a #GooCanvasText use goo_canvas_text_new().
     *
     * To get or set the properties of an existing #GooCanvasText, use
     * g_object_get() and g_object_set().
     */
    class CanvasText extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasText>;

        // Properties

        get alignment(): Pango.Alignment;
        set alignment(val: Pango.Alignment);
        get anchor(): CanvasAnchorType;
        set anchor(val: CanvasAnchorType);
        get ellipsize(): Pango.EllipsizeMode;
        set ellipsize(val: Pango.EllipsizeMode);
        get height(): number;
        set height(val: number);
        get text(): string;
        set text(val: string);
        get use_markup(): boolean;
        set use_markup(val: boolean);
        get useMarkup(): boolean;
        set useMarkup(val: boolean);
        get width(): number;
        set width(val: number);
        get wrap(): Pango.WrapMode;
        set wrap(val: Pango.WrapMode);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasText.SignalSignatures;

        // Fields

        text_data: CanvasTextData;
        layout_width: number;

        // Constructors

        constructor(properties?: Partial<CanvasText.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasText.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasText.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasText.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasText.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasText.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasText.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Gets the natural extents of the text, in the text item's coordinate space.
         *
         * The final extents of the text may be different, if the text item is placed
         * in a layout container such as #GooCanvasTable.
         */
        get_natural_extents(): [Pango.Rectangle | null, Pango.Rectangle | null];

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasTextModel {
        // Signal signatures
        interface SignalSignatures extends CanvasItemModelSimple.SignalSignatures {
            'notify::alignment': (pspec: GObject.ParamSpec) => void;
            'notify::anchor': (pspec: GObject.ParamSpec) => void;
            'notify::ellipsize': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::text': (pspec: GObject.ParamSpec) => void;
            'notify::use-markup': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::wrap': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemModelSimple.ConstructorProps, CanvasItemModel.ConstructorProps {
            alignment: Pango.Alignment;
            anchor: CanvasAnchorType;
            ellipsize: Pango.EllipsizeMode;
            height: number;
            text: string;
            use_markup: boolean;
            useMarkup: boolean;
            width: number;
            wrap: Pango.WrapMode;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasTextModel represents a model for text items.
     *
     * It is a subclass of #GooCanvasItemModelSimple and so inherits all of the
     * style properties such as "fill-color".
     *
     * It also implements the #GooCanvasItemModel interface, so you can use the
     * #GooCanvasItemModel functions such as goo_canvas_item_model_raise() and
     * goo_canvas_item_model_rotate().
     *
     * To create a #GooCanvasTextModel use goo_canvas_text_model_new().
     *
     * To get or set the properties of an existing #GooCanvasTextModel, use
     * g_object_get() and g_object_set().
     *
     * To respond to events such as mouse clicks on the text item you must connect
     * to the signal handlers of the corresponding #GooCanvasText objects.
     * (See goo_canvas_get_item() and #GooCanvas::item-created.)
     */
    class CanvasTextModel extends CanvasItemModelSimple implements CanvasItemModel {
        static $gtype: GObject.GType<CanvasTextModel>;

        // Properties

        get alignment(): Pango.Alignment;
        set alignment(val: Pango.Alignment);
        get anchor(): CanvasAnchorType;
        set anchor(val: CanvasAnchorType);
        get ellipsize(): Pango.EllipsizeMode;
        set ellipsize(val: Pango.EllipsizeMode);
        get height(): number;
        set height(val: number);
        get text(): string;
        set text(val: string);
        get use_markup(): boolean;
        set use_markup(val: boolean);
        get useMarkup(): boolean;
        set useMarkup(val: boolean);
        get width(): number;
        set width(val: number);
        get wrap(): Pango.WrapMode;
        set wrap(val: Pango.WrapMode);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasTextModel.SignalSignatures;

        // Fields

        parent_object: CanvasItemModelSimple;
        text_data: CanvasTextData;

        // Constructors

        constructor(properties?: Partial<CanvasTextModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasTextModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasTextModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasTextModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasTextModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasTextModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasTextModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItemModel, position: number): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_changed(recompute_bounds: boolean): void;
        vfunc_child_added(child_num: number): void;
        vfunc_child_moved(old_child_num: number, new_child_num: number): void;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_child_removed(child_num: number): void;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItemModel;
        vfunc_get_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given model.
         */
        vfunc_get_parent(): CanvasItemModel;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         */
        vfunc_get_transform(transform: cairo.Matrix): boolean;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        vfunc_remove_child(child_num: number): void;
        vfunc_set_child_property(
            child: CanvasItemModel,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        vfunc_set_parent(parent: CanvasItemModel): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasWidget {
        // Signal signatures
        interface SignalSignatures extends CanvasItemSimple.SignalSignatures {
            'notify::anchor': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::widget': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::antialias': (pspec: GObject.ParamSpec) => void;
            'notify::clip-fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::clip-path': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::fill-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::fill-rule': (pspec: GObject.ParamSpec) => void;
            'notify::font': (pspec: GObject.ParamSpec) => void;
            'notify::font-desc': (pspec: GObject.ParamSpec) => void;
            'notify::hint-metrics': (pspec: GObject.ParamSpec) => void;
            'notify::line-cap': (pspec: GObject.ParamSpec) => void;
            'notify::line-dash': (pspec: GObject.ParamSpec) => void;
            'notify::line-join': (pspec: GObject.ParamSpec) => void;
            'notify::line-join-miter-limit': (pspec: GObject.ParamSpec) => void;
            'notify::line-width': (pspec: GObject.ParamSpec) => void;
            'notify::operator': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-gdk-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-color-rgba': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pattern': (pspec: GObject.ParamSpec) => void;
            'notify::stroke-pixbuf': (pspec: GObject.ParamSpec) => void;
            'notify::can-focus': (pspec: GObject.ParamSpec) => void;
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::parent': (pspec: GObject.ParamSpec) => void;
            'notify::pointer-events': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::tooltip': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::visibility': (pspec: GObject.ParamSpec) => void;
            'notify::visibility-threshold': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends CanvasItemSimple.ConstructorProps, CanvasItem.ConstructorProps {
            anchor: CanvasAnchorType;
            height: number;
            widget: Gtk.Widget;
            width: number;
            x: number;
            y: number;
        }
    }

    /**
     * GooCanvasWidget provides support for placing any GtkWidget in the canvas.
     *
     * The #GooCanvasWidget:width and #GooCanvasWidget:height properties specify
     * the widget's size. If either of them is -1, then the requested size of the
     * widget is used instead, which is the default for both width and height.
     *
     * Note that there are a number of limitations in the use of #GooCanvasWidget:
     *
     * <itemizedlist><listitem><para>
     * It doesn't support any transformation besides simple translation.
     * This means you can't scale a canvas with a #GooCanvasWidget in it.
     * </para></listitem><listitem><para>
     * It doesn't support layering, so you can't place other items beneath
     * or above the #GooCanvasWidget.
     * </para></listitem><listitem><para>
     * It doesn't support rendering of widgets to a given cairo_t, which
     * means you can't output the widget to a pdf or postscript file.
     * </para></listitem><listitem><para>
     * It doesn't have a model/view variant like the other standard items,
     * so it can only be used in a simple canvas without a model.
     * </para></listitem><listitem><para>
     * It can't be made a static item.
     * </para></listitem></itemizedlist>
     */
    class CanvasWidget extends CanvasItemSimple implements CanvasItem {
        static $gtype: GObject.GType<CanvasWidget>;

        // Properties

        get anchor(): CanvasAnchorType;
        set anchor(val: CanvasAnchorType);
        get height(): number;
        set height(val: number);
        get widget(): Gtk.Widget;
        set widget(val: Gtk.Widget);
        get width(): number;
        set width(val: number);
        get x(): number;
        set x(val: number);
        get y(): number;
        set y(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasWidget.SignalSignatures;

        // Fields

        parent_object: CanvasItemSimple;

        // Constructors

        constructor(properties?: Partial<CanvasWidget.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasWidget.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasWidget.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasWidget.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasWidget.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasWidget.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasWidget.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited properties
        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Inherited methods
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        vfunc_add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        vfunc_allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        vfunc_animation_finished(stopped: boolean): void;
        vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
        vfunc_child_notify(pspec: GObject.ParamSpec): void;
        vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        vfunc_get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         */
        vfunc_get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         */
        vfunc_get_child(child_num: number): CanvasItem;
        vfunc_get_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         */
        vfunc_get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         */
        vfunc_get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         */
        vfunc_get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         */
        vfunc_get_n_children(): number;
        /**
         * Gets the parent of the given item.
         */
        vfunc_get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         */
        vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         */
        vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         */
        vfunc_get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         */
        vfunc_get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         */
        vfunc_get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         */
        vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         */
        vfunc_is_visible(): boolean;
        vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
        vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
        vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        vfunc_move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        vfunc_remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        vfunc_request_update(): void;
        vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        vfunc_set_canvas(canvas: Canvas): void;
        vfunc_set_child_property(
            child: CanvasItem,
            property_id: number,
            value: GObject.Value | any,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        vfunc_set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        vfunc_set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        vfunc_set_parent(parent: CanvasItem): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        vfunc_set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        vfunc_set_transform(transform?: cairo.Matrix | null): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace CanvasWidgetAccessibleFactory {
        // Signal signatures
        interface SignalSignatures extends Atk.ObjectFactory.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends Atk.ObjectFactory.ConstructorProps {}
    }

    class CanvasWidgetAccessibleFactory extends Atk.ObjectFactory {
        static $gtype: GObject.GType<CanvasWidgetAccessibleFactory>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CanvasWidgetAccessibleFactory.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CanvasWidgetAccessibleFactory.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof CanvasWidgetAccessibleFactory.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasWidgetAccessibleFactory.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CanvasWidgetAccessibleFactory.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CanvasWidgetAccessibleFactory.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CanvasWidgetAccessibleFactory.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CanvasWidgetAccessibleFactory.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    /**
     * #GooCanvasBounds represents the bounding box of an item in the canvas.
     */
    class CanvasBounds {
        static $gtype: GObject.GType<CanvasBounds>;

        // Fields

        x1: number;
        y1: number;
        x2: number;
        y2: number;

        // Constructors

        constructor(
            properties?: Partial<{
                x1: number;
                y1: number;
                x2: number;
                y2: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type CanvasClass = typeof Canvas;
    type CanvasEllipseClass = typeof CanvasEllipse;
    class CanvasEllipseData {
        static $gtype: GObject.GType<CanvasEllipseData>;

        // Fields

        center_x: number;
        center_y: number;
        radius_x: number;
        radius_y: number;

        // Constructors

        constructor(
            properties?: Partial<{
                center_x: number;
                center_y: number;
                radius_x: number;
                radius_y: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type CanvasEllipseModelClass = typeof CanvasEllipseModel;
    type CanvasGridClass = typeof CanvasGrid;
    class CanvasGridData {
        static $gtype: GObject.GType<CanvasGridData>;

        // Fields

        x: number;
        y: number;
        width: number;
        height: number;
        x_step: number;
        y_step: number;
        x_offset: number;
        y_offset: number;
        horz_grid_line_width: number;
        vert_grid_line_width: number;
        border_width: number;
        show_horz_grid_lines: number;
        show_vert_grid_lines: number;
        vert_grid_lines_on_top: number;

        // Constructors

        _init(...args: any[]): void;
    }

    type CanvasGridModelClass = typeof CanvasGridModel;
    type CanvasGroupClass = typeof CanvasGroup;
    type CanvasGroupModelClass = typeof CanvasGroupModel;
    type CanvasImageClass = typeof CanvasImage;
    class CanvasImageData {
        static $gtype: GObject.GType<CanvasImageData>;

        // Fields

        x: number;
        y: number;
        width: number;
        height: number;

        // Constructors

        _init(...args: any[]): void;
    }

    type CanvasImageModelClass = typeof CanvasImageModel;
    type CanvasItemIface = typeof CanvasItem;
    type CanvasItemModelIface = typeof CanvasItemModel;
    type CanvasItemModelSimpleClass = typeof CanvasItemModelSimple;
    type CanvasItemSimpleClass = typeof CanvasItemSimple;
    /**
     * This is the data common to both the model and view classes.
     */
    class CanvasItemSimpleData {
        static $gtype: GObject.GType<CanvasItemSimpleData>;

        // Fields

        style: CanvasStyle;
        clip_path_commands: any[];
        tooltip: string;
        visibility_threshold: number;
        visibility: number;
        pointer_events: number;
        can_focus: number;
        own_style: number;
        clip_fill_rule: number;
        is_static: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * #GooCanvasLineDash specifies a dash pattern to be used when drawing items.
     */
    class CanvasLineDash {
        static $gtype: GObject.GType<CanvasLineDash>;

        // Fields

        ref_count: number;
        num_dashes: number;
        dashes: number;
        dash_offset: number;

        // Constructors

        constructor(
            properties?: Partial<{
                ref_count: number;
                num_dashes: number;
                dashes: number;
                dash_offset: number;
            }>,
        );
        _init(...args: any[]): void;

        static newv(dashes: number[]): CanvasLineDash;

        // Methods

        /**
         * Increments the reference count of the dash pattern.
         * @returns the dash pattern.
         */
        ref(): CanvasLineDash;
        /**
         * Sets the start offset into the dash pattern.
         * @param dash_offset the start offset into the dash pattern.
         */
        set_offset(dash_offset: number): void;
        /**
         * Decrements the reference count of the dash pattern. If it falls to 0
         * it is freed.
         */
        unref(): void;
    }

    type CanvasPathClass = typeof CanvasPath;
    class CanvasPathData {
        static $gtype: GObject.GType<CanvasPathData>;

        // Fields

        path_commands: any[];

        // Constructors

        constructor(
            properties?: Partial<{
                path_commands: any[];
            }>,
        );
        _init(...args: any[]): void;
    }

    type CanvasPathModelClass = typeof CanvasPathModel;
    /**
     * #GooCairoPoints represents an array of points.
     */
    class CanvasPoints {
        static $gtype: GObject.GType<CanvasPoints>;

        // Fields

        coords: number;
        num_points: number;
        ref_count: number;

        // Constructors

        constructor(
            properties?: Partial<{
                coords: number;
                num_points: number;
                ref_count: number;
            }>,
        );
        _init(...args: any[]): void;

        static ['new'](num_points: number): CanvasPoints;

        // Methods

        /**
         * Gets the coordinates of a point in the #GooCanvasPoints struct.
         * @param idx index of point to get.
         */
        get_point(idx: number): [number, number];
        /**
         * Increments the reference count of the given #GooCanvasPoints struct.
         * @returns the #GooCanvasPoints struct.
         */
        ref(): CanvasPoints;
        /**
         * Sets the coordinates of a point in the #GooCanvasPoints struct.
         * @param idx index of point to set.
         * @param x x value to set point coordinate to.
         * @param y y value to set point coordinate to.
         */
        set_point(idx: number, x: number, y: number): void;
        /**
         * Decrements the reference count of the given #GooCanvasPoints struct,
         * freeing it if the reference count falls to zero.
         */
        unref(): void;
    }

    class CanvasPolylineArrowData {
        static $gtype: GObject.GType<CanvasPolylineArrowData>;

        // Fields

        arrow_width: number;
        arrow_length: number;
        arrow_tip_length: number;
        line_start: number[];
        line_end: number[];
        start_arrow_coords: number[];
        end_arrow_coords: number[];

        // Constructors

        constructor(
            properties?: Partial<{
                arrow_width: number;
                arrow_length: number;
                arrow_tip_length: number;
                line_start: number[];
                line_end: number[];
                start_arrow_coords: number[];
                end_arrow_coords: number[];
            }>,
        );
        _init(...args: any[]): void;
    }

    type CanvasPolylineClass = typeof CanvasPolyline;
    class CanvasPolylineData {
        static $gtype: GObject.GType<CanvasPolylineData>;

        // Fields

        coords: number;
        arrow_data: CanvasPolylineArrowData;
        num_points: number;
        close_path: number;
        start_arrow: number;
        end_arrow: number;
        reconfigure_arrows: number;

        // Constructors

        constructor(
            properties?: Partial<{
                coords: number;
                num_points: number;
                close_path: number;
                start_arrow: number;
                end_arrow: number;
                reconfigure_arrows: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type CanvasPolylineModelClass = typeof CanvasPolylineModel;
    type CanvasRectClass = typeof CanvasRect;
    class CanvasRectData {
        static $gtype: GObject.GType<CanvasRectData>;

        // Fields

        x: number;
        y: number;
        width: number;
        height: number;
        radius_x: number;
        radius_y: number;
        radius_top_left_x: number;
        radius_top_left_y: number;
        radius_top_right_x: number;
        radius_top_right_y: number;
        radius_bottom_right_x: number;
        radius_bottom_right_y: number;
        radius_bottom_left_x: number;
        radius_bottom_left_y: number;

        // Constructors

        constructor(
            properties?: Partial<{
                x: number;
                y: number;
                width: number;
                height: number;
                radius_x: number;
                radius_y: number;
                radius_top_left_x: number;
                radius_top_left_y: number;
                radius_top_right_x: number;
                radius_top_right_y: number;
                radius_bottom_right_x: number;
                radius_bottom_right_y: number;
                radius_bottom_left_x: number;
                radius_bottom_left_y: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type CanvasRectModelClass = typeof CanvasRectModel;
    type CanvasStyleClass = typeof CanvasStyle;
    /**
     * #GooCanvasStyleProperty represents a property setting.
     */
    class CanvasStyleProperty {
        static $gtype: GObject.GType<CanvasStyleProperty>;

        // Fields

        id: GLib.Quark;

        // Constructors

        _init(...args: any[]): void;
    }

    type CanvasTableClass = typeof CanvasTable;
    class CanvasTableData {
        static $gtype: GObject.GType<CanvasTableData>;

        // Fields

        width: number;
        height: number;
        dimensions: CanvasTableDimension[];
        border_width: number;
        children: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    class CanvasTableDimension {
        static $gtype: GObject.GType<CanvasTableDimension>;

        // Fields

        size: number;
        default_spacing: number;
        spacings: number;
        homogeneous: number;

        // Constructors

        constructor(
            properties?: Partial<{
                size: number;
                default_spacing: number;
                spacings: number;
                homogeneous: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    abstract class CanvasTableLayoutData {
        static $gtype: GObject.GType<CanvasTableLayoutData>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CanvasTableModelClass = typeof CanvasTableModel;
    type CanvasTextClass = typeof CanvasText;
    class CanvasTextData {
        static $gtype: GObject.GType<CanvasTextData>;

        // Fields

        text: string;
        x: number;
        y: number;
        width: number;
        use_markup: number;
        anchor: number;
        alignment: number;
        ellipsize: number;
        wrap: number;

        // Constructors

        constructor(
            properties?: Partial<{
                text: string;
                x: number;
                y: number;
                width: number;
                use_markup: number;
                anchor: number;
                alignment: number;
                ellipsize: number;
                wrap: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type CanvasTextModelClass = typeof CanvasTextModel;
    type CanvasWidgetClass = typeof CanvasWidget;
    /**
     * GooCanvasPathCommand holds the data for each command in the path.
     *
     * The `relative` flag specifies that the coordinates for the command are
     * relative to the current point. Otherwise they are assumed to be absolute
     * coordinates.
     */
    class CanvasPathCommand {
        static $gtype: GObject.GType<CanvasPathCommand>;

        // Constructors

        _init(...args: any[]): void;
    }

    namespace CanvasItem {
        /**
         * Interface for implementing CanvasItem.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            /**
             * Adds a child item to a container item at the given stack position.
             * @param child the item to add.
             * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
             */
            vfunc_add_child(child: CanvasItem, position: number): void;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically layout items such as #GooCanvasTable.
             *
             * It allocates an area to a child #GooCanvasItem.
             *
             * Note that the parent layout item will use a transform to move each of its
             * children for the layout, so there is no need for the child item to
             * reposition itself. It only needs to recalculate its device bounds.
             *
             * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
             * of the child item's allocated position from its requested position are
             * provided. Simple items can just add these to their bounds.
             * @param cr a cairo context.
             * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
             * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
             * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
             * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
             */
            vfunc_allocate_area(
                cr: cairo.Context,
                requested_area: CanvasBounds,
                allocated_area: CanvasBounds,
                x_offset: number,
                y_offset: number,
            ): void;
            vfunc_animation_finished(stopped: boolean): void;
            vfunc_button_press_event(target: CanvasItem, event: Gdk.EventButton): boolean;
            vfunc_button_release_event(target: CanvasItem, event: Gdk.EventButton): boolean;
            vfunc_child_notify(pspec: GObject.ParamSpec): void;
            vfunc_enter_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
            vfunc_focus_in_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
            vfunc_focus_out_event(target: CanvasItem, event: Gdk.EventFocus): boolean;
            /**
             * Gets the bounds of the item.
             *
             * Note that the bounds includes the entire fill and stroke extents of the
             * item, whether they are painted or not.
             */
            vfunc_get_bounds(): CanvasBounds;
            /**
             * Returns the #GooCanvas containing the given #GooCanvasItem.
             */
            vfunc_get_canvas(): Canvas;
            /**
             * Gets the child item at the given stack position.
             * @param child_num the position of a child in the container's stack.
             */
            vfunc_get_child(child_num: number): CanvasItem;
            vfunc_get_child_property(
                child: CanvasItem,
                property_id: number,
                value: GObject.Value | any,
                pspec: GObject.ParamSpec,
            ): void;
            /**
             * Returns %TRUE if the item is static. Static items do not move or change
             * size when the canvas is scrolled or the scale changes.
             */
            vfunc_get_is_static(): boolean;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically container items such as #GooCanvasGroup.
             *
             * It gets the items at the given point.
             * @param x the x coordinate of the point.
             * @param y the y coordinate of the point.
             * @param cr a cairo contect.
             * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
             * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
             * @param found_items the list of items found  so far.
             */
            vfunc_get_items_at(
                x: number,
                y: number,
                cr: cairo.Context,
                is_pointer_event: boolean,
                parent_is_visible: boolean,
                found_items: CanvasItem[],
            ): CanvasItem[];
            /**
             * Gets the model of the given canvas item.
             */
            vfunc_get_model(): CanvasItemModel;
            /**
             * Gets the number of children of the container.
             */
            vfunc_get_n_children(): number;
            /**
             * Gets the parent of the given item.
             */
            vfunc_get_parent(): CanvasItem;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically layout items such as #GooCanvasTable.
             *
             * It gets the requested area of a child item.
             * @param cr a cairo context.
             * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
             */
            vfunc_get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically layout items such as #GooCanvasTable.
             *
             * It gets the requested area of a child item, assuming it is allocated the
             * given width. This is useful for text items whose requested height may change
             * depending on the allocated width.
             * @param cr a cairo context.
             * @param width the allocated width.
             * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
             */
            vfunc_get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically layout items such as #GooCanvasTable.
             *
             * It gets the requested height of a child item, assuming it is allocated the
             * given width. This is useful for text items whose requested height may change
             * depending on the allocated width.
             * @param cr a cairo context.
             * @param width the width that the item may be allocated.
             */
            vfunc_get_requested_height(cr: cairo.Context, width: number): number;
            /**
             * Gets the item's style. If the item doesn't have its own style it will return
             * its parent's style.
             */
            vfunc_get_style(): CanvasStyle;
            /**
             * Gets the transformation matrix of an item.
             */
            vfunc_get_transform(): [boolean, cairo.Matrix];
            /**
             * Gets the transformation matrix of an item combined with any special
             * transform needed for the given child. These special transforms are used
             * by layout items such as #GooCanvasTable.
             * @param child a child of @item.
             */
            vfunc_get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
            vfunc_grab_broken_event(target: CanvasItem, event: Gdk.EventGrabBroken): boolean;
            /**
             * Checks if the item is visible.
             *
             * This entails checking the item's own visibility setting, as well as those
             * of its ancestors.
             *
             * Note that the item may be scrolled off the screen and so may not
             * be actually visible to the user.
             */
            vfunc_is_visible(): boolean;
            vfunc_key_press_event(target: CanvasItem, event: Gdk.EventKey): boolean;
            vfunc_key_release_event(target: CanvasItem, event: Gdk.EventKey): boolean;
            vfunc_leave_notify_event(target: CanvasItem, event: Gdk.EventCrossing): boolean;
            vfunc_motion_notify_event(target: CanvasItem, event: Gdk.EventMotion): boolean;
            /**
             * Moves a child item to a new stack position within the container.
             * @param old_position the current position of the child item.
             * @param new_position the new position of the child item.
             */
            vfunc_move_child(old_position: number, new_position: number): void;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically container items such as #GooCanvasGroup.
             *
             * It paints the item and all children if they intersect the given bounds.
             *
             * Note that the `scale` argument may be different to the current scale in the
             * #GooCanvasItem, e.g. when the canvas is being printed.
             * @param cr a cairo context.
             * @param bounds the bounds that need to be repainted, in device space.
             * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
             */
            vfunc_paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
            vfunc_query_tooltip(x: number, y: number, keyboard_tooltip: boolean, tooltip: Gtk.Tooltip): boolean;
            /**
             * Removes the child item at the given position.
             * @param child_num the position of the child item to remove.
             */
            vfunc_remove_child(child_num: number): void;
            /**
             * This function is only intended to be used when implementing new canvas
             * items.
             *
             * It requests that an update of the item is scheduled. It will be performed
             * as soon as the application is idle, and before the canvas is redrawn.
             */
            vfunc_request_update(): void;
            vfunc_scroll_event(target: CanvasItem, event: Gdk.EventScroll): boolean;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically container items such as #GooCanvasGroup.
             *
             * It sets the canvas of the item.
             * @param canvas a #GooCanvas
             */
            vfunc_set_canvas(canvas: Canvas): void;
            vfunc_set_child_property(
                child: CanvasItem,
                property_id: number,
                value: GObject.Value | any,
                pspec: GObject.ParamSpec,
            ): void;
            /**
             * Notifies the item that it is static. Static items do not move or change
             * size when the canvas is scrolled or the scale changes.
             *
             * Container items such as #GooCanvasGroup should call this function when
             * children are added, to notify children whether they are static or not.
             * Containers should also pass on any changes in their own status to children.
             * @param is_static if the item is static.
             */
            vfunc_set_is_static(is_static: boolean): void;
            /**
             * Sets the model of the given canvas item.
             * @param model a #GooCanvasItemModel.
             */
            vfunc_set_model(model: CanvasItemModel): void;
            /**
             * This function is only intended to be used when implementing new canvas
             * items (specifically container items such as #GooCanvasGroup).
             * It sets the parent of the child item.
             *
             * <note><para>
             * This function cannot be used to add an item to a group
             * or to change the parent of an item.
             * To do that use the #GooCanvasItem:parent property.
             * </para></note>
             * @param parent the new parent item.
             */
            vfunc_set_parent(parent: CanvasItem): void;
            /**
             * Sets the item's style, by copying the properties from the given style.
             * @param style a style.
             */
            vfunc_set_style(style: CanvasStyle): void;
            /**
             * Sets the transformation matrix of an item.
             * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
             */
            vfunc_set_transform(transform?: cairo.Matrix | null): void;
            /**
             * This function is only intended to be used when implementing new canvas
             * items, specifically container items such as #GooCanvasGroup.
             *
             * Updates the item, if needed, and any children.
             * @param entire_tree if the entire subtree should be updated.
             * @param cr a cairo context.
             * @param bounds a #GooCanvasBounds to return the new bounds in.
             */
            vfunc_update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            can_focus: boolean;
            canFocus: boolean;
            description: string;
            parent: CanvasItem;
            pointer_events: CanvasPointerEvents;
            pointerEvents: CanvasPointerEvents;
            title: string;
            tooltip: string;
            transform: CairoMatrix;
            visibility: CanvasItemVisibility;
            visibility_threshold: number;
            visibilityThreshold: number;
        }
    }

    export interface CanvasItemNamespace {
        $gtype: GObject.GType<CanvasItem>;
        prototype: CanvasItem;

        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout container items such as #GooCanvasTable.
         *
         * It finds a child property of a canvas item class by name.
         * @param iclass a #GObjectClass
         * @param property_name the name of the child property to find
         */
        class_find_child_property(iclass: typeof GObject.Object, property_name: string): GObject.ParamSpec;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout container items such as #GooCanvasTable.
         *
         * It installs a child property on a canvas item class.
         * @param iclass a #GObjectClass
         * @param property_id the id for the property
         * @param pspec the #GParamSpec for the property
         */
        class_install_child_property(
            iclass: typeof GObject.Object,
            property_id: number,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout container items such as #GooCanvasTable.
         *
         * It returns all child properties of a canvas item class.
         * @param iclass a #GObjectClass
         */
        class_list_child_properties(iclass: typeof GObject.Object): GObject.ParamSpec[];
    }
    interface CanvasItem extends GObject.Object, CanvasItem.Interface {
        // Properties

        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItem;
        set parent(val: CanvasItem);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        /**
         * The tooltip to display for the item, or %NULL to display no tooltip.
         *
         * Note that this property has no effect unless the
         * #GtkWidget:has-tooltip property is set to %TRUE on the #GooCanvas
         * containing this item.
         */
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Methods

        /**
         * Adds a child item to a container item at the given stack position.
         * @param child the item to add.
         * @param position the position of the item, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItem, position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It allocates an area to a child #GooCanvasItem.
         *
         * Note that the parent layout item will use a transform to move each of its
         * children for the layout, so there is no need for the child item to
         * reposition itself. It only needs to recalculate its device bounds.
         *
         * To help recalculate the item's device bounds, the `x_offset` and `y_offset`
         * of the child item's allocated position from its requested position are
         * provided. Simple items can just add these to their bounds.
         * @param cr a cairo context.
         * @param requested_area the area that the item originally requested, in the  parent's coordinate space.
         * @param allocated_area the area that the item has been allocated, in the parent's  coordinate space.
         * @param x_offset the x offset of the allocated area from the requested area in  the device coordinate space.
         * @param y_offset the y offset of the allocated area from the requested area in  the device coordinate space.
         */
        allocate_area(
            cr: cairo.Context,
            requested_area: CanvasBounds,
            allocated_area: CanvasBounds,
            x_offset: number,
            y_offset: number,
        ): void;
        /**
         * Animates an item from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the item currently has a simple transform. If the item has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It updates the canvas immediately, if an update is scheduled.
         * This ensures that all item bounds are up-to-date.
         */
        ensure_updated(): void;
        /**
         * Attempts to find the given child item with the container's stack.
         * @param child the child item to find.
         * @returns the position of the given @child item, or -1 if it isn't found.
         */
        find_child(child: CanvasItem): number;
        /**
         * Gets the bounds of the item.
         *
         * Note that the bounds includes the entire fill and stroke extents of the
         * item, whether they are painted or not.
         */
        get_bounds(): CanvasBounds;
        /**
         * Returns the #GooCanvas containing the given #GooCanvasItem.
         * @returns the #GooCanvas.
         */
        get_canvas(): Canvas;
        /**
         * Gets the child item at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child item at the given stack position, or  %NULL if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItem;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Returns %TRUE if the item is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         * @returns %TRUE if the item is static.
         */
        get_is_static(): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It gets the items at the given point.
         * @param x the x coordinate of the point.
         * @param y the y coordinate of the point.
         * @param cr a cairo contect.
         * @param is_pointer_event %TRUE if the "pointer-events" properties of items should  be used to determine which parts of the item are tested.
         * @param parent_is_visible %TRUE if the parent item is visible (which  implies that all ancestors are also visible).
         * @param found_items the list of items found  so far.
         * @returns the  @found_items list, with any more found items  added onto the start of the list, leaving the top item first.
         */
        get_items_at(
            x: number,
            y: number,
            cr: cairo.Context,
            is_pointer_event: boolean,
            parent_is_visible: boolean,
            found_items: CanvasItem[],
        ): CanvasItem[];
        /**
         * Gets the model of the given canvas item.
         * @returns the item's model, or %NULL if it has no model.
         */
        get_model(): CanvasItemModel;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given item.
         * @returns the parent item, or %NULL if the item has no parent.
         */
        get_parent(): CanvasItem;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item.
         * @param cr a cairo context.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space.
         * @returns %TRUE if the item should be allocated space.
         */
        get_requested_area(cr: cairo.Context, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested area of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the allocated width.
         * @param requested_area a #GooCanvasBounds to return the requested area in, in the  parent's coordinate space. If %FALSE is returned, this is undefined.
         * @returns %TRUE if the item's requested area changes due to the new allocated width.
         */
        get_requested_area_for_width(cr: cairo.Context, width: number, requested_area: CanvasBounds): boolean;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically layout items such as #GooCanvasTable.
         *
         * It gets the requested height of a child item, assuming it is allocated the
         * given width. This is useful for text items whose requested height may change
         * depending on the allocated width.
         * @param cr a cairo context.
         * @param width the width that the item may be allocated.
         * @returns the requested height of the item, given the allocated width,  or %-1 if the item doesn't support this method or its height doesn't  change when allocated different widths.
         */
        get_requested_height(cr: cairo.Context, width: number): number;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item, providing that the item has a simple transformation matrix
         * (e.g. set with goo_canvas_item_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the item
         * has a complex transformation matrix the results will be incorrect.
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(): [boolean, number, number, number, number];
        /**
         * Gets the item's style. If the item doesn't have its own style it will return
         * its parent's style.
         * @returns the item's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item.
         * @returns %TRUE if a transform is set.
         */
        get_transform(): [boolean, cairo.Matrix];
        /**
         * Gets the transformation matrix of an item combined with any special
         * transform needed for the given child. These special transforms are used
         * by layout items such as #GooCanvasTable.
         * @param child a child of @item.
         * @returns %TRUE if a transform is set.
         */
        get_transform_for_child(child: CanvasItem): [boolean, cairo.Matrix];
        /**
         * Tests to see if the given item is a container.
         * @returns %TRUE if the item is a container.
         */
        is_container(): boolean;
        /**
         * Checks if the item is visible.
         *
         * This entails checking the item's own visibility setting, as well as those
         * of its ancestors.
         *
         * Note that the item may be scrolled off the screen and so may not
         * be actually visible to the user.
         * @returns %TRUE if the item is visible.
         */
        is_visible(): boolean;
        /**
         * Lowers an item in the stacking order.
         * @param below the item to lower @item below, or %NULL to lower @item to the  bottom of the stack.
         */
        lower(below?: CanvasItem | null): void;
        /**
         * Moves a child item to a new stack position within the container.
         * @param old_position the current position of the child item.
         * @param new_position the new position of the child item.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It paints the item and all children if they intersect the given bounds.
         *
         * Note that the `scale` argument may be different to the current scale in the
         * #GooCanvasItem, e.g. when the canvas is being printed.
         * @param cr a cairo context.
         * @param bounds the bounds that need to be repainted, in device space.
         * @param scale the scale to use to determine whether an item should be painted.  See #GooCanvasItem:visibility-threshold.
         */
        paint(cr: cairo.Context, bounds: CanvasBounds, scale: number): void;
        /**
         * Raises an item in the stacking order.
         * @param above the item to raise @item above, or %NULL to raise @item to the top  of the stack.
         */
        raise(above?: CanvasItem | null): void;
        /**
         * Removes an item from its parent. If the item is in a canvas it will be
         * removed.
         *
         * This would normally also result in the item being freed.
         */
        remove(): void;
        /**
         * Removes the child item at the given position.
         * @param child_num the position of the child item to remove.
         */
        remove_child(child_num: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items.
         *
         * It requests that an update of the item is scheduled. It will be performed
         * as soon as the application is idle, and before the canvas is redrawn.
         */
        request_update(): void;
        /**
         * Rotates the item's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the item's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * It sets the canvas of the item.
         * @param canvas a #GooCanvas
         */
        set_canvas(canvas: Canvas): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItem.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItem, property_name: string, value: GObject.Value | any): void;
        /**
         * Notifies the item that it is static. Static items do not move or change
         * size when the canvas is scrolled or the scale changes.
         *
         * Container items such as #GooCanvasGroup should call this function when
         * children are added, to notify children whether they are static or not.
         * Containers should also pass on any changes in their own status to children.
         * @param is_static if the item is static.
         */
        set_is_static(is_static: boolean): void;
        /**
         * Sets the model of the given canvas item.
         * @param model a #GooCanvasItemModel.
         */
        set_model(model: CanvasItemModel): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items (specifically container items such as #GooCanvasGroup).
         * It sets the parent of the child item.
         *
         * <note><para>
         * This function cannot be used to add an item to a group
         * or to change the parent of an item.
         * To do that use the #GooCanvasItem:parent property.
         * </para></note>
         * @param parent the new parent item.
         */
        set_parent(parent: CanvasItem): void;
        /**
         * A convenience function to set the item's transformation matrix.
         * @param x the x coordinate of the origin of the item's coordinate space.
         * @param y the y coordinate of the origin of the item's coordinate space.
         * @param scale the scale of the item.
         * @param rotation the clockwise rotation of the item, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the item's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the item's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the item's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given item, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the item's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * items, specifically container items such as #GooCanvasGroup.
         *
         * Updates the item, if needed, and any children.
         * @param entire_tree if the entire subtree should be updated.
         * @param cr a cairo context.
         * @param bounds a #GooCanvasBounds to return the new bounds in.
         */
        update(entire_tree: boolean, cr: cairo.Context, bounds: CanvasBounds): void;
    }

    export const CanvasItem: CanvasItemNamespace & {
        new (): CanvasItem; // This allows `obj instanceof CanvasItem`
    };

    namespace CanvasItemModel {
        /**
         * Interface for implementing CanvasItemModel.
         * Contains only the virtual methods that need to be implemented.
         */
        interface Interface {
            // Virtual methods

            /**
             * Adds a child at the given stack position.
             * @param child the child to add.
             * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
             */
            vfunc_add_child(child: CanvasItemModel, position: number): void;
            vfunc_animation_finished(stopped: boolean): void;
            vfunc_changed(recompute_bounds: boolean): void;
            vfunc_child_added(child_num: number): void;
            vfunc_child_moved(old_child_num: number, new_child_num: number): void;
            vfunc_child_notify(pspec: GObject.ParamSpec): void;
            vfunc_child_removed(child_num: number): void;
            /**
             * Gets the child at the given stack position.
             * @param child_num the position of a child in the container's stack.
             */
            vfunc_get_child(child_num: number): CanvasItemModel;
            vfunc_get_child_property(
                child: CanvasItemModel,
                property_id: number,
                value: GObject.Value | any,
                pspec: GObject.ParamSpec,
            ): void;
            /**
             * Gets the number of children of the container.
             */
            vfunc_get_n_children(): number;
            /**
             * Gets the parent of the given model.
             */
            vfunc_get_parent(): CanvasItemModel;
            /**
             * Gets the model's style. If the model doesn't have its own style it will
             * return its parent's style.
             */
            vfunc_get_style(): CanvasStyle;
            /**
             * Gets the transformation matrix of an item model.
             * @param transform the place to store the transform.
             */
            vfunc_get_transform(transform: cairo.Matrix): boolean;
            /**
             * Moves a child to a new stack position.
             * @param old_position the current position of the child.
             * @param new_position the new position of the child.
             */
            vfunc_move_child(old_position: number, new_position: number): void;
            /**
             * Removes the child at the given position.
             * @param child_num the position of the child to remove.
             */
            vfunc_remove_child(child_num: number): void;
            vfunc_set_child_property(
                child: CanvasItemModel,
                property_id: number,
                value: GObject.Value | any,
                pspec: GObject.ParamSpec,
            ): void;
            /**
             * This function is only intended to be used when implementing new canvas
             * item models (specifically container models such as #GooCanvasGroupModel).
             * It sets the parent of the child model.
             *
             * <note><para>
             * This function cannot be used to add a model to a group
             * or to change the parent of a model.
             * To do that use the #GooCanvasItemModel:parent property.
             * </para></note>
             * @param parent the new parent item model.
             */
            vfunc_set_parent(parent: CanvasItemModel): void;
            /**
             * Sets the model's style, by copying the properties from the given style.
             * @param style a style.
             */
            vfunc_set_style(style: CanvasStyle): void;
            /**
             * Sets the transformation matrix of an item model.
             * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
             */
            vfunc_set_transform(transform?: cairo.Matrix | null): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            can_focus: boolean;
            canFocus: boolean;
            description: string;
            parent: CanvasItemModel;
            pointer_events: CanvasPointerEvents;
            pointerEvents: CanvasPointerEvents;
            title: string;
            tooltip: string;
            transform: CairoMatrix;
            visibility: CanvasItemVisibility;
            visibility_threshold: number;
            visibilityThreshold: number;
        }
    }

    export interface CanvasItemModelNamespace {
        $gtype: GObject.GType<CanvasItemModel>;
        prototype: CanvasItemModel;

        /**
         * This function is only intended to be used when implementing new canvas
         * item models, specifically layout container item models such as
         * #GooCanvasTableModel.
         *
         * It finds a child property of a canvas item class by name.
         * @param mclass a #GObjectClass
         * @param property_name the name of the child property to find
         */
        class_find_child_property(mclass: typeof GObject.Object, property_name: string): GObject.ParamSpec;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models, specifically layout container item models such as
         * #GooCanvasTableModel.
         *
         * It installs a child property on a canvas item class.
         * @param mclass a #GObjectClass
         * @param property_id the id for the property
         * @param pspec the #GParamSpec for the property
         */
        class_install_child_property(
            mclass: typeof GObject.Object,
            property_id: number,
            pspec: GObject.ParamSpec,
        ): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models, specifically layout container item models such as
         * #GooCanvasTableModel.
         *
         * It returns all child properties of a canvas item class.
         * @param mclass a #GObjectClass
         */
        class_list_child_properties(mclass: typeof GObject.Object): GObject.ParamSpec[];
    }
    interface CanvasItemModel extends GObject.Object, CanvasItemModel.Interface {
        // Properties

        get can_focus(): boolean;
        set can_focus(val: boolean);
        get canFocus(): boolean;
        set canFocus(val: boolean);
        get description(): string;
        set description(val: string);
        get parent(): CanvasItemModel;
        set parent(val: CanvasItemModel);
        get pointer_events(): CanvasPointerEvents;
        set pointer_events(val: CanvasPointerEvents);
        get pointerEvents(): CanvasPointerEvents;
        set pointerEvents(val: CanvasPointerEvents);
        get title(): string;
        set title(val: string);
        get tooltip(): string;
        set tooltip(val: string);
        get transform(): CairoMatrix;
        set transform(val: CairoMatrix);
        get visibility(): CanvasItemVisibility;
        set visibility(val: CanvasItemVisibility);
        get visibility_threshold(): number;
        set visibility_threshold(val: number);
        get visibilityThreshold(): number;
        set visibilityThreshold(val: number);

        // Methods

        /**
         * Adds a child at the given stack position.
         * @param child the child to add.
         * @param position the position of the child, or -1 to place it last (at the top of  the stacking order).
         */
        add_child(child: CanvasItemModel, position: number): void;
        /**
         * Animates a model from its current position to the given offsets, scale
         * and rotation.
         * @param x the final x coordinate.
         * @param y the final y coordinate.
         * @param scale the final scale.
         * @param degrees the final rotation. This can be negative to rotate anticlockwise,  and can also be greater than 360 to rotate a number of times.
         * @param absolute if the @x, @y, @scale and @degrees values are absolute, or  relative to the current transform. Note that absolute animations only work  if the model currently has a simple transform. If the model has a shear or  some other complicated transform it may result in strange animations.
         * @param duration the duration of the animation, in milliseconds (1/1000ths of a  second).
         * @param step_time the time between each animation step, in milliseconds.
         * @param type specifies what happens when the animation finishes.
         */
        animate(
            x: number,
            y: number,
            scale: number,
            degrees: number,
            absolute: boolean,
            duration: number,
            step_time: number,
            type: CanvasAnimateType | null,
        ): void;
        /**
         * Attempts to find the given child with the container's stack.
         * @param child the child to find.
         * @returns the position of the given @child, or -1 if it isn't found.
         */
        find_child(child: CanvasItemModel): number;
        /**
         * Gets the child at the given stack position.
         * @param child_num the position of a child in the container's stack.
         * @returns the child at the given stack position, or %NULL  if @child_num is out of range.
         */
        get_child(child_num: number): CanvasItemModel;
        /**
         * Gets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to get.
         * @param value a location to return the value.
         */
        get_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * Gets the number of children of the container.
         * @returns the number of children.
         */
        get_n_children(): number;
        /**
         * Gets the parent of the given model.
         * @returns the parent model, or %NULL if the model has no parent.
         */
        get_parent(): CanvasItemModel;
        /**
         * This function can be used to get the position, scale and rotation of an
         * item model, providing that the model has a simple transformation matrix
         * (e.g. set with goo_canvas_item_model_set_simple_transform(), or using a
         * combination of simple translate, scale and rotate operations). If the model
         * has a complex transformation matrix the results will be incorrect.
         * @param x returns the x coordinate of the origin of the model's coordinate space.
         * @param y returns the y coordinate of the origin of the model's coordinate space.
         * @param scale returns the scale of the model.
         * @param rotation returns the clockwise rotation of the model, in degrees (0-360).
         * @returns %TRUE if a transform is set.
         */
        get_simple_transform(x: number, y: number, scale: number, rotation: number): boolean;
        /**
         * Gets the model's style. If the model doesn't have its own style it will
         * return its parent's style.
         * @returns the model's style.
         */
        get_style(): CanvasStyle;
        /**
         * Gets the transformation matrix of an item model.
         * @param transform the place to store the transform.
         * @returns %TRUE if a transform is set.
         */
        get_transform(transform: cairo.Matrix): boolean;
        /**
         * Tests to see if the given item model is a container.
         * @returns %TRUE if the item model is a container.
         */
        is_container(): boolean;
        /**
         * Lowers a model in the stacking order.
         * @param below the item model to lower @model below, or %NULL to lower @model to the  bottom of the stack.
         */
        lower(below?: CanvasItemModel | null): void;
        /**
         * Moves a child to a new stack position.
         * @param old_position the current position of the child.
         * @param new_position the new position of the child.
         */
        move_child(old_position: number, new_position: number): void;
        /**
         * Raises a model in the stacking order.
         * @param above the item model to raise @model above, or %NULL to raise @model to the top  of the stack.
         */
        raise(above?: CanvasItemModel | null): void;
        /**
         * Removes a model from its parent. If the model is in a canvas it will be
         * removed.
         *
         * This would normally also result in the model being freed.
         */
        remove(): void;
        /**
         * Removes the child at the given position.
         * @param child_num the position of the child to remove.
         */
        remove_child(child_num: number): void;
        /**
         * Rotates the model's coordinate system by the given amount, about the given
         * origin.
         * @param degrees the clockwise angle of rotation.
         * @param cx the x coordinate of the origin of the rotation.
         * @param cy the y coordinate of the origin of the rotation.
         */
        rotate(degrees: number, cx: number, cy: number): void;
        /**
         * Scales the model's coordinate system by the given amounts.
         * @param sx the amount to scale the horizontal axis.
         * @param sy the amount to scale the vertical axis.
         */
        scale(sx: number, sy: number): void;
        /**
         * Sets a child property of `child`.
         * @param child a child #GooCanvasItemModel.
         * @param property_name the name of the child property to set.
         * @param value the value to set the property to.
         */
        set_child_property(child: CanvasItemModel, property_name: string, value: GObject.Value | any): void;
        /**
         * This function is only intended to be used when implementing new canvas
         * item models (specifically container models such as #GooCanvasGroupModel).
         * It sets the parent of the child model.
         *
         * <note><para>
         * This function cannot be used to add a model to a group
         * or to change the parent of a model.
         * To do that use the #GooCanvasItemModel:parent property.
         * </para></note>
         * @param parent the new parent item model.
         */
        set_parent(parent: CanvasItemModel): void;
        /**
         * A convenience function to set the item model's transformation matrix.
         * @param x the x coordinate of the origin of the model's coordinate space.
         * @param y the y coordinate of the origin of the model's coordinate space.
         * @param scale the scale of the model.
         * @param rotation the clockwise rotation of the model, in degrees.
         */
        set_simple_transform(x: number, y: number, scale: number, rotation: number): void;
        /**
         * Sets the model's style, by copying the properties from the given style.
         * @param style a style.
         */
        set_style(style: CanvasStyle): void;
        /**
         * Sets the transformation matrix of an item model.
         * @param transform the new transformation matrix, or %NULL to reset the  transformation to the identity matrix.
         */
        set_transform(transform?: cairo.Matrix | null): void;
        /**
         * Skews the model's coordinate system along the x axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_x(degrees: number, cx: number, cy: number): void;
        /**
         * Skews the model's coordinate system along the y axis by the given amount,
         * about the given origin.
         * @param degrees the skew angle.
         * @param cx the x coordinate of the origin of the skew transform.
         * @param cy the y coordinate of the origin of the skew transform.
         */
        skew_y(degrees: number, cx: number, cy: number): void;
        /**
         * Stops any current animation for the given model, leaving it at its current
         * position.
         */
        stop_animation(): void;
        /**
         * Translates the origin of the model's coordinate system by the given amounts.
         * @param tx the amount to move the origin in the horizontal direction.
         * @param ty the amount to move the origin in the vertical direction.
         */
        translate(tx: number, ty: number): void;
    }

    export const CanvasItemModel: CanvasItemModelNamespace & {
        new (): CanvasItemModel; // This allows `obj instanceof CanvasItemModel`
    };

    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default GooCanvas;

// END
