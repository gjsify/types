// @ts-nocheck

/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * Gcr-3
 */

import type * as Gjs from './Gjs';
import type Gio from './Gio-2.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';
import type Gck from './Gck-1';

export namespace Gcr {

/**
 * The status of a built certificate chain. Will be set to
 * %GCR_CERTIFICATE_CHAIN_UNKNOWN for certificate chains that have not been
 * built.
 */
enum CertificateChainStatus {
    /**
     * The certificate chain's status is unknown.
     * When a chain is not yet built it has this status. If a chain is modified after
     * being built, it has this status.
     */
    UNKNOWN,
    /**
     * A full chain could not be loaded. The
     * chain does not end with a self-signed certificate, a trusted anchor, or a
     * pinned certificate.
     */
    INCOMPLETE,
    /**
     * The certificate chain contains a revoked
     * or otherwise explicitly distrusted certificate. The entire chain should
     * be distrusted.
     */
    DISTRUSTED,
    /**
     * The chain ends with a self-signed
     * certificate. No trust anchor was found.
     */
    SELFSIGNED,
    /**
     * The chain represents a pinned certificate. A
     * pinned certificate is an exception which trusts a given certificate
     * explicitly for a purpose and communication with a certain peer.
     */
    PINNED,
    /**
     * The chain ends with an anchored
     * certificate. The anchored certificate is not necessarily self-signed.
     */
    ANCHORED,
}
/**
 * The format of a certificate request. Currently only PKCS#10 is supported.
 */
enum CertificateRequestFormat {
    /**
     * certificate request is in PKCS#10 format
     */
    CERTIFICATE_REQUEST_PKCS10,
}
/**
 * Values responding to error codes for parsing and serializing data.
 */
enum DataError {
    /**
     * Failed to parse or serialize the data
     */
    FAILURE,
    /**
     * The data was unrecognized or unsupported
     */
    UNRECOGNIZED,
    /**
     * The operation was cancelled
     */
    CANCELLED,
    /**
     * The data was encrypted or locked and could not be unlocked.
     */
    LOCKED,
}
/**
 * The various format identifiers.
 */
enum DataFormat {
    /**
     * Represents all the formats, when enabling or disabling
     */
    ALL,
    /**
     * Not a valid format
     */
    INVALID,
    /**
     * DER encoded private key
     */
    DER_PRIVATE_KEY,
    /**
     * DER encoded RSA private key
     */
    DER_PRIVATE_KEY_RSA,
    /**
     * DER encoded DSA private key
     */
    DER_PRIVATE_KEY_DSA,
    /**
     * DER encoded EC private key
     */
    DER_PRIVATE_KEY_EC,
    /**
     * DER encoded SubjectPublicKeyInfo
     */
    DER_SUBJECT_PUBLIC_KEY,
    /**
     * DER encoded X.509 certificate
     */
    DER_CERTIFICATE_X509,
    /**
     * DER encoded PKCS#7 container file which can contain certificates
     */
    DER_PKCS7,
    /**
     * DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8,
    /**
     * Unencrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_PLAIN,
    /**
     * Encrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_ENCRYPTED,
    /**
     * DER encoded PKCS#10 certificate request file
     */
    DER_PKCS10,
    /**
     * DER encoded SPKAC as generated by HTML5 keygen element
     */
    DER_SPKAC,
    /**
     * OpenSSL style SPKAC data
     */
    BASE64_SPKAC,
    /**
     * DER encoded PKCS#12 file which can contain certificates and/or keys
     */
    DER_PKCS12,
    /**
     * OpenSSH v1 or v2 public key
     */
    OPENSSH_PUBLIC,
    /**
     * OpenPGP key packet(s)
     */
    OPENPGP_PACKET,
    /**
     * OpenPGP public or private key armor encoded data
     */
    OPENPGP_ARMOR,
    /**
     * An OpenSSL style PEM file with unspecified contents
     */
    PEM,
    /**
     * An OpenSSL style PEM file with a private RSA key
     */
    PEM_PRIVATE_KEY_RSA,
    /**
     * An OpenSSL style PEM file with a private DSA key
     */
    PEM_PRIVATE_KEY_DSA,
    /**
     * An OpenSSL style PEM file with an X.509 certificate
     */
    PEM_CERTIFICATE_X509,
    /**
     * An OpenSSL style PEM file containing PKCS#7
     */
    PEM_PKCS7,
    /**
     * Unencrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_PLAIN,
    /**
     * Encrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_ENCRYPTED,
    /**
     * An OpenSSL style PEM file containing PKCS#12
     */
    PEM_PKCS12,
    /**
     * An OpenSSL style PEM file with a private key
     */
    PEM_PRIVATE_KEY,
    /**
     * An OpenSSL style PEM file containing PKCS#10
     */
    PEM_PKCS10,
    /**
     * An OpenSSL style PEM file with a private EC key
     */
    PEM_PRIVATE_KEY_EC,
    /**
     * An OpenSSL style PEM file containing a SubjectPublicKeyInfo
     */
    PEM_PUBLIC_KEY,
}
/**
 * Various replies returned by [method`Prompt`.confirm] and friends.
 */
enum PromptReply {
    /**
     * the prompt was cancelled
     */
    CANCEL,
    /**
     * the user replied with 'ok'
     */
    CONTINUE,
}
/**
 * No error returned by the #GcrSystemPrompt is suitable for display or
 * to the user.
 * 
 * If the system prompter can only show one prompt at a time, and there is
 * already a prompt being displayed, and the timeout waiting to open the
 * prompt expires, then %GCR_SYSTEM_PROMPT_IN_PROGRESS is returned.
 */
enum SystemPromptError {
    /**
     * another prompt is already in progress
     */
    SYSTEM_PROMPT_IN_PROGRESS,
}
/**
 * The mode for the system prompter. Most system prompters can only show
 * one prompt at a time and would use the %GCR_SYSTEM_PROMPTER_SINGLE mode.
 */
enum SystemPrompterMode {
    /**
     * only one prompt shown at a time
     */
    SINGLE,
    /**
     * more than one prompt shown at a time
     */
    MULTIPLE,
}
/**
 * Flags to be used with the gcr_certificate_chain_build() operation.
 * @bitfield 
 */
enum CertificateChainFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * If this flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11.
     */
    NO_LOOKUPS,
}
enum ColumnFlags {
    NONE,
    HIDDEN,
    SORTABLE,
}
const ICON_CERTIFICATE: string
const ICON_GNUPG: string
const ICON_HOME_DIRECTORY: string
const ICON_KEY: string
const ICON_KEY_PAIR: string
const ICON_PASSWORD: string
const ICON_SMART_CARD: string
/**
 * The major version number of the Gcr library.
 */
const MAJOR_VERSION: number
/**
 * The micro version number of the Gcr library.
 */
const MICRO_VERSION: number
/**
 * The minor version number of the Gcr library.
 */
const MINOR_VERSION: number
/**
 * The purpose used to verify the client certificate in a TLS connection.
 */
const PURPOSE_CLIENT_AUTH: string
/**
 * The purpose used to verify certificate used for the signature on signed code.
 */
const PURPOSE_CODE_SIGNING: string
/**
 * The purpose used to verify certificates that are used in email communication
 * such as S/MIME.
 */
const PURPOSE_EMAIL: string
/**
 * The purpose used to verify the server certificate in a TLS connection. This
 * is the most common purpose in use.
 */
const PURPOSE_SERVER_AUTH: string
/**
 * The current secret exchange protocol. Key agreement is done using DH with the
 * 1536 bit IKE parameter group. Keys are derived using SHA256 with HKDF. The
 * transport encryption is done with 128 bit AES.
 */
const SECRET_EXCHANGE_PROTOCOL_1: string
const UNLOCK_OPTION_ALWAYS: string
const UNLOCK_OPTION_IDLE: string
const UNLOCK_OPTION_SESSION: string
const UNLOCK_OPTION_TIMEOUT: string
/**
 * Compare one certificate against another. If the certificates are equal
 * then zero is returned. If one certificate is %NULL or not a certificate,
 * then a non-zero value is returned.
 * 
 * The return value is useful in a stable sort, but has no user logical
 * meaning.
 * @param first the certificate to compare
 * @param other the certificate to compare against
 */
function certificate_compare(first: Comparable | null, other: Comparable | null): number
function data_error_get_domain(): GLib.Quark
/**
 * Create a key fingerprint for a certificate, public key or private key.
 * Note that this is not a fingerprint of certificate data, which you would
 * use gcr_certificate_get_fingerprint() for.
 * @param attrs attributes for key or certificate
 * @param checksum_type the type of fingerprint to create
 */
function fingerprint_from_attributes(attrs: Gck.Attributes, checksum_type: GLib.ChecksumType): Uint8Array | null
/**
 * Create a key fingerprint for a DER encoded subjectPublicKeyInfo. The
 * fingerprint is created so that it will be identical for a key and its
 * corresponding certificate.
 * 
 * Note that in the case of certificates this is not a fingerprint of the
 * actual certificate data, but rather of the public key contained in a
 * certificate.
 * @param key_info DER encoded subjectPublicKeyInfo structure
 * @param checksum_type the type of fingerprint to create
 */
function fingerprint_from_subject_public_key_info(key_info: Uint8Array, checksum_type: GLib.ChecksumType): Uint8Array | null
/**
 * Get an appropriate icon for the token
 * @param token_info the token info
 */
function icon_for_token(token_info: Gck.TokenInfo): Gio.Icon
/**
 * Create a set of importers which can import this parsed item.
 * The parsed item is represented by the state of the GcrParser at the
 * time of calling this method.
 * @param parsed a parser with a parsed item to import
 */
function importer_create_for_parsed(parsed: Parsed): Importer[]
/**
 * Queues an additional item to be imported in all compattible importers
 * in the set. The parsed item is represented by the state of the #GcrParser
 * at the time of calling this method.
 * 
 * If the parsed item is incompatible with an importer, then that the item
 * will not be queued on that importer.
 * @param importers a set of importers
 * @param parsed a parsed item
 */
function importer_queue_and_filter_for_parsed(importers: Importer[], parsed: Parsed): Importer[]
/**
 * Register an importer to handle parsed items that match the given attributes.
 * 
 * If `attrs` are a floating reference, then it is consumed.
 * @param importer_type the GType of the importer being registered
 * @param attrs the attributes that this importer is compatible with
 */
function importer_register(importer_type: GObject.GType, attrs: Gck.Attributes): void
/**
 * Register built-in PKCS#11 and GnuPG importers.
 */
function importer_register_well_known(): void
/**
 * Disconnect the mock prompter
 */
function mock_prompter_disconnect(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects any prompt, and closes the prompt when it gets it.
 */
function mock_prompter_expect_close(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects a confirmation prompt, and then cancels that prompt.
 */
function mock_prompter_expect_confirm_cancel(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects a password prompt, and then cancels that prompt.
 */
function mock_prompter_expect_password_cancel(): void
/**
 * Get the delay in milliseconds before the mock prompter completes
 * an expected prompt.
 */
function mock_prompter_get_delay_msec(): number
/**
 * Check if the mock prompter is expecting a response. This will be %TRUE
 * when one of the <literal>gcr_mock_prompter_expect_xxx<!-- -->()</literal>
 * functions have been used to queue an expected prompt, but that prompt
 * response has not be 'used' yet.
 */
function mock_prompter_is_expecting(): boolean
/**
 * Check if the mock prompter is showing any prompts.
 */
function mock_prompter_is_prompting(): boolean
/**
 * Set the delay in milliseconds before the mock prompter completes
 * an expected prompt.
 * @param delay_msec prompt response delay in milliseconds
 */
function mock_prompter_set_delay_msec(delay_msec: number): void
/**
 * Start the mock prompter. This is often used from the
 * <literal>setup<!-- -->()</literal> function of tests.
 * 
 * Starts the mock prompter in an additional thread. Use the returned DBus bus
 * name with gcr_system_prompt_open_for_prompter() to connect to this prompter.
 */
function mock_prompter_start(): string
/**
 * Stop the mock prompter. This is often used from the
 * <literal>teardown<!-- -->()</literal> function of tests.
 */
function mock_prompter_stop(): void
/**
 * Unreferences a parsed item which was referenced with gcr_parsed_ref()
 * @param parsed a parsed item
 */
function parsed_unref(parsed: object | null): void
/**
 * Add a #GckModule to the list of PKCS#11 modules that are used by the
 * GCR library.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param module a #GckModule
 */
function pkcs11_add_module(module: Gck.Module): void
/**
 * Initialize a PKCS#11 module and add it to the modules that are
 * used by the GCR library. Note that is an error to initialize the same
 * PKCS#11 module twice.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param module_path the full file path of the PKCS#11 module
 * @param unused unused
 */
function pkcs11_add_module_from_file(module_path: string, unused: object | null): boolean
/**
 * List all the PKCS#11 modules that are used by the GCR library.
 * Each module is a [class`Gck`.Module] object.
 * 
 * An empty list of modules will be returned if [func`pkcs1`1_set_modules],
 * or [func`pkcs1`1_initialize] has not yet run.
 * 
 * When done with the list, free it with gck_list_unref_free().
 */
function pkcs11_get_modules(): Gck.Module[]
/**
 * List all the PKCS#11 slots that are used by the GCR library for lookup
 * of trust assertions. Each slot is a [class`Gck`.Slot] object.
 * 
 * This will return an empty list if the [func`pkcs1`1_initialize] function has
 * not yet been called.
 */
function pkcs11_get_trust_lookup_slots(): Gck.Slot[]
/**
 * Get the PKCS#11 URIs that are used to identify which slots to use for
 * lookup trust assertions.
 */
function pkcs11_get_trust_lookup_uris(): string[] | null
/**
 * Selects an appropriate PKCS#11 slot to store trust assertions. The slot
 * to use is normally configured automatically by the system.
 * 
 * This will only return a valid result after the [func`pkcs1`1_initialize]
 * method has been called.
 * 
 * When done with the #GckSlot, use g_object_unref() to release it.
 */
function pkcs11_get_trust_store_slot(): Gck.Slot | null
/**
 * Get the PKCS#11 URI that is used to identify which slot to use for
 * storing trust storage.
 */
function pkcs11_get_trust_store_uri(): string | null
/**
 * Asynchronously initialize the registered PKCS#11 modules.
 * @param cancellable optional cancellable used to cancel the operation
 */
function pkcs11_initialize(cancellable: Gio.Cancellable | null): boolean
/**
 * Asynchronously initialize the registered PKCS#11 modules.
 * @param cancellable optional cancellable used to cancel the operation
 * @param callback callback which will be called when the operation completes
 */
function pkcs11_initialize_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Complete the asynchronous operation to initialize the registered PKCS#11
 * modules.
 * @param result the asynchronous result
 */
function pkcs11_initialize_finish(result: Gio.AsyncResult): boolean
/**
 * Set the list of PKCS#11 modules that are used by the GCR library.
 * Each module in the list is a [class`Gck`.Module] object.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param modules a list of PKCS#11 modules
 */
function pkcs11_set_modules(modules: Gck.Module[]): void
/**
 * Set the PKCS#11 URIs that are used to identify which slots to use for
 * lookup of trust assertions.
 * 
 * It is not normally necessary to call this function. The relevant
 * PKCS#11 slots are automatically configured by the GCR library.
 * @param pkcs11_uris the uris which identifies trust lookup slots
 */
function pkcs11_set_trust_lookup_uris(pkcs11_uris: string | null): void
/**
 * Set the PKCS#11 URI that is used to identify which slot to use for
 * storing trust assertions.
 * 
 * It is not normally necessary to call this function. The relevant
 * PKCS#11 slot is automatically configured by the GCR library.
 * @param pkcs11_uri the uri which identifies trust storage slot
 */
function pkcs11_set_trust_store_uri(pkcs11_uri: string | null): void
/**
 * Add a pinned `certificate` for connections to `peer` for `purpose`. A pinned
 * certificate overrides all other certificate verification and should be
 * used with care.
 * 
 * If the same pinned certificate already exists, then this operation
 * does not add another, and succeeds without error.
 * 
 * This call may block, see gcr_trust_add_pinned_certificate_async() for the
 * non-blocking version.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 */
function trust_add_pinned_certificate(certificate: Certificate, purpose: string, peer: string, cancellable: Gio.Cancellable | null): boolean
/**
 * Add a pinned certificate for communication with `peer` for `purpose`. A pinned
 * certificate overrides all other certificate verification and should be used
 * with care.
 * 
 * If the same pinned certificate already exists, then this operation
 * does not add another, and succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_add_pinned_certificate_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trust_add_pinned_certificate_async(certificate: Certificate, purpose: string, peer: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_add_pinned_certificate_async().
 * @param result the #GAsyncResult passed to the callback
 */
function trust_add_pinned_certificate_finish(result: Gio.AsyncResult): boolean
/**
 * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
 * anchor is used to verify the signatures on other certificates when verifying
 * a certificate chain. Also known as a trusted certificate authority.
 * 
 * This call may block, see [func`Gcr`.trust_is_certificate_anchored_async] for
 * the non-blocking version.
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param cancellable a #GCancellable
 */
function trust_is_certificate_anchored(certificate: Certificate, purpose: string, cancellable: Gio.Cancellable | null): boolean
/**
 * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
 * anchor is used to verify the signatures on other certificates when verifying
 * a certificate chain. Also known as a trusted certificate authority.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_is_certificate_anchored_finish() to get the result of the operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trust_is_certificate_anchored_async(certificate: Certificate, purpose: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_is_certificate_anchored_async().
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param result the #GAsyncResult passed to the callback
 */
function trust_is_certificate_anchored_finish(result: Gio.AsyncResult): boolean
/**
 * Check if `certificate` is pinned for `purpose` to communicate with `peer`.
 * A pinned certificate overrides all other certificate verification.
 * 
 * This call may block, see gcr_trust_is_certificate_pinned_async() for the
 * non-blocking version.
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param peer the peer for this pinned
 * @param cancellable a #GCancellable
 */
function trust_is_certificate_pinned(certificate: Certificate, purpose: string, peer: string, cancellable: Gio.Cancellable | null): boolean
/**
 * Check if `certificate` is pinned for `purpose` to communicate with `peer`. A
 * pinned certificate overrides all other certificate verification.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_is_certificate_pinned_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param peer the peer for this pinned
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trust_is_certificate_pinned_async(certificate: Certificate, purpose: string, peer: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_is_certificate_pinned_async().
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param result the #GAsyncResult passed to the callback
 */
function trust_is_certificate_pinned_finish(result: Gio.AsyncResult): boolean
/**
 * Remove a pinned certificate for communication with `peer` for `purpose`.
 * 
 * If the same pinned certificate does not exist, or was already removed,
 * then this operation succeeds without error.
 * 
 * This call may block, see gcr_trust_remove_pinned_certificate_async() for the
 * non-blocking version.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 */
function trust_remove_pinned_certificate(certificate: Certificate, purpose: string, peer: string, cancellable: Gio.Cancellable | null): boolean
/**
 * Remove a pinned certificate for communication with `peer` for `purpose`.
 * 
 * If the same pinned certificate does not exist, or was already removed,
 * then this operation succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_remove_pinned_certificate_finish() to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
function trust_remove_pinned_certificate_async(certificate: Certificate, purpose: string, peer: string, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_remove_pinned_certificate_async().
 * @param result the #GAsyncResult passed to the callback
 */
function trust_remove_pinned_certificate_finish(result: Gio.AsyncResult): boolean
/**
 * A function which is called by [class`FilterCollection]` in order to determine
 * whether an object should show through the filter or not.
 * @callback 
 * @param object object to filter
 */
interface FilterCollectionFunc {
    (object: GObject.Object): boolean
}
interface Certificate_ConstructProps extends Comparable_ConstructProps, GObject.Object_ConstructProps {
}

interface Certificate extends Comparable {

    // Own properties of Gcr-3.Gcr.Certificate

    /**
     * A readable description for this certificate
     */
    readonly description: string
    /**
     * The expiry date of the certificate
     */
    readonly expiry: GLib.Date
    /**
     * An icon representing the certificate
     */
    readonly icon: Gio.Icon
    /**
     * Common name part of the certificate issuer
     */
    readonly issuer: string
    /**
     * A readable label for this certificate.
     */
    readonly label: string
    /**
     * GLib markup to describe the certificate
     */
    readonly markup: string
    /**
     * Common name part of the certificate subject
     */
    readonly subject: string

    // Owm methods of Gcr-3.Gcr.Certificate

    /**
     * Get the basic constraints for the certificate if present. If %FALSE is
     * returned then no basic constraints are present and the `is_ca` and
     * `path_len` arguments are not changed.
     */
    get_basic_constraints(): [ /* returnType */ boolean, /* is_ca */ boolean, /* path_len */ number ]
    /**
     * Gets the raw DER data for an X.509 certificate.
     */
    get_der_data(): Uint8Array
    /**
     * Get the expiry date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    get_expiry_date(): GLib.Date
    /**
     * Calculate the fingerprint for this certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @param type the type of algorithm for the fingerprint.
     */
    get_fingerprint(type: GLib.ChecksumType): Uint8Array
    /**
     * Calculate the fingerprint for this certificate, and return it
     * as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @param type the type of algorithm for the fingerprint.
     */
    get_fingerprint_hex(type: GLib.ChecksumType): string
    /**
     * Get the issued date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    get_issued_date(): GLib.Date
    /**
     * Get the common name of the issuer of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    get_issuer_cn(): string
    /**
     * Get the full issuer DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    get_issuer_dn(): string
    /**
     * Get a name to represent the issuer of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    get_issuer_name(): string
    /**
     * Get a part of the DN of the issuer of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @param part a DN type string or OID.
     */
    get_issuer_part(part: string): string | null
    /**
     * Get the raw DER data for the issuer DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    get_issuer_raw(): Uint8Array
    /**
     * Get the key size in bits of the public key represented
     * by this certificate.
     */
    get_key_size(): number
    /**
     * Calculate a GMarkup string for displaying this certificate.
     */
    get_markup_text(): string
    /**
     * Get the raw binary serial number of the certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    get_serial_number(): Uint8Array
    /**
     * Get the serial number of the certificate as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    get_serial_number_hex(): string
    /**
     * Get the common name of the subject of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    get_subject_cn(): string
    /**
     * Get the full subject DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    get_subject_dn(): string
    /**
     * Get a name to represent the subject of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    get_subject_name(): string
    /**
     * Get a part of the DN of the subject of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @param part a DN type string or OID.
     */
    get_subject_part(part: string): string | null
    /**
     * Get the raw DER data for the subject DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    get_subject_raw(): Uint8Array
    /**
     * Check if `issuer` could be the issuer of this certificate. This is done by
     * comparing the relevant subject and issuer fields. No signature check is
     * done. Proper verification of certificates must be done via a crypto
     * library.
     * @param issuer a possible issuer #GcrCertificate
     */
    is_issuer(issuer: Certificate): boolean
    /**
     * Implementers of the #GcrCertificate mixin should call this function to notify
     * when the certificate has changed to emit notifications on the various
     * properties.
     */
    mixin_emit_notify(): void

    // Own virtual methods of Gcr-3.Gcr.Certificate

    /**
     * Gets the raw DER data for an X.509 certificate.
     * @virtual 
     */
    vfunc_get_der_data(): Uint8Array

    // Class property signals of Gcr-3.Gcr.Certificate

    connect(sigName: "notify::description", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::expiry", ...args: any[]): void
    connect(sigName: "notify::icon", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::issuer", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::markup", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::markup", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::markup", ...args: any[]): void
    connect(sigName: "notify::subject", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::subject", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface that represents an X.509 certificate.
 * 
 * Objects can implement this interface to make a certificate usable with the
 * GCR library.
 * 
 * Various methods are available to parse out relevant bits of the certificate.
 * However no verification of the validity of a certificate is done here. Use
 * your favorite crypto library to do this.
 * 
 * You can use [class`SimpleCertificate]` to simply load a certificate for which
 * you already have the raw certificate data.
 * 
 * The #GcrCertificate interface has several properties that must be implemented.
 * You can use a mixin to implement these properties if desired. See the
 * gcr_certificate_mixin_class_init() and gcr_certificate_mixin_get_property()
 * functions.
 * 
 * All certificates are comparable. If implementing a #GcrCertificate, you can
 * use GCR_CERTIFICATE_MIXIN_IMPLEMENT_COMPARABLE() to implement the #GcrComparable
 * interface.
 * @interface 
 */
class Certificate extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Certificate

    static name: string
    static $gtype: GObject.GType<Certificate>

    // Constructors of Gcr-3.Gcr.Certificate

    constructor(config?: Certificate_ConstructProps) 
    _init(config?: Certificate_ConstructProps): void
    /**
     * Compare one certificate against another. If the certificates are equal
     * then zero is returned. If one certificate is %NULL or not a certificate,
     * then a non-zero value is returned.
     * 
     * The return value is useful in a stable sort, but has no user logical
     * meaning.
     * @param first the certificate to compare
     * @param other the certificate to compare against
     */
    static compare(first: Comparable | null, other: Comparable | null): number
}

interface Collection_ConstructProps extends GObject.Object_ConstructProps {
}

/**
 * Signal callback interface for `added`
 */
interface Collection_AddedSignalCallback {
    ($obj: Collection, object: GObject.Object): void
}

/**
 * Signal callback interface for `removed`
 */
interface Collection_RemovedSignalCallback {
    ($obj: Collection, object: GObject.Object): void
}

interface Collection {

    // Owm methods of Gcr-3.Gcr.Collection

    /**
     * Check whether the collection contains an object or not.
     * @param object object to check
     */
    contains(object: GObject.Object): boolean
    /**
     * Emit the #GcrCollection::added signal for the given object. This function
     * is used by implementors of this interface.
     * @param object The object that was added
     */
    emit_added(object: GObject.Object): void
    /**
     * Emit the #GcrCollection::removed signal for the given object. This function
     * is used by implementors of this interface.
     * @param object The object that was removed
     */
    emit_removed(object: GObject.Object): void
    /**
     * Get the number of objects in this collection.
     */
    get_length(): number
    /**
     * Get a list of the objects in this collection.
     */
    get_objects(): GObject.Object[]

    // Own virtual methods of Gcr-3.Gcr.Collection

    vfunc_added(object: GObject.Object): void
    /**
     * Check whether the collection contains an object or not.
     * @virtual 
     * @param object object to check
     */
    vfunc_contains(object: GObject.Object): boolean
    /**
     * Get the number of objects in this collection.
     * @virtual 
     */
    vfunc_get_length(): number
    /**
     * Get a list of the objects in this collection.
     * @virtual 
     */
    vfunc_get_objects(): GObject.Object[]
    vfunc_removed(object: GObject.Object): void

    // Own signals of Gcr-3.Gcr.Collection

    connect(sigName: "added", callback: Collection_AddedSignalCallback): number
    connect_after(sigName: "added", callback: Collection_AddedSignalCallback): number
    emit(sigName: "added", object: GObject.Object, ...args: any[]): void
    connect(sigName: "removed", callback: Collection_RemovedSignalCallback): number
    connect_after(sigName: "removed", callback: Collection_RemovedSignalCallback): number
    emit(sigName: "removed", object: GObject.Object, ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.Collection

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A #GcrCollection is used to group a set of objects.
 * 
 * This is an abstract interface which can be used to determine which objects
 * show up in a selector or other user interface element.
 * 
 * Use [ctor`SimpleCollection`.new] to create a concrete implementation of this
 * interface which you can add objects to.
 * @interface 
 */
class Collection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Collection

    static name: string
    static $gtype: GObject.GType<Collection>

    // Constructors of Gcr-3.Gcr.Collection

    constructor(config?: Collection_ConstructProps) 
    _init(config?: Collection_ConstructProps): void
}

interface Comparable_ConstructProps extends GObject.Object_ConstructProps {
}

interface Comparable {

    // Owm methods of Gcr-3.Gcr.Comparable

    /**
     * Compare whether two objects represent the same thing. The return value can
     * also be used to sort the objects.
     * @param other Another comparable object
     */
    compare(other: Comparable | null): number

    // Own virtual methods of Gcr-3.Gcr.Comparable

    /**
     * Compare whether two objects represent the same thing. The return value can
     * also be used to sort the objects.
     * @virtual 
     * @param other Another comparable object
     */
    vfunc_compare(other: Comparable | null): number

    // Class property signals of Gcr-3.Gcr.Comparable

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface for comparing objects
 * @interface 
 */
class Comparable extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Comparable

    static name: string
    static $gtype: GObject.GType<Comparable>

    // Constructors of Gcr-3.Gcr.Comparable

    constructor(config?: Comparable_ConstructProps) 
    _init(config?: Comparable_ConstructProps): void
}

interface ImportInteraction_ConstructProps extends Gio.TlsInteraction_ConstructProps, GObject.Object_ConstructProps {
}

interface ImportInteraction extends Gio.TlsInteraction {

    // Owm methods of Gcr-3.Gcr.ImportInteraction

    /**
     * Supplement attributes before import. This means prompting the user for
     * things like labels and the like. The needed attributes will have been passed
     * to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes. If the user or
     * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     */
    supplement(builder: Gck.Builder, cancellable: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Asynchronously supplement attributes before import. This means prompting the
     * user for things like labels and the like. The needed attributes will have
     * been passed to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes.
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @param callback called when the operation completes
     */
    supplement_async(builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete operation to asynchronously supplement attributes before import.
     * 
     * If the user or cancellable cancels the operation the error should be set
     * with %G_IO_ERROR_CANCELLED.
     * @param result the asynchronous result
     */
    supplement_finish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /**
     * Prepare for supplementing the given attributes before import. This means
     * prompting the user for things like labels and the like. The attributes
     * will contain attributes for values that the importer needs, either empty
     * or prefilled with suggested values.
     * 
     * This method does not prompt the user, but rather just prepares the
     * interaction that these are the attributes that are needed.
     * @param builder attributes to supplement
     */
    supplement_prep(builder: Gck.Builder): void

    // Own virtual methods of Gcr-3.Gcr.ImportInteraction

    /**
     * Supplement attributes before import. This means prompting the user for
     * things like labels and the like. The needed attributes will have been passed
     * to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes. If the user or
     * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     */
    vfunc_supplement(builder: Gck.Builder, cancellable: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Asynchronously supplement attributes before import. This means prompting the
     * user for things like labels and the like. The needed attributes will have
     * been passed to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes.
     * @virtual 
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @param callback called when the operation completes
     */
    vfunc_supplement_async(builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete operation to asynchronously supplement attributes before import.
     * 
     * If the user or cancellable cancels the operation the error should be set
     * with %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the asynchronous result
     */
    vfunc_supplement_finish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /**
     * Prepare for supplementing the given attributes before import. This means
     * prompting the user for things like labels and the like. The attributes
     * will contain attributes for values that the importer needs, either empty
     * or prefilled with suggested values.
     * 
     * This method does not prompt the user, but rather just prepares the
     * interaction that these are the attributes that are needed.
     * @virtual 
     * @param builder attributes to supplement
     */
    vfunc_supplement_prep(builder: Gck.Builder): void

    // Class property signals of Gcr-3.Gcr.ImportInteraction

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This is an interface implemented by a caller performing an import. It allows
 * the importer to ask the caller for further information about the import.
 * 
 * It must be implemented on a derived class of [class`Gio`.TlsInteraction]
 * @interface 
 */
class ImportInteraction extends GObject.Object {

    // Own properties of Gcr-3.Gcr.ImportInteraction

    static name: string
    static $gtype: GObject.GType<ImportInteraction>

    // Constructors of Gcr-3.Gcr.ImportInteraction

    constructor(config?: ImportInteraction_ConstructProps) 
    _init(config?: ImportInteraction_ConstructProps): void
}

interface Importer_ConstructProps extends GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.Importer

    /**
     * The interaction for the importer.
     */
    interaction?: Gio.TlsInteraction | null
}

interface Importer {

    // Own properties of Gcr-3.Gcr.Importer

    /**
     * The icon for the importer.
     */
    readonly icon: Gio.Icon
    /**
     * The interaction for the importer.
     */
    interaction: Gio.TlsInteraction
    /**
     * The label for the importer.
     */
    readonly label: string
    /**
     * The URI of the location imported to.
     */
    readonly uri: string

    // Owm methods of Gcr-3.Gcr.Importer

    /**
     * Get the interaction used to prompt the user when needed by this
     * importer.
     */
    get_interaction(): Gio.TlsInteraction | null
    /**
     * Import the queued items in the importer. This call will block
     * until the operation completes.
     * @param cancellable a #GCancellable, or %NULL
     */
    import(cancellable: Gio.Cancellable | null): boolean
    /**
     * Import the queued items in the importer. This function returns immediately
     * and completes asynchronously.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback called when the operation completes
     */
    import_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an asynchronous operation to import queued items.
     * @param result an asynchronous result
     */
    import_finish(result: Gio.AsyncResult): boolean
    /**
     * Queues an additional item to be imported. The parsed item is represented
     * by the state of the [class`Parser]` at the time of calling this method.
     * 
     * If the parsed item is incompatible with the importer, then this will
     * fail and the item will not be queued.
     * @param parsed a parsed item to import
     */
    queue_for_parsed(parsed: Parsed): boolean
    /**
     * Set the interaction used to prompt the user when needed by this
     * importer.
     * @param interaction the interaction used by the importer
     */
    set_interaction(interaction: Gio.TlsInteraction): void

    // Own virtual methods of Gcr-3.Gcr.Importer

    /**
     * Import the queued items in the importer. This function returns immediately
     * and completes asynchronously.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @param callback called when the operation completes
     */
    vfunc_import_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an asynchronous operation to import queued items.
     * @virtual 
     * @param result an asynchronous result
     */
    vfunc_import_finish(result: Gio.AsyncResult): boolean
    vfunc_import_sync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Queues an additional item to be imported. The parsed item is represented
     * by the state of the [class`Parser]` at the time of calling this method.
     * 
     * If the parsed item is incompatible with the importer, then this will
     * fail and the item will not be queued.
     * @virtual 
     * @param parsed a parsed item to import
     */
    vfunc_queue_for_parsed(parsed: Parsed): boolean

    // Class property signals of Gcr-3.Gcr.Importer

    connect(sigName: "notify::icon", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::interaction", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::uri", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uri", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::uri", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface which allows importing of certificates and keys. Each importer
 * is registered with a set of PKCS#11 attributes to match stuff that it can
 * import.
 * 
 * An importer gets passed a [class`Parser]` and accesses the currently parsed
 * item. To create a set of importers that can import the currently parsed
 * item in a parser, use [func`Importer`.create_for_parsed]. The list of
 * importers returned has the parsed item queued for import.
 * 
 * To queue additional items with a importer use
 * [method`Importer`.queue_for_parsed].  In addition you can try and queue an
 * additional item with a set of importers using the
 * [func`Importer`.queue_and_filter_for_parsed].
 * 
 * To start the import, use [method`Importer`.import] or its async variants.
 * @interface 
 */
class Importer extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Importer

    static name: string
    static $gtype: GObject.GType<Importer>

    // Constructors of Gcr-3.Gcr.Importer

    constructor(config?: Importer_ConstructProps) 
    _init(config?: Importer_ConstructProps): void
    /**
     * Create a set of importers which can import this parsed item.
     * The parsed item is represented by the state of the GcrParser at the
     * time of calling this method.
     * @param parsed a parser with a parsed item to import
     */
    static create_for_parsed(parsed: Parsed): Importer[]
    /**
     * Queues an additional item to be imported in all compattible importers
     * in the set. The parsed item is represented by the state of the #GcrParser
     * at the time of calling this method.
     * 
     * If the parsed item is incompatible with an importer, then that the item
     * will not be queued on that importer.
     * @param importers a set of importers
     * @param parsed a parsed item
     */
    static queue_and_filter_for_parsed(importers: Importer[], parsed: Parsed): Importer[]
    /**
     * Register an importer to handle parsed items that match the given attributes.
     * 
     * If `attrs` are a floating reference, then it is consumed.
     * @param importer_type the GType of the importer being registered
     * @param attrs the attributes that this importer is compatible with
     */
    static register(importer_type: GObject.GType, attrs: Gck.Attributes): void
    /**
     * Register built-in PKCS#11 and GnuPG importers.
     */
    static register_well_known(): void
}

interface Prompt_ConstructProps extends GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.Prompt

    /**
     * The string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * 
     * In X11, this will be a stringified version of the XWindow handle; in
     * Wayland this is the result of an export using the XDG foreign
     * protocol.
     */
    caller_window?: string | null
    /**
     * The label for the cancel button in the prompt.
     */
    cancel_label?: string | null
    /**
     * Whether the additional choice is chosen or not.
     * 
     * The additional choice would have been setup using #GcrPrompt:choice-label.
     */
    choice_chosen?: boolean | null
    /**
     * The label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * If %NULL, then no additional choice is displayed.
     * 
     * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
     */
    choice_label?: string | null
    /**
     * The label for the continue button in the prompt.
     */
    continue_label?: string | null
    /**
     * The detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    description?: string | null
    /**
     * The prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    message?: string | null
    /**
     * Whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    password_new?: boolean | null
    /**
     * The title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * #GcrPrompt:message should contain relevant information.
     */
    title?: string | null
    /**
     * A prompt warning displayed on the prompt, or %NULL for no warning.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     */
    warning?: string | null
}

/**
 * Signal callback interface for `prompt-close`
 */
interface Prompt_PromptCloseSignalCallback {
    ($obj: Prompt): void
}

interface Prompt {

    // Own properties of Gcr-3.Gcr.Prompt

    /**
     * The string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * 
     * In X11, this will be a stringified version of the XWindow handle; in
     * Wayland this is the result of an export using the XDG foreign
     * protocol.
     */
    caller_window: string
    /**
     * The label for the cancel button in the prompt.
     */
    cancel_label: string
    /**
     * Whether the additional choice is chosen or not.
     * 
     * The additional choice would have been setup using #GcrPrompt:choice-label.
     */
    choice_chosen: boolean
    /**
     * The label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * If %NULL, then no additional choice is displayed.
     * 
     * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
     */
    choice_label: string
    /**
     * The label for the continue button in the prompt.
     */
    continue_label: string
    /**
     * The detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    description: string
    /**
     * The prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    message: string
    /**
     * Whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    password_new: boolean
    /**
     * Indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    readonly password_strength: number
    /**
     * The title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * #GcrPrompt:message should contain relevant information.
     */
    title: string
    /**
     * A prompt warning displayed on the prompt, or %NULL for no warning.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     */
    warning: string

    // Owm methods of Gcr-3.Gcr.Prompt

    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     */
    confirm(cancellable: Gio.Cancellable | null): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    confirm_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param result asynchronous result passed to callback
     */
    confirm_finish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a `gtk_dialog_run()`. The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     */
    confirm_run(cancellable: Gio.Cancellable | null): PromptReply
    /**
     * Get the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     */
    get_caller_window(): string
    /**
     * Get the label for the cancel button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     */
    get_cancel_label(): string
    /**
     * Get whether the additional choice was chosen or not.
     * 
     * The additional choice would have been setup using
     * gcr_prompt_set_choice_label().
     */
    get_choice_chosen(): boolean
    /**
     * Get the label for the additional choice.
     * 
     * This will be %NULL if no additional choice is being displayed.
     */
    get_choice_label(): string
    /**
     * Get the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     */
    get_continue_label(): string
    /**
     * Get the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    get_description(): string
    /**
     * Gets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    get_message(): string
    /**
     * Get whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    get_password_new(): boolean
    /**
     * Get indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    get_password_strength(): number
    /**
     * Gets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     */
    get_title(): string
    /**
     * Get a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     */
    get_warning(): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     */
    password(cancellable: Gio.Cancellable | null): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    password_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param result asynchronous result passed to callback
     */
    password_finish(result: Gio.AsyncResult): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a gtk_dialog_run(). The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     */
    password_run(cancellable: Gio.Cancellable | null): string
    /**
     * Reset the contents and properties of the prompt.
     */
    reset(): void
    /**
     * Set the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * @param window_id the window id
     */
    set_caller_window(window_id: string): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     * @param cancel_label the label
     */
    set_cancel_label(cancel_label: string): void
    /**
     * Set whether the additional choice is chosen or not.
     * 
     * The additional choice should be set up using gcr_prompt_set_choice_label().
     * @param chosen whether chosen
     */
    set_choice_chosen(chosen: boolean): void
    /**
     * Set the label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * The initial value of the choice can be set with the
     * gcr_prompt_set_choice_label() method.
     * 
     * If this is %NULL, then no additional choice is being displayed.
     * @param choice_label the additional choice or %NULL
     */
    set_choice_label(choice_label: string | null): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     * @param continue_label the label
     */
    set_continue_label(continue_label: string): void
    /**
     * Set the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * Use gcr_prompt_set_message() to set a general message containing relevant
     * information.
     * @param description the detailed description
     */
    set_description(description: string): void
    /**
     * Sets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     * @param message the prompt message
     */
    set_message(message: string): void
    /**
     * Set whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     * @param new_password whether in new password mode or not
     */
    set_password_new(new_password: boolean): void
    /**
     * Sets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     * @param title the prompt title
     */
    set_title(title: string): void
    /**
     * Set a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     * @param warning the warning or %NULL
     */
    set_warning(warning: string | null): void

    // Own virtual methods of Gcr-3.Gcr.Prompt

    vfunc_prompt_close(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     * @virtual 
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    vfunc_prompt_confirm_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @virtual 
     * @param result asynchronous result passed to callback
     */
    vfunc_prompt_confirm_finish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     * @virtual 
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    vfunc_prompt_password_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @virtual 
     * @param result asynchronous result passed to callback
     */
    vfunc_prompt_password_finish(result: Gio.AsyncResult): string

    // Own signals of Gcr-3.Gcr.Prompt

    connect(sigName: "prompt-close", callback: Prompt_PromptCloseSignalCallback): number
    connect_after(sigName: "prompt-close", callback: Prompt_PromptCloseSignalCallback): number
    emit(sigName: "prompt-close", ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.Prompt

    connect(sigName: "notify::caller-window", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caller-window", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::caller-window", ...args: any[]): void
    connect(sigName: "notify::cancel-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cancel-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::cancel-label", ...args: any[]): void
    connect(sigName: "notify::choice-chosen", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-chosen", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-chosen", ...args: any[]): void
    connect(sigName: "notify::choice-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-label", ...args: any[]): void
    connect(sigName: "notify::continue-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::continue-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::continue-label", ...args: any[]): void
    connect(sigName: "notify::description", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::message", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::message", ...args: any[]): void
    connect(sigName: "notify::password-new", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-new", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-new", ...args: any[]): void
    connect(sigName: "notify::password-strength", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-strength", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-strength", ...args: any[]): void
    connect(sigName: "notify::title", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::title", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::title", ...args: any[]): void
    connect(sigName: "notify::warning", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::warning", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::warning", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A prompt displayed to the user. It is an interface with various
 * implementations.
 * 
 * Various properties are set on the prompt, and then the prompt is displayed
 * the various prompt methods like [method`Prompt`.password_run].
 * 
 * A `GcrPrompt` may be used to display multiple related prompts. Most
 * implementions do not hide the window between display of multiple related
 * prompts, and the #GcrPrompt must be closed or destroyed in order to make
 * it go away. This allows the user to see that the prompts are related.
 * 
 * Use `GcrPromptDialog` (part of gcr-ui) to create an in-process GTK+ dialog
 * prompt. Use [class`SystemPrompt]` to create a system prompt in a prompter
 * process.
 * 
 * The prompt implementation will always display the [property`Prompt:`message]
 * property, but may choose not to display the [property`Prompt:`description] or
 * [property`Prompt:`title] properties.
 * @interface 
 */
class Prompt extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Prompt

    static name: string
    static $gtype: GObject.GType<Prompt>

    // Constructors of Gcr-3.Gcr.Prompt

    constructor(config?: Prompt_ConstructProps) 
    _init(config?: Prompt_ConstructProps): void
}

interface CertificateChain_ConstructProps extends GObject.Object_ConstructProps {
}

interface CertificateChain {

    // Own properties of Gcr-3.Gcr.CertificateChain

    /**
     * The length of the certificate chain.
     */
    readonly length: number

    // Own fields of Gcr-3.Gcr.CertificateChain

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.CertificateChain

    /**
     * Add `certificate` to the chain. The order of certificates in the chain are
     * important. The first certificate should be the endpoint certificate, and
     * then come the signers (certificate authorities) each in turn. If a root
     * certificate authority is present, it should come last.
     * 
     * Adding a certificate an already built chain (see
     * gcr_certificate_chain_build()) resets the type of the certificate chain
     * to %GCR_CERTIFICATE_CHAIN_UNKNOWN
     * @param certificate a #GcrCertificate to add to the chain
     */
    add(certificate: Certificate): void
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This operation will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * This call will block, see gcr_certificate_chain_build_async() for the
     * asynchronous version.
     * @param purpose the purpose the certificate chain will be used for
     * @param peer the peer the certificate chain will be used with, or %NULL
     * @param flags chain completion flags
     * @param cancellable a #GCancellable or %NULL
     */
    build(purpose: string, peer: string | null, flags: CertificateChainFlags, cancellable: Gio.Cancellable | null): boolean
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * gcr_certificate_chain_build_finish() to get the result of the operation.
     * @param purpose the purpose the certificate chain will be used for
     * @param peer the peer the certificate chain will be used with, or %NULL
     * @param flags chain completion flags
     * @param cancellable a #GCancellable or %NULL
     * @param callback this will be called when the operation completes.
     */
    build_async(purpose: string, peer: string | null, flags: CertificateChainFlags, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_certificate_chain_build_async().
     * @param result the #GAsyncResult passed to the callback
     */
    build_finish(result: Gio.AsyncResult): boolean
    /**
     * If the certificate chain has been built and is of status
     * %GCR_CERTIFICATE_CHAIN_ANCHORED, then this will return the anchor
     * certificate that was found. This is not necessarily a root certificate
     * authority. If an intermediate certificate authority in the chain was
     * found to be anchored, then that certificate will be returned.
     * 
     * If an anchor is returned it does not mean that the certificate chain has
     * been verified, but merely that an anchor has been found.
     */
    get_anchor(): Certificate
    /**
     * Get a certificate in the chain. It is an error to call this function
     * with an invalid index.
     * @param index index of the certificate to get
     */
    get_certificate(index: number): Certificate
    /**
     * Get the endpoint certificate in the chain. This is always the first
     * certificate in the chain. The endpoint certificate cannot be anchored.
     */
    get_endpoint(): Certificate
    /**
     * Get the length of the certificate chain.
     */
    get_length(): number
    /**
     * Get the status of a certificate chain. If the certificate chain has not
     * been built, then the status will be %GCR_CERTIFICATE_CHAIN_UNKNOWN.
     * 
     * A status of %GCR_CERTIFICATE_CHAIN_ANCHORED does not mean that the
     * certificate chain has been verified, but merely that an anchor has been
     * found.
     */
    get_status(): CertificateChainStatus

    // Class property signals of Gcr-3.Gcr.CertificateChain

    connect(sigName: "notify::length", callback: (($obj: CertificateChain, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::length", callback: (($obj: CertificateChain, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::length", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Represents a chain of certificates, normally used to
 * validate the trust in a certificate. An X.509 certificate chain has one
 * endpoint certificate (the one for which trust is being verified) and then
 * in turn the certificate that issued each previous certificate in the chain.
 * 
 * This functionality is for building of certificate chains not for validating
 * them. Use your favorite crypto library to validate trust in a certificate
 * chain once its built.
 * 
 * The order of certificates in the chain should be first the endpoint
 * certificates and then the signing certificates.
 * 
 * Create a new certificate chain with [ctor`CertificateChain`.new] and then
 * add the certificates with [method`CertificateChain`.add].
 * 
 * You can then use [method`CertificateChain`.build] to build the remainder of
 * the chain. This will lookup missing certificates in PKCS#11 modules and
 * also check that each certificate in the chain is the signer of the previous
 * one. If a trust anchor, pinned certificate, or self-signed certificate is
 * found, then the chain is considered built. Any extra certificates are
 * removed from the chain.
 * 
 * Once the certificate chain has been built, you can access its status
 * through [method`CertificateChain`.get_status]. The status signifies whether
 * the chain is anchored on a trust root, self-signed, incomplete etc. See
 * [enum`CertificateChainStatus]` for information on the various statuses.
 * 
 * It's important to understand that the building of a certificate chain is
 * merely the first step towards verifying trust in a certificate.
 * @class 
 */
class CertificateChain extends GObject.Object {

    // Own properties of Gcr-3.Gcr.CertificateChain

    static name: string
    static $gtype: GObject.GType<CertificateChain>

    // Constructors of Gcr-3.Gcr.CertificateChain

    constructor(config?: CertificateChain_ConstructProps) 
    /**
     * Create a new #GcrCertificateChain.
     * @constructor 
     */
    constructor() 
    /**
     * Create a new #GcrCertificateChain.
     * @constructor 
     */
    static new(): CertificateChain
    _init(config?: CertificateChain_ConstructProps): void
}

interface CertificateRequest_ConstructProps extends GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.CertificateRequest

    /**
     * The private key that this certificate request is for.
     */
    private_key?: Gck.Object | null
}

interface CertificateRequest {

    // Own properties of Gcr-3.Gcr.CertificateRequest

    /**
     * The private key that this certificate request is for.
     */
    readonly private_key: Gck.Object

    // Owm methods of Gcr-3.Gcr.CertificateRequest

    /**
     * Complete and sign a certificate request, so that it can be encoded
     * and sent to a certificate authority.
     * 
     * This call may block as it signs the request using the private key.
     * @param cancellable a cancellation object
     */
    complete(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously complete and sign a certificate request, so that it can
     * be encoded and sent to a certificate authority.
     * 
     * This call will return immediately and complete later.
     * @param cancellable a cancellation object
     * @param callback called when the operation completes
     */
    complete_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finish an asynchronous operation to complete and sign a certificate
     * request.
     * @param result result of the asynchronous operation
     */
    complete_finish(result: Gio.AsyncResult): boolean
    /**
     * Encode the certificate request. It must have been completed with
     * [method`CertificateRequest`.complete] or
     * [method`CertificateRequest`.complete_async].
     * 
     * If `textual` is %FALSE, the output is a DER encoded certificate request.
     * 
     * If `textual` is %TRUE, the output is encoded as text. For PKCS#10 requests
     * this is done using the OpenSSL style PEM encoding.
     * @param textual whether to encode output as text
     */
    encode(textual: boolean): Uint8Array
    /**
     * Get the format of this certificate request.
     */
    get_format(): CertificateRequestFormat
    /**
     * Get the private key this certificate request is for.
     */
    get_private_key(): Gck.Object
    /**
     * Set the common name encoded in the certificate request.
     * @param cn common name to set on the request
     */
    set_cn(cn: string): void

    // Class property signals of Gcr-3.Gcr.CertificateRequest

    connect(sigName: "notify::private-key", callback: (($obj: CertificateRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key", callback: (($obj: CertificateRequest, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::private-key", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An object that allows creation of certificate requests. A certificate
 * request is sent to a certificate authority to request an X.509 certificate.
 * 
 * Use [func`CertificateRequest`.prepare] to create a blank certificate
 * request for a given private key. Set the common name on the certificate
 * request with [method`CertificateRequest`.set_cn], and then sign the request
 * with [method`CertificateRequest`.complete_async].
 * @class 
 */
class CertificateRequest extends GObject.Object {

    // Own properties of Gcr-3.Gcr.CertificateRequest

    static name: string
    static $gtype: GObject.GType<CertificateRequest>

    // Constructors of Gcr-3.Gcr.CertificateRequest

    constructor(config?: CertificateRequest_ConstructProps) 
    _init(config?: CertificateRequest_ConstructProps): void
    /**
     * Check whether [class`CertificateRequest]` is capable of creating a request
     * for the given `private_key`.
     * @param private_key a private key
     * @param cancellable cancellation object
     */
    static capable(private_key: Gck.Object, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously check whether [class`CertificateRequest]` is capable of
     * creating a request for the given `private_key`.
     * @param private_key a private key
     * @param cancellable cancellation object
     * @param callback will be called when the operation completes
     */
    static capable_async(private_key: Gck.Object, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Get the result for asynchronously check whether [class`CertificateRequest]` is
     * capable of creating a request for the given `private_key`.
     * @param result asynchronous result
     */
    static capable_finish(result: Gio.AsyncResult): boolean
    /**
     * Create a new certificate request, in the given format for the private key.
     * @param format the format for the certificate request
     * @param private_key the private key the the certificate is being requested for
     */
    static prepare(format: CertificateRequestFormat, private_key: Gck.Object): CertificateRequest
}

interface FilterCollection_ConstructProps extends Collection_ConstructProps, GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.FilterCollection

    underlying?: Collection | null
}

interface FilterCollection extends Collection {

    // Own properties of Gcr-3.Gcr.FilterCollection

    readonly underlying: Collection

    // Own fields of Gcr-3.Gcr.FilterCollection

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.FilterCollection

    /**
     * Get the collection that is being filtered by this filter collection.
     */
    get_underlying(): Collection
    /**
     * Refilter all objects in the underlying collection. Call this function if
     * the filter callback function changes its filtering criteria.
     */
    refilter(): void
    /**
     * Set the callback used to filter the objects in the underlying collection.
     * The callback should return %TRUE if an object should appear in the
     * filtered collection.
     * 
     * If a %NULL callback is set, then all underlynig objects will appear in the
     * filtered collection.
     * 
     * This will refilter the collection.
     * @param callback function to call for each object
     */
    set_callback(callback: FilterCollectionFunc | null): void

    // Class property signals of Gcr-3.Gcr.FilterCollection

    connect(sigName: "notify::underlying", callback: (($obj: FilterCollection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::underlying", callback: (($obj: FilterCollection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::underlying", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A collection which filters a [iface`Collection]`.
 * 
 * An implementation of [iface`Collection]` which filters objects from another
 * underlying collection. Use [ctor`FilterCollection`.new_with_callback]
 * to create a new filter collection.
 * 
 * The callback will determine the criteria for whether an object shows through
 * the filter or not.
 * @class 
 */
class FilterCollection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.FilterCollection

    static name: string
    static $gtype: GObject.GType<FilterCollection>

    // Constructors of Gcr-3.Gcr.FilterCollection

    constructor(config?: FilterCollection_ConstructProps) 
    /**
     * Create a new #GcrFilterCollection.
     * 
     * The callback should return %TRUE if an object should appear in the
     * filtered collection.
     * 
     * If a %NULL callback is set, then all underlynig objects will appear in the
     * filtered collection.
     * @constructor 
     * @param underlying the underlying collection
     * @param callback function to call for each object
     */
    static new_with_callback(underlying: Collection, callback: FilterCollectionFunc | null): FilterCollection
    _init(config?: FilterCollection_ConstructProps): void
}

interface Parser_ConstructProps extends GObject.Object_ConstructProps {
}

/**
 * Signal callback interface for `authenticate`
 */
interface Parser_AuthenticateSignalCallback {
    ($obj: Parser, count: number): boolean
}

/**
 * Signal callback interface for `parsed`
 */
interface Parser_ParsedSignalCallback {
    ($obj: Parser): void
}

interface Parser {

    // Own properties of Gcr-3.Gcr.Parser

    /**
     * Get the attributes that make up the currently parsed item. This is
     * generally only valid during a #GcrParser::parsed signal.
     */
    readonly parsed_attributes: Gck.Attributes
    /**
     * The description of the type of the currently parsed item. This is generally
     * only valid during a #GcrParser::parsed signal.
     */
    readonly parsed_description: string
    /**
     * The label of the currently parsed item. This is generally
     * only valid during a #GcrParser::parsed signal.
     */
    readonly parsed_label: string

    // Own fields of Gcr-3.Gcr.Parser

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.Parser

    /**
     * Add a password to the set of passwords to try when parsing locked or encrypted
     * items. This is usually called from the #GcrParser::authenticate signal.
     * @param password a password to try
     */
    add_password(password: string | null): void
    /**
     * Disable parsing of the given format. Use %GCR_FORMAT_ALL to disable all the formats.
     * @param format The format identifier
     */
    format_disable(format: DataFormat): void
    /**
     * Enable parsing of the given format. Use %GCR_FORMAT_ALL to enable all the formats.
     * @param format The format identifier
     */
    format_enable(format: DataFormat): void
    /**
     * Check whether the given format is supported by the parser.
     * @param format The format identifier
     */
    format_supported(format: DataFormat): boolean
    /**
     * Get the filename of the parser item.
     */
    get_filename(): string
    /**
     * Get the currently parsed item
     */
    get_parsed(): Parsed
    /**
     * Get the attributes which make up the currently parsed item. This is generally
     * only valid during the #GcrParser::parsed signal.
     */
    get_parsed_attributes(): Gck.Attributes | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the #GcrParser::parsed signal.
     */
    get_parsed_block(): Uint8Array | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the #GcrParser::parsed signal.
     */
    get_parsed_bytes(): GLib.Bytes
    /**
     * Get a description for the type of the currently parsed item. This is generally
     * only valid during the #GcrParser::parsed signal.
     */
    get_parsed_description(): string | null
    /**
     * Get the format of the raw data block that represents this parsed object.
     * This corresponds with the data returned from gcr_parser_get_parsed_block().
     * 
     * This is only valid during the #GcrParser::parsed signal.
     */
    get_parsed_format(): DataFormat
    /**
     * Get the label of the currently parsed item. This is generally only valid
     * during the #GcrParser::parsed signal.
     */
    get_parsed_label(): string | null
    /**
     * Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * @param data the data to parse
     */
    parse_bytes(data: GLib.Bytes): boolean
    /**
     * Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * 
     * A copy of the data will be made. Use gcr_parser_parse_bytes() to avoid this.
     * @param data the data to parse
     */
    parse_data(data: Uint8Array): boolean
    /**
     * Parse items from the data in a #GInputStream. This function may block while
     * reading from the input stream. Use gcr_parser_parse_stream_async() for
     * a non-blocking variant.
     * 
     * The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * @param input The input stream
     * @param cancellable An optional cancellation object
     */
    parse_stream(input: Gio.InputStream, cancellable: Gio.Cancellable | null): boolean
    /**
     * Parse items from the data in a #GInputStream. This function completes
     * asyncronously and doesn't block.
     * 
     * The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * @param input The input stream
     * @param cancellable An optional cancellation object
     * @param callback Called when the operation result is ready.
     */
    parse_stream_async(input: Gio.InputStream, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to parse a stream.
     * @param result The operation result
     */
    parse_stream_finish(result: Gio.AsyncResult): boolean
    /**
     * Sets the filename of the parser item.
     * @param filename a string of the filename of the parser item
     */
    set_filename(filename: string | null): void

    // Own virtual methods of Gcr-3.Gcr.Parser

    vfunc_authenticate(count: number): boolean
    vfunc_parsed(): void

    // Own signals of Gcr-3.Gcr.Parser

    connect(sigName: "authenticate", callback: Parser_AuthenticateSignalCallback): number
    connect_after(sigName: "authenticate", callback: Parser_AuthenticateSignalCallback): number
    emit(sigName: "authenticate", count: number, ...args: any[]): void
    connect(sigName: "parsed", callback: Parser_ParsedSignalCallback): number
    connect_after(sigName: "parsed", callback: Parser_ParsedSignalCallback): number
    emit(sigName: "parsed", ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.Parser

    connect(sigName: "notify::parsed-attributes", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-attributes", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parsed-attributes", ...args: any[]): void
    connect(sigName: "notify::parsed-description", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-description", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parsed-description", ...args: any[]): void
    connect(sigName: "notify::parsed-label", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-label", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parsed-label", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A parser for parsing various types of files or data.
 * 
 * A `GcrParser` can parse various certificate and key files such as OpenSSL
 * PEM files, DER encoded certifictes, PKCS#8 keys and so on. Each various
 * format is identified by a value in the [enum`DataFormat]` enumeration.
 * 
 * In order to parse data, a new parser is created with gcr_parser_new() and
 * then the [signal`Parser:`:authenticate] and [signal`Parser:`:parsed] signals
 * should be connected to. Data is then fed to the parser via
 * [method`Parser`.parse_data] or [method`Parser`.parse_stream].
 * 
 * During the [signal`Parser:`:parsed] signal the attributes that make up the
 * currently parsed item can be retrieved using the
 * [method`Parser`.get_parsed_attributes] function.
 * @class 
 */
class Parser extends GObject.Object {

    // Own properties of Gcr-3.Gcr.Parser

    static name: string
    static $gtype: GObject.GType<Parser>

    // Constructors of Gcr-3.Gcr.Parser

    constructor(config?: Parser_ConstructProps) 
    /**
     * Create a new #GcrParser
     * @constructor 
     */
    constructor() 
    /**
     * Create a new #GcrParser
     * @constructor 
     */
    static new(): Parser
    _init(config?: Parser_ConstructProps): void
}

interface Pkcs11Certificate_ConstructProps extends Certificate_ConstructProps, Comparable_ConstructProps, Gck.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.Pkcs11Certificate

    /**
     * Automatically loaded attributes for this certificate.
     */
    attributes?: Gck.Attributes | null
}

interface Pkcs11Certificate extends Certificate, Comparable {

    // Own properties of Gcr-3.Gcr.Pkcs11Certificate

    /**
     * Automatically loaded attributes for this certificate.
     */
    readonly attributes: Gck.Attributes

    // Own fields of Gcr-3.Gcr.Pkcs11Certificate

    parent: Gck.Object

    // Owm methods of Gcr-3.Gcr.Pkcs11Certificate

    /**
     * Access the automatically loaded attributes for this certificate.
     */
    get_attributes(): Gck.Attributes

    // Conflicting methods

    get_data(...args: any[]): any

    // Class property signals of Gcr-3.Gcr.Pkcs11Certificate

    connect(sigName: "notify::attributes", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::attributes", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::attributes", ...args: any[]): void
    connect(sigName: "notify::handle", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::handle", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::handle", ...args: any[]): void
    connect(sigName: "notify::module", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::module", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::module", ...args: any[]): void
    connect(sigName: "notify::session", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::session", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::session", ...args: any[]): void
    connect(sigName: "notify::description", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::expiry", ...args: any[]): void
    connect(sigName: "notify::icon", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::issuer", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::markup", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::markup", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::markup", ...args: any[]): void
    connect(sigName: "notify::subject", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::subject", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A certificate loaded from a PKCS#11 storage.
 * It is also a valid [class`Gck`.Object] and can be used as such.
 * 
 * Use gcr_pkcs11_certificate_lookup_issuer() to lookup the issuer of a given
 * certificate in the PKCS#11 store.
 * 
 * Various common PKCS#11 certificate attributes are automatically loaded and
 * are available via gcr_pkcs11_certificate_get_attributes().
 * @class 
 */
class Pkcs11Certificate extends Gck.Object {

    // Own properties of Gcr-3.Gcr.Pkcs11Certificate

    static name: string
    static $gtype: GObject.GType<Pkcs11Certificate>

    // Constructors of Gcr-3.Gcr.Pkcs11Certificate

    constructor(config?: Pkcs11Certificate_ConstructProps) 
    _init(config?: Pkcs11Certificate_ConstructProps): void
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * This call may block, see gcr_pkcs11_certificate_lookup_issuer() for the
     * non-blocking version.
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     * @param certificate a #GcrCertificate
     * @param cancellable a #GCancellable
     */
    static lookup_issuer(certificate: Certificate, cancellable: Gio.Cancellable | null): Certificate
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * When the operation is finished, callback will be called. You can then call
     * gcr_pkcs11_certificate_lookup_issuer_finish() to get the result of the
     * operation.
     * @param certificate a #GcrCertificate
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    static lookup_issuer_async(certificate: Certificate, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_pkcs11_certificate_lookup_issuer_async().
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     * @param result the #GAsyncResult passed to the callback
     */
    static lookup_issuer_finish(result: Gio.AsyncResult): Certificate
}

interface SecretExchange_ConstructProps extends GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.SecretExchange

    /**
     * The protocol being used for the exchange.
     * 
     * Will be %NULL if no protocol was specified when creating this object,
     * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
     * have not been called successfully.
     */
    protocol?: string | null
}

interface SecretExchange {

    // Own properties of Gcr-3.Gcr.SecretExchange

    /**
     * The protocol being used for the exchange.
     * 
     * Will be %NULL if no protocol was specified when creating this object,
     * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
     * have not been called successfully.
     */
    readonly protocol: string

    // Owm methods of Gcr-3.Gcr.SecretExchange

    /**
     * Begin the secret exchange. The resulting string should be sent to the other
     * side of the exchange. The other side should use [method`SecretExchange`.receive]
     * to process the string.
     */
    begin(): string
    /**
     * Will return %NULL if no protocol was specified, and either
     * [method`SecretExchange`.begin] or [method`SecretExchange`.receive] have not
     * been called successfully.
     */
    get_protocol(): string
    /**
     * Returns the last secret received. If no secret has yet been received this
     * will return %NULL. The string is owned by the #GcrSecretExchange object
     * and will be valid until the next time that gcr_secret_exchange_receive()
     * is called on this object, or the object is destroyed.
     * 
     * Depending on the secret passed into the other side of the secret exchange,
     * the result may be a binary string. It does however have a null terminator,
     * so if you're certain that it is does not contain arbitrary binary data,
     * it can be used as a string.
     */
    get_secret(): string[]
    /**
     * Receive a string from the other side of secret exchange. This string will
     * have been created by [method`SecretExchange`.begin] or
     * [method`SecretExchange`.send].
     * 
     * After this call completes successfully the value returned from
     * gcr_secret_exchange_get_secret() will have changed.
     * @param exchange the string received
     */
    receive(exchange: string): boolean
    /**
     * Send a reply to the other side of the secret exchange, optionally sending a
     * secret.
     * 
     * [method`SecretExchange`.receive] must have been successfully called at least
     * once on this object. In other words this object must have received data
     * from the other side of the secret exchange, before we can send a secret.
     * @param secret optionally, a secret to send to the other side
     * @param secret_len length of `secret,` or -1 if null terminated
     */
    send(secret: string | null, secret_len: number): string

    // Own virtual methods of Gcr-3.Gcr.SecretExchange

    vfunc_derive_transport_key(peer: number, n_peer: number): boolean
    vfunc_generate_exchange_key(scheme: string, public_key: number, n_public_key: number): boolean

    // Class property signals of Gcr-3.Gcr.SecretExchange

    connect(sigName: "notify::protocol", callback: (($obj: SecretExchange, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: SecretExchange, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Allows exchange of secrets between two processes on the same system without
 * exposing those secrets to things like loggers, non-pageable memory etc.
 * 
 * This does not protect against active attacks like MITM attacks.
 * 
 * Each side creates a secret exchange object, and one of the sides calls
 * [method`SecretExchange`.begin]. This creates a string, which should be passed
 * to the other side. Each side passes the strings it receives into
 * [method`SecretExchange`.receive].
 * 
 * In order to send a reply (either with or without a secret) use
 * [method`SecretExchange`.send]. A side must have successfully called
 * [method`SecretExchange`.receive] before it can use
 * [method`SecretExchange`.send].
 * 
 * The secret exchange objects can be used for multiple iterations of the
 * conversation, or for just one request/reply. The only limitation being that
 * the initial request cannot contain a secret.
 * 
 * Caveat: Information about the approximate length (rounded up to the nearest
 * 16 bytes) may be leaked. If this is considered inacceptable, do not use
 * [class`SecretExchange]`.
 * @class 
 */
class SecretExchange extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SecretExchange

    static name: string
    static $gtype: GObject.GType<SecretExchange>

    // Constructors of Gcr-3.Gcr.SecretExchange

    constructor(config?: SecretExchange_ConstructProps) 
    /**
     * Create a new secret exchange object.
     * 
     * Specify a protocol of %NULL to allow any protocol. This is especially
     * relevant on the side of the exchange that does not call
     * [method`SecretExchange`.begin], that is the originator. Currently the only
     * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
     * @constructor 
     * @param protocol the exchange protocol to use
     */
    constructor(protocol: string | null) 
    /**
     * Create a new secret exchange object.
     * 
     * Specify a protocol of %NULL to allow any protocol. This is especially
     * relevant on the side of the exchange that does not call
     * [method`SecretExchange`.begin], that is the originator. Currently the only
     * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
     * @constructor 
     * @param protocol the exchange protocol to use
     */
    static new(protocol: string | null): SecretExchange
    _init(config?: SecretExchange_ConstructProps): void
}

interface SimpleCertificate_ConstructProps extends Certificate_ConstructProps, Comparable_ConstructProps, GObject.Object_ConstructProps {
}

interface SimpleCertificate extends Certificate, Comparable {

    // Own fields of Gcr-3.Gcr.SimpleCertificate

    parent: GObject.Object

    // Class property signals of Gcr-3.Gcr.SimpleCertificate

    connect(sigName: "notify::description", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::expiry", ...args: any[]): void
    connect(sigName: "notify::icon", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::icon", ...args: any[]): void
    connect(sigName: "notify::issuer", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::markup", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::markup", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::markup", ...args: any[]): void
    connect(sigName: "notify::subject", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::subject", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An implementation of [iface`Certificate]` which loads a certificate from DER
 * data already located in memory.
 * 
 * To create an object, use the [ctor`SimpleCertificate`.new] or
 * [ctor`SimpleCertificate`.new_static] functions.
 * @class 
 */
class SimpleCertificate extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SimpleCertificate

    static name: string
    static $gtype: GObject.GType<SimpleCertificate>

    // Constructors of Gcr-3.Gcr.SimpleCertificate

    constructor(config?: SimpleCertificate_ConstructProps) 
    /**
     * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
     * copied so you can dispose of it after this function returns.
     * @constructor 
     * @param data the raw DER certificate data
     */
    constructor(data: Uint8Array) 
    /**
     * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
     * copied so you can dispose of it after this function returns.
     * @constructor 
     * @param data the raw DER certificate data
     */
    static new(data: Uint8Array): SimpleCertificate
    _init(config?: SimpleCertificate_ConstructProps): void
}

interface SimpleCollection_ConstructProps extends Collection_ConstructProps, GObject.Object_ConstructProps {
}

interface SimpleCollection extends Collection {

    // Own fields of Gcr-3.Gcr.SimpleCollection

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.SimpleCollection

    /**
     * Add an object to this collection
     * @param object The object to add
     */
    add(object: GObject.Object): void
    /**
     * Remove an object from the collection.
     * @param object The object to remove from the collection
     */
    remove(object: GObject.Object): void

    // Class property signals of Gcr-3.Gcr.SimpleCollection

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A simple implementation of [iface`Collection]`, which you can add and remove
 * objects from.
 * 
 * You can use [method`SimpleCollection`.add] to add objects, and
 * [method`SimpleCollection`.remove] to remove them again.
 * @class 
 */
class SimpleCollection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SimpleCollection

    static name: string
    static $gtype: GObject.GType<SimpleCollection>

    // Constructors of Gcr-3.Gcr.SimpleCollection

    constructor(config?: SimpleCollection_ConstructProps) 
    /**
     * Create a new #GcrSimpleCollection.
     * @constructor 
     */
    constructor() 
    /**
     * Create a new #GcrSimpleCollection.
     * @constructor 
     */
    static new(): SimpleCollection
    _init(config?: SimpleCollection_ConstructProps): void
}

interface SshAskpass_ConstructProps extends GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.SshAskpass

    /**
     * The interaction used to prompt for passwords.
     */
    interaction?: Gio.TlsInteraction | null
}

interface SshAskpass {

    // Own properties of Gcr-3.Gcr.SshAskpass

    /**
     * The interaction used to prompt for passwords.
     */
    readonly interaction: Gio.TlsInteraction

    // Owm methods of Gcr-3.Gcr.SshAskpass

    /**
     * Get the interaction associated with this object.
     */
    get_interaction(): Gio.TlsInteraction

    // Class property signals of Gcr-3.Gcr.SshAskpass

    connect(sigName: "notify::interaction", callback: (($obj: SshAskpass, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: SshAskpass, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * When used as the setup function while spawning an ssh command like ssh-add
 * or ssh, this allows callbacks for passwords on the provided interaction.
 * @class 
 */
class SshAskpass extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SshAskpass

    static name: string
    static $gtype: GObject.GType<SshAskpass>

    // Constructors of Gcr-3.Gcr.SshAskpass

    constructor(config?: SshAskpass_ConstructProps) 
    /**
     * Create a new GcrSshAskpass object which can be used to spawn an
     * ssh command and prompt for any necessary passwords.
     * 
     * Use the gcr_ssh_askpass_child_setup() function as a callback with
     * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
     * @constructor 
     * @param interaction the interaction to use for prompting paswords
     */
    constructor(interaction: Gio.TlsInteraction) 
    /**
     * Create a new GcrSshAskpass object which can be used to spawn an
     * ssh command and prompt for any necessary passwords.
     * 
     * Use the gcr_ssh_askpass_child_setup() function as a callback with
     * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
     * @constructor 
     * @param interaction the interaction to use for prompting paswords
     */
    static new(interaction: Gio.TlsInteraction): SshAskpass
    _init(config?: SshAskpass_ConstructProps): void
    /**
     * Use this function as a callback setup function passed to g_spawn_sync(),
     * g_spawn_async(), g_spawn_async_with_pipes().
     * @param askpass a #GcrSshAskpass object
     */
    static child_setup(askpass: object | null): void
}

interface SystemPrompt_ConstructProps extends Prompt_ConstructProps, Gio.AsyncInitable_ConstructProps, Gio.Initable_ConstructProps, GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.SystemPrompt

    /**
     * The DBus bus name of the prompter to use for prompting, or %NULL
     * for the default prompter.
     */
    bus_name?: string | null
    /**
     * The #GcrSecretExchange to use when transferring passwords. A default
     * secret exchange will be used if this is not set.
     */
    secret_exchange?: SecretExchange | null
    /**
     * The timeout in seconds to wait when opening the prompt.
     */
    timeout_seconds?: number | null
}

interface SystemPrompt extends Prompt, Gio.AsyncInitable, Gio.Initable {

    // Own properties of Gcr-3.Gcr.SystemPrompt

    /**
     * The DBus bus name of the prompter to use for prompting, or %NULL
     * for the default prompter.
     */
    readonly bus_name: string
    /**
     * The #GcrSecretExchange to use when transferring passwords. A default
     * secret exchange will be used if this is not set.
     */
    secret_exchange: SecretExchange
    /**
     * The timeout in seconds to wait when opening the prompt.
     */
    readonly timeout_seconds: number

    // Own fields of Gcr-3.Gcr.SystemPrompt

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.SystemPrompt

    /**
     * Close this prompt. After calling this function, no further prompts will
     * succeed on this object. The prompt object is not unreferenced by this
     * function, and you must unreference it once done.
     * 
     * This call may block, use the gcr_system_prompt_close_async() to perform
     * this action indefinitely.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     * @param cancellable an optional cancellation object
     */
    close(cancellable?: Gio.Cancellable | null): boolean

    // Overloads of close

    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    close(...args: any[]): any
    close(...args: any[]): boolean | void | any
    /**
     * Close this prompt asynchronously. After calling this function, no further
     * methods may be called on this object. The prompt object is not unreferenced
     * by this function, and you must unreference it once done.
     * 
     * This call returns immediately and completes asynchronously.
     * @param cancellable an optional cancellation object
     * @param callback called when the operation completes
     */
    close_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete operation to close this prompt.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     * @param result asynchronous operation result
     */
    close_finish(result: Gio.AsyncResult): boolean
    /**
     * Get the current [class`SecretExchange]` used to transfer secrets in this prompt.
     */
    get_secret_exchange(): SecretExchange

    // Class property signals of Gcr-3.Gcr.SystemPrompt

    connect(sigName: "notify::bus-name", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bus-name", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::bus-name", ...args: any[]): void
    connect(sigName: "notify::secret-exchange", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::secret-exchange", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::secret-exchange", ...args: any[]): void
    connect(sigName: "notify::timeout-seconds", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeout-seconds", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::timeout-seconds", ...args: any[]): void
    connect(sigName: "notify::caller-window", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caller-window", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::caller-window", ...args: any[]): void
    connect(sigName: "notify::cancel-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cancel-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::cancel-label", ...args: any[]): void
    connect(sigName: "notify::choice-chosen", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-chosen", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-chosen", ...args: any[]): void
    connect(sigName: "notify::choice-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-label", ...args: any[]): void
    connect(sigName: "notify::continue-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::continue-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::continue-label", ...args: any[]): void
    connect(sigName: "notify::description", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::message", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::message", ...args: any[]): void
    connect(sigName: "notify::password-new", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-new", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-new", ...args: any[]): void
    connect(sigName: "notify::password-strength", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-strength", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-strength", ...args: any[]): void
    connect(sigName: "notify::title", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::title", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::title", ...args: any[]): void
    connect(sigName: "notify::warning", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::warning", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::warning", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A [iface`Prompt]` implementation which calls to the system prompter to
 * display prompts in a system modal fashion.
 * 
 * Since the system prompter usually only displays one prompt at a time, you
 * may have to wait for the prompt to be displayed. Use [func`SystemPrompt`.open]
 * or a related function to open a prompt. Since this can take a long time, you
 * should always check that the prompt is still needed after it is opened. A
 * previous prompt may have already provided the information needed and you
 * may no longer need to prompt.
 * 
 * Use [method`SystemPrompt`.close] to close the prompt when you're done with it.
 * @class 
 */
class SystemPrompt extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SystemPrompt

    static name: string
    static $gtype: GObject.GType<SystemPrompt>

    // Constructors of Gcr-3.Gcr.SystemPrompt

    constructor(config?: SystemPrompt_ConstructProps) 
    _init(config?: SystemPrompt_ConstructProps): void
    static error_get_domain(): GLib.Quark
    /**
     * Opens a system prompt with the default prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     */
    static open(timeout_seconds: number, cancellable: Gio.Cancellable | null): SystemPrompt
    /**
     * Asynchronously open a system prompt with the default system prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    static open_async(timeout_seconds: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to asynchronously open a system prompt.
     * @param result the asynchronous result
     */
    static open_finish(result: Gio.AsyncResult): SystemPrompt
    /**
     * Opens a system prompt. If prompter_name is %NULL, then the default
     * system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param prompter_name the prompter dbus name
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     */
    static open_for_prompter(prompter_name: string | null, timeout_seconds: number, cancellable: Gio.Cancellable | null): SystemPrompt
    /**
     * Opens a system prompt asynchronously. If prompter_name is %NULL, then the
     * default system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param prompter_name the prompter D-Bus name
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    static open_for_prompter_async(prompter_name: string | null, timeout_seconds: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

interface SystemPrompter_ConstructProps extends GObject.Object_ConstructProps {

    // Own constructor properties of Gcr-3.Gcr.SystemPrompter

    /**
     * The #GType for prompts created by this prompter. This must be a
     * #GcrPrompt implementation.
     */
    prompt_type?: GObject.GType | null
}

/**
 * Signal callback interface for `new-prompt`
 */
interface SystemPrompter_NewPromptSignalCallback {
    ($obj: SystemPrompter): Prompt
}

interface SystemPrompter {

    // Own properties of Gcr-3.Gcr.SystemPrompter

    /**
     * The #GType for prompts created by this prompter. This must be a
     * #GcrPrompt implementation.
     */
    readonly prompt_type: GObject.GType
    /**
     * Whether the prompter is prompting or not.
     */
    readonly prompting: boolean

    // Own fields of Gcr-3.Gcr.SystemPrompter

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.SystemPrompter

    /**
     * Get the mode for this prompter.
     * 
     * Most system prompters only display one prompt at a time and therefore
     * return %GCR_SYSTEM_PROMPTER_SINGLE.
     */
    get_mode(): SystemPrompterMode
    /**
     * Get the #GType for prompts created by this prompter.
     * 
     * The returned #GType will be a #GcrPrompt implementation.
     */
    get_prompt_type(): GObject.GType
    /**
     * Get whether prompting or not.
     */
    get_prompting(): boolean
    /**
     * Register this system prompter on the DBus `connection`.
     * 
     * This makes the prompter available for clients to call. The prompter will
     * remain registered until gcr_system_prompter_unregister() is called, or the
     * prompter is unreferenced.
     * @param connection a DBus connection
     */
    register(connection: Gio.DBusConnection): void
    /**
     * Unregister this system prompter on the DBus `connection`.
     * 
     * The prompter must have previously been registered with gcr_system_prompter_register().
     * 
     * If `wait` is set then this function will wait until all prompts have been closed
     * or cancelled. This is usually only used by tests.
     * @param wait whether to wait for closing prompts
     */
    unregister(wait: boolean): void

    // Own signals of Gcr-3.Gcr.SystemPrompter

    connect(sigName: "new-prompt", callback: SystemPrompter_NewPromptSignalCallback): number
    connect_after(sigName: "new-prompt", callback: SystemPrompter_NewPromptSignalCallback): number
    emit(sigName: "new-prompt", ...args: any[]): void

    // Class property signals of Gcr-3.Gcr.SystemPrompter

    connect(sigName: "notify::prompt-type", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prompt-type", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::prompt-type", ...args: any[]): void
    connect(sigName: "notify::prompting", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prompting", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::prompting", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A prompter used by implementations of system prompts.
 * 
 * This is a D-Bus service which is rarely implemented. Use [class`SystemPrompt]`
 * to display system prompts.
 * 
 * The system prompter service responds to D-Bus requests to create system
 * prompts and creates #GcrPrompt type objects to display those prompts.
 * 
 * Pass the GType of the implementation of [iface`Prompt]` to
 * [ctor`SystemPrompter`.new].
 * @class 
 */
class SystemPrompter extends GObject.Object {

    // Own properties of Gcr-3.Gcr.SystemPrompter

    static name: string
    static $gtype: GObject.GType<SystemPrompter>

    // Constructors of Gcr-3.Gcr.SystemPrompter

    constructor(config?: SystemPrompter_ConstructProps) 
    /**
     * Create a new system prompter service. This prompter won't do anything unless
     * you connect to its signals and show appropriate prompts.
     * 
     * If `prompt_type` is zero, then the new-prompt signal must be handled and
     * return a valid prompt object implementing the #GcrPrompt interface.
     * 
     * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
     * interface.
     * @constructor 
     * @param mode the mode for the prompt
     * @param prompt_type the gobject type for prompts created by this prompter
     */
    constructor(mode: SystemPrompterMode, prompt_type: GObject.GType) 
    /**
     * Create a new system prompter service. This prompter won't do anything unless
     * you connect to its signals and show appropriate prompts.
     * 
     * If `prompt_type` is zero, then the new-prompt signal must be handled and
     * return a valid prompt object implementing the #GcrPrompt interface.
     * 
     * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
     * interface.
     * @constructor 
     * @param mode the mode for the prompt
     * @param prompt_type the gobject type for prompts created by this prompter
     */
    static new(mode: SystemPrompterMode, prompt_type: GObject.GType): SystemPrompter
    _init(config?: SystemPrompter_ConstructProps): void
}

interface UnionCollection_ConstructProps extends Collection_ConstructProps, GObject.Object_ConstructProps {
}

interface UnionCollection extends Collection {

    // Own fields of Gcr-3.Gcr.UnionCollection

    parent: GObject.Object

    // Owm methods of Gcr-3.Gcr.UnionCollection

    /**
     * Add objects from this collection to the union
     * @param collection The collection whose objects to add
     */
    add(collection: Collection): void
    /**
     * Get the collections that have been added to this union.
     */
    elements(): Collection[]
    /**
     * Check whether the collection is present in the union.
     * @param collection the collection to check
     */
    have(collection: Collection): boolean
    /**
     * Remove an object from the collection.
     * @param collection The collection whose objects to remove
     */
    remove(collection: Collection): void
    /**
     * Return the number of collections in this union. This does not reflect
     * the number of objects in the combined collection.
     */
    size(): number
    /**
     * Add objects from this collection to the union. Do not add an additional
     * reference to the collection.
     * @param collection The collection whose objects to add
     */
    take(collection: Collection): void

    // Class property signals of Gcr-3.Gcr.UnionCollection

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An implementation of #GcrCollection, which combines the objects in
 * other [iface`Collection]`s. Use [method`UnionCollection`.add] to add and
 * [method`UnionCollection`.remove] to remove them.
 * @class 
 */
class UnionCollection extends GObject.Object {

    // Own properties of Gcr-3.Gcr.UnionCollection

    static name: string
    static $gtype: GObject.GType<UnionCollection>

    // Constructors of Gcr-3.Gcr.UnionCollection

    constructor(config?: UnionCollection_ConstructProps) 
    /**
     * Create a new #GcrUnionCollection.
     * @constructor 
     */
    constructor() 
    /**
     * Create a new #GcrUnionCollection.
     * @constructor 
     */
    static new(): UnionCollection
    _init(config?: UnionCollection_ConstructProps): void
}

interface CertificateChainClass {

    // Own fields of Gcr-3.Gcr.CertificateChainClass

    /**
     * The parent class
     * @field 
     */
    parent_class: GObject.ObjectClass
}

/**
 * The class for #GcrCertificateChain.
 * @record 
 */
abstract class CertificateChainClass {

    // Own properties of Gcr-3.Gcr.CertificateChainClass

    static name: string
}

interface CertificateChainPrivate {
}

class CertificateChainPrivate {

    // Own properties of Gcr-3.Gcr.CertificateChainPrivate

    static name: string
}

interface CertificateIface {

    // Own fields of Gcr-3.Gcr.CertificateIface

    /**
     * the parent interface type
     * @field 
     */
    parent: GObject.TypeInterface
    get_der_data: (self: Certificate) => Uint8Array
}

/**
 * The interface that implementors of #GcrCertificate must implement.
 * @record 
 */
abstract class CertificateIface {

    // Own properties of Gcr-3.Gcr.CertificateIface

    static name: string
}

interface CertificateRequestClass {

    // Own fields of Gcr-3.Gcr.CertificateRequestClass

    parent_class: GObject.ObjectClass
}

abstract class CertificateRequestClass {

    // Own properties of Gcr-3.Gcr.CertificateRequestClass

    static name: string
}

interface CollectionIface {

    // Own fields of Gcr-3.Gcr.CollectionIface

    parent: GObject.TypeInterface
    added: (self: Collection, object: GObject.Object) => void
    removed: (self: Collection, object: GObject.Object) => void
    get_length: (self: Collection) => number
    get_objects: (self: Collection) => GObject.Object[]
    contains: (self: Collection, object: GObject.Object) => boolean
}

abstract class CollectionIface {

    // Own properties of Gcr-3.Gcr.CollectionIface

    static name: string
}

interface Column {

    // Own fields of Gcr-3.Gcr.Column

    property_name: string
    property_type: GObject.GType
    column_type: GObject.GType
    label: string
    flags: ColumnFlags
    transformer: GObject.ValueTransform
    user_data: object
}

class Column {

    // Own properties of Gcr-3.Gcr.Column

    static name: string
}

interface ComparableIface {

    // Own fields of Gcr-3.Gcr.ComparableIface

    /**
     * type interface
     * @field 
     */
    parent: GObject.TypeInterface
    compare: (self: Comparable, other: Comparable | null) => number
}

/**
 * The interface to implement for [iface`Comparable]`
 * @record 
 */
abstract class ComparableIface {

    // Own properties of Gcr-3.Gcr.ComparableIface

    static name: string
}

interface FilterCollectionClass {

    // Own fields of Gcr-3.Gcr.FilterCollectionClass

    /**
     * the parent class
     * @field 
     */
    parent_class: GObject.ObjectClass
}

/**
 * The class struct for [class`FilterCollection]`.
 * @record 
 */
abstract class FilterCollectionClass {

    // Own properties of Gcr-3.Gcr.FilterCollectionClass

    static name: string
}

interface FilterCollectionPrivate {
}

class FilterCollectionPrivate {

    // Own properties of Gcr-3.Gcr.FilterCollectionPrivate

    static name: string
}

interface ImportInteractionIface {

    // Own fields of Gcr-3.Gcr.ImportInteractionIface

    /**
     * parent interface
     * @field 
     */
    parent: GObject.TypeInterface
    supplement_prep: (interaction: ImportInteraction, builder: Gck.Builder) => void
    supplement: (interaction: ImportInteraction, builder: Gck.Builder, cancellable: Gio.Cancellable | null) => Gio.TlsInteractionResult
    supplement_async: (interaction: ImportInteraction, builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    supplement_finish: (interaction: ImportInteraction, result: Gio.AsyncResult) => Gio.TlsInteractionResult
}

/**
 * Interface implemented by implementations of [iface`ImportInteraction]`.
 * @record 
 */
abstract class ImportInteractionIface {

    // Own properties of Gcr-3.Gcr.ImportInteractionIface

    static name: string
}

interface ImporterIface {

    // Own fields of Gcr-3.Gcr.ImporterIface

    /**
     * parent interface
     * @field 
     */
    parent: GObject.TypeInterface
    queue_for_parsed: (importer: Importer, parsed: Parsed) => boolean
    import_sync: (importer: Importer, cancellable: Gio.Cancellable | null) => boolean
    import_async: (importer: Importer, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    import_finish: (importer: Importer, result: Gio.AsyncResult) => boolean
}

/**
 * Interface implemented for a #GcrImporter.
 * @record 
 */
abstract class ImporterIface {

    // Own properties of Gcr-3.Gcr.ImporterIface

    static name: string
}

interface Parsed {

    // Owm methods of Gcr-3.Gcr.Parsed

    /**
     * Get the attributes which make up the parsed item.
     */
    get_attributes(): Gck.Attributes | null
    /**
     * Get the raw data block for the parsed item.
     */
    get_bytes(): GLib.Bytes
    /**
     * Get the raw data block for the parsed item.
     */
    get_data(): Uint8Array | null
    /**
     * Get the descirption for a parsed item.
     */
    get_description(): string | null
    /**
     * Get the filename of the parsed item.
     */
    get_filename(): string
    /**
     * Get the format of the parsed item.
     */
    get_format(): DataFormat
    /**
     * Get the label for the parsed item.
     */
    get_label(): string | null
    /**
     * Add a reference to a parsed item. An item may not be shared across threads
     * until it has been referenced at least once.
     */
    ref(): Parsed
}

/**
 * A parsed item parsed by a #GcrParser.
 * @record 
 */
class Parsed {

    // Own properties of Gcr-3.Gcr.Parsed

    static name: string

    // Constructors of Gcr-3.Gcr.Parsed

    /**
     * Unreferences a parsed item which was referenced with gcr_parsed_ref()
     * @param parsed a parsed item
     */
    static unref(parsed: object | null): void
}

interface ParserClass {

    // Own fields of Gcr-3.Gcr.ParserClass

    /**
     * The parent class
     * @field 
     */
    parent_class: GObject.ObjectClass
    authenticate: (self: Parser, count: number) => boolean
    parsed: (self: Parser) => void
}

/**
 * The class for #GcrParser
 * @record 
 */
abstract class ParserClass {

    // Own properties of Gcr-3.Gcr.ParserClass

    static name: string
}

interface ParserPrivate {
}

class ParserPrivate {

    // Own properties of Gcr-3.Gcr.ParserPrivate

    static name: string
}

interface Pkcs11CertificateClass {
}

abstract class Pkcs11CertificateClass {

    // Own properties of Gcr-3.Gcr.Pkcs11CertificateClass

    static name: string
}

interface Pkcs11CertificatePrivate {
}

class Pkcs11CertificatePrivate {

    // Own properties of Gcr-3.Gcr.Pkcs11CertificatePrivate

    static name: string
}

interface PromptIface {

    // Own fields of Gcr-3.Gcr.PromptIface

    /**
     * parent interface
     * @field 
     */
    parent_iface: GObject.TypeInterface
    prompt_password_async: (prompt: Prompt, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    prompt_password_finish: (prompt: Prompt, result: Gio.AsyncResult) => string
    prompt_confirm_async: (prompt: Prompt, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    prompt_confirm_finish: (prompt: Prompt, result: Gio.AsyncResult) => PromptReply
    prompt_close: (prompt: Prompt) => void
}

/**
 * The interface for implementing [class`Prompt]`.
 * @record 
 */
abstract class PromptIface {

    // Own properties of Gcr-3.Gcr.PromptIface

    static name: string
}

interface SecretExchangeClass {

    // Own fields of Gcr-3.Gcr.SecretExchangeClass

    generate_exchange_key: (exchange: SecretExchange, scheme: string, public_key: number, n_public_key: number) => boolean
    derive_transport_key: (exchange: SecretExchange, peer: number, n_peer: number) => boolean
}

abstract class SecretExchangeClass {

    // Own properties of Gcr-3.Gcr.SecretExchangeClass

    static name: string
}

interface SecretExchangePrivate {
}

class SecretExchangePrivate {

    // Own properties of Gcr-3.Gcr.SecretExchangePrivate

    static name: string
}

interface SimpleCertificateClass {

    // Own fields of Gcr-3.Gcr.SimpleCertificateClass

    parent_class: GObject.ObjectClass
}

abstract class SimpleCertificateClass {

    // Own properties of Gcr-3.Gcr.SimpleCertificateClass

    static name: string
}

interface SimpleCertificatePrivate {
}

class SimpleCertificatePrivate {

    // Own properties of Gcr-3.Gcr.SimpleCertificatePrivate

    static name: string
}

interface SimpleCollectionClass {

    // Own fields of Gcr-3.Gcr.SimpleCollectionClass

    parent_class: GObject.ObjectClass
}

abstract class SimpleCollectionClass {

    // Own properties of Gcr-3.Gcr.SimpleCollectionClass

    static name: string
}

interface SimpleCollectionPrivate {
}

class SimpleCollectionPrivate {

    // Own properties of Gcr-3.Gcr.SimpleCollectionPrivate

    static name: string
}

interface SshAskpassClass {

    // Own fields of Gcr-3.Gcr.SshAskpassClass

    parent_class: GObject.ObjectClass
}

abstract class SshAskpassClass {

    // Own properties of Gcr-3.Gcr.SshAskpassClass

    static name: string
}

interface SystemPromptClass {

    // Own fields of Gcr-3.Gcr.SystemPromptClass

    parent_class: GObject.ObjectClass
}

abstract class SystemPromptClass {

    // Own properties of Gcr-3.Gcr.SystemPromptClass

    static name: string
}

interface SystemPromptPrivate {
}

class SystemPromptPrivate {

    // Own properties of Gcr-3.Gcr.SystemPromptPrivate

    static name: string
}

interface SystemPrompterClass {

    // Own fields of Gcr-3.Gcr.SystemPrompterClass

    /**
     * parent class
     * @field 
     */
    parent_class: GObject.ObjectClass
}

/**
 * The class for #GcrSystemPrompter.
 * @record 
 */
abstract class SystemPrompterClass {

    // Own properties of Gcr-3.Gcr.SystemPrompterClass

    static name: string
}

interface SystemPrompterPrivate {
}

class SystemPrompterPrivate {

    // Own properties of Gcr-3.Gcr.SystemPrompterPrivate

    static name: string
}

interface UnionCollectionClass {

    // Own fields of Gcr-3.Gcr.UnionCollectionClass

    parent_class: GObject.ObjectClass
}

abstract class UnionCollectionClass {

    // Own properties of Gcr-3.Gcr.UnionCollectionClass

    static name: string
}

interface UnionCollectionPrivate {
}

class UnionCollectionPrivate {

    // Own properties of Gcr-3.Gcr.UnionCollectionPrivate

    static name: string
}

}
export default Gcr;