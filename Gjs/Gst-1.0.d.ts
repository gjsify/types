/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * Gst-1.0
 */

import type * as Gjs from './Gjs';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';
import type GModule from './GModule-2.0';

export namespace Gst {

/**
 * The different types of buffering methods.
 */
enum BufferingMode {
    /**
     * a small amount of data is buffered
     */
    STREAM,
    /**
     * the stream is being downloaded
     */
    DOWNLOAD,
    /**
     * the stream is being downloaded in a ringbuffer
     */
    TIMESHIFT,
    /**
     * the stream is a live stream
     */
    LIVE,
}
/**
 * The result values for a GstBusSyncHandler.
 */
enum BusSyncReply {
    /**
     * drop the message
     */
    DROP,
    /**
     * pass the message to the async queue
     */
    PASS,
    /**
     * pass message to async queue, continue if message is handled
     */
    ASYNC,
}
/**
 * Modes of caps intersection
 * 
 * %GST_CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps
 * by iterating on the caps' structures as the following matrix shows:
 * 
 * ```
 *          caps1
 *       +-------------
 *       | 1  2  4  7
 * caps2 | 3  5  8 10
 *       | 6  9 11 12
 * ```
 * 
 * Used when there is no explicit precedence of one caps over the other. e.g.
 * tee's sink pad getcaps function, it will probe its src pad peers' for their
 * caps and intersect them with this mode.
 * 
 * %GST_CAPS_INTERSECT_FIRST is useful when an element wants to preserve
 * another element's caps priority order when intersecting with its own caps.
 * Example: If caps1 is `[A, B, C]` and caps2 is `[E, B, D, A]`, the result
 * would be `[A, B]`, maintaining the first caps priority on the intersection.
 */
enum CapsIntersectMode {
    /**
     * Zig-zags over both caps.
     */
    ZIG_ZAG,
    /**
     * Keeps the first caps order.
     */
    FIRST,
}
/**
 * The type of the clock entry
 */
enum ClockEntryType {
    /**
     * a single shot timeout
     */
    SINGLE,
    /**
     * a periodic timeout request
     */
    PERIODIC,
}
/**
 * The return value of a clock operation.
 */
enum ClockReturn {
    /**
     * The operation succeeded.
     */
    OK,
    /**
     * The operation was scheduled too late.
     */
    EARLY,
    /**
     * The clockID was unscheduled
     */
    UNSCHEDULED,
    /**
     * The ClockID is busy
     */
    BUSY,
    /**
     * A bad time was provided to a function.
     */
    BADTIME,
    /**
     * An error occurred
     */
    ERROR,
    /**
     * Operation is not supported
     */
    UNSUPPORTED,
    /**
     * The ClockID is done waiting
     */
    DONE,
}
/**
 * The different kind of clocks.
 */
enum ClockType {
    /**
     * time since Epoch
     */
    REALTIME,
    /**
     * monotonic time since some unspecified starting
     *                            point
     */
    MONOTONIC,
    /**
     * some other time source is used (Since: 1.0.5)
     */
    OTHER,
    /**
     * time since Epoch, but using International Atomic Time
     *                      as reference (Since: 1.18)
     */
    TAI,
}
/**
 * Core errors are errors inside the core GStreamer library.
 */
enum CoreError {
    /**
     * a general error which doesn't fit in any other
     * category.  Make sure you add a custom message to the error call.
     */
    FAILED,
    /**
     * do not use this except as a placeholder for
     * deciding where to go while developing code.
     */
    TOO_LAZY,
    /**
     * use this when you do not want to implement
     * this functionality yet.
     */
    NOT_IMPLEMENTED,
    /**
     * used for state change errors.
     */
    STATE_CHANGE,
    /**
     * used for pad-related errors.
     */
    PAD,
    /**
     * used for thread-related errors.
     */
    THREAD,
    /**
     * used for negotiation-related errors.
     */
    NEGOTIATION,
    /**
     * used for event-related errors.
     */
    EVENT,
    /**
     * used for seek-related errors.
     */
    SEEK,
    /**
     * used for caps-related errors.
     */
    CAPS,
    /**
     * used for negotiation-related errors.
     */
    TAG,
    /**
     * used if a plugin is missing.
     */
    MISSING_PLUGIN,
    /**
     * used for clock related errors.
     */
    CLOCK,
    /**
     * used if functionality has been disabled at
     *                           compile time.
     */
    DISABLED,
    /**
     * the number of core error types.
     */
    NUM_ERRORS,
}
enum DebugColorMode {
    /**
     * Do not use colors in logs.
     */
    OFF,
    /**
     * Paint logs in a platform-specific way.
     */
    ON,
    /**
     * Paint logs with UNIX terminal color codes
     *                             no matter what platform GStreamer is running on.
     */
    UNIX,
}
/**
 * The level defines the importance of a debugging message. The more important a
 * message is, the greater the probability that the debugging system outputs it.
 */
enum DebugLevel {
    /**
     * No debugging level specified or desired. Used to deactivate
     *  debugging output.
     */
    NONE,
    /**
     * Error messages are to be used only when an error occurred
     *  that stops the application from keeping working correctly.
     *  An examples is gst_element_error, which outputs a message with this priority.
     *  It does not mean that the application is terminating as with g_error.
     */
    ERROR,
    /**
     * Warning messages are to inform about abnormal behaviour
     *  that could lead to problems or weird behaviour later on. An example of this
     *  would be clocking issues ("your computer is pretty slow") or broken input
     *  data ("Can't synchronize to stream.")
     */
    WARNING,
    /**
     * Fixme messages are messages that indicate that something
     *  in the executed code path is not fully implemented or handled yet. Note
     *  that this does not replace proper error handling in any way, the purpose
     *  of this message is to make it easier to spot incomplete/unfinished pieces
     *  of code when reading the debug log.
     */
    FIXME,
    /**
     * Informational messages should be used to keep the developer
     *  updated about what is happening.
     *  Examples where this should be used are when a typefind function has
     *  successfully determined the type of the stream or when an mp3 plugin detects
     *  the format to be used. ("This file has mono sound.")
     */
    INFO,
    /**
     * Debugging messages should be used when something common
     *  happens that is not the expected default behavior, or something that's
     *  useful to know but doesn't happen all the time (ie. per loop iteration or
     *  buffer processed or event handled).
     *  An example would be notifications about state changes or receiving/sending
     *  of events.
     */
    DEBUG,
    /**
     * Log messages are messages that are very common but might be
     *  useful to know. As a rule of thumb a pipeline that is running as expected
     *  should never output anything else but LOG messages whilst processing data.
     *  Use this log level to log recurring information in chain functions and
     *  loop functions, for example.
     */
    LOG,
    /**
     * Tracing-related messages.
     *  Examples for this are referencing/dereferencing of objects.
     */
    TRACE,
    /**
     * memory dump messages are used to log (small) chunks of
     *  data as memory dumps in the log. They will be displayed as hexdump with
     *  ASCII characters.
     */
    MEMDUMP,
    /**
     * The number of defined debugging levels.
     */
    COUNT,
}
/**
 * #GstEventType lists the standard event types that can be sent in a pipeline.
 * 
 * The custom event types can be used for private messages between elements
 * that can't be expressed using normal
 * GStreamer buffer passing semantics. Custom events carry an arbitrary
 * #GstStructure.
 * Specific custom events are distinguished by the name of the structure.
 */
enum EventType {
    /**
     * unknown event.
     */
    UNKNOWN,
    /**
     * Start a flush operation. This event clears all data
     *                 from the pipeline and unblock all streaming threads.
     */
    FLUSH_START,
    /**
     * Stop a flush operation. This event resets the
     *                 running-time of the pipeline.
     */
    FLUSH_STOP,
    /**
     * Event to mark the start of a new stream. Sent before any
     *                 other serialized event and only sent at the start of a new stream,
     *                 not after flushing seeks.
     */
    STREAM_START,
    /**
     * #GstCaps event. Notify the pad of a new media type.
     */
    CAPS,
    /**
     * A new media segment follows in the dataflow. The
     *                 segment events contains information for clipping buffers and
     *                 converting buffer timestamps to running-time and
     *                 stream-time.
     */
    SEGMENT,
    /**
     * A new #GstStreamCollection is available (Since: 1.10)
     */
    STREAM_COLLECTION,
    /**
     * A new set of metadata tags has been found in the stream.
     */
    TAG,
    /**
     * Notification of buffering requirements. Currently not
     *                 used yet.
     */
    BUFFERSIZE,
    /**
     * An event that sinks turn into a message. Used to
     *                          send messages that should be emitted in sync with
     *                          rendering.
     */
    SINK_MESSAGE,
    /**
     * Indicates that there is no more data for
     *                 the stream group ID in the message. Sent before EOS
     *                 in some instances and should be handled mostly the same. (Since: 1.10)
     */
    STREAM_GROUP_DONE,
    /**
     * End-Of-Stream. No more data is to be expected to follow
     *                 without either a STREAM_START event, or a FLUSH_STOP and a SEGMENT
     *                 event.
     */
    EOS,
    /**
     * An event which indicates that a new table of contents (TOC)
     *                 was found or updated.
     */
    TOC,
    /**
     * An event which indicates that new or updated
     *                 encryption information has been found in the stream.
     */
    PROTECTION,
    /**
     * Marks the end of a segment playback.
     */
    SEGMENT_DONE,
    /**
     * Marks a gap in the datastream.
     */
    GAP,
    /**
     * Notify downstream that a playback rate override
     *                                 should be applied as soon as possible. (Since: 1.18)
     */
    INSTANT_RATE_CHANGE,
    /**
     * A quality message. Used to indicate to upstream elements
     *                 that the downstream elements should adjust their processing
     *                 rate.
     */
    QOS,
    /**
     * A request for a new playback position and rate.
     */
    SEEK,
    /**
     * Navigation events are usually used for communicating
     *                        user requests, such as mouse or keyboard movements,
     *                        to upstream elements.
     */
    NAVIGATION,
    /**
     * Notification of new latency adjustment. Sinks will use
     *                     the latency information to adjust their synchronisation.
     */
    LATENCY,
    /**
     * A request for stepping through the media. Sinks will usually
     *                  execute the step operation.
     */
    STEP,
    /**
     * A request for upstream renegotiating caps and reconfiguring.
     */
    RECONFIGURE,
    /**
     * A request for a new playback position based on TOC
     *                        entry's UID.
     */
    TOC_SELECT,
    /**
     * A request to select one or more streams (Since: 1.10)
     */
    SELECT_STREAMS,
    /**
     * Sent by the pipeline to notify elements that handle the
     *                                    instant-rate-change event about the running-time when
     *                                    the rate multiplier should be applied (or was applied). (Since: 1.18)
     */
    INSTANT_RATE_SYNC_TIME,
    /**
     * Upstream custom event
     */
    CUSTOM_UPSTREAM,
    /**
     * Downstream custom event that travels in the
     *                        data flow.
     */
    CUSTOM_DOWNSTREAM,
    /**
     * Custom out-of-band downstream event.
     */
    CUSTOM_DOWNSTREAM_OOB,
    /**
     * Custom sticky downstream event.
     */
    CUSTOM_DOWNSTREAM_STICKY,
    /**
     * Custom upstream or downstream event.
     *                         In-band when travelling downstream.
     */
    CUSTOM_BOTH,
    /**
     * Custom upstream or downstream out-of-band event.
     */
    CUSTOM_BOTH_OOB,
}
/**
 * The result of passing data to a pad.
 * 
 * Note that the custom return values should not be exposed outside of the
 * element scope.
 */
enum FlowReturn {
    /**
     * Pre-defined custom success code.
     */
    CUSTOM_SUCCESS_2,
    /**
     * Pre-defined custom success code (define your
     *                               custom success code to this to avoid compiler
     *                               warnings).
     */
    CUSTOM_SUCCESS_1,
    /**
     * Elements can use values starting from
     *                               this (and higher) to define custom success
     *                               codes.
     */
    CUSTOM_SUCCESS,
    /**
     * Data passing was ok.
     */
    OK,
    /**
     * Pad is not linked.
     */
    NOT_LINKED,
    /**
     * Pad is flushing.
     */
    FLUSHING,
    /**
     * Pad is EOS.
     */
    EOS,
    /**
     * Pad is not negotiated.
     */
    NOT_NEGOTIATED,
    /**
     * Some (fatal) error occurred. Element generating
     *                               this error should post an error message using
     *                               GST_ELEMENT_ERROR() with more details.
     */
    ERROR,
    /**
     * This operation is not supported.
     */
    NOT_SUPPORTED,
    /**
     * Elements can use values starting from
     *                               this (and lower) to define custom error codes.
     */
    CUSTOM_ERROR,
    /**
     * Pre-defined custom error code (define your
     *                               custom error code to this to avoid compiler
     *                               warnings).
     */
    CUSTOM_ERROR_1,
    /**
     * Pre-defined custom error code.
     */
    CUSTOM_ERROR_2,
}
/**
 * Standard predefined formats
 */
enum Format {
    /**
     * undefined format
     */
    UNDEFINED,
    /**
     * the default format of the pad/element. This can be
     *    samples for raw audio, frames/fields for raw video (some, but not all,
     *    elements support this; use `GST_FORMAT_TIME` if you don't have a good
     *    reason to query for samples/frames)
     */
    DEFAULT,
    /**
     * bytes
     */
    BYTES,
    /**
     * time in nanoseconds
     */
    TIME,
    /**
     * buffers (few, if any, elements implement this as of
     *     May 2009)
     */
    BUFFERS,
    /**
     * percentage of stream (few, if any, elements implement
     *     this as of May 2009)
     */
    PERCENT,
}
/**
 * The result of a #GstIteratorItemFunction.
 */
enum IteratorItem {
    /**
     * Skip this item
     */
    SKIP,
    /**
     * Return item
     */
    PASS,
    /**
     * Stop after this item.
     */
    END,
}
/**
 * The result of gst_iterator_next().
 */
enum IteratorResult {
    /**
     * No more items in the iterator
     */
    DONE,
    /**
     * An item was retrieved
     */
    OK,
    /**
     * Datastructure changed while iterating
     */
    RESYNC,
    /**
     * An error happened
     */
    ERROR,
}
/**
 * Library errors are for errors from the library being used by elements
 * (initializing, finalizing, settings, ...)
 */
enum LibraryError {
    /**
     * a general error which doesn't fit in any other
     * category.  Make sure you add a custom message to the error call.
     */
    FAILED,
    /**
     * do not use this except as a placeholder for
     * deciding where to go while developing code.
     */
    TOO_LAZY,
    /**
     * used when the library could not be opened.
     */
    INIT,
    /**
     * used when the library could not be closed.
     */
    SHUTDOWN,
    /**
     * used when the library doesn't accept settings.
     */
    SETTINGS,
    /**
     * used when the library generated an encoding error.
     */
    ENCODE,
    /**
     * the number of library error types.
     */
    NUM_ERRORS,
}
/**
 * The direction of a pad.
 */
enum PadDirection {
    /**
     * direction is unknown.
     */
    UNKNOWN,
    /**
     * the pad is a source pad.
     */
    SRC,
    /**
     * the pad is a sink pad.
     */
    SINK,
}
/**
 * Result values from gst_pad_link and friends.
 */
enum PadLinkReturn {
    /**
     * link succeeded
     */
    OK,
    /**
     * pads have no common grandparent
     */
    WRONG_HIERARCHY,
    /**
     * pad was already linked
     */
    WAS_LINKED,
    /**
     * pads have wrong direction
     */
    WRONG_DIRECTION,
    /**
     * pads do not have common format
     */
    NOFORMAT,
    /**
     * pads cannot cooperate in scheduling
     */
    NOSCHED,
    /**
     * refused for some reason
     */
    REFUSED,
}
/**
 * The status of a GstPad. After activating a pad, which usually happens when the
 * parent element goes from READY to PAUSED, the GstPadMode defines if the
 * pad operates in push or pull mode.
 */
enum PadMode {
    /**
     * Pad will not handle dataflow
     */
    NONE,
    /**
     * Pad handles dataflow in downstream push mode
     */
    PUSH,
    /**
     * Pad handles dataflow in upstream pull mode
     */
    PULL,
}
/**
 * Indicates when this pad will become available.
 */
enum PadPresence {
    /**
     * the pad is always available
     */
    ALWAYS,
    /**
     * the pad will become available depending on the media stream
     */
    SOMETIMES,
    /**
     * the pad is only available on request with
     *  gst_element_request_pad().
     */
    REQUEST,
}
/**
 * Different return values for the #GstPadProbeCallback.
 */
enum PadProbeReturn {
    /**
     * drop data in data probes. For push mode this means that
     *        the data item is not sent downstream. For pull mode, it means that
     *        the data item is not passed upstream. In both cases, no other probes
     *        are called for this item and %GST_FLOW_OK or %TRUE is returned to the
     *        caller.
     */
    DROP,
    /**
     * normal probe return value. This leaves the probe in
     *        place, and defers decisions about dropping or passing data to other
     *        probes, if any. If there are no other probes, the default behaviour
     *        for the probe type applies ('block' for blocking probes,
     *        and 'pass' for non-blocking probes).
     */
    OK,
    /**
     * remove this probe, passing the data. For blocking probes
     *        this will cause data flow to unblock, unless there are also other
     *        blocking probes installed.
     */
    REMOVE,
    /**
     * pass the data item in the block probe and block on the
     *        next item. Note, that if there are multiple pad probes installed and
     *        any probe returns PASS, the data will be passed.
     */
    PASS,
    /**
     * Data has been handled in the probe and will not be
     *        forwarded further. For events and buffers this is the same behaviour as
     *        %GST_PAD_PROBE_DROP (except that in this case you need to unref the buffer
     *        or event yourself). For queries it will also return %TRUE to the caller.
     *        The probe can also modify the #GstFlowReturn value by using the
     *        #GST_PAD_PROBE_INFO_FLOW_RETURN() accessor.
     *        Note that the resulting query must contain valid entries.
     *        Since: 1.6
     */
    HANDLED,
}
/**
 * The different parsing errors that can occur.
 */
enum ParseError {
    /**
     * A syntax error occurred.
     */
    SYNTAX,
    /**
     * The description contained an unknown element
     */
    NO_SUCH_ELEMENT,
    /**
     * An element did not have a specified property
     */
    NO_SUCH_PROPERTY,
    /**
     * There was an error linking two pads.
     */
    LINK,
    /**
     * There was an error setting a property
     */
    COULD_NOT_SET_PROPERTY,
    /**
     * An empty bin was specified.
     */
    EMPTY_BIN,
    /**
     * An empty description was specified
     */
    EMPTY,
    /**
     * A delayed link did not get resolved.
     */
    DELAYED_LINK,
}
/**
 * The plugin loading errors
 */
enum PluginError {
    /**
     * The plugin could not be loaded
     */
    MODULE,
    /**
     * The plugin has unresolved dependencies
     */
    DEPENDENCIES,
    /**
     * The plugin has already be loaded from a different file
     */
    NAME_MISMATCH,
}
/**
 * The type of a %GST_MESSAGE_PROGRESS. The progress messages inform the
 * application of the status of asynchronous tasks.
 */
enum ProgressType {
    /**
     * A new task started.
     */
    START,
    /**
     * A task completed and a new one continues.
     */
    CONTINUE,
    /**
     * A task completed.
     */
    COMPLETE,
    /**
     * A task was canceled.
     */
    CANCELED,
    /**
     * A task caused an error. An error message is also
     *          posted on the bus.
     */
    ERROR,
}
/**
 * The result of a #GstPromise
 */
enum PromiseResult {
    /**
     * Initial state. Waiting for transition to any
     * 	other state.
     */
    PENDING,
    /**
     * Interrupted by the consumer as it doesn't
     * 	want the value anymore.
     */
    INTERRUPTED,
    /**
     * A producer marked a reply
     */
    REPLIED,
    /**
     * The promise expired (the carrying object
     * 	lost all refs) and the promise will never be fulfilled.
     */
    EXPIRED,
}
/**
 * The different types of QoS events that can be given to the
 * gst_event_new_qos() method.
 */
enum QOSType {
    /**
     * The QoS event type that is produced when upstream
     *    elements are producing data too quickly and the element can't keep up
     *    processing the data. Upstream should reduce their production rate. This
     *    type is also used when buffers arrive early or in time.
     */
    OVERFLOW,
    /**
     * The QoS event type that is produced when upstream
     *    elements are producing data too slowly and need to speed up their
     *    production rate.
     */
    UNDERFLOW,
    /**
     * The QoS event type that is produced when the
     *    application enabled throttling to limit the data rate.
     */
    THROTTLE,
}
/**
 * Standard predefined Query types
 */
enum QueryType {
    /**
     * unknown query type
     */
    UNKNOWN,
    /**
     * current position in stream
     */
    POSITION,
    /**
     * total duration of the stream
     */
    DURATION,
    /**
     * latency of stream
     */
    LATENCY,
    /**
     * current jitter of stream
     */
    JITTER,
    /**
     * current rate of the stream
     */
    RATE,
    /**
     * seeking capabilities
     */
    SEEKING,
    /**
     * segment start/stop positions
     */
    SEGMENT,
    /**
     * convert values between formats
     */
    CONVERT,
    /**
     * query supported formats for convert
     */
    FORMATS,
    /**
     * query available media for efficient seeking.
     */
    BUFFERING,
    /**
     * a custom application or element defined query.
     */
    CUSTOM,
    /**
     * query the URI of the source or sink.
     */
    URI,
    /**
     * the buffer allocation properties
     */
    ALLOCATION,
    /**
     * the scheduling properties
     */
    SCHEDULING,
    /**
     * the accept caps query
     */
    ACCEPT_CAPS,
    /**
     * the caps query
     */
    CAPS,
    /**
     * wait till all serialized data is consumed downstream
     */
    DRAIN,
    /**
     * query the pipeline-local context from
     *     downstream or upstream (since 1.2)
     */
    CONTEXT,
    /**
     * the bitrate query (since 1.16)
     */
    BITRATE,
}
/**
 * Element priority ranks. Defines the order in which the autoplugger (or
 * similar rank-picking mechanisms, such as e.g. gst_element_make_from_uri())
 * will choose this element over an alternative one with the same function.
 * 
 * These constants serve as a rough guidance for defining the rank of a
 * #GstPluginFeature. Any value is valid, including values bigger than
 * `GST_RANK_PRIMARY`.
 */
enum Rank {
    /**
     * will be chosen last or not at all
     */
    NONE,
    /**
     * unlikely to be chosen
     */
    MARGINAL,
    /**
     * likely to be chosen
     */
    SECONDARY,
    /**
     * will be chosen first
     */
    PRIMARY,
}
/**
 * Resource errors are for any resource used by an element:
 * memory, files, network connections, process space, ...
 * They're typically used by source and sink elements.
 */
enum ResourceError {
    /**
     * a general error which doesn't fit in any other
     * category.  Make sure you add a custom message to the error call.
     */
    FAILED,
    /**
     * do not use this except as a placeholder for
     * deciding where to go while developing code.
     */
    TOO_LAZY,
    /**
     * used when the resource could not be found.
     */
    NOT_FOUND,
    /**
     * used when resource is busy.
     */
    BUSY,
    /**
     * used when resource fails to open for reading.
     */
    OPEN_READ,
    /**
     * used when resource fails to open for writing.
     */
    OPEN_WRITE,
    /**
     * used when resource cannot be opened for
     * both reading and writing, or either (but unspecified which).
     */
    OPEN_READ_WRITE,
    /**
     * used when the resource can't be closed.
     */
    CLOSE,
    /**
     * used when the resource can't be read from.
     */
    READ,
    /**
     * used when the resource can't be written to.
     */
    WRITE,
    /**
     * used when a seek on the resource fails.
     */
    SEEK,
    /**
     * used when a synchronize on the resource fails.
     */
    SYNC,
    /**
     * used when settings can't be manipulated on.
     */
    SETTINGS,
    /**
     * used when the resource has no space left.
     */
    NO_SPACE_LEFT,
    /**
     * used when the resource can't be opened
     *                                     due to missing authorization.
     *                                     (Since: 1.2.4)
     */
    NOT_AUTHORIZED,
    /**
     * the number of resource error types.
     */
    NUM_ERRORS,
}
/**
 * The different search modes.
 */
enum SearchMode {
    /**
     * Only search for exact matches.
     */
    EXACT,
    /**
     * Search for an exact match or the element just before.
     */
    BEFORE,
    /**
     * Search for an exact match or the element just after.
     */
    AFTER,
}
/**
 * The different types of seek events. When constructing a seek event with
 * gst_event_new_seek() or when doing gst_segment_do_seek ().
 */
enum SeekType {
    /**
     * no change in position is required
     */
    NONE,
    /**
     * absolute position is requested
     */
    SET,
    /**
     * relative position to duration is requested
     */
    END,
}
/**
 * The possible states an element can be in. States can be changed using
 * gst_element_set_state() and checked using gst_element_get_state().
 */
enum State {
    /**
     * no pending state.
     */
    VOID_PENDING,
    /**
     * the NULL state or initial state of an element.
     */
    NULL,
    /**
     * the element is ready to go to PAUSED.
     */
    READY,
    /**
     * the element is PAUSED, it is ready to accept and
     *                          process data. Sink elements however only accept one
     *                          buffer and then block.
     */
    PAUSED,
    /**
     * the element is PLAYING, the #GstClock is running and
     *                          the data is flowing.
     */
    PLAYING,
}
/**
 * These are the different state changes an element goes through.
 * %GST_STATE_NULL &rArr; %GST_STATE_PLAYING is called an upwards state change
 * and %GST_STATE_PLAYING &rArr; %GST_STATE_NULL a downwards state change.
 */
enum StateChange {
    /**
     * state change from NULL to READY.
     *   * The element must check if the resources it needs are available. Device
     *     sinks and -sources typically try to probe the device to constrain their
     *     caps.
     *   * The element opens the device (in case feature need to be probed).
     */
    NULL_TO_READY,
    /**
     * state change from READY to PAUSED.
     *   * The element pads are activated in order to receive data in PAUSED.
     *     Streaming threads are started.
     *   * Some elements might need to return %GST_STATE_CHANGE_ASYNC and complete
     *     the state change when they have enough information. It is a requirement
     *     for sinks to return %GST_STATE_CHANGE_ASYNC and complete the state change
     *     when they receive the first buffer or %GST_EVENT_EOS (preroll).
     *     Sinks also block the dataflow when in PAUSED.
     *   * A pipeline resets the running_time to 0.
     *   * Live sources return %GST_STATE_CHANGE_NO_PREROLL and don't generate data.
     */
    READY_TO_PAUSED,
    /**
     * state change from PAUSED to PLAYING.
     *   * Most elements ignore this state change.
     *   * The pipeline selects a #GstClock and distributes this to all the children
     *     before setting them to PLAYING. This means that it is only allowed to
     *     synchronize on the #GstClock in the PLAYING state.
     *   * The pipeline uses the #GstClock and the running_time to calculate the
     *     base_time. The base_time is distributed to all children when performing
     *     the state change.
     *   * Sink elements stop blocking on the preroll buffer or event and start
     *     rendering the data.
     *   * Sinks can post %GST_MESSAGE_EOS in the PLAYING state. It is not allowed
     *     to post %GST_MESSAGE_EOS when not in the PLAYING state.
     *   * While streaming in PAUSED or PLAYING elements can create and remove
     *     sometimes pads.
     *   * Live sources start generating data and return %GST_STATE_CHANGE_SUCCESS.
     */
    PAUSED_TO_PLAYING,
    /**
     * state change from PLAYING to PAUSED.
     *   * Most elements ignore this state change.
     *   * The pipeline calculates the running_time based on the last selected
     *     #GstClock and the base_time. It stores this information to continue
     *     playback when going back to the PLAYING state.
     *   * Sinks unblock any #GstClock wait calls.
     *   * When a sink does not have a pending buffer to play, it returns
     *     #GST_STATE_CHANGE_ASYNC from this state change and completes the state
     *     change when it receives a new buffer or an %GST_EVENT_EOS.
     *   * Any queued %GST_MESSAGE_EOS items are removed since they will be reposted
     *     when going back to the PLAYING state. The EOS messages are queued in
     *     #GstBin containers.
     *   * Live sources stop generating data and return %GST_STATE_CHANGE_NO_PREROLL.
     */
    PLAYING_TO_PAUSED,
    /**
     * state change from PAUSED to READY.
     *   * Sinks unblock any waits in the preroll.
     *   * Elements unblock any waits on devices
     *   * Chain or get_range functions return %GST_FLOW_FLUSHING.
     *   * The element pads are deactivated so that streaming becomes impossible and
     *     all streaming threads are stopped.
     *   * The sink forgets all negotiated formats
     *   * Elements remove all sometimes pads
     */
    PAUSED_TO_READY,
    /**
     * state change from READY to NULL.
     *   * Elements close devices
     *   * Elements reset any internal state.
     */
    READY_TO_NULL,
    /**
     * state change from NULL to NULL. (Since: 1.14)
     */
    NULL_TO_NULL,
    /**
     * state change from READY to READY,
     * This might happen when going to PAUSED asynchronously failed, in that case
     * elements should make sure they are in a proper, coherent READY state. (Since: 1.14)
     */
    READY_TO_READY,
    /**
     * state change from PAUSED to PAUSED.
     * This might happen when elements were in PLAYING state and 'lost state',
     * they should make sure to go back to real 'PAUSED' state (prerolling for example). (Since: 1.14)
     */
    PAUSED_TO_PAUSED,
    /**
     * state change from PLAYING to PLAYING. (Since: 1.14)
     */
    PLAYING_TO_PLAYING,
}
/**
 * The possible return values from a state change function such as
 * gst_element_set_state(). Only `GST_STATE_CHANGE_FAILURE` is a real failure.
 */
enum StateChangeReturn {
    /**
     * the state change failed
     */
    FAILURE,
    /**
     * the state change succeeded
     */
    SUCCESS,
    /**
     * the state change will happen asynchronously
     */
    ASYNC,
    /**
     * the state change succeeded but the element
     *                               cannot produce data in %GST_STATE_PAUSED.
     *                               This typically happens with live sources.
     */
    NO_PREROLL,
}
/**
 * Stream errors are for anything related to the stream being processed:
 * format errors, media type errors, ...
 * They're typically used by decoders, demuxers, converters, ...
 */
enum StreamError {
    /**
     * a general error which doesn't fit in any other
     * category.  Make sure you add a custom message to the error call.
     */
    FAILED,
    /**
     * do not use this except as a placeholder for
     * deciding where to go while developing code.
     */
    TOO_LAZY,
    /**
     * use this when you do not want to implement
     * this functionality yet.
     */
    NOT_IMPLEMENTED,
    /**
     * used when the element doesn't know the
     * stream's type.
     */
    TYPE_NOT_FOUND,
    /**
     * used when the element doesn't handle this type
     * of stream.
     */
    WRONG_TYPE,
    /**
     * used when there's no codec to handle the
     * stream's type.
     */
    CODEC_NOT_FOUND,
    /**
     * used when decoding fails.
     */
    DECODE,
    /**
     * used when encoding fails.
     */
    ENCODE,
    /**
     * used when demuxing fails.
     */
    DEMUX,
    /**
     * used when muxing fails.
     */
    MUX,
    /**
     * used when the stream is of the wrong format
     * (for example, wrong caps).
     */
    FORMAT,
    /**
     * used when the stream is encrypted and can't be
     * decrypted because this is not supported by the element.
     */
    DECRYPT,
    /**
     * used when the stream is encrypted and
     * can't be decrypted because no suitable key is available.
     */
    DECRYPT_NOKEY,
    /**
     * the number of stream error types.
     */
    NUM_ERRORS,
}
/**
 * The type of a %GST_MESSAGE_STREAM_STATUS. The stream status messages inform the
 * application of new streaming threads and their status.
 */
enum StreamStatusType {
    /**
     * A new thread need to be created.
     */
    CREATE,
    /**
     * a thread entered its loop function
     */
    ENTER,
    /**
     * a thread left its loop function
     */
    LEAVE,
    /**
     * a thread is destroyed
     */
    DESTROY,
    /**
     * a thread is started
     */
    START,
    /**
     * a thread is paused
     */
    PAUSE,
    /**
     * a thread is stopped
     */
    STOP,
}
/**
 * The type of a %GST_MESSAGE_STRUCTURE_CHANGE.
 */
enum StructureChangeType {
    /**
     * Pad linking is starting or done.
     */
    LINK,
    /**
     * Pad unlinking is starting or done.
     */
    UNLINK,
}
/**
 * Extra tag flags used when registering tags.
 */
enum TagFlag {
    /**
     * undefined flag
     */
    UNDEFINED,
    /**
     * tag is meta data
     */
    META,
    /**
     * tag is encoded
     */
    ENCODED,
    /**
     * tag is decoded
     */
    DECODED,
    /**
     * number of tag flags
     */
    COUNT,
}
/**
 * The different tag merging modes are basically replace, overwrite and append,
 * but they can be seen from two directions. Given two taglists: (A) the tags
 * already in the element and (B) the ones that are supplied to the element (
 * e.g. via gst_tag_setter_merge_tags() / gst_tag_setter_add_tags() or a
 * %GST_EVENT_TAG), how are these tags merged?
 * In the table below this is shown for the cases that a tag exists in the list
 * (A) or does not exists (!A) and combinations thereof.
 * 
 * | merge mode  | A + B | A + !B | !A + B | !A + !B |
 * | ----------- | ----- | ------ | ------ | ------- |
 * | REPLACE_ALL | B     | ø      | B      | ø       |
 * | REPLACE     | B     | A      | B      | ø       |
 * | APPEND      | A, B  | A      | B      | ø       |
 * | PREPEND     | B, A  | A      | B      | ø       |
 * | KEEP        | A     | A      | B      | ø       |
 * | KEEP_ALL    | A     | A      | ø      | ø       |
 */
enum TagMergeMode {
    /**
     * undefined merge mode
     */
    UNDEFINED,
    /**
     * replace all tags (clear list and append)
     */
    REPLACE_ALL,
    /**
     * replace tags
     */
    REPLACE,
    /**
     * append tags
     */
    APPEND,
    /**
     * prepend tags
     */
    PREPEND,
    /**
     * keep existing tags
     */
    KEEP,
    /**
     * keep all existing tags
     */
    KEEP_ALL,
    /**
     * the number of merge modes
     */
    COUNT,
}
/**
 * GstTagScope specifies if a taglist applies to the complete
 * medium or only to one single stream.
 */
enum TagScope {
    /**
     * tags specific to this single stream
     */
    STREAM,
    /**
     * global tags for the complete medium
     */
    GLOBAL,
}
/**
 * The different states a task can be in
 */
enum TaskState {
    /**
     * the task is started and running
     */
    STARTED,
    /**
     * the task is stopped
     */
    STOPPED,
    /**
     * the task is paused
     */
    PAUSED,
}
/**
 * The different types of TOC entries (see #GstTocEntry).
 * 
 * There are two types of TOC entries: alternatives or parts in a sequence.
 */
enum TocEntryType {
    /**
     * entry is an angle (i.e. an alternative)
     */
    ANGLE,
    /**
     * entry is a version (i.e. alternative)
     */
    VERSION,
    /**
     * entry is an edition (i.e. alternative)
     */
    EDITION,
    /**
     * invalid entry type value
     */
    INVALID,
    /**
     * entry is a title (i.e. a part of a sequence)
     */
    TITLE,
    /**
     * entry is a track (i.e. a part of a sequence)
     */
    TRACK,
    /**
     * entry is a chapter (i.e. a part of a sequence)
     */
    CHAPTER,
}
/**
 * How a #GstTocEntry should be repeated. By default, entries are played a
 * single time.
 */
enum TocLoopType {
    /**
     * single forward playback
     */
    NONE,
    /**
     * repeat forward
     */
    FORWARD,
    /**
     * repeat backward
     */
    REVERSE,
    /**
     * repeat forward and backward
     */
    PING_PONG,
}
/**
 * The scope of a TOC.
 */
enum TocScope {
    /**
     * global TOC representing all selectable options
     *     (this is what applications are usually interested in)
     */
    GLOBAL,
    /**
     * TOC for the currently active/selected stream
     *     (this is a TOC representing the current stream from start to EOS,
     *     and is what a TOC writer / muxer is usually interested in; it will
     *     usually be a subset of the global TOC, e.g. just the chapters of
     *     the current title, or the chapters selected for playback from the
     *     current title)
     */
    CURRENT,
}
/**
 * Tracing record will contain fields that contain a measured value or extra
 * meta-data. One such meta data are values that tell where a measurement was
 * taken. This enumerating declares to which scope such a meta data field
 * relates to. If it is e.g. %GST_TRACER_VALUE_SCOPE_PAD, then each of the log
 * events may contain values for different #GstPads.
 */
enum TracerValueScope {
    /**
     * the value is related to the process
     */
    PROCESS,
    /**
     * the value is related to a thread
     */
    THREAD,
    /**
     * the value is related to an #GstElement
     */
    ELEMENT,
    /**
     * the value is related to a #GstPad
     */
    PAD,
}
/**
 * The probability of the typefind function. Higher values have more certainty
 * in doing a reliable typefind.
 */
enum TypeFindProbability {
    /**
     * type undetected.
     */
    NONE,
    /**
     * unlikely typefind.
     */
    MINIMUM,
    /**
     * possible type detected.
     */
    POSSIBLE,
    /**
     * likely a type was detected.
     */
    LIKELY,
    /**
     * nearly certain that a type was detected.
     */
    NEARLY_CERTAIN,
    /**
     * very certain a type was detected.
     */
    MAXIMUM,
}
/**
 * Different URI-related errors that can occur.
 */
enum URIError {
    /**
     * The protocol is not supported
     */
    UNSUPPORTED_PROTOCOL,
    /**
     * There was a problem with the URI
     */
    BAD_URI,
    /**
     * Could not set or change the URI because the
     *     URI handler was in a state where that is not possible or not permitted
     */
    BAD_STATE,
    /**
     * There was a problem with the entity that
     *     the URI references
     */
    BAD_REFERENCE,
}
/**
 * The different types of URI direction.
 */
enum URIType {
    /**
     * The URI direction is unknown
     */
    UNKNOWN,
    /**
     * The URI is a consumer.
     */
    SINK,
    /**
     * The URI is a producer.
     */
    SRC,
}
/**
 * Flags for allocators.
 */
enum AllocatorFlags {
    /**
     * The allocator has a custom alloc function.
     */
    CUSTOM_ALLOC,
    /**
     * first flag that can be used for custom purposes
     */
    LAST,
}
/**
 * GstBinFlags are a set of flags specific to bins. Most are set/used
 * internally. They can be checked using the GST_OBJECT_FLAG_IS_SET() macro,
 * and (un)set using GST_OBJECT_FLAG_SET() and GST_OBJECT_FLAG_UNSET().
 */
enum BinFlags {
    /**
     * Don't resync a state change when elements are added or linked in the bin
     */
    NO_RESYNC,
    /**
     * Indicates whether the bin can handle elements that add/remove source pads
     * at any point in time without first posting a no-more-pads signal.
     */
    STREAMS_AWARE,
    /**
     * The last enum in the series of flags for bins. Derived classes can use this
     * as first value in a list of flags.
     */
    LAST,
}
/**
 * A set of flags that can be provided to the gst_buffer_copy_into()
 * function to specify which items should be copied.
 */
enum BufferCopyFlags {
    /**
     * copy nothing
     */
    NONE,
    /**
     * flag indicating that buffer flags should be copied
     */
    FLAGS,
    /**
     * flag indicating that buffer pts, dts,
     *   duration, offset and offset_end should be copied
     */
    TIMESTAMPS,
    /**
     * flag indicating that buffer meta should be
     *   copied
     */
    META,
    /**
     * flag indicating that buffer memory should be reffed
     *   and appended to already existing memory. Unless the memory is marked as
     *   NO_SHARE, no actual copy of the memory is made but it is simply reffed.
     *   Add `GST_BUFFER_COPY_DEEP` to force a real copy.
     */
    MEMORY,
    /**
     * flag indicating that buffer memory should be
     *   merged
     */
    MERGE,
    /**
     * flag indicating that memory should always be copied instead of reffed
     */
    DEEP,
}
/**
 * A set of buffer flags used to describe properties of a #GstBuffer.
 */
enum BufferFlags {
    /**
     * the buffer is live data and should be discarded in
     *                                 the PAUSED state.
     */
    LIVE,
    /**
     * the buffer contains data that should be dropped
     *                                 because it will be clipped against the segment
     *                                 boundaries or because it does not contain data
     *                                 that should be shown to the user.
     */
    DECODE_ONLY,
    /**
     * the buffer marks a data discontinuity in the stream.
     *                                 This typically occurs after a seek or a dropped buffer
     *                                 from a live or network source.
     */
    DISCONT,
    /**
     * the buffer timestamps might have a discontinuity
     *                                 and this buffer is a good point to resynchronize.
     */
    RESYNC,
    /**
     * the buffer data is corrupted.
     */
    CORRUPTED,
    /**
     * the buffer contains a media specific marker. for
     *                                 video this is the end of a frame boundary, for audio
     *                                 this is the start of a talkspurt. for RTP
     *                                 packets this matches the marker flag in the
     *                                 RTP packet header.
     */
    MARKER,
    /**
     * the buffer contains header information that is
     *                                 needed to decode the following data.
     */
    HEADER,
    /**
     * the buffer has been created to fill a gap in the
     *                                 stream and contains media neutral data (elements can
     *                                 switch to optimized code path that ignores the buffer
     *                                 content).
     */
    GAP,
    /**
     * the buffer can be dropped without breaking the
     *                                 stream, for example to reduce bandwidth.
     */
    DROPPABLE,
    /**
     * this unit cannot be decoded independently.
     */
    DELTA_UNIT,
    /**
     * this flag is set when memory of the buffer
     *                                 is added/removed
     */
    TAG_MEMORY,
    /**
     * Elements which write to disk or permanent storage should ensure the data
     * is synced after writing the contents of this buffer.
     */
    SYNC_AFTER,
    /**
     * This buffer is important and should not be dropped.
     * 
     * This can be used to mark important buffers, e.g. to flag RTP packets
     * carrying keyframes or codec setup data for RTP Forward Error Correction
     * purposes, or to prevent still video frames from being dropped by elements
     * due to QoS.
     */
    NON_DROPPABLE,
    /**
     * additional media specific flags can be added starting from
     *                                 this flag.
     */
    LAST,
}
/**
 * Additional flags to control the allocation of a buffer
 */
enum BufferPoolAcquireFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * buffer is keyframe
     */
    KEY_UNIT,
    /**
     * when the bufferpool is empty, acquire_buffer
     * will by default block until a buffer is released into the pool again. Setting
     * this flag makes acquire_buffer return #GST_FLOW_EOS instead of blocking.
     */
    DONTWAIT,
    /**
     * buffer is discont
     */
    DISCONT,
    /**
     * last flag, subclasses can use private flags
     *    starting from this value.
     */
    LAST,
}
/**
 * The standard flags that a bus may have.
 */
enum BusFlags {
    /**
     * The bus is currently dropping all messages
     */
    FLUSHING,
    /**
     * offset to define more flags
     */
    FLAG_LAST,
}
/**
 * Extra flags for a caps.
 */
enum CapsFlags {
    /**
     * Caps has no specific content, but can contain
     *    anything.
     */
    ANY,
}
/**
 * The capabilities of this clock
 */
enum ClockFlags {
    /**
     * clock can do a single sync timeout request
     */
    CAN_DO_SINGLE_SYNC,
    /**
     * clock can do a single async timeout request
     */
    CAN_DO_SINGLE_ASYNC,
    /**
     * clock can do sync periodic timeout requests
     */
    CAN_DO_PERIODIC_SYNC,
    /**
     * clock can do async periodic timeout callbacks
     */
    CAN_DO_PERIODIC_ASYNC,
    /**
     * clock's resolution can be changed
     */
    CAN_SET_RESOLUTION,
    /**
     * clock can be slaved to a master clock
     */
    CAN_SET_MASTER,
    /**
     * clock needs to be synced before it can be used
     */
    NEEDS_STARTUP_SYNC,
    /**
     * subclasses can add additional flags starting from this flag
     */
    LAST,
}
/**
 * These are some terminal style flags you can use when creating your
 * debugging categories to make them stand out in debugging output.
 */
enum DebugColorFlags {
    /**
     * Use black as foreground color.
     */
    FG_BLACK,
    /**
     * Use red as foreground color.
     */
    FG_RED,
    /**
     * Use green as foreground color.
     */
    FG_GREEN,
    /**
     * Use yellow as foreground color.
     */
    FG_YELLOW,
    /**
     * Use blue as foreground color.
     */
    FG_BLUE,
    /**
     * Use magenta as foreground color.
     */
    FG_MAGENTA,
    /**
     * Use cyan as foreground color.
     */
    FG_CYAN,
    /**
     * Use white as foreground color.
     */
    FG_WHITE,
    /**
     * Use black as background color.
     */
    BG_BLACK,
    /**
     * Use red as background color.
     */
    BG_RED,
    /**
     * Use green as background color.
     */
    BG_GREEN,
    /**
     * Use yellow as background color.
     */
    BG_YELLOW,
    /**
     * Use blue as background color.
     */
    BG_BLUE,
    /**
     * Use magenta as background color.
     */
    BG_MAGENTA,
    /**
     * Use cyan as background color.
     */
    BG_CYAN,
    /**
     * Use white as background color.
     */
    BG_WHITE,
    /**
     * Make the output bold.
     */
    BOLD,
    /**
     * Underline the output.
     */
    UNDERLINE,
}
/**
 * Available details for pipeline graphs produced by GST_DEBUG_BIN_TO_DOT_FILE()
 * and GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS().
 */
enum DebugGraphDetails {
    /**
     * show caps-name on edges
     */
    MEDIA_TYPE,
    /**
     * show caps-details on edges
     */
    CAPS_DETAILS,
    /**
     * show modified parameters on
     *                                           elements
     */
    NON_DEFAULT_PARAMS,
    /**
     * show element states
     */
    STATES,
    /**
     * show full element parameter values even
     *                                    if they are very long
     */
    FULL_PARAMS,
    /**
     * show all the typical details that one might want
     */
    ALL,
    /**
     * show all details regardless of how large or
     *                                verbose they make the resulting output
     */
    VERBOSE,
}
/**
 * The standard flags that an element may have.
 */
enum ElementFlags {
    /**
     * ignore state changes from parent
     */
    LOCKED_STATE,
    /**
     * the element is a sink
     */
    SINK,
    /**
     * the element is a source.
     */
    SOURCE,
    /**
     * the element can provide a clock
     */
    PROVIDE_CLOCK,
    /**
     * the element requires a clock
     */
    REQUIRE_CLOCK,
    /**
     * the element can use an index
     */
    INDEXABLE,
    /**
     * offset to define more flags
     */
    LAST,
}
/**
 * #GstEventTypeFlags indicate the aspects of the different #GstEventType
 * values. You can get the type flags of a #GstEventType with the
 * gst_event_type_get_flags() function.
 */
enum EventTypeFlags {
    /**
     * Set if the event can travel upstream.
     */
    UPSTREAM,
    /**
     * Set if the event can travel downstream.
     */
    DOWNSTREAM,
    /**
     * Set if the event should be serialized with data
     *                               flow.
     */
    SERIALIZED,
    /**
     * Set if the event is sticky on the pads.
     */
    STICKY,
    /**
     * Multiple sticky events can be on a pad, each
     *                               identified by the event name.
     */
    STICKY_MULTI,
}
/**
 * The different flags that can be set on #GST_EVENT_GAP events. See
 * gst_event_set_gap_flags() for details.
 */
enum GapFlags {
    /**
     * The #GST_EVENT_GAP signals missing data,
     *    for example because of packet loss.
     */
    DATA,
}
/**
 * Flags used when locking miniobjects
 */
enum LockFlags {
    /**
     * lock for read access
     */
    READ,
    /**
     * lock for write access
     */
    WRITE,
    /**
     * lock for exclusive access
     */
    EXCLUSIVE,
    /**
     * first flag that can be used for custom purposes
     */
    LAST,
}
/**
 * Flags used when mapping memory
 */
enum MapFlags {
    /**
     * map for read access
     */
    READ,
    /**
     * map for write access
     */
    WRITE,
    /**
     * first flag that can be used for custom purposes
     */
    FLAG_LAST,
}
/**
 * Flags for wrapped memory.
 */
enum MemoryFlags {
    /**
     * memory is readonly. It is not allowed to map the
     * memory with #GST_MAP_WRITE.
     */
    READONLY,
    /**
     * memory must not be shared. Copies will have to be
     * made when this memory needs to be shared between buffers. (DEPRECATED:
     * do not use in new code, instead you should create a custom GstAllocator for
     * memory pooling instead of relying on the GstBuffer they were originally
     * attached to.)
     */
    NO_SHARE,
    /**
     * the memory prefix is filled with 0 bytes
     */
    ZERO_PREFIXED,
    /**
     * the memory padding is filled with 0 bytes
     */
    ZERO_PADDED,
    /**
     * the memory is physically
     * contiguous. (Since: 1.2)
     */
    PHYSICALLY_CONTIGUOUS,
    /**
     * the memory can't be mapped via
     * gst_memory_map() without any preconditions. (Since: 1.2)
     */
    NOT_MAPPABLE,
    /**
     * first flag that can be used for custom purposes
     */
    LAST,
}
/**
 * The different message types that are available.
 */
enum MessageType {
    /**
     * an undefined message
     */
    UNKNOWN,
    /**
     * end-of-stream reached in a pipeline. The application will
     * only receive this message in the PLAYING state and every time it sets a
     * pipeline to PLAYING that is in the EOS state. The application can perform a
     * flushing seek in the pipeline, which will undo the EOS state again.
     */
    EOS,
    /**
     * an error occurred. When the application receives an error
     * message it should stop playback of the pipeline and not assume that more
     * data will be played. It is possible to specify a redirection url to the error
     * messages by setting a `redirect-location` field into the error message, application
     * or high level bins might use the information as required.
     */
    ERROR,
    /**
     * a warning occurred.
     */
    WARNING,
    /**
     * an info message occurred
     */
    INFO,
    /**
     * a tag was found.
     */
    TAG,
    /**
     * the pipeline is buffering. When the application
     * receives a buffering message in the PLAYING state for a non-live pipeline it
     * must PAUSE the pipeline until the buffering completes, when the percentage
     * field in the message is 100%. For live pipelines, no action must be
     * performed and the buffering percentage can be used to inform the user about
     * the progress.
     */
    BUFFERING,
    /**
     * a state change happened
     */
    STATE_CHANGED,
    /**
     * an element changed state in a streaming thread.
     * This message is deprecated.
     */
    STATE_DIRTY,
    /**
     * a stepping operation finished.
     */
    STEP_DONE,
    /**
     * an element notifies its capability of providing
     *                             a clock. This message is used internally and
     *                             never forwarded to the application.
     */
    CLOCK_PROVIDE,
    /**
     * The current clock as selected by the pipeline became
     *                          unusable. The pipeline will select a new clock on
     *                          the next PLAYING state change. The application
     *                          should set the pipeline to PAUSED and back to
     *                          PLAYING when this message is received.
     */
    CLOCK_LOST,
    /**
     * a new clock was selected in the pipeline.
     */
    NEW_CLOCK,
    /**
     * the structure of the pipeline changed. This
     * message is used internally and never forwarded to the application.
     */
    STRUCTURE_CHANGE,
    /**
     * status about a stream, emitted when it starts,
     *                             stops, errors, etc..
     */
    STREAM_STATUS,
    /**
     * message posted by the application, possibly
     *                           via an application-specific element.
     */
    APPLICATION,
    /**
     * element-specific message, see the specific element's
     *                       documentation
     */
    ELEMENT,
    /**
     * pipeline started playback of a segment. This
     * message is used internally and never forwarded to the application.
     */
    SEGMENT_START,
    /**
     * pipeline completed playback of a segment. This
     * message is forwarded to the application after all elements that posted
     * `GST_MESSAGE_SEGMENT_START` posted a GST_MESSAGE_SEGMENT_DONE message.
     */
    SEGMENT_DONE,
    /**
     * The duration of a pipeline changed. The
     * application can get the new duration with a duration query.
     */
    DURATION_CHANGED,
    /**
     * Posted by elements when their latency changes. The
     * application should recalculate and distribute a new latency.
     */
    LATENCY,
    /**
     * Posted by elements when they start an ASYNC
     * #GstStateChange. This message is not forwarded to the application but is used
     * internally.
     */
    ASYNC_START,
    /**
     * Posted by elements when they complete an ASYNC
     * #GstStateChange. The application will only receive this message from the toplevel
     * pipeline.
     */
    ASYNC_DONE,
    /**
     * Posted by elements when they want the pipeline to
     * change state. This message is a suggestion to the application which can
     * decide to perform the state change on (part of) the pipeline.
     */
    REQUEST_STATE,
    /**
     * A stepping operation was started.
     */
    STEP_START,
    /**
     * A buffer was dropped or an element changed its processing
     * strategy for Quality of Service reasons.
     */
    QOS,
    /**
     * A progress message.
     */
    PROGRESS,
    /**
     * A new table of contents (TOC) was found or previously found TOC
     * was updated.
     */
    TOC,
    /**
     * Message to request resetting the pipeline's
     *     running time from the pipeline. This is an internal message which
     *     applications will likely never receive.
     */
    RESET_TIME,
    /**
     * Message indicating start of a new stream. Useful
     *     e.g. when using playbin in gapless playback mode, to get notified when
     *     the next title actually starts playing (which will be some time after
     *     the URI for the next title has been set).
     */
    STREAM_START,
    /**
     * Message indicating that an element wants a specific context (Since: 1.2)
     */
    NEED_CONTEXT,
    /**
     * Message indicating that an element created a context (Since: 1.2)
     */
    HAVE_CONTEXT,
    /**
     * Message is an extended message type (see below).
     *     These extended message IDs can't be used directly with mask-based API
     *     like gst_bus_poll() or gst_bus_timed_pop_filtered(), but you can still
     *     filter for GST_MESSAGE_EXTENDED and then check the result for the
     *     specific type. (Since: 1.4)
     */
    EXTENDED,
    /**
     * Message indicating a #GstDevice was added to
     *     a #GstDeviceProvider (Since: 1.4)
     */
    DEVICE_ADDED,
    /**
     * Message indicating a #GstDevice was removed
     *     from a #GstDeviceProvider (Since: 1.4)
     */
    DEVICE_REMOVED,
    /**
     * Message indicating a #GObject property has
     *     changed (Since: 1.10)
     */
    PROPERTY_NOTIFY,
    /**
     * Message indicating a new #GstStreamCollection
     *     is available (Since: 1.10)
     */
    STREAM_COLLECTION,
    /**
     * Message indicating the active selection of
     *     #GstStreams has changed (Since: 1.10)
     */
    STREAMS_SELECTED,
    /**
     * Message indicating to request the application to
     *     try to play the given URL(s). Useful if for example a HTTP 302/303
     *     response is received with a non-HTTP URL inside. (Since: 1.10)
     */
    REDIRECT,
    /**
     * Message indicating a #GstDevice was changed
     *     a #GstDeviceProvider (Since: 1.16)
     */
    DEVICE_CHANGED,
    /**
     * Message sent by elements to request the
     *     running time from the pipeline when an instant rate change should
     *     be applied (which may be in the past when the answer arrives). (Since: 1.18)
     */
    INSTANT_RATE_REQUEST,
    /**
     * mask for all of the above messages.
     */
    ANY,
}
/**
 * Extra metadata flags.
 */
enum MetaFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * metadata should not be modified
     */
    READONLY,
    /**
     * metadata is managed by a bufferpool
     */
    POOLED,
    /**
     * metadata should not be removed
     */
    LOCKED,
    /**
     * additional flags can be added starting from this flag.
     */
    LAST,
}
/**
 * Flags for the mini object
 */
enum MiniObjectFlags {
    /**
     * the object can be locked and unlocked with
     * gst_mini_object_lock() and gst_mini_object_unlock().
     */
    LOCKABLE,
    /**
     * the object is permanently locked in
     * READONLY mode. Only read locks can be performed on the object.
     */
    LOCK_READONLY,
    /**
     * the object is expected to stay alive
     * even after gst_deinit() has been called and so should be ignored by leak
     * detection tools. (Since: 1.10)
     */
    MAY_BE_LEAKED,
    /**
     * first flag that can be used by subclasses.
     */
    LAST,
}
/**
 * The standard flags that an gstobject may have.
 */
enum ObjectFlags {
    /**
     * the object is expected to stay alive even
     * after gst_deinit() has been called and so should be ignored by leak
     * detection tools. (Since: 1.10)
     */
    MAY_BE_LEAKED,
    /**
     * subclasses can add additional flags starting from this flag
     */
    LAST,
}
/**
 * Pad state flags
 */
enum PadFlags {
    /**
     * is dataflow on a pad blocked
     */
    BLOCKED,
    /**
     * is pad flushing
     */
    FLUSHING,
    /**
     * is pad in EOS state
     */
    EOS,
    /**
     * is pad currently blocking on a buffer or event
     */
    BLOCKING,
    /**
     * ensure that there is a parent object before calling
     *                       into the pad callbacks.
     */
    NEED_PARENT,
    /**
     * the pad should be reconfigured/renegotiated.
     *                            The flag has to be unset manually after
     *                            reconfiguration happened.
     */
    NEED_RECONFIGURE,
    /**
     * the pad has pending events
     */
    PENDING_EVENTS,
    /**
     * the pad is using fixed caps. This means that
     *     once the caps are set on the pad, the default caps query function
     *     will only return those caps.
     */
    FIXED_CAPS,
    /**
     * the default event and query handler will forward
     *                      all events and queries to the internally linked pads
     *                      instead of discarding them.
     */
    PROXY_CAPS,
    /**
     * the default query handler will forward
     *                      allocation queries to the internally linked pads
     *                      instead of discarding them.
     */
    PROXY_ALLOCATION,
    /**
     * the default query handler will forward
     *                      scheduling queries to the internally linked pads
     *                      instead of discarding them.
     */
    PROXY_SCHEDULING,
    /**
     * the default accept-caps handler will check
     *                      it the caps intersect the query-caps result instead
     *                      of checking for a subset. This is interesting for
     *                      parsers that can accept incompletely specified caps.
     */
    ACCEPT_INTERSECT,
    /**
     * the default accept-caps handler will use
     *                      the template pad caps instead of query caps to
     *                      compare with the accept caps. Use this in combination
     *                      with %GST_PAD_FLAG_ACCEPT_INTERSECT. (Since: 1.6)
     */
    ACCEPT_TEMPLATE,
    /**
     * offset to define more flags
     */
    LAST,
}
/**
 * The amount of checking to be done when linking pads. `GST_PAD_LINK_CHECK_CAPS`
 * and `GST_PAD_LINK_CHECK_TEMPLATE_CAPS` are mutually exclusive. If both are
 * specified, expensive but safe `GST_PAD_LINK_CHECK_CAPS` are performed.
 * 
 * > Only disable some of the checks if you are 100% certain you know the link
 * > will not fail because of hierarchy/caps compatibility failures. If uncertain,
 * > use the default checks (%GST_PAD_LINK_CHECK_DEFAULT) or the regular methods
 * > for linking the pads.
 */
enum PadLinkCheck {
    /**
     * Don't check hierarchy or caps compatibility.
     */
    NOTHING,
    /**
     * Check the pads have same parents/grandparents.
     *   Could be omitted if it is already known that the two elements that own the
     *   pads are in the same bin.
     */
    HIERARCHY,
    /**
     * Check if the pads are compatible by using
     *   their template caps. This is much faster than `GST_PAD_LINK_CHECK_CAPS,` but
     *   would be unsafe e.g. if one pad has %GST_CAPS_ANY.
     */
    TEMPLATE_CAPS,
    /**
     * Check if the pads are compatible by comparing the
     *   caps returned by gst_pad_query_caps().
     */
    CAPS,
    /**
     * Disables pushing a reconfigure event when pads are
     *   linked.
     */
    NO_RECONFIGURE,
    /**
     * The default checks done when linking
     *   pads (i.e. the ones used by gst_pad_link()).
     */
    DEFAULT,
}
/**
 * The different probing types that can occur. When either one of
 * `GST_PAD_PROBE_TYPE_IDLE` or `GST_PAD_PROBE_TYPE_BLOCK` is used, the probe will be a
 * blocking probe.
 */
enum PadProbeType {
    /**
     * invalid probe type
     */
    INVALID,
    /**
     * probe idle pads and block while the callback is called
     */
    IDLE,
    /**
     * probe and block pads
     */
    BLOCK,
    /**
     * probe buffers
     */
    BUFFER,
    /**
     * probe buffer lists
     */
    BUFFER_LIST,
    /**
     * probe downstream events
     */
    EVENT_DOWNSTREAM,
    /**
     * probe upstream events
     */
    EVENT_UPSTREAM,
    /**
     * probe flush events. This probe has to be
     *     explicitly enabled and is not included in the
     *     `@`GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM or
     *     `@`GST_PAD_PROBE_TYPE_EVENT_UPSTREAM probe types.
     */
    EVENT_FLUSH,
    /**
     * probe downstream queries
     */
    QUERY_DOWNSTREAM,
    /**
     * probe upstream queries
     */
    QUERY_UPSTREAM,
    /**
     * probe push
     */
    PUSH,
    /**
     * probe pull
     */
    PULL,
    /**
     * probe and block at the next opportunity, at data flow or when idle
     */
    BLOCKING,
    /**
     * probe downstream data (buffers, buffer lists, and events)
     */
    DATA_DOWNSTREAM,
    /**
     * probe upstream data (events)
     */
    DATA_UPSTREAM,
    /**
     * probe upstream and downstream data (buffers, buffer lists, and events)
     */
    DATA_BOTH,
    /**
     * probe and block downstream data (buffers, buffer lists, and events)
     */
    BLOCK_DOWNSTREAM,
    /**
     * probe and block upstream data (events)
     */
    BLOCK_UPSTREAM,
    /**
     * probe upstream and downstream events
     */
    EVENT_BOTH,
    /**
     * probe upstream and downstream queries
     */
    QUERY_BOTH,
    /**
     * probe upstream events and queries and downstream buffers, buffer lists, events and queries
     */
    ALL_BOTH,
    /**
     * probe push and pull
     */
    SCHEDULING,
}
/**
 * Flags for the padtemplate
 */
enum PadTemplateFlags {
    /**
     * first flag that can be used by subclasses.
     */
    LAST,
}
/**
 * Parsing options.
 */
enum ParseFlags {
    /**
     * Do not use any special parsing options.
     */
    NONE,
    /**
     * Always return %NULL when an error occurs
     *     (default behaviour is to return partially constructed bins or elements
     *      in some cases)
     */
    FATAL_ERRORS,
    /**
     * If a bin only has a single element,
     *     just return the element.
     */
    NO_SINGLE_ELEMENT_BINS,
    /**
     * If more than one toplevel element is described
     *     by the pipeline description string, put them in a #GstBin instead of a
     *     #GstPipeline. (Since: 1.10)
     */
    PLACE_IN_BIN,
}
/**
 * Pipeline flags
 */
enum PipelineFlags {
    /**
     * this pipeline works with a fixed clock
     */
    FIXED_CLOCK,
    /**
     * offset to define more flags
     */
    LAST,
}
enum PluginAPIFlags {
    /**
     * Ignore enum members when generating
     *   the plugins cache. This is useful if the members of the enum are generated
     *   dynamically, in order not to expose incorrect documentation to the end user.
     */
    MEMBERS,
}
/**
 * Flags used in connection with gst_plugin_add_dependency().
 */
enum PluginDependencyFlags {
    /**
     * no special flags
     */
    NONE,
    /**
     * recurse into subdirectories
     */
    RECURSE,
    /**
     * use paths
     *         argument only if none of the environment variables is set
     */
    PATHS_ARE_DEFAULT_ONLY,
    /**
     * interpret
     *         filename argument as filter suffix and check all matching files in
     *         the directory
     */
    FILE_NAME_IS_SUFFIX,
    /**
     * interpret
     *         filename argument as filter prefix and check all matching files in
     *         the directory. Since: 1.8.
     */
    FILE_NAME_IS_PREFIX,
    /**
     * interpret
     *   non-absolute paths as relative to the main executable directory. Since
     *   1.14.
     */
    PATHS_ARE_RELATIVE_TO_EXE,
}
/**
 * The plugin loading state
 */
enum PluginFlags {
    /**
     * Temporarily loaded plugins
     */
    CACHED,
    /**
     * The plugin won't be scanned (again)
     */
    BLACKLISTED,
}
/**
 * #GstQueryTypeFlags indicate the aspects of the different #GstQueryType
 * values. You can get the type flags of a #GstQueryType with the
 * gst_query_type_get_flags() function.
 */
enum QueryTypeFlags {
    /**
     * Set if the query can travel upstream.
     */
    UPSTREAM,
    /**
     * Set if the query can travel downstream.
     */
    DOWNSTREAM,
    /**
     * Set if the query should be serialized with data
     *                               flow.
     */
    SERIALIZED,
}
/**
 * The different scheduling flags.
 */
enum SchedulingFlags {
    /**
     * if seeking is possible
     */
    SEEKABLE,
    /**
     * if sequential access is recommended
     */
    SEQUENTIAL,
    /**
     * if bandwidth is limited and buffering possible (since 1.2)
     */
    BANDWIDTH_LIMITED,
}
/**
 * Flags to be used with gst_element_seek() or gst_event_new_seek(). All flags
 * can be used together.
 * 
 * A non flushing seek might take some time to perform as the currently
 * playing data in the pipeline will not be cleared.
 * 
 * An accurate seek might be slower for formats that don't have any indexes
 * or timestamp markers in the stream. Specifying this flag might require a
 * complete scan of the file in those cases.
 * 
 * When performing a segment seek: after the playback of the segment completes,
 * no EOS will be emitted by the element that performed the seek, but a
 * %GST_MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.
 * When this message is posted, it is possible to send a new seek event to
 * continue playback. With this seek method it is possible to perform seamless
 * looping or simple linear editing.
 * 
 * When only changing the playback rate and not the direction, the
 * %GST_SEEK_FLAG_INSTANT_RATE_CHANGE flag can be used for a non-flushing seek
 * to signal that the rate change should be applied immediately. This requires
 * special support in the seek handlers (e.g. demuxers) and any elements
 * synchronizing to the clock, and in general can't work in all cases (for example
 * UDP streaming where the delivery rate is controlled by a remote server). The
 * instant-rate-change mode supports changing the trickmode-related GST_SEEK_ flags,
 * but can't be used in conjunction with other seek flags that affect the new
 * playback position - as the playback position will not be changing.
 * 
 * When doing fast forward (rate > 1.0) or fast reverse (rate < -1.0) trickmode
 * playback, the %GST_SEEK_FLAG_TRICKMODE flag can be used to instruct decoders
 * and demuxers to adjust the playback rate by skipping frames. This can improve
 * performance and decrease CPU usage because not all frames need to be decoded.
 * 
 * Beyond that, the %GST_SEEK_FLAG_TRICKMODE_KEY_UNITS flag can be used to
 * request that decoders skip all frames except key units, and
 * %GST_SEEK_FLAG_TRICKMODE_NO_AUDIO flags can be used to request that audio
 * decoders do no decoding at all, and simple output silence.
 * 
 * The %GST_SEEK_FLAG_SNAP_BEFORE flag can be used to snap to the previous
 * relevant location, and the %GST_SEEK_FLAG_SNAP_AFTER flag can be used to
 * select the next relevant location. If %GST_SEEK_FLAG_KEY_UNIT is specified,
 * the relevant location is a keyframe. If both flags are specified, the nearest
 * of these locations will be selected. If none are specified, the implementation is
 * free to select whichever it wants.
 * 
 * The before and after here are in running time, so when playing backwards,
 * the next location refers to the one that will played in next, and not the
 * one that is located after in the actual source stream.
 * 
 * Also see part-seeking.txt in the GStreamer design documentation for more
 * details on the meaning of these flags and the behaviour expected of
 * elements that handle them.
 */
enum SeekFlags {
    /**
     * no flag
     */
    NONE,
    /**
     * flush pipeline
     */
    FLUSH,
    /**
     * accurate position is requested, this might
     *                     be considerably slower for some formats.
     */
    ACCURATE,
    /**
     * seek to the nearest keyframe. This might be
     *                     faster but less accurate.
     */
    KEY_UNIT,
    /**
     * perform a segment seek.
     */
    SEGMENT,
    /**
     * when doing fast forward or fast reverse playback, allow
     *                     elements to skip frames instead of generating all
     *                     frames. (Since: 1.6)
     */
    TRICKMODE,
    /**
     * Deprecated backward compatibility flag, replaced
     *                     by %GST_SEEK_FLAG_TRICKMODE
     */
    SKIP,
    /**
     * go to a location before the requested position,
     *                     if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe at or before
     *                     the requested position the one at or before the seek target.
     */
    SNAP_BEFORE,
    /**
     * go to a location after the requested position,
     *                     if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe at of after the
     *                     requested position.
     */
    SNAP_AFTER,
    /**
     * go to a position near the requested position,
     *                     if %GST_SEEK_FLAG_KEY_UNIT this means the keyframe closest
     *                     to the requested position, if both keyframes are at an equal
     *                     distance, behaves like %GST_SEEK_FLAG_SNAP_BEFORE.
     */
    SNAP_NEAREST,
    /**
     * when doing fast forward or fast reverse
     *                     playback, request that elements only decode keyframes
     *                     and skip all other content, for formats that have
     *                     keyframes. (Since: 1.6)
     */
    TRICKMODE_KEY_UNITS,
    /**
     * when doing fast forward or fast reverse
     *                     playback, request that audio decoder elements skip
     *                     decoding and output only gap events or silence. (Since: 1.6)
     */
    TRICKMODE_NO_AUDIO,
    /**
     * When doing fast forward or fast reverse
     *                     playback, request that elements only decode keyframes and
     *                     forward predicted frames and skip all other content (for example
     *                     B-Frames), for formats that have keyframes and forward predicted
     *                     frames. (Since: 1.18)
     */
    TRICKMODE_FORWARD_PREDICTED,
    /**
     * Signals that a rate change should be
     *                     applied immediately. Only valid if start/stop position
     *                     are GST_CLOCK_TIME_NONE, the playback direction does not change
     *                     and the seek is not flushing. (Since: 1.18)
     */
    INSTANT_RATE_CHANGE,
}
/**
 * Flags for the GstSegment structure. Currently mapped to the corresponding
 * values of the seek flags.
 */
enum SegmentFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * reset the pipeline running_time to the segment
     *                          running_time
     */
    RESET,
    /**
     * perform skip playback (Since: 1.6)
     */
    TRICKMODE,
    /**
     * Deprecated backward compatibility flag, replaced
     *                         by `GST_SEGMENT_FLAG_TRICKMODE`
     */
    SKIP,
    /**
     * send SEGMENT_DONE instead of EOS
     */
    SEGMENT,
    /**
     * Decode only keyframes, where
     *                                        possible (Since: 1.6)
     */
    TRICKMODE_KEY_UNITS,
    /**
     * Decode only keyframes or forward
     *                                        predicted frames, where possible (Since: 1.18)
     */
    TRICKMODE_FORWARD_PREDICTED,
    /**
     * Do not decode any audio, where
     *                                        possible (Since: 1.6)
     */
    TRICKMODE_NO_AUDIO,
}
enum SerializeFlags {
    /**
     * No special flags specified.
     */
    NONE,
    /**
     * Serialize using the old format for
     *                                      nested structures.
     */
    BACKWARD_COMPAT,
}
enum StackTraceFlags {
    /**
     * Try to retrieve the minimum information
     *                             available, which may be none on some platforms
     *                             (Since: 1.18)
     */
    NONE,
    /**
     * Try to retrieve as much information as possible,
     *                             including source information when getting the
     *                             stack trace
     */
    FULL,
}
enum StreamFlags {
    /**
     * This stream has no special attributes
     */
    NONE,
    /**
     * This stream is a sparse stream (e.g. a subtitle
     *    stream), data may flow only in irregular intervals with large gaps in
     *    between.
     */
    SPARSE,
    /**
     * This stream should be selected by default. This
     *    flag may be used by demuxers to signal that a stream should be selected
     *    by default in a playback scenario.
     */
    SELECT,
    /**
     * This stream should not be selected by default.
     *    This flag may be used by demuxers to signal that a stream should not
     *    be selected by default in a playback scenario, but only if explicitly
     *    selected by the user (e.g. an audio track for the hard of hearing or
     *    a director's commentary track).
     */
    UNSELECT,
}
/**
 * #GstStreamType describes a high level classification set for
 * flows of data in #GstStream objects.
 * 
 * Note that this is a flag, and therefore users should not assume it
 * will be a single value. Do not use the equality operator for checking
 * whether a stream is of a certain type.
 */
enum StreamType {
    /**
     * The stream is of unknown (unclassified) type.
     */
    UNKNOWN,
    /**
     * The stream is of audio data
     */
    AUDIO,
    /**
     * The stream carries video data
     */
    VIDEO,
    /**
     * The stream is a muxed container type
     */
    CONTAINER,
    /**
     * The stream contains subtitle / subpicture data.
     */
    TEXT,
}
/**
 * Flag that describe the value. These flags help applications processing the
 * logs to understand the values.
 */
enum TracerValueFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * the value is optional. When using this flag
     *   one need to have an additional boolean arg before this value in the
     *   var-args list passed to  gst_tracer_record_log().
     */
    OPTIONAL,
    /**
     * the value is a combined figure, since the
     *   start of tracing. Examples are averages or timestamps.
     */
    AGGREGATED,
}
/**
 * The allocator name for the default system memory allocator
 */
const ALLOCATOR_SYSMEM: string
/**
 * Combination of all possible fields that can be copied with
 * gst_buffer_copy_into().
 */
const BUFFER_COPY_ALL: BufferCopyFlags
/**
 * Combination of all possible metadata fields that can be copied with
 * gst_buffer_copy_into().
 */
const BUFFER_COPY_METADATA: BufferCopyFlags
/**
 * Constant for no-offset return results.
 */
const BUFFER_OFFSET_NONE: number
const CAN_INLINE: number
const CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: string
/**
 * Constant to define an undefined clock time.
 */
const CLOCK_TIME_NONE: ClockTime
const DEBUG_BG_MASK: number
const DEBUG_FG_MASK: number
const DEBUG_FORMAT_MASK: number
const ELEMENT_FACTORY_KLASS_DECODER: string
const ELEMENT_FACTORY_KLASS_DECRYPTOR: string
const ELEMENT_FACTORY_KLASS_DEMUXER: string
const ELEMENT_FACTORY_KLASS_DEPAYLOADER: string
const ELEMENT_FACTORY_KLASS_ENCODER: string
const ELEMENT_FACTORY_KLASS_ENCRYPTOR: string
const ELEMENT_FACTORY_KLASS_FORMATTER: string
/**
 * Elements interacting with hardware devices should specify this classifier in
 * their metadata. You may need to put the element in "READY" state to test if
 * the hardware is present in the system.
 */
const ELEMENT_FACTORY_KLASS_HARDWARE: string
const ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: string
const ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: string
const ELEMENT_FACTORY_KLASS_MEDIA_METADATA: string
const ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: string
const ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: string
const ELEMENT_FACTORY_KLASS_MUXER: string
const ELEMENT_FACTORY_KLASS_PARSER: string
const ELEMENT_FACTORY_KLASS_PAYLOADER: string
const ELEMENT_FACTORY_KLASS_SINK: string
const ELEMENT_FACTORY_KLASS_SRC: string
/**
 * Elements of any of the defined GST_ELEMENT_FACTORY_LIST types
 */
const ELEMENT_FACTORY_TYPE_ANY: ElementFactoryListType
/**
 * All sinks handling audio, video or image media types
 */
const ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS: ElementFactoryListType
/**
 * All encoders handling audio media types
 */
const ELEMENT_FACTORY_TYPE_AUDIO_ENCODER: ElementFactoryListType
/**
 * All elements used to 'decode' streams (decoders, demuxers, parsers, depayloaders)
 */
const ELEMENT_FACTORY_TYPE_DECODABLE: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_DECODER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_DECRYPTOR: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_DEMUXER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_DEPAYLOADER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_ENCODER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_ENCRYPTOR: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_FORMATTER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_HARDWARE: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_MAX_ELEMENTS: ElementFactoryListType
/**
 * Elements matching any of the defined GST_ELEMENT_FACTORY_TYPE_MEDIA types
 * 
 * Note: Do not use this if you wish to not filter against any of the defined
 * media types. If you wish to do this, simply don't specify any
 * GST_ELEMENT_FACTORY_TYPE_MEDIA flag.
 */
const ELEMENT_FACTORY_TYPE_MEDIA_ANY: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_MEDIA_AUDIO: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_MEDIA_IMAGE: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_MEDIA_METADATA: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_MEDIA_VIDEO: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_MUXER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_PARSER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_PAYLOADER: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_SINK: ElementFactoryListType
const ELEMENT_FACTORY_TYPE_SRC: ElementFactoryListType
/**
 * All encoders handling video or image media types
 */
const ELEMENT_FACTORY_TYPE_VIDEO_ENCODER: ElementFactoryListType
/**
 * Name and contact details of the author(s). Use \n to separate
 * multiple author details.
 * E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;"
 */
const ELEMENT_METADATA_AUTHOR: string
/**
 * Sentence describing the purpose of the element.
 * E.g: "Write stream to a file"
 */
const ELEMENT_METADATA_DESCRIPTION: string
/**
 * Set uri pointing to user documentation. Applications can use this to show
 * help for e.g. effects to users.
 */
const ELEMENT_METADATA_DOC_URI: string
/**
 * Elements that bridge to certain other products can include an icon of that
 * used product. Application can show the icon in menus/selectors to help
 * identifying specific elements.
 */
const ELEMENT_METADATA_ICON_NAME: string
/**
 * String describing the type of element, as an unordered list
 * separated with slashes ('/'). See draft-klass.txt of the design docs
 * for more details and common types. E.g: "Sink/File"
 */
const ELEMENT_METADATA_KLASS: string
/**
 * The long English name of the element. E.g. "File Sink"
 */
const ELEMENT_METADATA_LONGNAME: string
const EVENT_NUM_SHIFT: number
/**
 * The same thing as #GST_EVENT_TYPE_UPSTREAM | #GST_EVENT_TYPE_DOWNSTREAM.
 */
const EVENT_TYPE_BOTH: EventTypeFlags
/**
 * A mask value with all bits set, for use as a
 * GstFlagSet mask where all flag bits must match
 * exactly
 */
const FLAG_SET_MASK_EXACT: number
/**
 * The PERCENT format is between 0 and this value
 */
const FORMAT_PERCENT_MAX: number
/**
 * The value used to scale down the reported PERCENT format value to
 * its real value.
 */
const FORMAT_PERCENT_SCALE: number
/**
 * A value which is guaranteed to never be returned by
 * gst_util_group_id_next().
 * 
 * Can be used as a default value in variables used to store group_id.
 */
const GROUP_ID_INVALID: number
/**
 * To be used in GST_PLUGIN_DEFINE if unsure about the licence.
 */
const LICENSE_UNKNOWN: string
/**
 * GstLockFlags value alias for GST_LOCK_FLAG_READ | GST_LOCK_FLAG_WRITE
 */
const LOCK_FLAG_READWRITE: LockFlags
/**
 * GstMapFlags value alias for GST_MAP_READ | GST_MAP_WRITE
 */
const MAP_READWRITE: MapFlags
/**
 * This metadata stays relevant as long as memory layout is unchanged.
 */
const META_TAG_MEMORY_STR: string
/**
 * Constant that defines one GStreamer millisecond.
 */
const MSECOND: ClockTimeDiff
/**
 * Constant that defines one GStreamer nanosecond
 */
const NSECOND: ClockTimeDiff
/**
 * Use this flag on GObject properties of GstObject to indicate that
 * they might not be available depending on environment such as OS, device, etc,
 * so such properties will be installed conditionally only if the GstObject is
 * able to support it.
 */
const PARAM_CONDITIONALLY_AVAILABLE: number
/**
 * Use this flag on GObject properties to signal they can make sense to be.
 * controlled over time. This hint is used by the GstController.
 */
const PARAM_CONTROLLABLE: number
/**
 * Use this flag on GObject properties of GstObject to indicate that
 * during `gst-inspect` and friends, the default value should be used
 * as default instead of the current value.
 */
const PARAM_DOC_SHOW_DEFAULT: number
/**
 * Use this flag on GObject properties of GstElements to indicate that
 * they can be changed when the element is in the PAUSED or lower state.
 * This flag implies GST_PARAM_MUTABLE_READY.
 */
const PARAM_MUTABLE_PAUSED: number
/**
 * Use this flag on GObject properties of GstElements to indicate that
 * they can be changed when the element is in the PLAYING or lower state.
 * This flag implies GST_PARAM_MUTABLE_PAUSED.
 */
const PARAM_MUTABLE_PLAYING: number
/**
 * Use this flag on GObject properties of GstElements to indicate that
 * they can be changed when the element is in the READY or lower state.
 */
const PARAM_MUTABLE_READY: number
/**
 * Bits based on GST_PARAM_USER_SHIFT can be used by 3rd party applications.
 */
const PARAM_USER_SHIFT: number
/**
 * The field name in a GstCaps that is used to signal the UUID of the protection
 * system.
 */
const PROTECTION_SYSTEM_ID_CAPS_FIELD: string
/**
 * The protection system value of the unspecified UUID.
 * In some cases the system protection ID is not present in the contents or in their
 * metadata, as encrypted WebM.
 * This define is used to set the value of the "system_id" field in GstProtectionEvent,
 * with this value, the application will use an external information to choose which
 * protection system to use.
 * 
 * Example: The matroskademux uses this value in the case of encrypted WebM,
 * the application will choose the appropriate protection system based on the information
 * received through EME API.
 */
const PROTECTION_UNSPECIFIED_SYSTEM_ID: string
const QUERY_NUM_SHIFT: number
/**
 * The same thing as #GST_QUERY_TYPE_UPSTREAM | #GST_QUERY_TYPE_DOWNSTREAM.
 */
const QUERY_TYPE_BOTH: QueryTypeFlags
/**
 * Constant that defines one GStreamer second.
 */
const SECOND: ClockTimeDiff
const SEGMENT_INSTANT_FLAGS: number
/**
 * A value which is guaranteed to never be returned by
 * gst_util_seqnum_next().
 * 
 * Can be used as a default value in variables used to store seqnum.
 */
const SEQNUM_INVALID: number
/**
 * album containing this data (string)
 * 
 * The album name as it should be displayed, e.g. 'The Jazz Guitar'
 */
const TAG_ALBUM: string
/**
 * The artist of the entire album, as it should be displayed.
 */
const TAG_ALBUM_ARTIST: string
/**
 * The artist of the entire album, as it should be sorted.
 */
const TAG_ALBUM_ARTIST_SORTNAME: string
/**
 * album gain in db (double)
 */
const TAG_ALBUM_GAIN: string
/**
 * peak of the album (double)
 */
const TAG_ALBUM_PEAK: string
/**
 * album containing this data, as used for sorting (string)
 * 
 * The album name as it should be sorted, e.g. 'Jazz Guitar, The'
 */
const TAG_ALBUM_SORTNAME: string
/**
 * count of discs inside collection this disc belongs to (unsigned integer)
 */
const TAG_ALBUM_VOLUME_COUNT: string
/**
 * disc number inside a collection (unsigned integer)
 */
const TAG_ALBUM_VOLUME_NUMBER: string
/**
 * Arbitrary application data (sample)
 * 
 * Some formats allow applications to add their own arbitrary data
 * into files. This data is application dependent.
 */
const TAG_APPLICATION_DATA: string
/**
 * Name of the application used to create the media (string)
 */
const TAG_APPLICATION_NAME: string
/**
 * person(s) responsible for the recording (string)
 * 
 * The artist name as it should be displayed, e.g. 'Jimi Hendrix' or
 * 'The Guitar Heroes'
 */
const TAG_ARTIST: string
/**
 * person(s) responsible for the recording, as used for sorting (string)
 * 
 * The artist name as it should be sorted, e.g. 'Hendrix, Jimi' or
 * 'Guitar Heroes, The'
 */
const TAG_ARTIST_SORTNAME: string
/**
 * generic file attachment (sample) (sample taglist should specify the content
 * type and if possible set "filename" to the file name of the
 * attachment)
 */
const TAG_ATTACHMENT: string
/**
 * codec the audio data is stored in (string)
 */
const TAG_AUDIO_CODEC: string
/**
 * number of beats per minute in audio (double)
 */
const TAG_BEATS_PER_MINUTE: string
/**
 * exact or average bitrate in bits/s (unsigned integer)
 */
const TAG_BITRATE: string
/**
 * codec the data is stored in (string)
 */
const TAG_CODEC: string
/**
 * free text commenting the data (string)
 */
const TAG_COMMENT: string
/**
 * person(s) who composed the recording (string)
 */
const TAG_COMPOSER: string
/**
 * The composer's name, used for sorting (string)
 */
const TAG_COMPOSER_SORTNAME: string
/**
 * conductor/performer refinement (string)
 */
const TAG_CONDUCTOR: string
/**
 * contact information (string)
 */
const TAG_CONTACT: string
/**
 * container format the data is stored in (string)
 */
const TAG_CONTAINER_FORMAT: string
/**
 * copyright notice of the data (string)
 */
const TAG_COPYRIGHT: string
/**
 * URI to location where copyright details can be found (string)
 */
const TAG_COPYRIGHT_URI: string
/**
 * date the data was created (#GDate structure)
 */
const TAG_DATE: string
/**
 * date and time the data was created (#GstDateTime structure)
 */
const TAG_DATE_TIME: string
/**
 * short text describing the content of the data (string)
 */
const TAG_DESCRIPTION: string
/**
 * Manufacturer of the device used to create the media (string)
 */
const TAG_DEVICE_MANUFACTURER: string
/**
 * Model of the device used to create the media (string)
 */
const TAG_DEVICE_MODEL: string
/**
 * length in GStreamer time units (nanoseconds) (unsigned 64-bit integer)
 */
const TAG_DURATION: string
/**
 * name of the person or organisation that encoded the file. May contain a
 * copyright message if the person or organisation also holds the copyright
 * (string)
 * 
 * Note: do not use this field to describe the encoding application. Use
 * #GST_TAG_APPLICATION_NAME or #GST_TAG_COMMENT for that.
 */
const TAG_ENCODED_BY: string
/**
 * encoder used to encode this stream (string)
 */
const TAG_ENCODER: string
/**
 * version of the encoder used to encode this stream (unsigned integer)
 */
const TAG_ENCODER_VERSION: string
/**
 * key/value text commenting the data (string)
 * 
 * Must be in the form of 'key=comment' or
 * 'key[lc]=comment' where 'lc' is an ISO-639
 * language code.
 * 
 * This tag is used for unknown Vorbis comment tags,
 * unknown APE tags and certain ID3v2 comment fields.
 */
const TAG_EXTENDED_COMMENT: string
/**
 * genre this data belongs to (string)
 */
const TAG_GENRE: string
/**
 * Indicates the direction the device is pointing to when capturing
 * a media. It is represented as degrees in floating point representation,
 * 0 means the geographic north, and increases clockwise (double from 0 to 360)
 * 
 * See also #GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION
 */
const TAG_GEO_LOCATION_CAPTURE_DIRECTION: string
/**
 * The city (english name) where the media has been produced (string).
 */
const TAG_GEO_LOCATION_CITY: string
/**
 * The country (english name) where the media has been produced (string).
 */
const TAG_GEO_LOCATION_COUNTRY: string
/**
 * geo elevation of where the media has been recorded or produced in meters
 * according to WGS84 (zero is average sea level) (double).
 */
const TAG_GEO_LOCATION_ELEVATION: string
/**
 * Represents the expected error on the horizontal positioning in
 * meters (double).
 */
const TAG_GEO_LOCATION_HORIZONTAL_ERROR: string
/**
 * geo latitude location of where the media has been recorded or produced in
 * degrees according to WGS84 (zero at the equator, negative values for southern
 * latitudes) (double).
 */
const TAG_GEO_LOCATION_LATITUDE: string
/**
 * geo longitude location of where the media has been recorded or produced in
 * degrees according to WGS84 (zero at the prime meridian in Greenwich/UK,
 * negative values for western longitudes). (double).
 */
const TAG_GEO_LOCATION_LONGITUDE: string
/**
 * Indicates the movement direction of the device performing the capture
 * of a media. It is represented as degrees in floating point representation,
 * 0 means the geographic north, and increases clockwise (double from 0 to 360)
 * 
 * See also #GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION
 */
const TAG_GEO_LOCATION_MOVEMENT_DIRECTION: string
/**
 * Speed of the capturing device when performing the capture.
 * Represented in m/s. (double)
 * 
 * See also #GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION
 */
const TAG_GEO_LOCATION_MOVEMENT_SPEED: string
/**
 * human readable descriptive location of where the media has been recorded or
 * produced. (string).
 */
const TAG_GEO_LOCATION_NAME: string
/**
 * A location 'smaller' than GST_TAG_GEO_LOCATION_CITY that specifies better
 * where the media has been produced. (e.g. the neighborhood) (string).
 * 
 * This tag has been added as this is how it is handled/named in XMP's
 * Iptc4xmpcore schema.
 */
const TAG_GEO_LOCATION_SUBLOCATION: string
/**
 * Groups together media that are related and spans multiple tracks. An
 * example are multiple pieces of a concerto. (string)
 */
const TAG_GROUPING: string
/**
 * Homepage for this media (i.e. artist or movie homepage) (string)
 */
const TAG_HOMEPAGE: string
/**
 * image (sample) (sample taglist should specify the content type and preferably
 * also set "image-type" field as `GstTagImageType`)
 */
const TAG_IMAGE: string
/**
 * Represents the 'Orientation' tag from EXIF. Defines how the image
 * should be rotated and mirrored for display. (string)
 * 
 * This tag has a predefined set of allowed values:
 *   "rotate-0"
 *   "rotate-90"
 *   "rotate-180"
 *   "rotate-270"
 *   "flip-rotate-0"
 *   "flip-rotate-90"
 *   "flip-rotate-180"
 *   "flip-rotate-270"
 * 
 * The naming is adopted according to a possible transformation to perform
 * on the image to fix its orientation, obviously equivalent operations will
 * yield the same result.
 * 
 * Rotations indicated by the values are in clockwise direction and
 * 'flip' means an horizontal mirroring.
 */
const TAG_IMAGE_ORIENTATION: string
/**
 * Information about the people behind a remix and similar
 * interpretations of another existing piece (string)
 */
const TAG_INTERPRETED_BY: string
/**
 * International Standard Recording Code - see http://www.ifpi.org/isrc/ (string)
 */
const TAG_ISRC: string
/**
 * comma separated keywords describing the content (string).
 */
const TAG_KEYWORDS: string
/**
 * ISO-639-2 or ISO-639-1 code for the language the content is in (string)
 * 
 * There is utility API in libgsttag in gst-plugins-base to obtain a translated
 * language name from the language code: `gst_tag_get_language_name()`
 */
const TAG_LANGUAGE_CODE: string
/**
 * Name of the language the content is in (string)
 * 
 * Free-form name of the language the content is in, if a language code
 * is not available. This tag should not be set in addition to a language
 * code. It is undefined what language or locale the language name is in.
 */
const TAG_LANGUAGE_NAME: string
/**
 * license of data (string)
 */
const TAG_LICENSE: string
/**
 * URI to location where license details can be found (string)
 */
const TAG_LICENSE_URI: string
/**
 * Origin of media as a URI (location, where the original of the file or stream
 * is hosted) (string)
 */
const TAG_LOCATION: string
/**
 * The lyrics of the media (string)
 */
const TAG_LYRICS: string
/**
 * maximum bitrate in bits/s (unsigned integer)
 */
const TAG_MAXIMUM_BITRATE: string
/**
 * [Midi note number](http://en.wikipedia.org/wiki/Note#Note_designation_in_accordance_with_octave_name)
 * of the audio track. This is useful for sample instruments and in particular
 * for multi-samples.
 */
const TAG_MIDI_BASE_NOTE: string
/**
 * minimum bitrate in bits/s (unsigned integer)
 */
const TAG_MINIMUM_BITRATE: string
/**
 * nominal bitrate in bits/s (unsigned integer). The actual bitrate might be
 * different from this target bitrate.
 */
const TAG_NOMINAL_BITRATE: string
/**
 * organization (string)
 */
const TAG_ORGANIZATION: string
/**
 * person(s) performing (string)
 */
const TAG_PERFORMER: string
/**
 * image that is meant for preview purposes, e.g. small icon-sized version
 * (sample) (sample taglist should specify the content type)
 */
const TAG_PREVIEW_IMAGE: string
/**
 * Any private data that may be contained in tags (sample).
 * 
 * It is represented by #GstSample in which #GstBuffer contains the
 * binary data and the sample's info #GstStructure may contain any
 * extra information that identifies the origin or meaning of the data.
 * 
 * Private frames in ID3v2 tags ('PRIV' frames) will be represented
 * using this tag, in which case the GstStructure will be named
 * "ID3PrivateFrame" and contain a field named "owner" of type string
 * which contains the owner-identification string from the tag.
 */
const TAG_PRIVATE_DATA: string
/**
 * Name of the label or publisher (string)
 */
const TAG_PUBLISHER: string
/**
 * reference level of track and album gain values (double)
 */
const TAG_REFERENCE_LEVEL: string
/**
 * serial number of track (unsigned integer)
 */
const TAG_SERIAL: string
/**
 * Number of the episode within a season/show (unsigned integer)
 */
const TAG_SHOW_EPISODE_NUMBER: string
/**
 * Name of the show, used for displaying (string)
 */
const TAG_SHOW_NAME: string
/**
 * Number of the season of a show/series (unsigned integer)
 */
const TAG_SHOW_SEASON_NUMBER: string
/**
 * Name of the show, used for sorting (string)
 */
const TAG_SHOW_SORTNAME: string
/**
 * codec/format the subtitle data is stored in (string)
 */
const TAG_SUBTITLE_CODEC: string
/**
 * commonly used title (string)
 * 
 * The title as it should be displayed, e.g. 'The Doll House'
 */
const TAG_TITLE: string
/**
 * commonly used title, as used for sorting (string)
 * 
 * The title as it should be sorted, e.g. 'Doll House, The'
 */
const TAG_TITLE_SORTNAME: string
/**
 * count of tracks inside collection this track belongs to (unsigned integer)
 */
const TAG_TRACK_COUNT: string
/**
 * track gain in db (double)
 */
const TAG_TRACK_GAIN: string
/**
 * track number inside a collection (unsigned integer)
 */
const TAG_TRACK_NUMBER: string
/**
 * peak of the track (double)
 */
const TAG_TRACK_PEAK: string
/**
 * Rating attributed by a person (likely the application user).
 * The higher the value, the more the user likes this media
 * (unsigned int from 0 to 100)
 */
const TAG_USER_RATING: string
/**
 * version of this data (string)
 */
const TAG_VERSION: string
/**
 * codec the video data is stored in (string)
 */
const TAG_VIDEO_CODEC: string
/**
 * Special value for the repeat_count set in gst_toc_entry_set_loop() or
 * returned by gst_toc_entry_set_loop() to indicate infinite looping.
 */
const TOC_REPEAT_COUNT_INFINITE: number
/**
 * Value for #GstUri<!-- -->.port to indicate no port number.
 */
const URI_NO_PORT: number
/**
 * Constant that defines one GStreamer microsecond.
 */
const USECOND: ClockTimeDiff
/**
 * Indicates that the first value provided to a comparison function
 * (gst_value_compare()) is equal to the second one.
 */
const VALUE_EQUAL: number
/**
 * Indicates that the first value provided to a comparison function
 * (gst_value_compare()) is greater than the second one.
 */
const VALUE_GREATER_THAN: number
/**
 * Indicates that the first value provided to a comparison function
 * (gst_value_compare()) is lesser than the second one.
 */
const VALUE_LESS_THAN: number
/**
 * Indicates that the comparison function (gst_value_compare()) can not
 * determine a order for the two provided values.
 */
const VALUE_UNORDERED: number
/**
 * The major version of GStreamer at compile time:
 */
const VERSION_MAJOR: number
/**
 * The micro version of GStreamer at compile time:
 */
const VERSION_MICRO: number
/**
 * The minor version of GStreamer at compile time:
 */
const VERSION_MINOR: number
/**
 * The nano version of GStreamer at compile time:
 * Actual releases have 0, GIT versions have 1, prerelease versions have 2-...
 */
const VERSION_NANO: number
function buffer_get_max_memory(): number
function buffer_list_replace(old_list?: BufferList | null, new_list?: BufferList | null): [ /* returnType */ boolean, /* old_list */ BufferList | null ]
function buffer_list_take(old_list: BufferList, new_list?: BufferList | null): [ /* returnType */ boolean, /* old_list */ BufferList ]
function caps_features_from_string(features: string): CapsFeatures | null
function caps_from_string(string: string): Caps | null
function context_replace(old_context: Context, new_context?: Context | null): [ /* returnType */ boolean, /* old_context */ Context ]
function core_error_quark(): GLib.Quark
function debug_add_log_function(func: LogFunction): void
function debug_add_ring_buffer_logger(max_size_per_thread: number, thread_timeout: number): void
function debug_bin_to_dot_data(bin: Bin, details: DebugGraphDetails): string
function debug_bin_to_dot_file(bin: Bin, details: DebugGraphDetails, file_name: string): void
function debug_bin_to_dot_file_with_ts(bin: Bin, details: DebugGraphDetails, file_name: string): void
function debug_construct_term_color(colorinfo: number): string
function debug_construct_win_color(colorinfo: number): number
function debug_get_all_categories(): DebugCategory[]
function debug_get_color_mode(): DebugColorMode
function debug_get_default_threshold(): DebugLevel
function debug_get_stack_trace(flags: StackTraceFlags): string | null
function debug_is_active(): boolean
function debug_is_colored(): boolean
function debug_level_get_name(level: DebugLevel): string
function debug_log_default(category: DebugCategory, level: DebugLevel, file: string, function_: string, line: number, object: GObject.Object | null, message: DebugMessage, user_data?: object | null): void
function debug_log_get_line(category: DebugCategory, level: DebugLevel, file: string, function_: string, line: number, object: GObject.Object | null, message: DebugMessage): string
function debug_log_literal(category: DebugCategory, level: DebugLevel, file: string, function_: string, line: number, object: GObject.Object | null, message_string: string): void
function debug_print_stack_trace(): void
function debug_remove_log_function(func?: LogFunction | null): number
function debug_remove_log_function_by_data(data?: object | null): number
function debug_remove_ring_buffer_logger(): void
function debug_ring_buffer_logger_get_logs(): string[]
function debug_set_active(active: boolean): void
function debug_set_color_mode(mode: DebugColorMode): void
function debug_set_color_mode_from_string(mode: string): void
function debug_set_colored(colored: boolean): void
function debug_set_default_threshold(level: DebugLevel): void
function debug_set_threshold_for_name(name: string, level: DebugLevel): void
function debug_set_threshold_from_string(list: string, reset: boolean): void
function debug_unset_threshold_for_name(name: string): void
function deinit(): void
function dynamic_type_register(plugin: Plugin, type: GObject.Type): boolean
function error_get_message(domain: GLib.Quark, code: number): string
function event_type_get_flags(type: EventType): EventTypeFlags
function event_type_get_name(type: EventType): string
function event_type_to_quark(type: EventType): GLib.Quark
function filename_to_uri(filename: string): string
function flow_get_name(ret: FlowReturn): string
function flow_to_quark(ret: FlowReturn): GLib.Quark
function format_get_by_nick(nick: string): Format
function format_get_details(format: Format): FormatDefinition | null
function format_get_name(format: Format): string | null
function format_iterate_definitions(): Iterator
function format_register(nick: string, description: string): Format
function format_to_quark(format: Format): GLib.Quark
function formats_contains(formats: Format[], format: Format): boolean
function get_main_executable_path(): string | null
function init(argv?: string[] | null): /* argv */ string[] | null
function init_check(argv?: string[] | null): [ /* returnType */ boolean, /* argv */ string[] | null ]
function is_caps_features(obj?: object | null): boolean
function is_initialized(): boolean
function library_error_quark(): GLib.Quark
function message_take(old_message: Message, new_message?: Message | null): [ /* returnType */ boolean, /* old_message */ Message ]
function message_type_get_name(type: MessageType): string
function message_type_to_quark(type: MessageType): GLib.Quark
function meta_api_type_get_tags(api: GObject.Type): string[]
function meta_api_type_has_tag(api: GObject.Type, tag: GLib.Quark): boolean
function meta_api_type_register(api: string, tags: string[]): GObject.Type
function meta_get_info(impl: string): MetaInfo | null
function meta_register(api: GObject.Type, impl: string, size: number, init_func: MetaInitFunction, free_func: MetaFreeFunction, transform_func: MetaTransformFunction): MetaInfo
function meta_register_custom(name: string, tags: string[], transform_func: CustomMetaTransformFunction | null): MetaInfo
function mini_object_replace(olddata?: MiniObject | null, newdata?: MiniObject | null): [ /* returnType */ boolean, /* olddata */ MiniObject | null ]
function mini_object_take(olddata: MiniObject, newdata: MiniObject): [ /* returnType */ boolean, /* olddata */ MiniObject ]
function pad_mode_get_name(mode: PadMode): string
function param_spec_array(name: string, nick: string, blurb: string, element_spec: GObject.ParamSpec, flags: GObject.ParamFlags): GObject.ParamSpec
function param_spec_fraction(name: string, nick: string, blurb: string, min_num: number, min_denom: number, max_num: number, max_denom: number, default_num: number, default_denom: number, flags: GObject.ParamFlags): GObject.ParamSpec | null
function parent_buffer_meta_api_get_type(): GObject.Type
function parent_buffer_meta_get_info(): MetaInfo
function parse_bin_from_description(bin_description: string, ghost_unlinked_pads: boolean): Bin
function parse_bin_from_description_full(bin_description: string, ghost_unlinked_pads: boolean, context: ParseContext | null, flags: ParseFlags): Element
function parse_error_quark(): GLib.Quark
function parse_launch(pipeline_description: string): Element
function parse_launch_full(pipeline_description: string, context: ParseContext | null, flags: ParseFlags): Element
function parse_launchv(argv: string[]): Element
function parse_launchv_full(argv: string[], context: ParseContext | null, flags: ParseFlags): Element
function plugin_error_quark(): GLib.Quark
function preset_get_app_dir(): string | null
function preset_set_app_dir(app_dir: string): boolean
function protection_filter_systems_by_available_decryptors(system_identifiers: string[]): string[] | null
function protection_meta_api_get_type(): GObject.Type
function protection_meta_get_info(): MetaInfo
function protection_select_system(system_identifiers: string[]): string | null
function query_take(old_query?: Query | null, new_query?: Query | null): [ /* returnType */ boolean, /* old_query */ Query | null ]
function query_type_get_flags(type: QueryType): QueryTypeFlags
function query_type_get_name(type: QueryType): string
function query_type_to_quark(type: QueryType): GLib.Quark
function reference_timestamp_meta_api_get_type(): GObject.Type
function reference_timestamp_meta_get_info(): MetaInfo
function resource_error_quark(): GLib.Quark
function segtrap_is_enabled(): boolean
function segtrap_set_enabled(enabled: boolean): void
function state_change_get_name(transition: StateChange): string
function static_caps_get_type(): GObject.Type
function static_pad_template_get_type(): GObject.Type
function stream_error_quark(): GLib.Quark
function stream_type_get_name(stype: StreamType): string
function structure_take(oldstr_ptr?: Structure | null, newstr?: Structure | null): [ /* returnType */ boolean, /* oldstr_ptr */ Structure | null ]
function tag_exists(tag: string): boolean
function tag_get_description(tag: string): string | null
function tag_get_flag(tag: string): TagFlag
function tag_get_nick(tag: string): string | null
function tag_get_type(tag: string): GObject.Type
function tag_is_fixed(tag: string): boolean
function tag_list_copy_value(list: TagList, tag: string): [ /* returnType */ boolean, /* dest */ any ]
function tag_list_replace(old_taglist?: TagList | null, new_taglist?: TagList | null): [ /* returnType */ boolean, /* old_taglist */ TagList | null ]
function tag_list_take(old_taglist: TagList, new_taglist?: TagList | null): [ /* returnType */ boolean, /* old_taglist */ TagList ]
function tag_merge_strings_with_comma(src: any): /* dest */ any
function tag_merge_use_first(src: any): /* dest */ any
function toc_entry_type_get_nick(type: TocEntryType): string
function tracing_get_active_tracers(): Tracer[]
function tracing_register_hook(tracer: Tracer, detail: string, func: GObject.Callback): void
function type_find_get_type(): GObject.Type
function type_find_register(plugin: Plugin | null, name: string, rank: number, func: TypeFindFunction, extensions: string | null, possible_caps: Caps | null): boolean
function type_is_plugin_api(type: GObject.Type): [ /* returnType */ boolean, /* flags */ PluginAPIFlags | null ]
function type_mark_as_plugin_api(type: GObject.Type, flags: PluginAPIFlags): void
function update_registry(): boolean
function uri_construct(protocol: string, location: string): string
function uri_error_quark(): GLib.Quark
function uri_from_string(uri: string): Uri | null
function uri_from_string_escaped(uri: string): Uri | null
function uri_get_location(uri: string): string | null
function uri_get_protocol(uri: string): string | null
function uri_has_protocol(uri: string, protocol: string): boolean
function uri_is_valid(uri: string): boolean
function uri_join_strings(base_uri: string, ref_uri: string): string
function uri_protocol_is_supported(type: URIType, protocol: string): boolean
function uri_protocol_is_valid(protocol: string): boolean
function util_array_binary_search(array: object | null, num_elements: number, element_size: number, search_func: GLib.CompareDataFunc, mode: SearchMode, search_data?: object | null): object | null
function util_double_to_fraction(src: number): [ /* dest_n */ number, /* dest_d */ number ]
function util_dump_buffer(buf: Buffer): void
function util_dump_mem(mem: Uint8Array): void
function util_fraction_add(a_n: number, a_d: number, b_n: number, b_d: number): [ /* returnType */ boolean, /* res_n */ number, /* res_d */ number ]
function util_fraction_compare(a_n: number, a_d: number, b_n: number, b_d: number): number
function util_fraction_multiply(a_n: number, a_d: number, b_n: number, b_d: number): [ /* returnType */ boolean, /* res_n */ number, /* res_d */ number ]
function util_fraction_to_double(src_n: number, src_d: number): /* dest */ number
function util_gdouble_to_guint64(value: number): number
function util_get_object_array(object: GObject.Object, name: string): [ /* returnType */ boolean, /* array */ GObject.ValueArray ]
function util_get_timestamp(): ClockTime
function util_greatest_common_divisor(a: number, b: number): number
function util_greatest_common_divisor_int64(a: number, b: number): number
function util_group_id_next(): number
function util_guint64_to_gdouble(value: number): number
function util_seqnum_compare(s1: number, s2: number): number
function util_seqnum_next(): number
function util_set_object_arg(object: GObject.Object, name: string, value: string): void
function util_set_object_array(object: GObject.Object, name: string, array: GObject.ValueArray): boolean
function util_set_value_from_string(value_str: string): /* value */ any
function util_uint64_scale(val: number, num: number, denom: number): number
function util_uint64_scale_ceil(val: number, num: number, denom: number): number
function util_uint64_scale_int(val: number, num: number, denom: number): number
function util_uint64_scale_int_ceil(val: number, num: number, denom: number): number
function util_uint64_scale_int_round(val: number, num: number, denom: number): number
function util_uint64_scale_round(val: number, num: number, denom: number): number
function value_can_compare(value1: any, value2: any): boolean
function value_can_intersect(value1: any, value2: any): boolean
function value_can_subtract(minuend: any, subtrahend: any): boolean
function value_can_union(value1: any, value2: any): boolean
function value_compare(value1: any, value2: any): number
function value_deserialize(src: string): [ /* returnType */ boolean, /* dest */ any ]
function value_deserialize_with_pspec(src: string, pspec?: GObject.ParamSpec | null): [ /* returnType */ boolean, /* dest */ any ]
function value_fixate(dest: any, src: any): boolean
function value_fraction_multiply(product: any, factor1: any, factor2: any): boolean
function value_fraction_subtract(dest: any, minuend: any, subtrahend: any): boolean
function value_get_bitmask(value: any): number
function value_get_caps(value: any): Caps
function value_get_caps_features(value: any): CapsFeatures
function value_get_double_range_max(value: any): number
function value_get_double_range_min(value: any): number
function value_get_flagset_flags(value: any): number
function value_get_flagset_mask(value: any): number
function value_get_fraction_denominator(value: any): number
function value_get_fraction_numerator(value: any): number
function value_get_fraction_range_max(value: any): any | null
function value_get_fraction_range_min(value: any): any | null
function value_get_int64_range_max(value: any): number
function value_get_int64_range_min(value: any): number
function value_get_int64_range_step(value: any): number
function value_get_int_range_max(value: any): number
function value_get_int_range_min(value: any): number
function value_get_int_range_step(value: any): number
function value_get_structure(value: any): Structure
function value_init_and_copy(src: any): /* dest */ any
function value_intersect(value1: any, value2: any): [ /* returnType */ boolean, /* dest */ any | null ]
function value_is_fixed(value: any): boolean
function value_is_subset(value1: any, value2: any): boolean
function value_register(table: ValueTable): void
function value_serialize(value: any): string | null
function value_set_bitmask(value: any, bitmask: number): void
function value_set_caps(value: any, caps: Caps): void
function value_set_caps_features(value: any, features: CapsFeatures): void
function value_set_double_range(value: any, start: number, end: number): void
function value_set_flagset(value: any, flags: number, mask: number): void
function value_set_fraction(value: any, numerator: number, denominator: number): void
function value_set_fraction_range(value: any, start: any, end: any): void
function value_set_fraction_range_full(value: any, numerator_start: number, denominator_start: number, numerator_end: number, denominator_end: number): void
function value_set_int64_range(value: any, start: number, end: number): void
function value_set_int64_range_step(value: any, start: number, end: number, step: number): void
function value_set_int_range(value: any, start: number, end: number): void
function value_set_int_range_step(value: any, start: number, end: number, step: number): void
function value_set_structure(value: any, structure: Structure): void
function value_subtract(minuend: any, subtrahend: any): [ /* returnType */ boolean, /* dest */ any | null ]
function value_union(value1: any, value2: any): [ /* returnType */ boolean, /* dest */ any ]
function version(): [ /* major */ number, /* minor */ number, /* micro */ number, /* nano */ number ]
function version_string(): string
/**
 * A function that will be called from gst_buffer_foreach_meta(). The `meta`
 * field will point to a the reference of the meta.
 * 
 * `buffer` should not be modified from this callback.
 * 
 * When this function returns %TRUE, the next meta will be
 * returned. When %FALSE is returned, gst_buffer_foreach_meta() will return.
 * 
 * When `meta` is set to %NULL, the item will be removed from the buffer.
 */
interface BufferForeachMetaFunc {
    (buffer: Buffer): boolean
}
/**
 * A function that will be called from gst_buffer_list_foreach(). The `buffer`
 * field will point to a the reference of the buffer at `idx`.
 * 
 * When this function returns %TRUE, the next buffer will be
 * returned. When %FALSE is returned, gst_buffer_list_foreach() will return.
 * 
 * When `buffer` is set to %NULL, the item will be removed from the bufferlist.
 * When `buffer` has been made writable, the new buffer reference can be assigned
 * to `buffer`. This function is responsible for unreffing the old buffer when
 * removing or modifying.
 */
interface BufferListFunc {
    (idx: number): boolean
}
/**
 * Specifies the type of function passed to gst_bus_add_watch() or
 * gst_bus_add_watch_full(), which is called from the mainloop when a message
 * is available on the bus.
 * 
 * The message passed to the function will be unreffed after execution of this
 * function so it should not be freed in the function.
 * 
 * Note that this function is used as a #GSourceFunc which means that returning
 * %FALSE will remove the #GSource from the mainloop.
 */
interface BusFunc {
    (bus: Bus, message: Message): boolean
}
/**
 * Handler will be invoked synchronously, when a new message has been injected
 * into the bus. This function is mostly used internally. Only one sync handler
 * can be attached to a given bus.
 * 
 * If the handler returns %GST_BUS_DROP, it should unref the message, else the
 * message should not be unreffed by the sync handler.
 */
interface BusSyncHandler {
    (bus: Bus, message: Message): BusSyncReply
}
/**
 * A function that will be called in gst_caps_filter_and_map_in_place().
 * The function may modify `features` and `structure,` and both will be
 * removed from the caps if %FALSE is returned.
 */
interface CapsFilterMapFunc {
    (features: CapsFeatures, structure: Structure): boolean
}
/**
 * A function that will be called in gst_caps_foreach(). The function may
 * not modify `features` or `structure`.
 */
interface CapsForeachFunc {
    (features: CapsFeatures, structure: Structure): boolean
}
/**
 * A function that will be called in gst_caps_map_in_place(). The function
 * may modify `features` and `structure`.
 */
interface CapsMapFunc {
    (features: CapsFeatures, structure: Structure): boolean
}
/**
 * The function prototype of the callback.
 */
interface ClockCallback {
    (clock: Clock, time: ClockTime, id: ClockID): boolean
}
/**
 * FIXME(2.0): remove, this is unused
 */
interface ControlBindingConvert {
    (binding: ControlBinding, src_value: number, dest_value: any): void
}
/**
 * Function for returning a value for a given timestamp.
 */
interface ControlSourceGetValue {
    (self: ControlSource, timestamp: ClockTime, value: number): boolean
}
/**
 * Function for returning an array of values starting at a given timestamp.
 */
interface ControlSourceGetValueArray {
    (self: ControlSource, timestamp: ClockTime, interval: ClockTime, n_values: number, values: number): boolean
}
/**
 * Function called for each `meta` in `buffer` as a result of performing a
 * transformation on `transbuf`. Additional `type` specific transform data
 * is passed to the function as `data`.
 * 
 * Implementations should check the `type` of the transform and parse
 * additional type specific fields in `data` that should be used to update
 * the metadata on `transbuf`.
 */
interface CustomMetaTransformFunction {
    (transbuf: Buffer, meta: CustomMeta, buffer: Buffer, type: GLib.Quark, data?: object | null): boolean
}
/**
 * we define this to avoid a compiler warning regarding a cast from a function
 * pointer to a void pointer
 * (see https://bugzilla.gnome.org/show_bug.cgi?id=309253)
 */
interface DebugFuncPtr {
    (): void
}
/**
 * Callback prototype used in #gst_element_call_async
 */
interface ElementCallAsyncFunc {
    (element: Element): void
}
/**
 * Function called for each pad when using gst_element_foreach_sink_pad(),
 * gst_element_foreach_src_pad(), or gst_element_foreach_pad().
 */
interface ElementForeachPadFunc {
    (element: Element, pad: Pad): boolean
}
/**
 * This function will be called when creating a copy of `it` and should
 * create a copy of all custom iterator fields or increase their
 * reference counts.
 */
interface IteratorCopyFunction {
    (it: Iterator, copy: Iterator): void
}
/**
 * A function to be passed to gst_iterator_fold().
 */
interface IteratorFoldFunction {
    (item: any, ret: any): boolean
}
/**
 * A function that is called by gst_iterator_foreach() for every element.
 */
interface IteratorForeachFunction {
    (item: any): void
}
/**
 * This function will be called when the iterator is freed.
 * 
 * Implementors of a #GstIterator should implement this
 * function and pass it to the constructor of the custom iterator.
 * The function will be called with the iterator lock held.
 */
interface IteratorFreeFunction {
    (it: Iterator): void
}
/**
 * The function that will be called after the next item of the iterator
 * has been retrieved. This function can be used to skip items or stop
 * the iterator.
 * 
 * The function will be called with the iterator lock held.
 */
interface IteratorItemFunction {
    (it: Iterator, item: any): IteratorItem
}
/**
 * The function that will be called when the next element of the iterator
 * should be retrieved.
 * 
 * Implementors of a #GstIterator should implement this
 * function and pass it to the constructor of the custom iterator.
 * The function will be called with the iterator lock held.
 */
interface IteratorNextFunction {
    (it: Iterator, result: any): IteratorResult
}
/**
 * This function will be called whenever a concurrent update happened
 * to the iterated datastructure. The implementor of the iterator should
 * restart the iterator from the beginning and clean up any state it might
 * have.
 * 
 * Implementors of a #GstIterator should implement this
 * function and pass it to the constructor of the custom iterator.
 * The function will be called with the iterator lock held.
 */
interface IteratorResyncFunction {
    (it: Iterator): void
}
/**
 * Function prototype for a logging function that can be registered with
 * gst_debug_add_log_function().
 * Use G_GNUC_NO_INSTRUMENT on that function.
 */
interface LogFunction {
    (category: DebugCategory, level: DebugLevel, file: string, function_: string, line: number, object: GObject.Object, message: DebugMessage): void
}
/**
 * Copy `size` bytes from `mem` starting at `offset` and return them wrapped in a
 * new GstMemory object.
 * If `size` is set to -1, all bytes starting at `offset` are copied.
 */
interface MemoryCopyFunction {
    (mem: Memory, offset: number, size: number): Memory
}
/**
 * Check if `mem1` and `mem2` occupy contiguous memory and return the offset of
 * `mem1` in the parent buffer in `offset`.
 */
interface MemoryIsSpanFunction {
    (mem1: Memory, mem2: Memory, offset: number): boolean
}
/**
 * Get the memory of `mem` that can be accessed according to the mode specified
 * in `info'`s flags. The function should return a pointer that contains at least
 * `maxsize` bytes.
 */
interface MemoryMapFullFunction {
    (mem: Memory, info: MapInfo, maxsize: number): object | null
}
/**
 * Get the memory of `mem` that can be accessed according to the mode specified
 * in `flags`. The function should return a pointer that contains at least
 * `maxsize` bytes.
 */
interface MemoryMapFunction {
    (mem: Memory, maxsize: number, flags: MapFlags): object | null
}
/**
 * Share `size` bytes from `mem` starting at `offset` and return them wrapped in a
 * new GstMemory object. If `size` is set to -1, all bytes starting at `offset` are
 * shared. This function does not make a copy of the bytes in `mem`.
 */
interface MemoryShareFunction {
    (mem: Memory, offset: number, size: number): Memory
}
/**
 * Release the pointer previously retrieved with gst_memory_map() with `info`.
 */
interface MemoryUnmapFullFunction {
    (mem: Memory, info: MapInfo): void
}
/**
 * Release the pointer previously retrieved with gst_memory_map().
 */
interface MemoryUnmapFunction {
    (mem: Memory): void
}
/**
 * Function called when `meta` is freed in `buffer`.
 */
interface MetaFreeFunction {
    (meta: Meta, buffer: Buffer): void
}
/**
 * Function called when `meta` is initialized in `buffer`.
 */
interface MetaInitFunction {
    (meta: Meta, params: object | null, buffer: Buffer): boolean
}
/**
 * Function called for each `meta` in `buffer` as a result of performing a
 * transformation on `transbuf`. Additional `type` specific transform data
 * is passed to the function as `data`.
 * 
 * Implementations should check the `type` of the transform and parse
 * additional type specific fields in `data` that should be used to update
 * the metadata on `transbuf`.
 */
interface MetaTransformFunction {
    (transbuf: Buffer, meta: Meta, buffer: Buffer, type: GLib.Quark, data?: object | null): boolean
}
/**
 * Function prototype for methods to create copies of instances.
 */
interface MiniObjectCopyFunction {
    (obj: MiniObject): MiniObject
}
/**
 * Function prototype for when a miniobject has lost its last refcount.
 * Implementation of the mini object are allowed to revive the
 * passed object by doing a gst_mini_object_ref(). If the object is not
 * revived after the dispose function, the function should return %TRUE
 * and the memory associated with the object is freed.
 */
interface MiniObjectDisposeFunction {
    (obj: MiniObject): boolean
}
/**
 * Virtual function prototype for methods to free resources used by
 * mini-objects.
 */
interface MiniObjectFreeFunction {
    (obj: MiniObject): void
}
/**
 * A #GstMiniObjectNotify function can be added to a mini object as a
 * callback that gets triggered when gst_mini_object_unref() drops the
 * last ref and `obj` is about to be freed.
 */
interface MiniObjectNotify {
    (obj: MiniObject): void
}
/**
 * This function is called when the pad is activated during the element
 * READY to PAUSED state change. By default this function will call the
 * activate function that puts the pad in push mode but elements can
 * override this function to activate the pad in pull mode if they wish.
 */
interface PadActivateFunction {
    (pad: Pad, parent: Object): boolean
}
/**
 * The prototype of the push and pull activate functions.
 */
interface PadActivateModeFunction {
    (pad: Pad, parent: Object, mode: PadMode, active: boolean): boolean
}
/**
 * A function that will be called on sinkpads when chaining buffers.
 * The function typically processes the data contained in the buffer and
 * either consumes the data or passes it on to the internally linked pad(s).
 * 
 * The implementer of this function receives a refcount to `buffer` and should
 * gst_buffer_unref() when the buffer is no longer needed.
 * 
 * When a chain function detects an error in the data stream, it must post an
 * error on the bus and return an appropriate #GstFlowReturn value.
 */
interface PadChainFunction {
    (pad: Pad, parent: Object | null, buffer: Buffer): FlowReturn
}
/**
 * A function that will be called on sinkpads when chaining buffer lists.
 * The function typically processes the data contained in the buffer list and
 * either consumes the data or passes it on to the internally linked pad(s).
 * 
 * The implementer of this function receives a refcount to `list` and
 * should gst_buffer_list_unref() when the list is no longer needed.
 * 
 * When a chainlist function detects an error in the data stream, it must
 * post an error on the bus and return an appropriate #GstFlowReturn value.
 */
interface PadChainListFunction {
    (pad: Pad, parent: Object | null, list: BufferList): FlowReturn
}
/**
 * Function signature to handle an event for the pad.
 * 
 * This variant is for specific elements that will take into account the
 * last downstream flow return (from a pad push), in which case they can
 * return it.
 */
interface PadEventFullFunction {
    (pad: Pad, parent: Object | null, event: Event): FlowReturn
}
/**
 * Function signature to handle an event for the pad.
 */
interface PadEventFunction {
    (pad: Pad, parent: Object | null, event: Event): boolean
}
/**
 * A forward function is called for all internally linked pads, see
 * gst_pad_forward().
 */
interface PadForwardFunction {
    (pad: Pad): boolean
}
/**
 * This function will be called on source pads when a peer element
 * request a buffer at the specified `offset` and `length`. If this function
 * returns #GST_FLOW_OK, the result buffer will be stored in `buffer`. The
 * contents of `buffer` is invalid for any other return value.
 * 
 * This function is installed on a source pad with
 * gst_pad_set_getrange_function() and can only be called on source pads after
 * they are successfully activated with gst_pad_activate_mode() with the
 * #GST_PAD_MODE_PULL.
 * 
 * `offset` and `length` are always given in byte units. `offset` must normally be a value
 * between 0 and the length in bytes of the data available on `pad`. The
 * length (duration in bytes) can be retrieved with a #GST_QUERY_DURATION or with a
 * #GST_QUERY_SEEKING.
 * 
 * Any `offset` larger or equal than the length will make the function return
 * #GST_FLOW_EOS, which corresponds to EOS. In this case `buffer` does not
 * contain a valid buffer.
 * 
 * The buffer size of `buffer` will only be smaller than `length` when `offset` is
 * near the end of the stream. In all other cases, the size of `buffer` must be
 * exactly the requested size.
 * 
 * It is allowed to call this function with a 0 `length` and valid `offset,` in
 * which case `buffer` will contain a 0-sized buffer and the function returns
 * #GST_FLOW_OK.
 * 
 * When this function is called with a -1 `offset,` the sequentially next buffer
 * of length `length` in the stream is returned.
 * 
 * When this function is called with a -1 `length,` a buffer with a default
 * optimal length is returned in `buffer`. The length might depend on the value
 * of `offset`.
 */
interface PadGetRangeFunction {
    (pad: Pad, parent: Object | null, offset: number, length: number, buffer: Buffer): FlowReturn
}
/**
 * The signature of the internal pad link iterator function.
 */
interface PadIterIntLinkFunction {
    (pad: Pad, parent?: Object | null): Iterator
}
/**
 * Function signature to handle a new link on the pad.
 */
interface PadLinkFunction {
    (pad: Pad, parent: Object | null, peer: Pad): PadLinkReturn
}
/**
 * Callback used by gst_pad_add_probe(). Gets called to notify about the current
 * blocking type.
 * 
 * The callback is allowed to modify the data pointer in `info`.
 */
interface PadProbeCallback {
    (pad: Pad, info: PadProbeInfo): PadProbeReturn
}
/**
 * The signature of the query function.
 */
interface PadQueryFunction {
    (pad: Pad, parent: Object | null, query: Query): boolean
}
/**
 * Callback used by gst_pad_sticky_events_foreach().
 * 
 * When this function returns %TRUE, the next event will be
 * returned. When %FALSE is returned, gst_pad_sticky_events_foreach() will return.
 * 
 * When `event` is set to %NULL, the item will be removed from the list of sticky events.
 * `event` can be replaced by assigning a new reference to it.
 * This function is responsible for unreffing the old event when
 * removing or modifying.
 */
interface PadStickyEventsForeachFunction {
    (pad: Pad, event?: Event | null): boolean
}
/**
 * Function signature to handle a unlinking the pad prom its peer.
 * 
 * The pad's lock is already held when the unlink function is called, so most
 * pad functions cannot be called from within the callback.
 */
interface PadUnlinkFunction {
    (pad: Pad, parent?: Object | null): void
}
/**
 * A function that can be used with e.g. gst_registry_feature_filter()
 * to get a list of pluginfeature that match certain criteria.
 */
interface PluginFeatureFilter {
    (feature: PluginFeature): boolean
}
/**
 * A function that can be used with e.g. gst_registry_plugin_filter()
 * to get a list of plugins that match certain criteria.
 */
interface PluginFilter {
    (plugin: Plugin): boolean
}
/**
 * A plugin should provide a pointer to a function of either #GstPluginInitFunc
 * or this type in the plugin_desc struct.
 * The function will be called by the loader at startup. One would then
 * register each #GstPluginFeature. This version allows
 * user data to be passed to init function (useful for bindings).
 */
interface PluginInitFullFunc {
    (plugin: Plugin): boolean
}
/**
 * A plugin should provide a pointer to a function of this type in the
 * plugin_desc struct.
 * This function will be called by the loader at startup. One would then
 * register each #GstPluginFeature.
 */
interface PluginInitFunc {
    (plugin: Plugin): boolean
}
interface PromiseChangeFunc {
    (promise: Promise): void
}
/**
 * A function that will be called in gst_structure_filter_and_map_in_place().
 * The function may modify `value,` and the value will be removed from
 * the structure if %FALSE is returned.
 */
interface StructureFilterMapFunc {
    (field_id: GLib.Quark, value: any): boolean
}
/**
 * A function that will be called in gst_structure_foreach(). The function may
 * not modify `value`.
 */
interface StructureForeachFunc {
    (field_id: GLib.Quark, value: any): boolean
}
/**
 * A function that will be called in gst_structure_map_in_place(). The function
 * may modify `value`.
 */
interface StructureMapFunc {
    (field_id: GLib.Quark, value: any): boolean
}
/**
 * A function that will be called in gst_tag_list_foreach(). The function may
 * not modify the tag list.
 */
interface TagForeachFunc {
    (list: TagList, tag: string): void
}
/**
 * A function for merging multiple values of a tag used when registering
 * tags.
 */
interface TagMergeFunc {
    (dest: any, src: any): void
}
/**
 * A function that will repeatedly be called in the thread created by
 * a #GstTask.
 */
interface TaskFunction {
    (): void
}
/**
 * Task function, see gst_task_pool_push().
 */
interface TaskPoolFunction {
    (): void
}
/**
 * Custom GstTask thread callback functions that can be installed.
 */
interface TaskThreadFunc {
    (task: Task, thread: GLib.Thread): void
}
/**
 * A function that will be called by typefinding.
 */
interface TypeFindFunction {
    (find: TypeFind): void
}
/**
 * Used together with gst_value_compare() to compare #GValue items.
 */
interface ValueCompareFunc {
    (value1: any, value2: any): number
}
/**
 * Used by gst_value_deserialize() to parse a non-binary form into the #GValue.
 */
interface ValueDeserializeFunc {
    (dest: any, s: string): boolean
}
/**
 * Used by gst_value_deserialize_with_pspec() to parse a non-binary form into the #GValue.
 */
interface ValueDeserializeWithPSpecFunc {
    (dest: any, s: string, pspec: GObject.ParamSpec): boolean
}
/**
 * Used by gst_value_serialize() to obtain a non-binary form of the #GValue.
 * 
 * Free-function: g_free
 */
interface ValueSerializeFunc {
    (value1: any): string
}
class ChildProxy {
    /* Methods of Gst-1.0.Gst.ChildProxy */
    /**
     * Emits the #GstChildProxy::child-added signal.
     * @param child the newly added child
     * @param name the name of the new child
     */
    child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     * @param child the removed child
     * @param name the name of the old child
     */
    child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     * @param index the child's position in the child list
     */
    get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     * @param name the child's name
     */
    get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    get_children_count(): number
    /**
     * Gets a single property using the GstChildProxy mechanism.
     * You are responsible for freeing it by calling g_value_unset()
     * @param name name of the property
     */
    get_property(name: string): /* value */ any
    /**
     * Looks up which object and #GParamSpec would be effected by the given `name`.
     * @param name name of the property to look up
     */
    lookup(name: string): [ /* returnType */ boolean, /* target */ GObject.Object | null, /* pspec */ GObject.ParamSpec | null ]
    /**
     * Sets a single property using the GstChildProxy mechanism.
     * @param name name of the property to set
     * @param value new #GValue for the property
     */
    set_property(name: string, value: any): void
    /* Virtual methods of Gst-1.0.Gst.ChildProxy */
    /**
     * Emits the #GstChildProxy::child-added signal.
     * @param child the newly added child
     * @param name the name of the new child
     */
    vfunc_child_added(child: GObject.Object, name: string): void
    /**
     * Emits the #GstChildProxy::child-removed signal.
     * @param child the removed child
     * @param name the name of the old child
     */
    vfunc_child_removed(child: GObject.Object, name: string): void
    /**
     * Fetches a child by its number.
     * @param index the child's position in the child list
     */
    vfunc_get_child_by_index(index: number): GObject.Object | null
    /**
     * Looks up a child element by the given name.
     * 
     * This virtual method has a default implementation that uses #GstObject
     * together with gst_object_get_name(). If the interface is to be used with
     * #GObjects, this methods needs to be overridden.
     * @param name the child's name
     */
    vfunc_get_child_by_name(name: string): GObject.Object | null
    /**
     * Gets the number of child objects this parent contains.
     */
    vfunc_get_children_count(): number
    /* Signals of Gst-1.0.Gst.ChildProxy */
    /**
     * Will be emitted after the `object` was added to the `child_proxy`.
     * @param object the #GObject that was added
     * @param name the name of the new child
     */
    connect(sigName: "child-added", callback: (($obj: ChildProxy, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-added", callback: (($obj: ChildProxy, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-added", object: GObject.Object, name: string): void
    /**
     * Will be emitted after the `object` was removed from the `child_proxy`.
     * @param object the #GObject that was removed
     * @param name the name of the old child
     */
    connect(sigName: "child-removed", callback: (($obj: ChildProxy, object: GObject.Object, name: string) => void)): number
    connect_after(sigName: "child-removed", callback: (($obj: ChildProxy, object: GObject.Object, name: string) => void)): number
    emit(sigName: "child-removed", object: GObject.Object, name: string): void
    static name: string
}
class Preset {
    /* Methods of Gst-1.0.Gst.Preset */
    /**
     * Delete the given preset.
     * @param name preset name to remove
     */
    delete_preset(name: string): boolean
    /**
     * Gets the `value` for an existing meta data `tag`. Meta data `tag` names can be
     * something like e.g. "comment". Returned values need to be released when done.
     * @param name preset name
     * @param tag meta data item name
     */
    get_meta(name: string, tag: string): [ /* returnType */ boolean, /* value */ string ]
    /**
     * Get a copy of preset names as a %NULL terminated string array.
     */
    get_preset_names(): string[]
    /**
     * Get a the names of the GObject properties that can be used for presets.
     */
    get_property_names(): string[]
    /**
     * Check if one can add new presets, change existing ones and remove presets.
     */
    is_editable(): boolean
    /**
     * Load the given preset.
     * @param name preset name to load
     */
    load_preset(name: string): boolean
    /**
     * Renames a preset. If there is already a preset by the `new_name` it will be
     * overwritten.
     * @param old_name current preset name
     * @param new_name new preset name
     */
    rename_preset(old_name: string, new_name: string): boolean
    /**
     * Save the current object settings as a preset under the given name. If there
     * is already a preset by this `name` it will be overwritten.
     * @param name preset name to save
     */
    save_preset(name: string): boolean
    /**
     * Sets a new `value` for an existing meta data item or adds a new item. Meta
     * data `tag` names can be something like e.g. "comment". Supplying %NULL for the
     * `value` will unset an existing value.
     * @param name preset name
     * @param tag meta data item name
     * @param value new value
     */
    set_meta(name: string, tag: string, value?: string | null): boolean
    /* Virtual methods of Gst-1.0.Gst.Preset */
    /**
     * Delete the given preset.
     * @param name preset name to remove
     */
    vfunc_delete_preset(name: string): boolean
    /**
     * Gets the `value` for an existing meta data `tag`. Meta data `tag` names can be
     * something like e.g. "comment". Returned values need to be released when done.
     * @param name preset name
     * @param tag meta data item name
     */
    vfunc_get_meta(name: string, tag: string): [ /* returnType */ boolean, /* value */ string ]
    /**
     * Get a copy of preset names as a %NULL terminated string array.
     */
    vfunc_get_preset_names(): string[]
    /**
     * Get a the names of the GObject properties that can be used for presets.
     */
    vfunc_get_property_names(): string[]
    /**
     * Load the given preset.
     * @param name preset name to load
     */
    vfunc_load_preset(name: string): boolean
    /**
     * Renames a preset. If there is already a preset by the `new_name` it will be
     * overwritten.
     * @param old_name current preset name
     * @param new_name new preset name
     */
    vfunc_rename_preset(old_name: string, new_name: string): boolean
    /**
     * Save the current object settings as a preset under the given name. If there
     * is already a preset by this `name` it will be overwritten.
     * @param name preset name to save
     */
    vfunc_save_preset(name: string): boolean
    /**
     * Sets a new `value` for an existing meta data item or adds a new item. Meta
     * data `tag` names can be something like e.g. "comment". Supplying %NULL for the
     * `value` will unset an existing value.
     * @param name preset name
     * @param tag meta data item name
     * @param value new value
     */
    vfunc_set_meta(name: string, tag: string, value?: string | null): boolean
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Gets the directory for application specific presets if set by the
     * application.
     */
    static get_app_dir(): string | null
    /**
     * Sets an extra directory as an absolute path that should be considered when
     * looking for presets. Any presets in the application dir will shadow the
     * system presets.
     * @param app_dir the application specific preset dir
     */
    static set_app_dir(app_dir: string): boolean
}
interface TagSetter_ConstructProps extends Element_ConstructProps {
}
class TagSetter {
    /* Fields of Gst-1.0.Gst.Element */
    object: Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    target_state: State
    /**
     * the current state of an element
     */
    current_state: State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    next_state: State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    pending_state: State
    /**
     * the last return value of an element state change
     */
    last_return: StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    bus: Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    clock: Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    base_time: ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    start_time: ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    numpads: number
    /**
     * list of pads
     */
    pads: Pad[]
    /**
     * number of source pads of the element.
     */
    numsrcpads: number
    /**
     * list of source pads
     */
    srcpads: Pad[]
    /**
     * number of sink pads of the element.
     */
    numsinkpads: number
    /**
     * list of sink pads
     */
    sinkpads: Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    pads_cookie: number
    /**
     * list of contexts
     */
    contexts: Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.TagSetter */
    /**
     * Adds the given tag / GValue pair on the setter using the given merge mode.
     * @param mode the mode to use
     * @param tag tag to set
     * @param value GValue to set for the tag
     */
    add_tag_value(mode: TagMergeMode, tag: string, value: any): void
    /**
     * Returns the current list of tags the setter uses.  The list should not be
     * modified or freed.
     * 
     * This function is not thread-safe.
     */
    get_tag_list(): TagList | null
    /**
     * Queries the mode by which tags inside the setter are overwritten by tags
     * from events
     */
    get_tag_merge_mode(): TagMergeMode
    /**
     * Merges the given list into the setter's list using the given mode.
     * @param list a tag list to merge from
     * @param mode the mode to merge with
     */
    merge_tags(list: TagList, mode: TagMergeMode): void
    /**
     * Reset the internal taglist. Elements should call this from within the
     * state-change handler.
     */
    reset_tags(): void
    /**
     * Sets the given merge mode that is used for adding tags from events to tags
     * specified by this interface. The default is #GST_TAG_MERGE_KEEP, which keeps
     * the tags set with this interface and discards tags from events.
     * @param mode The mode with which tags are added
     */
    set_tag_merge_mode(mode: TagMergeMode): void
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     * @param pad the #GstPad to add to the element.
     */
    add_pad(pad: Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     * @param func Function to call asynchronously from another thread
     */
    call_async(func: ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    change_state(transition: StateChange): StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     * @param ret The previous state return value
     */
    continue_state(ret: StateChangeReturn): StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     * @param func function to call for each pad
     */
    foreach_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each sink pad
     */
    foreach_sink_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each source pad
     */
    foreach_src_pad(func: ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     * @param pad the #GstPad to find a compatible one for.
     * @param caps the #GstCaps to use as a filter.
     */
    get_compatible_pad(pad: Pad, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     * @param compattempl the #GstPadTemplate to find a compatible     template for
     */
    get_compatible_pad_template(compattempl: PadTemplate): PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     * @param context_type a name of a context to retrieve
     */
    get_context(context_type: string): Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * @param context_type a name of a context to retrieve
     */
    get_context_unlocked(context_type: string): Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     * @param name the name of the #GstPadTemplate to get.
     */
    get_pad_template(name: string): PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     * @param name the name of the request #GstPad to retrieve.
     */
    get_request_pad(name: string): Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     * @param name the name of the static #GstPad to retrieve.
     */
    get_static_pad(name: string): Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     */
    link(dest: Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_filtered(dest: Element, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     */
    link_pads(srcpadname: string | null, dest: Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element     or %NULL for any pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_pads_filtered(srcpadname: string | null, dest: Element, destpadname?: string | null, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     * @param flags the #GstPadLinkCheck to be performed when linking pads.
     */
    link_pads_full(srcpadname: string | null, dest: Element, destpadname: string | null, flags: PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     */
    message_full(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     * @param structure optional details structure
     */
    message_full_with_details(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    query(query: Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     * @param pad the #GstPad to release.
     */
    release_request_pad(pad: Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     * @param pad the #GstPad to remove from the element.
     */
    remove_pad(pad: Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    request_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     * @param name the name of the request #GstPad to retrieve.
     */
    request_pad_simple(name: string): Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     * @param rate The new playback rate
     * @param format The format of the seek values
     * @param flags The optional seek flags.
     * @param start_type The type and flags for the new start position
     * @param start The value of the new start position
     * @param stop_type The type and flags for the new stop position
     * @param stop The value of the new stop position
     */
    seek(rate: number, format: Format, flags: SeekFlags, start_type: SeekType, start: number, stop_type: SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     * @param format a #GstFormat to execute the seek in, such as #GST_FORMAT_TIME
     * @param seek_flags seek options; playback applications will usually want to use            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here
     * @param seek_pos position to seek to (relative to the start); if you are doing            a seek in #GST_FORMAT_TIME this value is in nanoseconds -            multiply with #GST_SECOND to convert seconds to nanoseconds or            with #GST_MSECOND to convert milliseconds to nanoseconds.
     */
    seek_simple(format: Format, seek_flags: SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    send_event(event: Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_base_time(time: ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    set_context(context: Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     * @param locked_state %TRUE to lock the element's state
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_start_time(time: ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    set_state(state: State): StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     * @param dest the sink #GstElement to unlink.
     */
    unlink(dest: Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     * @param srcpadname the name of the #GstPad in source element.
     * @param dest a #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element.
     */
    unlink_pads(srcpadname: string, dest: Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    vfunc_change_state(transition: StateChange): StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    vfunc_get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Pad): void
    vfunc_pad_removed(pad: Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    vfunc_post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    vfunc_query(query: Query): boolean
    vfunc_release_pad(pad: Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    vfunc_request_new_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    vfunc_send_event(event: Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    vfunc_set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    vfunc_set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    vfunc_set_context(context: Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    vfunc_set_state(state: State): StateChangeReturn
    vfunc_state_changed(oldstate: State, newstate: State, pending: State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: TagSetter) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: TagSetter) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     * @param new_pad the pad that has been added
     */
    connect(sigName: "pad-added", callback: (($obj: TagSetter, new_pad: Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: TagSetter, new_pad: Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Pad): void
    /**
     * a #GstPad has been removed from the element
     * @param old_pad the pad that has been removed
     */
    connect(sigName: "pad-removed", callback: (($obj: TagSetter, old_pad: Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: TagSetter, old_pad: Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: TagSetter, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TagSetter, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: TagSetter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TagSetter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TagSetter_ConstructProps)
    _init (config?: TagSetter_ConstructProps): void
    static $gtype: GObject.Type
}
interface TocSetter_ConstructProps extends Element_ConstructProps {
}
class TocSetter {
    /* Fields of Gst-1.0.Gst.Element */
    object: Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    target_state: State
    /**
     * the current state of an element
     */
    current_state: State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    next_state: State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    pending_state: State
    /**
     * the last return value of an element state change
     */
    last_return: StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    bus: Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    clock: Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    base_time: ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    start_time: ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    numpads: number
    /**
     * list of pads
     */
    pads: Pad[]
    /**
     * number of source pads of the element.
     */
    numsrcpads: number
    /**
     * list of source pads
     */
    srcpads: Pad[]
    /**
     * number of sink pads of the element.
     */
    numsinkpads: number
    /**
     * list of sink pads
     */
    sinkpads: Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    pads_cookie: number
    /**
     * list of contexts
     */
    contexts: Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.TocSetter */
    /**
     * Return current TOC the setter uses. The TOC should not be
     * modified without making it writable first.
     */
    get_toc(): Toc | null
    /**
     * Reset the internal TOC. Elements should call this from within the
     * state-change handler.
     */
    reset(): void
    /**
     * Set the given TOC on the setter. Previously set TOC will be
     * unreffed before setting a new one.
     * @param toc a #GstToc to set.
     */
    set_toc(toc?: Toc | null): void
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     * @param pad the #GstPad to add to the element.
     */
    add_pad(pad: Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     * @param func Function to call asynchronously from another thread
     */
    call_async(func: ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    change_state(transition: StateChange): StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     * @param ret The previous state return value
     */
    continue_state(ret: StateChangeReturn): StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     * @param func function to call for each pad
     */
    foreach_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each sink pad
     */
    foreach_sink_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each source pad
     */
    foreach_src_pad(func: ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     * @param pad the #GstPad to find a compatible one for.
     * @param caps the #GstCaps to use as a filter.
     */
    get_compatible_pad(pad: Pad, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     * @param compattempl the #GstPadTemplate to find a compatible     template for
     */
    get_compatible_pad_template(compattempl: PadTemplate): PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     * @param context_type a name of a context to retrieve
     */
    get_context(context_type: string): Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * @param context_type a name of a context to retrieve
     */
    get_context_unlocked(context_type: string): Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     * @param name the name of the #GstPadTemplate to get.
     */
    get_pad_template(name: string): PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     * @param name the name of the request #GstPad to retrieve.
     */
    get_request_pad(name: string): Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     * @param name the name of the static #GstPad to retrieve.
     */
    get_static_pad(name: string): Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     */
    link(dest: Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_filtered(dest: Element, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     */
    link_pads(srcpadname: string | null, dest: Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element     or %NULL for any pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_pads_filtered(srcpadname: string | null, dest: Element, destpadname?: string | null, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     * @param flags the #GstPadLinkCheck to be performed when linking pads.
     */
    link_pads_full(srcpadname: string | null, dest: Element, destpadname: string | null, flags: PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     */
    message_full(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     * @param structure optional details structure
     */
    message_full_with_details(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    query(query: Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     * @param pad the #GstPad to release.
     */
    release_request_pad(pad: Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     * @param pad the #GstPad to remove from the element.
     */
    remove_pad(pad: Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    request_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     * @param name the name of the request #GstPad to retrieve.
     */
    request_pad_simple(name: string): Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     * @param rate The new playback rate
     * @param format The format of the seek values
     * @param flags The optional seek flags.
     * @param start_type The type and flags for the new start position
     * @param start The value of the new start position
     * @param stop_type The type and flags for the new stop position
     * @param stop The value of the new stop position
     */
    seek(rate: number, format: Format, flags: SeekFlags, start_type: SeekType, start: number, stop_type: SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     * @param format a #GstFormat to execute the seek in, such as #GST_FORMAT_TIME
     * @param seek_flags seek options; playback applications will usually want to use            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here
     * @param seek_pos position to seek to (relative to the start); if you are doing            a seek in #GST_FORMAT_TIME this value is in nanoseconds -            multiply with #GST_SECOND to convert seconds to nanoseconds or            with #GST_MSECOND to convert milliseconds to nanoseconds.
     */
    seek_simple(format: Format, seek_flags: SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    send_event(event: Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_base_time(time: ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    set_context(context: Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     * @param locked_state %TRUE to lock the element's state
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_start_time(time: ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    set_state(state: State): StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     * @param dest the sink #GstElement to unlink.
     */
    unlink(dest: Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     * @param srcpadname the name of the #GstPad in source element.
     * @param dest a #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element.
     */
    unlink_pads(srcpadname: string, dest: Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    vfunc_change_state(transition: StateChange): StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    vfunc_get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Pad): void
    vfunc_pad_removed(pad: Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    vfunc_post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    vfunc_query(query: Query): boolean
    vfunc_release_pad(pad: Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    vfunc_request_new_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    vfunc_send_event(event: Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    vfunc_set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    vfunc_set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    vfunc_set_context(context: Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    vfunc_set_state(state: State): StateChangeReturn
    vfunc_state_changed(oldstate: State, newstate: State, pending: State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: TocSetter) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: TocSetter) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     * @param new_pad the pad that has been added
     */
    connect(sigName: "pad-added", callback: (($obj: TocSetter, new_pad: Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: TocSetter, new_pad: Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Pad): void
    /**
     * a #GstPad has been removed from the element
     * @param old_pad the pad that has been removed
     */
    connect(sigName: "pad-removed", callback: (($obj: TocSetter, old_pad: Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: TocSetter, old_pad: Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: TocSetter, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TocSetter, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: TocSetter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TocSetter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TocSetter_ConstructProps)
    _init (config?: TocSetter_ConstructProps): void
    static $gtype: GObject.Type
}
class URIHandler {
    /* Methods of Gst-1.0.Gst.URIHandler */
    /**
     * Gets the list of protocols supported by `handler`. This list may not be
     * modified.
     */
    get_protocols(): string[] | null
    /**
     * Gets the currently handled URI.
     */
    get_uri(): string | null
    /**
     * Gets the type of the given URI handler
     */
    get_uri_type(): URIType
    /**
     * Tries to set the URI of the given handler.
     * @param uri URI to set
     */
    set_uri(uri: string): boolean
    /* Virtual methods of Gst-1.0.Gst.URIHandler */
    /**
     * Gets the currently handled URI.
     */
    vfunc_get_uri(): string | null
    /**
     * Tries to set the URI of the given handler.
     * @param uri URI to set
     */
    vfunc_set_uri(uri: string): boolean
    static name: string
}
interface Allocator_ConstructProps extends Object_ConstructProps {
}
class Allocator {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Allocator */
    /**
     * Use `allocator` to allocate a new memory block with memory that is at least
     * `size` big.
     * 
     * The optional `params` can specify the prefix and padding for the memory. If
     * %NULL is passed, no flags, no extra prefix/padding and a default alignment is
     * used.
     * 
     * The prefix/padding will be filled with 0 if flags contains
     * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.
     * 
     * When `allocator` is %NULL, the default allocator will be used.
     * 
     * The alignment in `params` is given as a bitmask so that `align` + 1 equals
     * the amount of bytes to align to. For example, to align to 8 bytes,
     * use an alignment of 7.
     * @param size size of the visible memory area
     * @param params optional parameters
     */
    alloc(size: number, params?: AllocationParams | null): Memory | null
    /**
     * Free `memory` that was previously allocated with gst_allocator_alloc().
     * @param memory the memory to free
     */
    free(memory: Memory): void
    /**
     * Set the default allocator.
     */
    set_default(): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Allocator */
    /**
     * Use `allocator` to allocate a new memory block with memory that is at least
     * `size` big.
     * 
     * The optional `params` can specify the prefix and padding for the memory. If
     * %NULL is passed, no flags, no extra prefix/padding and a default alignment is
     * used.
     * 
     * The prefix/padding will be filled with 0 if flags contains
     * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.
     * 
     * When `allocator` is %NULL, the default allocator will be used.
     * 
     * The alignment in `params` is given as a bitmask so that `align` + 1 equals
     * the amount of bytes to align to. For example, to align to 8 bytes,
     * use an alignment of 7.
     * @param size size of the visible memory area
     * @param params optional parameters
     */
    vfunc_alloc(size: number, params?: AllocationParams | null): Memory | null
    /**
     * Free `memory` that was previously allocated with gst_allocator_alloc().
     * @param memory the memory to free
     */
    vfunc_free(memory: Memory): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Allocator, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Allocator, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Allocator, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Allocator, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Allocator_ConstructProps)
    _init (config?: Allocator_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Find a previously registered allocator with `name`. When `name` is %NULL, the
     * default allocator will be returned.
     * @param name the name of the allocator
     */
    static find(name?: string | null): Allocator | null
    /**
     * Registers the memory `allocator` with `name`.
     * @param name the name of the allocator
     * @param allocator #GstAllocator
     */
    static register(name: string, allocator: Allocator): void
    static $gtype: GObject.Type
}
interface Bin_ConstructProps extends Element_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling?: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward?: boolean
}
class Bin {
    /* Properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward: boolean
    /* Fields of Gst-1.0.Gst.Element */
    object: Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    target_state: State
    /**
     * the current state of an element
     */
    current_state: State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    next_state: State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    pending_state: State
    /**
     * the last return value of an element state change
     */
    last_return: StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    bus: Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    clock: Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    base_time: ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    start_time: ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    numpads: number
    /**
     * list of pads
     */
    pads: Pad[]
    /**
     * number of source pads of the element.
     */
    numsrcpads: number
    /**
     * list of source pads
     */
    srcpads: Pad[]
    /**
     * number of sink pads of the element.
     */
    numsinkpads: number
    /**
     * list of sink pads
     */
    sinkpads: Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    pads_cookie: number
    /**
     * list of contexts
     */
    contexts: Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Bin */
    /**
     * Adds the given element to the bin.  Sets the element's parent, and thus
     * takes ownership of the element. An element can only be added to one bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is added to the bin.
     * 
     * > When you add an element to an already-running pipeline, you will have to
     * > take care to set the state of the newly-added element to the desired
     * > state (usually PLAYING or PAUSED, same you set the pipeline to originally)
     * > with gst_element_set_state(), or use gst_element_sync_state_with_parent().
     * > The bin or pipeline will not take care of this for you.
     * @param element the #GstElement to add
     */
    add(element: Element): boolean
    /**
     * Recursively looks for elements with an unlinked pad of the given
     * direction within the specified bin and returns an unlinked pad
     * if one is found, or %NULL otherwise. If a pad is found, the caller
     * owns a reference to it and should use gst_object_unref() on the
     * pad when it is not needed any longer.
     * @param direction whether to look for an unlinked source or sink pad
     */
    find_unlinked_pad(direction: PadDirection): Pad | null
    /**
     * Looks for an element inside the bin that implements the given
     * interface. If such an element is found, it returns the element.
     * You can cast this element to the given interface afterwards.  If you want
     * all elements that implement the interface, use
     * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
     * @param iface the #GType of an interface
     */
    get_by_interface(iface: GObject.Type): Element | null
    /**
     * Gets the element with the given name from a bin. This
     * function recurses into child bins.
     * @param name the element name to search for
     */
    get_by_name(name: string): Element | null
    /**
     * Gets the element with the given name from this bin. If the
     * element is not found, a recursion is performed on the parent bin.
     * @param name the element name to search for
     */
    get_by_name_recurse_up(name: string): Element | null
    get_suppressed_flags(): ElementFlags
    /**
     * Looks for all elements inside the bin with the given element factory name.
     * The function recurses inside child bins. The iterator will yield a series of
     * #GstElement.
     * @param factory_name the name of the #GstElementFactory
     */
    iterate_all_by_element_factory_name(factory_name: string): Iterator | null
    /**
     * Looks for all elements inside the bin that implements the given
     * interface. You can safely cast all returned elements to the given interface.
     * The function recurses inside child bins. The iterator will yield a series
     * of #GstElement.
     * @param iface the #GType of an interface
     */
    iterate_all_by_interface(iface: GObject.Type): Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     */
    iterate_elements(): Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     * This iterator recurses into GstBin children.
     */
    iterate_recurse(): Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SINK flag set.
     */
    iterate_sinks(): Iterator | null
    /**
     * Gets an iterator for the elements in this bin in topologically
     * sorted order. This means that the elements are returned from
     * the most downstream elements (sinks) to the sources.
     * 
     * This function is used internally to perform the state changes
     * of the bin elements and for clock selection.
     */
    iterate_sorted(): Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SOURCE flag set.
     */
    iterate_sources(): Iterator | null
    /**
     * Queries `bin` for the current latency and reconfigures this latency on all the
     * elements using a LATENCY event.
     * 
     * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
     * is posted on the bus.
     * 
     * This function simply emits the #GstBin::do-latency signal so any custom latency
     * calculations will be performed.
     */
    recalculate_latency(): boolean
    /**
     * Removes the element from the bin, unparenting it as well.
     * Unparenting the element means that the element will be dereferenced,
     * so if the bin holds the only reference to the element, the element
     * will be freed in the process of removing it from the bin.  If you
     * want the element to still exist after removing, you need to call
     * gst_object_ref() before removing it from the bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is removed from the bin.
     * @param element the #GstElement to remove
     */
    remove(element: Element): boolean
    /**
     * Suppresses the given flags on the bin. #GstElementFlags of a
     * child element are propagated when it is added to the bin.
     * When suppressed flags are set, those specified flags will
     * not be propagated to the bin.
     * @param flags the #GstElementFlags to suppress
     */
    set_suppressed_flags(flags: ElementFlags): void
    /**
     * Synchronizes the state of every child of `bin` with the state
     * of `bin`. See also gst_element_sync_state_with_parent().
     */
    sync_children_states(): boolean
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     * @param pad the #GstPad to add to the element.
     */
    add_pad(pad: Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     * @param func Function to call asynchronously from another thread
     */
    call_async(func: ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    change_state(transition: StateChange): StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     * @param ret The previous state return value
     */
    continue_state(ret: StateChangeReturn): StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     * @param func function to call for each pad
     */
    foreach_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each sink pad
     */
    foreach_sink_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each source pad
     */
    foreach_src_pad(func: ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     * @param pad the #GstPad to find a compatible one for.
     * @param caps the #GstCaps to use as a filter.
     */
    get_compatible_pad(pad: Pad, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     * @param compattempl the #GstPadTemplate to find a compatible     template for
     */
    get_compatible_pad_template(compattempl: PadTemplate): PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     * @param context_type a name of a context to retrieve
     */
    get_context(context_type: string): Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * @param context_type a name of a context to retrieve
     */
    get_context_unlocked(context_type: string): Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     * @param name the name of the #GstPadTemplate to get.
     */
    get_pad_template(name: string): PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     * @param name the name of the request #GstPad to retrieve.
     */
    get_request_pad(name: string): Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     * @param name the name of the static #GstPad to retrieve.
     */
    get_static_pad(name: string): Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     */
    link(dest: Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_filtered(dest: Element, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     */
    link_pads(srcpadname: string | null, dest: Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element     or %NULL for any pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_pads_filtered(srcpadname: string | null, dest: Element, destpadname?: string | null, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     * @param flags the #GstPadLinkCheck to be performed when linking pads.
     */
    link_pads_full(srcpadname: string | null, dest: Element, destpadname: string | null, flags: PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     */
    message_full(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     * @param structure optional details structure
     */
    message_full_with_details(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    query(query: Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     * @param pad the #GstPad to release.
     */
    release_request_pad(pad: Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     * @param pad the #GstPad to remove from the element.
     */
    remove_pad(pad: Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    request_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     * @param name the name of the request #GstPad to retrieve.
     */
    request_pad_simple(name: string): Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     * @param rate The new playback rate
     * @param format The format of the seek values
     * @param flags The optional seek flags.
     * @param start_type The type and flags for the new start position
     * @param start The value of the new start position
     * @param stop_type The type and flags for the new stop position
     * @param stop The value of the new stop position
     */
    seek(rate: number, format: Format, flags: SeekFlags, start_type: SeekType, start: number, stop_type: SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     * @param format a #GstFormat to execute the seek in, such as #GST_FORMAT_TIME
     * @param seek_flags seek options; playback applications will usually want to use            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here
     * @param seek_pos position to seek to (relative to the start); if you are doing            a seek in #GST_FORMAT_TIME this value is in nanoseconds -            multiply with #GST_SECOND to convert seconds to nanoseconds or            with #GST_MSECOND to convert milliseconds to nanoseconds.
     */
    seek_simple(format: Format, seek_flags: SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    send_event(event: Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_base_time(time: ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    set_context(context: Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     * @param locked_state %TRUE to lock the element's state
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_start_time(time: ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    set_state(state: State): StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     * @param dest the sink #GstElement to unlink.
     */
    unlink(dest: Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     * @param srcpadname the name of the #GstPad in source element.
     * @param dest a #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element.
     */
    unlink_pads(srcpadname: string, dest: Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Bin */
    /**
     * Method to add an element to the bin.
     * @param element the element to be added
     */
    vfunc_add_element(element: Element): boolean
    /**
     * Method called when an element was added somewhere in the bin hierarchy.
     * @param sub_bin the #GstBin to which the element was added
     * @param child the element that was added
     */
    vfunc_deep_element_added(sub_bin: Bin, child: Element): void
    /**
     * Method called when an element was removed somewhere in the bin hierarchy.
     * @param sub_bin the #GstBin from which the element was removed
     * @param child the element that was removed
     */
    vfunc_deep_element_removed(sub_bin: Bin, child: Element): void
    vfunc_do_latency(): boolean
    /**
     * Method called when an element was added to the bin.
     * @param child the element that was added
     */
    vfunc_element_added(child: Element): void
    /**
     * Method called when an element was removed from the bin.
     * @param child the element that was removed
     */
    vfunc_element_removed(child: Element): void
    /**
     * Method to handle a message from the children.
     * @param message the message to be handled
     */
    vfunc_handle_message(message: Message): void
    /**
     * Method to remove an element from the bin.
     * @param element the element to be removed
     */
    vfunc_remove_element(element: Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    vfunc_change_state(transition: StateChange): StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    vfunc_get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Pad): void
    vfunc_pad_removed(pad: Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    vfunc_post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    vfunc_query(query: Query): boolean
    vfunc_release_pad(pad: Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    vfunc_request_new_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    vfunc_send_event(event: Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    vfunc_set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    vfunc_set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    vfunc_set_context(context: Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    vfunc_set_state(state: State): StateChangeReturn
    vfunc_state_changed(oldstate: State, newstate: State, pending: State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Bin */
    /**
     * Will be emitted after the element was added to `sub_bin`.
     * @param sub_bin the #GstBin the element was added to
     * @param element the #GstElement that was added to `sub_bin`
     */
    connect(sigName: "deep-element-added", callback: (($obj: Bin, sub_bin: Bin, element: Element) => void)): number
    connect_after(sigName: "deep-element-added", callback: (($obj: Bin, sub_bin: Bin, element: Element) => void)): number
    emit(sigName: "deep-element-added", sub_bin: Bin, element: Element): void
    /**
     * Will be emitted after the element was removed from `sub_bin`.
     * @param sub_bin the #GstBin the element was removed from
     * @param element the #GstElement that was removed from `sub_bin`
     */
    connect(sigName: "deep-element-removed", callback: (($obj: Bin, sub_bin: Bin, element: Element) => void)): number
    connect_after(sigName: "deep-element-removed", callback: (($obj: Bin, sub_bin: Bin, element: Element) => void)): number
    emit(sigName: "deep-element-removed", sub_bin: Bin, element: Element): void
    /**
     * Will be emitted when the bin needs to perform latency calculations. This
     * signal is only emitted for toplevel bins or when #GstBin:async-handling is
     * enabled.
     * 
     * Only one signal handler is invoked. If no signals are connected, the
     * default handler is invoked, which will query and distribute the lowest
     * possible latency to all sinks.
     * 
     * Connect to this signal if the default latency calculations are not
     * sufficient, like when you need different latencies for different sinks in
     * the same pipeline.
     */
    connect(sigName: "do-latency", callback: (($obj: Bin) => boolean)): number
    connect_after(sigName: "do-latency", callback: (($obj: Bin) => boolean)): number
    emit(sigName: "do-latency"): void
    /**
     * Will be emitted after the element was added to the bin.
     * @param element the #GstElement that was added to the bin
     */
    connect(sigName: "element-added", callback: (($obj: Bin, element: Element) => void)): number
    connect_after(sigName: "element-added", callback: (($obj: Bin, element: Element) => void)): number
    emit(sigName: "element-added", element: Element): void
    /**
     * Will be emitted after the element was removed from the bin.
     * @param element the #GstElement that was removed from the bin
     */
    connect(sigName: "element-removed", callback: (($obj: Bin, element: Element) => void)): number
    connect_after(sigName: "element-removed", callback: (($obj: Bin, element: Element) => void)): number
    emit(sigName: "element-removed", element: Element): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: Bin) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: Bin) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     * @param new_pad the pad that has been added
     */
    connect(sigName: "pad-added", callback: (($obj: Bin, new_pad: Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: Bin, new_pad: Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Pad): void
    /**
     * a #GstPad has been removed from the element
     * @param old_pad the pad that has been removed
     */
    connect(sigName: "pad-removed", callback: (($obj: Bin, old_pad: Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: Bin, old_pad: Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Bin, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Bin, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Bin, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Bin, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::async-handling", callback: (($obj: Bin, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::async-handling", callback: (($obj: Bin, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::message-forward", callback: (($obj: Bin, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-forward", callback: (($obj: Bin, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Bin_ConstructProps)
    _init (config?: Bin_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name?: string | null): Bin
    static $gtype: GObject.Type
}
class Bitmask {
    static name: string
}
interface BufferPool_ConstructProps extends Object_ConstructProps {
}
class BufferPool {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.BufferPool */
    /**
     * Acquires a buffer from `pool`. `buffer` should point to a memory location that
     * can hold a pointer to the new buffer.
     * 
     * `params` can contain optional parameters to influence the allocation.
     * @param params parameters.
     */
    acquire_buffer(params?: BufferPoolAcquireParams | null): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * Gets a copy of the current configuration of the pool. This configuration
     * can be modified and used for the gst_buffer_pool_set_config() call.
     */
    get_config(): Structure
    /**
     * Gets a %NULL terminated array of string with supported bufferpool options for
     * `pool`. An option would typically be enabled with
     * gst_buffer_pool_config_add_option().
     */
    get_options(): string[]
    /**
     * Checks if the bufferpool supports `option`.
     * @param option an option
     */
    has_option(option: string): boolean
    /**
     * Checks if `pool` is active. A pool can be activated with the
     * gst_buffer_pool_set_active() call.
     */
    is_active(): boolean
    /**
     * Releases `buffer` to `pool`. `buffer` should have previously been allocated from
     * `pool` with gst_buffer_pool_acquire_buffer().
     * 
     * This function is usually called automatically when the last ref on `buffer`
     * disappears.
     * @param buffer a #GstBuffer
     */
    release_buffer(buffer: Buffer): void
    /**
     * Controls the active state of `pool`. When the pool is inactive, new calls to
     * gst_buffer_pool_acquire_buffer() will return with %GST_FLOW_FLUSHING.
     * 
     * Activating the bufferpool will preallocate all resources in the pool based on
     * the configuration of the pool.
     * 
     * Deactivating will free the resources again when there are no outstanding
     * buffers. When there are outstanding buffers, they will be freed as soon as
     * they are all returned to the pool.
     * @param active the new active state
     */
    set_active(active: boolean): boolean
    /**
     * Sets the configuration of the pool. If the pool is already configured, and
     * the configuration hasn't changed, this function will return %TRUE. If the
     * pool is active, this method will return %FALSE and active configuration
     * will remain. Buffers allocated from this pool must be returned or else this
     * function will do nothing and return %FALSE.
     * 
     * `config` is a #GstStructure that contains the configuration parameters for
     * the pool. A default and mandatory set of parameters can be configured with
     * gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
     * and gst_buffer_pool_config_add_option().
     * 
     * If the parameters in `config` can not be set exactly, this function returns
     * %FALSE and will try to update as much state as possible. The new state can
     * then be retrieved and refined with gst_buffer_pool_get_config().
     * 
     * This function takes ownership of `config`.
     * @param config a #GstStructure
     */
    set_config(config: Structure): boolean
    /**
     * Enables or disables the flushing state of a `pool` without freeing or
     * allocating buffers.
     * @param flushing whether to start or stop flushing
     */
    set_flushing(flushing: boolean): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.BufferPool */
    /**
     * Acquires a buffer from `pool`. `buffer` should point to a memory location that
     * can hold a pointer to the new buffer.
     * 
     * `params` can contain optional parameters to influence the allocation.
     * @param params parameters.
     */
    vfunc_acquire_buffer(params?: BufferPoolAcquireParams | null): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * Allocate a buffer. the default implementation allocates
     * buffers from the configured memory allocator and with the configured
     * parameters. All metadata that is present on the allocated buffer will
     * be marked as #GST_META_FLAG_POOLED and #GST_META_FLAG_LOCKED and will
     * not be removed from the buffer in #GstBufferPoolClass::reset_buffer.
     * The buffer should have the #GST_BUFFER_FLAG_TAG_MEMORY cleared.
     * @param params parameters.
     */
    vfunc_alloc_buffer(params?: BufferPoolAcquireParams | null): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * Enter the flushing state.
     */
    vfunc_flush_start(): void
    /**
     * Leave the flushing state.
     */
    vfunc_flush_stop(): void
    /**
     * Free a buffer. The default implementation unrefs the buffer.
     * @param buffer the #GstBuffer to free
     */
    vfunc_free_buffer(buffer: Buffer): void
    /**
     * Gets a %NULL terminated array of string with supported bufferpool options for
     * `pool`. An option would typically be enabled with
     * gst_buffer_pool_config_add_option().
     */
    vfunc_get_options(): string[]
    /**
     * Releases `buffer` to `pool`. `buffer` should have previously been allocated from
     * `pool` with gst_buffer_pool_acquire_buffer().
     * 
     * This function is usually called automatically when the last ref on `buffer`
     * disappears.
     * @param buffer a #GstBuffer
     */
    vfunc_release_buffer(buffer: Buffer): void
    /**
     * Reset the buffer to its state when it was freshly allocated.
     * The default implementation will clear the flags, timestamps and
     * will remove the metadata without the #GST_META_FLAG_POOLED flag (even
     * the metadata with #GST_META_FLAG_LOCKED). If the
     * #GST_BUFFER_FLAG_TAG_MEMORY was set, this function can also try to
     * restore the memory and clear the #GST_BUFFER_FLAG_TAG_MEMORY again.
     * @param buffer the #GstBuffer to reset
     */
    vfunc_reset_buffer(buffer: Buffer): void
    /**
     * Sets the configuration of the pool. If the pool is already configured, and
     * the configuration hasn't changed, this function will return %TRUE. If the
     * pool is active, this method will return %FALSE and active configuration
     * will remain. Buffers allocated from this pool must be returned or else this
     * function will do nothing and return %FALSE.
     * 
     * `config` is a #GstStructure that contains the configuration parameters for
     * the pool. A default and mandatory set of parameters can be configured with
     * gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
     * and gst_buffer_pool_config_add_option().
     * 
     * If the parameters in `config` can not be set exactly, this function returns
     * %FALSE and will try to update as much state as possible. The new state can
     * then be retrieved and refined with gst_buffer_pool_get_config().
     * 
     * This function takes ownership of `config`.
     * @param config a #GstStructure
     */
    vfunc_set_config(config: Structure): boolean
    /**
     * Start the bufferpool. The default implementation will preallocate
     * min-buffers buffers and put them in the queue.
     */
    vfunc_start(): boolean
    /**
     * Stop the bufferpool. the default implementation will free the
     * preallocated buffers. This function is called when all the buffers are
     * returned to the pool.
     */
    vfunc_stop(): boolean
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: BufferPool, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: BufferPool, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: BufferPool, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: BufferPool, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: BufferPool_ConstructProps)
    _init (config?: BufferPool_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): BufferPool
    /**
     * Enables the option in `config`. This will instruct the `bufferpool` to enable
     * the specified option on the buffers that it allocates.
     * 
     * The options supported by `pool` can be retrieved with gst_buffer_pool_get_options().
     * @param config a #GstBufferPool configuration
     * @param option an option to add
     */
    static config_add_option(config: Structure, option: string): void
    /**
     * Gets the `allocator` and `params` from `config`.
     * @param config a #GstBufferPool configuration
     */
    static config_get_allocator(config: Structure): [ /* returnType */ boolean, /* allocator */ Allocator | null, /* params */ AllocationParams | null ]
    /**
     * Parses an available `config` and gets the option at `index` of the options API
     * array.
     * @param config a #GstBufferPool configuration
     * @param index position in the option array to read
     */
    static config_get_option(config: Structure, index: number): string | null
    /**
     * Gets the configuration values from `config`.
     * @param config a #GstBufferPool configuration
     */
    static config_get_params(config: Structure): [ /* returnType */ boolean, /* caps */ Caps | null, /* size */ number | null, /* min_buffers */ number | null, /* max_buffers */ number | null ]
    /**
     * Checks if `config` contains `option`.
     * @param config a #GstBufferPool configuration
     * @param option an option
     */
    static config_has_option(config: Structure, option: string): boolean
    /**
     * Retrieves the number of values currently stored in the options array of the
     * `config` structure.
     * @param config a #GstBufferPool configuration
     */
    static config_n_options(config: Structure): number
    /**
     * Sets the `allocator` and `params` on `config`.
     * 
     * One of `allocator` and `params` can be %NULL, but not both. When `allocator`
     * is %NULL, the default allocator of the pool will use the values in `param`
     * to perform its allocation. When `param` is %NULL, the pool will use the
     * provided `allocator` with its default #GstAllocationParams.
     * 
     * A call to gst_buffer_pool_set_config() can update the allocator and params
     * with the values that it is able to do. Some pools are, for example, not able
     * to operate with different allocators or cannot allocate with the values
     * specified in `params`. Use gst_buffer_pool_get_config() to get the currently
     * used values.
     * @param config a #GstBufferPool configuration
     * @param allocator a #GstAllocator
     * @param params #GstAllocationParams
     */
    static config_set_allocator(config: Structure, allocator?: Allocator | null, params?: AllocationParams | null): void
    /**
     * Configures `config` with the given parameters.
     * @param config a #GstBufferPool configuration
     * @param caps caps for the buffers
     * @param size the size of each buffer, not including prefix and padding
     * @param min_buffers the minimum amount of buffers to allocate.
     * @param max_buffers the maximum amount of buffers to allocate or 0 for unlimited.
     */
    static config_set_params(config: Structure, caps: Caps | null, size: number, min_buffers: number, max_buffers: number): void
    /**
     * Validates that changes made to `config` are still valid in the context of the
     * expected parameters. This function is a helper that can be used to validate
     * changes made by a pool to a config when gst_buffer_pool_set_config()
     * returns %FALSE. This expects that `caps` haven't changed and that
     * `min_buffers` aren't lower then what we initially expected.
     * This does not check if options or allocator parameters are still valid,
     * won't check if size have changed, since changing the size is valid to adapt
     * padding.
     * @param config a #GstBufferPool configuration
     * @param caps the excepted caps of buffers
     * @param size the expected size of each buffer, not including prefix and padding
     * @param min_buffers the expected minimum amount of buffers to allocate.
     * @param max_buffers the expect maximum amount of buffers to allocate or 0 for unlimited.
     */
    static config_validate_params(config: Structure, caps: Caps | null, size: number, min_buffers: number, max_buffers: number): boolean
    static $gtype: GObject.Type
}
interface Bus_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Bus */
    /**
     * Enables async message delivery support for bus watches,
     * gst_bus_pop() and similar API. Without this only the
     * synchronous message handlers are called.
     * 
     * This property is used to create the child element buses
     * in #GstBin.
     */
    enable_async?: boolean
}
class Bus {
    /* Properties of Gst-1.0.Gst.Bus */
    /**
     * Enables async message delivery support for bus watches,
     * gst_bus_pop() and similar API. Without this only the
     * synchronous message handlers are called.
     * 
     * This property is used to create the child element buses
     * in #GstBin.
     */
    readonly enable_async: boolean
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Bus */
    /**
     * Adds a bus signal watch to the default main context with the default priority
     * ( %G_PRIORITY_DEFAULT ). It is also possible to use a non-default
     * main context set up using g_main_context_push_thread_default() (before
     * one had to create a bus watch source and attach it to the desired main
     * context 'manually').
     * 
     * After calling this statement, the bus will emit the "message" signal for each
     * message posted on the bus.
     * 
     * This function may be called multiple times. To clean up, the caller is
     * responsible for calling gst_bus_remove_signal_watch() as many times as this
     * function is called.
     */
    add_signal_watch(): void
    /**
     * Adds a bus signal watch to the default main context with the given `priority`
     * (e.g. %G_PRIORITY_DEFAULT). It is also possible to use a non-default main
     * context set up using g_main_context_push_thread_default()
     * (before one had to create a bus watch source and attach it to the desired
     * main context 'manually').
     * 
     * After calling this statement, the bus will emit the "message" signal for each
     * message posted on the bus when the #GMainLoop is running.
     * 
     * This function may be called multiple times. To clean up, the caller is
     * responsible for calling gst_bus_remove_signal_watch() as many times as this
     * function is called.
     * 
     * There can only be a single bus watch per bus, you must remove any signal
     * watch before you can set another type of watch.
     * @param priority The priority of the watch.
     */
    add_signal_watch_full(priority: number): void
    /**
     * Adds a bus watch to the default main context with the given `priority` (e.g.
     * %G_PRIORITY_DEFAULT). It is also possible to use a non-default  main
     * context set up using g_main_context_push_thread_default() (before
     * one had to create a bus watch source and attach it to the desired main
     * context 'manually').
     * 
     * This function is used to receive asynchronous messages in the main loop.
     * There can only be a single bus watch per bus, you must remove it before you
     * can set a new one.
     * 
     * The bus watch will only work if a #GMainLoop is being run.
     * 
     * When `func` is called, the message belongs to the caller; if you want to
     * keep a copy of it, call gst_message_ref() before leaving `func`.
     * 
     * The watch can be removed using gst_bus_remove_watch() or by returning %FALSE
     * from `func`. If the watch was added to the default main context it is also
     * possible to remove the watch using g_source_remove().
     * 
     * The bus watch will take its own reference to the `bus,` so it is safe to unref
     * `bus` using gst_object_unref() after setting the bus watch.
     * @param priority The priority of the watch.
     * @param func A function to call when a message is received.
     */
    add_watch(priority: number, func: BusFunc): number
    /**
     * A helper #GstBusFunc that can be used to convert all asynchronous messages
     * into signals.
     * @param message the #GstMessage received
     * @param data user data
     */
    async_signal_func(message: Message, data?: object | null): boolean
    /**
     * Create watch for this bus. The #GSource will be dispatched whenever
     * a message is on the bus. After the GSource is dispatched, the
     * message is popped off the bus and unreffed.
     * 
     * As with other watches, there can only be one watch on the bus, including
     * any signal watch added with #gst_bus_add_signal_watch.
     */
    create_watch(): GLib.Source | null
    /**
     * Instructs GStreamer to stop emitting the "sync-message" signal for this bus.
     * See gst_bus_enable_sync_message_emission() for more information.
     * 
     * In the event that multiple pieces of code have called
     * gst_bus_enable_sync_message_emission(), the sync-message emissions will only
     * be stopped after all calls to gst_bus_enable_sync_message_emission() were
     * "cancelled" by calling this function. In this way the semantics are exactly
     * the same as gst_object_ref() that which calls enable should also call
     * disable.
     */
    disable_sync_message_emission(): void
    /**
     * Instructs GStreamer to emit the "sync-message" signal after running the bus's
     * sync handler. This function is here so that code can ensure that they can
     * synchronously receive messages without having to affect what the bin's sync
     * handler is.
     * 
     * This function may be called multiple times. To clean up, the caller is
     * responsible for calling gst_bus_disable_sync_message_emission() as many times
     * as this function is called.
     * 
     * While this function looks similar to gst_bus_add_signal_watch(), it is not
     * exactly the same -- this function enables *synchronous* emission of
     * signals when messages arrive; gst_bus_add_signal_watch() adds an idle callback
     * to pop messages off the bus *asynchronously*. The sync-message signal
     * comes from the thread of whatever object posted the message; the "message"
     * signal is marshalled to the main thread via the #GMainLoop.
     */
    enable_sync_message_emission(): void
    /**
     * Gets the file descriptor from the bus which can be used to get notified about
     * messages being available with functions like g_poll(), and allows integration
     * into other event loops based on file descriptors.
     * Whenever a message is available, the POLLIN / %G_IO_IN event is set.
     * 
     * Warning: NEVER read or write anything to the returned fd but only use it
     * for getting notifications via g_poll() or similar and then use the normal
     * GstBus API, e.g. gst_bus_pop().
     */
    get_pollfd(): /* fd */ GLib.PollFD
    /**
     * Checks if there are pending messages on the bus that
     * should be handled.
     */
    have_pending(): boolean
    /**
     * Peeks the message on the top of the bus' queue. The message will remain
     * on the bus' message queue.
     */
    peek(): Message | null
    /**
     * Polls the bus for messages. Will block while waiting for messages to come.
     * You can specify a maximum time to poll with the `timeout` parameter. If
     * `timeout` is negative, this function will block indefinitely.
     * 
     * All messages not in `events` will be popped off the bus and will be ignored.
     * It is not possible to use message enums beyond #GST_MESSAGE_EXTENDED in the
     * `events` mask
     * 
     * Because poll is implemented using the "message" signal enabled by
     * gst_bus_add_signal_watch(), calling gst_bus_poll() will cause the "message"
     * signal to be emitted for every message that poll sees. Thus a "message"
     * signal handler will see the same messages that this function sees -- neither
     * will steal messages from the other.
     * 
     * This function will run a #GMainLoop from the default main context when
     * polling.
     * 
     * You should never use this function, since it is pure evil. This is
     * especially true for GUI applications based on Gtk+ or Qt, but also for any
     * other non-trivial application that uses the GLib main loop. As this function
     * runs a GLib main loop, any callback attached to the default GLib main
     * context may be invoked. This could be timeouts, GUI events, I/O events etc.;
     * even if gst_bus_poll() is called with a 0 timeout. Any of these callbacks
     * may do things you do not expect, e.g. destroy the main application window or
     * some other resource; change other application state; display a dialog and
     * run another main loop until the user clicks it away. In short, using this
     * function may add a lot of complexity to your code through unexpected
     * re-entrancy and unexpected changes to your application's state.
     * 
     * For 0 timeouts use gst_bus_pop_filtered() instead of this function; for
     * other short timeouts use gst_bus_timed_pop_filtered(); everything else is
     * better handled by setting up an asynchronous bus watch and doing things
     * from there.
     * @param events a mask of #GstMessageType, representing the set of message types to poll for (note special handling of extended message types below)
     * @param timeout the poll timeout, as a #GstClockTime, or #GST_CLOCK_TIME_NONE to poll indefinitely.
     */
    poll(events: MessageType, timeout: ClockTime): Message | null
    /**
     * Gets a message from the bus.
     */
    pop(): Message | null
    /**
     * Gets a message matching `type` from the bus.  Will discard all messages on
     * the bus that do not match `type` and that have been posted before the first
     * message that does match `type`.  If there is no message matching `type` on
     * the bus, all messages will be discarded. It is not possible to use message
     * enums beyond #GST_MESSAGE_EXTENDED in the `events` mask.
     * @param types message types to take into account
     */
    pop_filtered(types: MessageType): Message | null
    /**
     * Posts a message on the given bus. Ownership of the message
     * is taken by the bus.
     * @param message the #GstMessage to post
     */
    post(message: Message): boolean
    /**
     * Removes a signal watch previously added with gst_bus_add_signal_watch().
     */
    remove_signal_watch(): void
    /**
     * Removes an installed bus watch from `bus`.
     */
    remove_watch(): boolean
    /**
     * If `flushing,` flushes out and unrefs any messages queued in the bus. Releases
     * references to the message origin objects. Will flush future messages until
     * gst_bus_set_flushing() sets `flushing` to %FALSE.
     * @param flushing whether or not to flush the bus
     */
    set_flushing(flushing: boolean): void
    /**
     * Sets the synchronous handler on the bus. The function will be called
     * every time a new message is posted on the bus. Note that the function
     * will be called in the same thread context as the posting object. This
     * function is usually only called by the creator of the bus. Applications
     * should handle messages asynchronously using the gst_bus watch and poll
     * functions.
     * 
     * Before 1.16.3 it was not possible to replace an existing handler and
     * clearing an existing handler with %NULL was not thread-safe.
     * @param func The handler function to install
     */
    set_sync_handler(func: BusSyncHandler | null): void
    /**
     * A helper #GstBusSyncHandler that can be used to convert all synchronous
     * messages into signals.
     * @param message the #GstMessage received
     * @param data user data
     */
    sync_signal_handler(message: Message, data?: object | null): BusSyncReply
    /**
     * Gets a message from the bus, waiting up to the specified timeout.
     * 
     * If `timeout` is 0, this function behaves like gst_bus_pop(). If `timeout` is
     * #GST_CLOCK_TIME_NONE, this function will block forever until a message was
     * posted on the bus.
     * @param timeout a timeout
     */
    timed_pop(timeout: ClockTime): Message | null
    /**
     * Gets a message from the bus whose type matches the message type mask `types,`
     * waiting up to the specified timeout (and discarding any messages that do not
     * match the mask provided).
     * 
     * If `timeout` is 0, this function behaves like gst_bus_pop_filtered(). If
     * `timeout` is #GST_CLOCK_TIME_NONE, this function will block forever until a
     * matching message was posted on the bus.
     * @param timeout a timeout in nanoseconds, or %GST_CLOCK_TIME_NONE to wait forever
     * @param types message types to take into account, %GST_MESSAGE_ANY for any type
     */
    timed_pop_filtered(timeout: ClockTime, types: MessageType): Message | null
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Bus */
    /**
     * A message has been posted on the bus.
     * @param message the message that has been posted asynchronously
     */
    vfunc_message(message: Message): void
    /**
     * A message has been posted on the bus.
     * @param message the message that has been posted synchronously
     */
    vfunc_sync_message(message: Message): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Bus */
    /**
     * A message has been posted on the bus. This signal is emitted from a
     * #GSource added to the mainloop. this signal will only be emitted when
     * there is a #GMainLoop running.
     * @param message the message that has been posted asynchronously
     */
    connect(sigName: "message", callback: (($obj: Bus, message: Message) => void)): number
    connect_after(sigName: "message", callback: (($obj: Bus, message: Message) => void)): number
    emit(sigName: "message", message: Message): void
    /**
     * A message has been posted on the bus. This signal is emitted from the
     * thread that posted the message so one has to be careful with locking.
     * 
     * This signal will not be emitted by default, you have to call
     * gst_bus_enable_sync_message_emission() before.
     * @param message the message that has been posted synchronously
     */
    connect(sigName: "sync-message", callback: (($obj: Bus, message: Message) => void)): number
    connect_after(sigName: "sync-message", callback: (($obj: Bus, message: Message) => void)): number
    emit(sigName: "sync-message", message: Message): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Bus, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Bus, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Bus, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Bus, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::enable-async", callback: (($obj: Bus, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enable-async", callback: (($obj: Bus, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Bus_ConstructProps)
    _init (config?: Bus_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Bus
    static $gtype: GObject.Type
}
interface Clock_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Clock */
    timeout?: number
    window_size?: number
    window_threshold?: number
}
class Clock {
    /* Properties of Gst-1.0.Gst.Clock */
    timeout: number
    window_size: number
    window_threshold: number
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Clock */
    /**
     * The time `master` of the master clock and the time `slave` of the slave
     * clock are added to the list of observations. If enough observations
     * are available, a linear regression algorithm is run on the
     * observations and `clock` is recalibrated.
     * 
     * If this functions returns %TRUE, `r_squared` will contain the
     * correlation coefficient of the interpolation. A value of 1.0
     * means a perfect regression was performed. This value can
     * be used to control the sampling frequency of the master and slave
     * clocks.
     * @param slave a time on the slave
     * @param master a time on the master
     */
    add_observation(slave: ClockTime, master: ClockTime): [ /* returnType */ boolean, /* r_squared */ number ]
    /**
     * Add a clock observation to the internal slaving algorithm the same as
     * gst_clock_add_observation(), and return the result of the master clock
     * estimation, without updating the internal calibration.
     * 
     * The caller can then take the results and call gst_clock_set_calibration()
     * with the values, or some modified version of them.
     * @param slave a time on the slave
     * @param master a time on the master
     */
    add_observation_unapplied(slave: ClockTime, master: ClockTime): [ /* returnType */ boolean, /* r_squared */ number, /* internal */ ClockTime | null, /* external */ ClockTime | null, /* rate_num */ ClockTime | null, /* rate_denom */ ClockTime | null ]
    /**
     * Converts the given `internal` clock time to the external time, adjusting for the
     * rate and reference time set with gst_clock_set_calibration() and making sure
     * that the returned time is increasing. This function should be called with the
     * clock's OBJECT_LOCK held and is mainly used by clock subclasses.
     * 
     * This function is the reverse of gst_clock_unadjust_unlocked().
     * @param internal a clock time
     */
    adjust_unlocked(internal: ClockTime): ClockTime
    /**
     * Converts the given `internal_target` clock time to the external time,
     * using the passed calibration parameters. This function performs the
     * same calculation as gst_clock_adjust_unlocked() when called using the
     * current calibration parameters, but doesn't ensure a monotonically
     * increasing result as gst_clock_adjust_unlocked() does.
     * 
     * Note: The `clock` parameter is unused and can be NULL
     * @param internal_target a clock time
     * @param cinternal a reference internal time
     * @param cexternal a reference external time
     * @param cnum the numerator of the rate of the clock relative to its        internal time
     * @param cdenom the denominator of the rate of the clock
     */
    adjust_with_calibration(internal_target: ClockTime, cinternal: ClockTime, cexternal: ClockTime, cnum: ClockTime, cdenom: ClockTime): ClockTime
    /**
     * Gets the internal rate and reference time of `clock`. See
     * gst_clock_set_calibration() for more information.
     * 
     * `internal,` `external,` `rate_num,` and `rate_denom` can be left %NULL if the
     * caller is not interested in the values.
     */
    get_calibration(): [ /* internal */ ClockTime | null, /* external */ ClockTime | null, /* rate_num */ ClockTime | null, /* rate_denom */ ClockTime | null ]
    /**
     * Gets the current internal time of the given clock. The time is returned
     * unadjusted for the offset and the rate.
     */
    get_internal_time(): ClockTime
    /**
     * Gets the master clock that `clock` is slaved to or %NULL when the clock is
     * not slaved to any master clock.
     */
    get_master(): Clock | null
    /**
     * Gets the accuracy of the clock. The accuracy of the clock is the granularity
     * of the values returned by gst_clock_get_time().
     */
    get_resolution(): ClockTime
    /**
     * Gets the current time of the given clock. The time is always
     * monotonically increasing and adjusted according to the current
     * offset and rate.
     */
    get_time(): ClockTime
    /**
     * Gets the amount of time that master and slave clocks are sampled.
     */
    get_timeout(): ClockTime
    /**
     * Checks if the clock is currently synced, by looking at whether
     * %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is set.
     */
    is_synced(): boolean
    /**
     * Gets an ID from `clock` to trigger a periodic notification.
     * The periodic notifications will start at time `start_time` and
     * will then be fired with the given `interval`.
     * @param start_time the requested start time
     * @param interval the requested interval
     */
    new_periodic_id(start_time: ClockTime, interval: ClockTime): ClockID
    /**
     * Gets a #GstClockID from `clock` to trigger a single shot
     * notification at the requested time.
     * @param time the requested time
     */
    new_single_shot_id(time: ClockTime): ClockID
    /**
     * Reinitializes the provided periodic `id` to the provided start time and
     * interval. Does not modify the reference count.
     * @param id a #GstClockID
     * @param start_time the requested start time
     * @param interval the requested interval
     */
    periodic_id_reinit(id: ClockID, start_time: ClockTime, interval: ClockTime): boolean
    /**
     * Adjusts the rate and time of `clock`. A rate of 1/1 is the normal speed of
     * the clock. Values bigger than 1/1 make the clock go faster.
     * 
     * `internal` and `external` are calibration parameters that arrange that
     * gst_clock_get_time() should have been `external` at internal time `internal`.
     * This internal time should not be in the future; that is, it should be less
     * than the value of gst_clock_get_internal_time() when this function is called.
     * 
     * Subsequent calls to gst_clock_get_time() will return clock times computed as
     * follows:
     * 
     * ``` C
     *   time = (internal_time - internal) * rate_num / rate_denom + external
     * ```
     * 
     * This formula is implemented in gst_clock_adjust_unlocked(). Of course, it
     * tries to do the integer arithmetic as precisely as possible.
     * 
     * Note that gst_clock_get_time() always returns increasing values so when you
     * move the clock backwards, gst_clock_get_time() will report the previous value
     * until the clock catches up.
     * @param internal a reference internal time
     * @param external a reference external time
     * @param rate_num the numerator of the rate of the clock relative to its            internal time
     * @param rate_denom the denominator of the rate of the clock
     */
    set_calibration(internal: ClockTime, external: ClockTime, rate_num: ClockTime, rate_denom: ClockTime): void
    /**
     * Sets `master` as the master clock for `clock`. `clock` will be automatically
     * calibrated so that gst_clock_get_time() reports the same time as the
     * master clock.
     * 
     * A clock provider that slaves its clock to a master can get the current
     * calibration values with gst_clock_get_calibration().
     * 
     * `master` can be %NULL in which case `clock` will not be slaved anymore. It will
     * however keep reporting its time adjusted with the last configured rate
     * and time offsets.
     * @param master a master #GstClock
     */
    set_master(master?: Clock | null): boolean
    /**
     * Sets the accuracy of the clock. Some clocks have the possibility to operate
     * with different accuracy at the expense of more resource usage. There is
     * normally no need to change the default resolution of a clock. The resolution
     * of a clock can only be changed if the clock has the
     * #GST_CLOCK_FLAG_CAN_SET_RESOLUTION flag set.
     * @param resolution The resolution to set
     */
    set_resolution(resolution: ClockTime): ClockTime
    /**
     * Sets `clock` to synced and emits the #GstClock::synced signal, and wakes up any
     * thread waiting in gst_clock_wait_for_sync().
     * 
     * This function must only be called if %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC
     * is set on the clock, and is intended to be called by subclasses only.
     * @param synced if the clock is synced
     */
    set_synced(synced: boolean): void
    /**
     * Sets the amount of time, in nanoseconds, to sample master and slave
     * clocks
     * @param timeout a timeout
     */
    set_timeout(timeout: ClockTime): void
    /**
     * Reinitializes the provided single shot `id` to the provided time. Does not
     * modify the reference count.
     * @param id a #GstClockID
     * @param time The requested time.
     */
    single_shot_id_reinit(id: ClockID, time: ClockTime): boolean
    /**
     * Converts the given `external` clock time to the internal time of `clock,`
     * using the rate and reference time set with gst_clock_set_calibration().
     * This function should be called with the clock's OBJECT_LOCK held and
     * is mainly used by clock subclasses.
     * 
     * This function is the reverse of gst_clock_adjust_unlocked().
     * @param external an external clock time
     */
    unadjust_unlocked(external: ClockTime): ClockTime
    /**
     * Converts the given `external_target` clock time to the internal time,
     * using the passed calibration parameters. This function performs the
     * same calculation as gst_clock_unadjust_unlocked() when called using the
     * current calibration parameters.
     * 
     * Note: The `clock` parameter is unused and can be NULL
     * @param external_target a clock time
     * @param cinternal a reference internal time
     * @param cexternal a reference external time
     * @param cnum the numerator of the rate of the clock relative to its        internal time
     * @param cdenom the denominator of the rate of the clock
     */
    unadjust_with_calibration(external_target: ClockTime, cinternal: ClockTime, cexternal: ClockTime, cnum: ClockTime, cdenom: ClockTime): ClockTime
    /**
     * Waits until `clock` is synced for reporting the current time. If `timeout`
     * is %GST_CLOCK_TIME_NONE it will wait forever, otherwise it will time out
     * after `timeout` nanoseconds.
     * 
     * For asynchronous waiting, the #GstClock::synced signal can be used.
     * 
     * This returns immediately with %TRUE if %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC
     * is not set on the clock, or if the clock is already synced.
     * @param timeout timeout for waiting or %GST_CLOCK_TIME_NONE
     */
    wait_for_sync(timeout: ClockTime): boolean
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Clock */
    /**
     * Change the resolution of the clock. Not all values might
     * be acceptable.
     * @param old_resolution the previous resolution
     * @param new_resolution the new resolution
     */
    vfunc_change_resolution(old_resolution: ClockTime, new_resolution: ClockTime): ClockTime
    /**
     * Gets the current internal time of the given clock. The time is returned
     * unadjusted for the offset and the rate.
     */
    vfunc_get_internal_time(): ClockTime
    /**
     * Gets the accuracy of the clock. The accuracy of the clock is the granularity
     * of the values returned by gst_clock_get_time().
     */
    vfunc_get_resolution(): ClockTime
    /**
     * Unblock a blocking or async wait operation.
     * @param entry the entry to unschedule
     */
    vfunc_unschedule(entry: ClockEntry): void
    /**
     * Perform a blocking wait on the given #GstClockEntry and return
     * the jitter.
     * @param entry the entry to wait on
     */
    vfunc_wait(entry: ClockEntry): [ /* returnType */ ClockReturn, /* jitter */ ClockTimeDiff | null ]
    /**
     * Perform an asynchronous wait on the given #GstClockEntry.
     * @param entry the entry to wait on
     */
    vfunc_wait_async(entry: ClockEntry): ClockReturn
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Clock */
    /**
     * Signaled on clocks with %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC set once
     * the clock is synchronized, or when it completely lost synchronization.
     * This signal will not be emitted on clocks without the flag.
     * 
     * This signal will be emitted from an arbitrary thread, most likely not
     * the application's main thread.
     * @param synced if the clock is synced now
     */
    connect(sigName: "synced", callback: (($obj: Clock, synced: boolean) => void)): number
    connect_after(sigName: "synced", callback: (($obj: Clock, synced: boolean) => void)): number
    emit(sigName: "synced", synced: boolean): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Clock, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Clock, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::timeout", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeout", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::window-size", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::window-size", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::window-threshold", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::window-threshold", callback: (($obj: Clock, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Clock_ConstructProps)
    _init (config?: Clock_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Compares the two #GstClockID instances. This function can be used
     * as a GCompareFunc when sorting ids.
     * @param id1 A #GstClockID
     * @param id2 A #GstClockID to compare with
     */
    static id_compare_func(id1?: object | null, id2?: object | null): number
    /**
     * This function returns the underlying clock.
     * @param id a #GstClockID
     */
    static id_get_clock(id: ClockID): Clock | null
    /**
     * Gets the time of the clock ID
     * @param id The #GstClockID to query
     */
    static id_get_time(id: ClockID): ClockTime
    /**
     * Increases the refcount of given `id`.
     * @param id The #GstClockID to ref
     */
    static id_ref(id: ClockID): ClockID
    /**
     * Unrefs given `id`. When the refcount reaches 0 the
     * #GstClockID will be freed.
     * @param id The #GstClockID to unref
     */
    static id_unref(id: ClockID): void
    /**
     * Cancels an outstanding request with `id`. This can either
     * be an outstanding async notification or a pending sync notification.
     * After this call, `id` cannot be used anymore to receive sync or
     * async notifications, you need to create a new #GstClockID.
     * @param id The id to unschedule
     */
    static id_unschedule(id: ClockID): void
    /**
     * This function returns whether `id` uses `clock` as the underlying clock.
     * `clock` can be NULL, in which case the return value indicates whether
     * the underlying clock has been freed.  If this is the case, the `id` is
     * no longer usable and should be freed.
     * @param id a #GstClockID to check
     * @param clock a #GstClock to compare against
     */
    static id_uses_clock(id: ClockID, clock: Clock): boolean
    /**
     * Performs a blocking wait on `id`.
     * `id` should have been created with gst_clock_new_single_shot_id()
     * or gst_clock_new_periodic_id() and should not have been unscheduled
     * with a call to gst_clock_id_unschedule().
     * 
     * If the `jitter` argument is not %NULL and this function returns #GST_CLOCK_OK
     * or #GST_CLOCK_EARLY, it will contain the difference
     * against the clock and the time of `id` when this method was
     * called.
     * Positive values indicate how late `id` was relative to the clock
     * (in which case this function will return #GST_CLOCK_EARLY).
     * Negative values indicate how much time was spent waiting on the clock
     * before this function returned.
     * @param id The #GstClockID to wait on
     */
    static id_wait(id: ClockID): [ /* returnType */ ClockReturn, /* jitter */ ClockTimeDiff | null ]
    /**
     * Registers a callback on the given #GstClockID `id` with the given
     * function and user_data. When passing a #GstClockID with an invalid
     * time to this function, the callback will be called immediately
     * with  a time set to %GST_CLOCK_TIME_NONE. The callback will
     * be called when the time of `id` has been reached.
     * 
     * The callback `func` can be invoked from any thread, either provided by the
     * core or from a streaming thread. The application should be prepared for this.
     * @param id a #GstClockID to wait on
     * @param func The callback function
     */
    static id_wait_async(id: ClockID, func: ClockCallback): ClockReturn
    static $gtype: GObject.Type
}
interface ControlBinding_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.ControlBinding */
    name?: string
    object?: Object
}
class ControlBinding {
    /* Properties of Gst-1.0.Gst.ControlBinding */
    readonly name: string
    readonly object: Object
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.ControlBinding */
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param timestamp the time the control-change should be read from
     */
    get_value(timestamp: ClockTime): any | null
    /**
     * Checks if the control binding is disabled.
     */
    is_disabled(): boolean
    /**
     * This function is used to disable a control binding for some time, i.e.
     * gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_disabled(disabled: boolean): void
    /**
     * Sets the property of the `object,` according to the #GstControlSources that
     * handles it and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param object the object that has controlled properties
     * @param timestamp the time that should be processed
     * @param last_sync the last time this was called
     */
    sync_values(object: Object, timestamp: ClockTime, last_sync: ClockTime): boolean
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.ControlBinding */
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    vfunc_get_g_value_array(timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param timestamp the time the control-change should be read from
     */
    vfunc_get_value(timestamp: ClockTime): any | null
    /**
     * Sets the property of the `object,` according to the #GstControlSources that
     * handles it and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param object the object that has controlled properties
     * @param timestamp the time that should be processed
     * @param last_sync the last time this was called
     */
    vfunc_sync_values(object: Object, timestamp: ClockTime, last_sync: ClockTime): boolean
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: ControlBinding, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: ControlBinding, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ControlBinding, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ControlBinding, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: ControlBinding, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: ControlBinding, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::object", callback: (($obj: ControlBinding, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::object", callback: (($obj: ControlBinding, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ControlBinding_ConstructProps)
    _init (config?: ControlBinding_ConstructProps): void
    static $gtype: GObject.Type
}
interface ControlSource_ConstructProps extends Object_ConstructProps {
}
class ControlSource {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.ControlSource */
    /**
     * Gets the value for this #GstControlSource at a given timestamp.
     * @param timestamp the time for which the value should be returned
     */
    control_source_get_value(timestamp: ClockTime): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets an array of values for for this #GstControlSource. Values that are
     * undefined contain NANs.
     * @param timestamp the first timestamp
     * @param interval the time steps
     * @param values array to put control-values in
     */
    control_source_get_value_array(timestamp: ClockTime, interval: ClockTime, values: number[]): boolean
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: ControlSource, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: ControlSource, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ControlSource, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ControlSource, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ControlSource_ConstructProps)
    _init (config?: ControlSource_ConstructProps): void
    static $gtype: GObject.Type
}
interface Device_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Device */
    caps?: Caps
    device_class?: string
    display_name?: string
    properties?: Structure
}
class Device {
    /* Properties of Gst-1.0.Gst.Device */
    readonly caps: Caps
    readonly device_class: string
    readonly display_name: string
    readonly properties: Structure
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Device */
    /**
     * Creates the element with all of the required parameters set to use
     * this device.
     * @param name name of new element, or %NULL to automatically create a unique name.
     */
    create_element(name?: string | null): Element | null
    /**
     * Getter for the #GstCaps that this device supports.
     */
    get_caps(): Caps | null
    /**
     * Gets the "class" of a device. This is a "/" separated list of
     * classes that represent this device. They are a subset of the
     * classes of the #GstDeviceProvider that produced this device.
     */
    get_device_class(): string
    /**
     * Gets the user-friendly name of the device.
     */
    get_display_name(): string
    /**
     * Gets the extra properties of a device.
     */
    get_properties(): Structure | null
    /**
     * Check if `device` matches all of the given classes
     * @param classes a "/"-separated list of device classes to match, only match if  all classes are matched
     */
    has_classes(classes: string): boolean
    /**
     * Check if `factory` matches all of the given classes
     * @param classes a %NULL terminated array of classes   to match, only match if all classes are matched
     */
    has_classesv(classes: string[]): boolean
    /**
     * Tries to reconfigure an existing element to use the device. If this
     * function fails, then one must destroy the element and create a new one
     * using gst_device_create_element().
     * 
     * Note: This should only be implemented for elements can change their
     * device in the PLAYING state.
     * @param element a #GstElement
     */
    reconfigure_element(element: Element): boolean
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Device */
    /**
     * Creates the element with all of the required parameters set to use
     * this device.
     * @param name name of new element, or %NULL to automatically create a unique name.
     */
    vfunc_create_element(name?: string | null): Element | null
    /**
     * Tries to reconfigure an existing element to use the device. If this
     * function fails, then one must destroy the element and create a new one
     * using gst_device_create_element().
     * 
     * Note: This should only be implemented for elements can change their
     * device in the PLAYING state.
     * @param element a #GstElement
     */
    vfunc_reconfigure_element(element: Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Device */
    connect(sigName: "removed", callback: (($obj: Device) => void)): number
    connect_after(sigName: "removed", callback: (($obj: Device) => void)): number
    emit(sigName: "removed"): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Device, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Device, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::caps", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caps", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-class", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-class", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::display-name", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::display-name", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::properties", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::properties", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Device_ConstructProps)
    _init (config?: Device_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceMonitor_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.DeviceMonitor */
    show_all?: boolean
}
class DeviceMonitor {
    /* Properties of Gst-1.0.Gst.DeviceMonitor */
    show_all: boolean
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.DeviceMonitor */
    /**
     * Adds a filter for which #GstDevice will be monitored, any device that matches
     * all these classes and the #GstCaps will be returned.
     * 
     * If this function is called multiple times to add more filters, each will be
     * matched independently. That is, adding more filters will not further restrict
     * what devices are matched.
     * 
     * The #GstCaps supported by the device as returned by gst_device_get_caps() are
     * not intersected with caps filters added using this function.
     * 
     * Filters must be added before the #GstDeviceMonitor is started.
     * @param classes device classes to use as filter or %NULL for any class
     * @param caps the #GstCaps to filter or %NULL for ANY
     */
    add_filter(classes?: string | null, caps?: Caps | null): number
    /**
     * Gets the #GstBus of this #GstDeviceMonitor
     */
    get_bus(): Bus
    /**
     * Gets a list of devices from all of the relevant monitors. This may actually
     * probe the hardware if the monitor is not currently started.
     */
    get_devices(): Device[] | null
    /**
     * Get a list of the currently selected device provider factories.
     * 
     * This
     */
    get_providers(): string[]
    /**
     * Get if `monitor` is currently showing all devices, even those from hidden
     * providers.
     */
    get_show_all_devices(): boolean
    /**
     * Removes a filter from the #GstDeviceMonitor using the id that was returned
     * by gst_device_monitor_add_filter().
     * @param filter_id the id of the filter
     */
    remove_filter(filter_id: number): boolean
    /**
     * Set if all devices should be visible, even those devices from hidden
     * providers. Setting `show_all` to true might show some devices multiple times.
     * @param show_all show all devices
     */
    set_show_all_devices(show_all: boolean): void
    /**
     * Starts monitoring the devices, one this has succeeded, the
     * %GST_MESSAGE_DEVICE_ADDED and %GST_MESSAGE_DEVICE_REMOVED messages
     * will be emitted on the bus when the list of devices changes.
     */
    start(): boolean
    /**
     * Stops monitoring the devices.
     */
    stop(): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: DeviceMonitor, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: DeviceMonitor, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: DeviceMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceMonitor, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::show-all", callback: (($obj: DeviceMonitor, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::show-all", callback: (($obj: DeviceMonitor, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceMonitor_ConstructProps)
    _init (config?: DeviceMonitor_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): DeviceMonitor
    static $gtype: GObject.Type
}
interface DeviceProvider_ConstructProps extends Object_ConstructProps {
}
class DeviceProvider {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.DeviceProvider */
    can_monitor(): boolean
    /**
     * Posts a message on the provider's #GstBus to inform applications that
     * a new device has been added.
     * 
     * This is for use by subclasses.
     * 
     * `device'`s reference count will be incremented, and any floating reference
     * will be removed (see gst_object_ref_sink()).
     * @param device a #GstDevice that has been added
     */
    device_add(device: Device): void
    /**
     * This function is used when `changed_device` was modified into its new form
     * `device`. This will post a `DEVICE_CHANGED` message on the bus to let
     * the application know that the device was modified. #GstDevice is immutable
     * for MT. safety purposes so this is an "atomic" way of letting the application
     * know when a device was modified.
     * @param device the new version of `changed_device`
     * @param changed_device the old version of the device that has been updated
     */
    device_changed(device: Device, changed_device: Device): void
    /**
     * Posts a message on the provider's #GstBus to inform applications that
     * a device has been removed.
     * 
     * This is for use by subclasses.
     * @param device a #GstDevice that has been removed
     */
    device_remove(device: Device): void
    /**
     * Gets the #GstBus of this #GstDeviceProvider
     */
    get_bus(): Bus
    /**
     * Gets a list of devices that this provider understands. This may actually
     * probe the hardware if the provider is not currently started.
     * 
     * If the provider has been started, this will returned the same #GstDevice
     * objedcts that have been returned by the #GST_MESSAGE_DEVICE_ADDED messages.
     */
    get_devices(): Device[]
    /**
     * Retrieves the factory that was used to create this device provider.
     */
    get_factory(): DeviceProviderFactory | null
    /**
     * Get the provider factory names of the #GstDeviceProvider instances that
     * are hidden by `provider`.
     */
    get_hidden_providers(): string[]
    /**
     * Get metadata with `key` in `provider`.
     * @param key the key to get
     */
    get_metadata(key: string): string
    /**
     * Make `provider` hide the devices from the factory with `name`.
     * 
     * This function is used when `provider` will also provide the devices reported
     * by provider factory `name`. A monitor should stop monitoring the
     * device provider with `name` to avoid duplicate devices.
     * @param name a provider factory name
     */
    hide_provider(name: string): void
    /**
     * This function can be used to know if the `provider` was successfully started.
     */
    is_started(): boolean
    /**
     * Starts providering the devices. This will cause #GST_MESSAGE_DEVICE_ADDED
     * and #GST_MESSAGE_DEVICE_REMOVED messages to be posted on the provider's bus
     * when devices are added or removed from the system.
     * 
     * Since the #GstDeviceProvider is a singleton,
     * gst_device_provider_start() may already have been called by another
     * user of the object, gst_device_provider_stop() needs to be called the same
     * number of times.
     * 
     * After this function has been called, gst_device_provider_get_devices() will
     * return the same objects that have been received from the
     * #GST_MESSAGE_DEVICE_ADDED messages and will no longer probe.
     */
    start(): boolean
    /**
     * Decreases the use-count by one. If the use count reaches zero, this
     * #GstDeviceProvider will stop providering the devices. This needs to be
     * called the same number of times that gst_device_provider_start() was called.
     */
    stop(): void
    /**
     * Make `provider` unhide the devices from factory `name`.
     * 
     * This function is used when `provider` will no longer provide the devices
     * reported by provider factory `name`. A monitor should start
     * monitoring the devices from provider factory `name` in order to see
     * all devices again.
     * @param name a provider factory name
     */
    unhide_provider(name: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.DeviceProvider */
    /**
     * Starts providering the devices. This will cause #GST_MESSAGE_DEVICE_ADDED
     * and #GST_MESSAGE_DEVICE_REMOVED messages to be posted on the provider's bus
     * when devices are added or removed from the system.
     * 
     * Since the #GstDeviceProvider is a singleton,
     * gst_device_provider_start() may already have been called by another
     * user of the object, gst_device_provider_stop() needs to be called the same
     * number of times.
     * 
     * After this function has been called, gst_device_provider_get_devices() will
     * return the same objects that have been received from the
     * #GST_MESSAGE_DEVICE_ADDED messages and will no longer probe.
     */
    vfunc_start(): boolean
    /**
     * Decreases the use-count by one. If the use count reaches zero, this
     * #GstDeviceProvider will stop providering the devices. This needs to be
     * called the same number of times that gst_device_provider_start() was called.
     */
    vfunc_stop(): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.DeviceProvider */
    connect(sigName: "provider-hidden", callback: (($obj: DeviceProvider, object: string) => void)): number
    connect_after(sigName: "provider-hidden", callback: (($obj: DeviceProvider, object: string) => void)): number
    emit(sigName: "provider-hidden", object: string): void
    connect(sigName: "provider-unhidden", callback: (($obj: DeviceProvider, object: string) => void)): number
    connect_after(sigName: "provider-unhidden", callback: (($obj: DeviceProvider, object: string) => void)): number
    emit(sigName: "provider-unhidden", object: string): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: DeviceProvider, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: DeviceProvider, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: DeviceProvider, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceProvider, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceProvider_ConstructProps)
    _init (config?: DeviceProvider_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Create a new device providerfactory capable of instantiating objects of the
     * `type` and add the factory to `plugin`.
     * @param plugin #GstPlugin to register the device provider with, or %NULL for     a static device provider.
     * @param name name of device providers of this type
     * @param rank rank of device provider (higher rank means more importance when autoplugging)
     * @param type GType of device provider to register
     */
    static register(plugin: Plugin | null, name: string, rank: number, type: GObject.Type): boolean
    /**
     * Set `key` with `value` as metadata in `klass`.
     * @param key the key to set
     * @param value the value to set
     */
    static add_metadata(klass: DeviceProvider | Function | GObject.Type, key: string, value: string): void
    /**
     * Set `key` with `value` as metadata in `klass`.
     * 
     * Same as gst_device_provider_class_add_metadata(), but `value` must be a static string
     * or an inlined string, as it will not be copied. (GStreamer plugins will
     * be made resident once loaded, so this function can be used even from
     * dynamically loaded plugins.)
     * @param key the key to set
     * @param value the value to set
     */
    static add_static_metadata(klass: DeviceProvider | Function | GObject.Type, key: string, value: string): void
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    static get_metadata(klass: DeviceProvider | Function | GObject.Type, key: string): string | null
    /**
     * Sets the detailed information for a #GstDeviceProviderClass.
     * 
     * > This function is for use in _class_init functions only.
     * @param longname The long English name of the device provider. E.g. "File Sink"
     * @param classification String describing the type of device provider, as an  unordered list separated with slashes ('/'). See draft-klass.txt of the  design docs for more details and common types. E.g: "Sink/File"
     * @param description Sentence describing the purpose of the device provider. E.g: "Write stream to a file"
     * @param author Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;"
     */
    static set_metadata(klass: DeviceProvider | Function | GObject.Type, longname: string, classification: string, description: string, author: string): void
    /**
     * Sets the detailed information for a #GstDeviceProviderClass.
     * 
     * > This function is for use in _class_init functions only.
     * 
     * Same as gst_device_provider_class_set_metadata(), but `longname,` `classification,`
     * `description,` and `author` must be static strings or inlined strings, as
     * they will not be copied. (GStreamer plugins will be made resident once
     * loaded, so this function can be used even from dynamically loaded plugins.)
     * @param longname The long English name of the element. E.g. "File Sink"
     * @param classification String describing the type of element, as an unordered list separated with slashes ('/'). See draft-klass.txt of the design docs for more details and common types. E.g: "Sink/File"
     * @param description Sentence describing the purpose of the element.  E.g: "Write stream to a file"
     * @param author Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;"
     */
    static set_static_metadata(klass: DeviceProvider | Function | GObject.Type, longname: string, classification: string, description: string, author: string): void
    static $gtype: GObject.Type
}
interface DeviceProviderFactory_ConstructProps extends PluginFeature_ConstructProps {
}
class DeviceProviderFactory {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.DeviceProviderFactory */
    /**
     * Returns the device provider of the type defined by the given device
     * providerfactory.
     */
    get(): DeviceProvider | null
    /**
     * Get the #GType for device providers managed by this factory. The type can
     * only be retrieved if the device provider factory is loaded, which can be
     * assured with gst_plugin_feature_load().
     */
    get_device_provider_type(): GObject.Type
    /**
     * Get the metadata on `factory` with `key`.
     * @param key a key
     */
    get_metadata(key: string): string | null
    /**
     * Get the available keys for the metadata on `factory`.
     */
    get_metadata_keys(): string[] | null
    /**
     * Check if `factory` matches all of the given `classes`
     * @param classes a "/" separate list of classes to match, only match     if all classes are matched
     */
    has_classes(classes?: string | null): boolean
    /**
     * Check if `factory` matches all of the given classes
     * @param classes a %NULL terminated array   of classes to match, only match if all classes are matched
     */
    has_classesv(classes?: string[] | null): boolean
    /* Methods of Gst-1.0.Gst.PluginFeature */
    /**
     * Checks whether the given plugin feature is at least
     *  the required version
     * @param min_major minimum required major version
     * @param min_minor minimum required minor version
     * @param min_micro minimum required micro version
     */
    check_version(min_major: number, min_minor: number, min_micro: number): boolean
    /**
     * Get the plugin that provides this feature.
     */
    get_plugin(): Plugin | null
    /**
     * Get the name of the plugin that provides this feature.
     */
    get_plugin_name(): string | null
    /**
     * Gets the rank of a plugin feature.
     */
    get_rank(): number
    /**
     * Loads the plugin containing `feature` if it's not already loaded. `feature` is
     * unaffected; use the return value instead.
     * 
     * Normally this function is used like this:
     * 
     * ```c
     * GstPluginFeature *loaded_feature;
     * 
     * loaded_feature = gst_plugin_feature_load (feature);
     * // presumably, we're no longer interested in the potentially-unloaded feature
     * gst_object_unref (feature);
     * feature = loaded_feature;
     * ```
     * 
     */
    load(): PluginFeature | null
    /**
     * Specifies a rank for a plugin feature, so that autoplugging uses
     * the most appropriate feature.
     * @param rank rank value - higher number means more priority rank
     */
    set_rank(rank: number): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: DeviceProviderFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: DeviceProviderFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: DeviceProviderFactory, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceProviderFactory, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceProviderFactory_ConstructProps)
    _init (config?: DeviceProviderFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Search for an device provider factory of the given name. Refs the returned
     * device provider factory; caller is responsible for unreffing.
     * @param name name of factory to find
     */
    static find(name: string): DeviceProviderFactory | null
    /**
     * Returns the device provider of the type defined by the given device
     * provider factory.
     * @param factoryname a named factory to instantiate
     */
    static get_by_name(factoryname: string): DeviceProvider | null
    /**
     * Get a list of factories with a rank greater or equal to `minrank`.
     * The list of factories is returned by decreasing rank.
     * @param minrank Minimum rank
     */
    static list_get_device_providers(minrank: Rank): DeviceProviderFactory[]
    static $gtype: GObject.Type
}
class DoubleRange {
    static name: string
}
interface DynamicTypeFactory_ConstructProps extends PluginFeature_ConstructProps {
}
class DynamicTypeFactory {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.PluginFeature */
    /**
     * Checks whether the given plugin feature is at least
     *  the required version
     * @param min_major minimum required major version
     * @param min_minor minimum required minor version
     * @param min_micro minimum required micro version
     */
    check_version(min_major: number, min_minor: number, min_micro: number): boolean
    /**
     * Get the plugin that provides this feature.
     */
    get_plugin(): Plugin | null
    /**
     * Get the name of the plugin that provides this feature.
     */
    get_plugin_name(): string | null
    /**
     * Gets the rank of a plugin feature.
     */
    get_rank(): number
    /**
     * Loads the plugin containing `feature` if it's not already loaded. `feature` is
     * unaffected; use the return value instead.
     * 
     * Normally this function is used like this:
     * 
     * ```c
     * GstPluginFeature *loaded_feature;
     * 
     * loaded_feature = gst_plugin_feature_load (feature);
     * // presumably, we're no longer interested in the potentially-unloaded feature
     * gst_object_unref (feature);
     * feature = loaded_feature;
     * ```
     * 
     */
    load(): PluginFeature | null
    /**
     * Specifies a rank for a plugin feature, so that autoplugging uses
     * the most appropriate feature.
     * @param rank rank value - higher number means more priority rank
     */
    set_rank(rank: number): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: DynamicTypeFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: DynamicTypeFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: DynamicTypeFactory, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DynamicTypeFactory, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DynamicTypeFactory_ConstructProps)
    _init (config?: DynamicTypeFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static load(factoryname: string): GObject.Type
    static $gtype: GObject.Type
}
interface Element_ConstructProps extends Object_ConstructProps {
}
class Element {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     * @param pad the #GstPad to add to the element.
     */
    add_pad(pad: Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     * @param func Function to call asynchronously from another thread
     */
    call_async(func: ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    change_state(transition: StateChange): StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     * @param ret The previous state return value
     */
    continue_state(ret: StateChangeReturn): StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     * @param func function to call for each pad
     */
    foreach_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each sink pad
     */
    foreach_sink_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each source pad
     */
    foreach_src_pad(func: ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     * @param pad the #GstPad to find a compatible one for.
     * @param caps the #GstCaps to use as a filter.
     */
    get_compatible_pad(pad: Pad, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     * @param compattempl the #GstPadTemplate to find a compatible     template for
     */
    get_compatible_pad_template(compattempl: PadTemplate): PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     * @param context_type a name of a context to retrieve
     */
    get_context(context_type: string): Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * @param context_type a name of a context to retrieve
     */
    get_context_unlocked(context_type: string): Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     * @param name the name of the #GstPadTemplate to get.
     */
    get_pad_template(name: string): PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     * @param name the name of the request #GstPad to retrieve.
     */
    get_request_pad(name: string): Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     * @param name the name of the static #GstPad to retrieve.
     */
    get_static_pad(name: string): Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     */
    link(dest: Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_filtered(dest: Element, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     */
    link_pads(srcpadname: string | null, dest: Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element     or %NULL for any pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_pads_filtered(srcpadname: string | null, dest: Element, destpadname?: string | null, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     * @param flags the #GstPadLinkCheck to be performed when linking pads.
     */
    link_pads_full(srcpadname: string | null, dest: Element, destpadname: string | null, flags: PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     */
    message_full(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     * @param structure optional details structure
     */
    message_full_with_details(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    query(query: Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     * @param pad the #GstPad to release.
     */
    release_request_pad(pad: Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     * @param pad the #GstPad to remove from the element.
     */
    remove_pad(pad: Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    request_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     * @param name the name of the request #GstPad to retrieve.
     */
    request_pad_simple(name: string): Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     * @param rate The new playback rate
     * @param format The format of the seek values
     * @param flags The optional seek flags.
     * @param start_type The type and flags for the new start position
     * @param start The value of the new start position
     * @param stop_type The type and flags for the new stop position
     * @param stop The value of the new stop position
     */
    seek(rate: number, format: Format, flags: SeekFlags, start_type: SeekType, start: number, stop_type: SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     * @param format a #GstFormat to execute the seek in, such as #GST_FORMAT_TIME
     * @param seek_flags seek options; playback applications will usually want to use            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here
     * @param seek_pos position to seek to (relative to the start); if you are doing            a seek in #GST_FORMAT_TIME this value is in nanoseconds -            multiply with #GST_SECOND to convert seconds to nanoseconds or            with #GST_MSECOND to convert milliseconds to nanoseconds.
     */
    seek_simple(format: Format, seek_flags: SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    send_event(event: Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_base_time(time: ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    set_context(context: Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     * @param locked_state %TRUE to lock the element's state
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_start_time(time: ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    set_state(state: State): StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     * @param dest the sink #GstElement to unlink.
     */
    unlink(dest: Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     * @param srcpadname the name of the #GstPad in source element.
     * @param dest a #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element.
     */
    unlink_pads(srcpadname: string, dest: Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    vfunc_change_state(transition: StateChange): StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    vfunc_get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Pad): void
    vfunc_pad_removed(pad: Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    vfunc_post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    vfunc_query(query: Query): boolean
    vfunc_release_pad(pad: Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    vfunc_request_new_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    vfunc_send_event(event: Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    vfunc_set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    vfunc_set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    vfunc_set_context(context: Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    vfunc_set_state(state: State): StateChangeReturn
    vfunc_state_changed(oldstate: State, newstate: State, pending: State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: Element) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: Element) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     * @param new_pad the pad that has been added
     */
    connect(sigName: "pad-added", callback: (($obj: Element, new_pad: Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: Element, new_pad: Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Pad): void
    /**
     * a #GstPad has been removed from the element
     * @param old_pad the pad that has been removed
     */
    connect(sigName: "pad-removed", callback: (($obj: Element, old_pad: Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: Element, old_pad: Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Element, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Element, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Element, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Element, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Element_ConstructProps)
    _init (config?: Element_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Creates an element for handling the given URI.
     * @param type Whether to create a source or a sink
     * @param uri URI to create an element for
     * @param elementname Name of created element, can be %NULL.
     */
    static make_from_uri(type: URIType, uri: string, elementname?: string | null): Element
    /**
     * Create a new elementfactory capable of instantiating objects of the
     * `type` and add the factory to `plugin`.
     * @param plugin #GstPlugin to register the element with, or %NULL for     a static element.
     * @param name name of elements of this type
     * @param rank rank of element (higher rank means more importance when autoplugging)
     * @param type GType of element to register
     */
    static register(plugin: Plugin | null, name: string, rank: number, type: GObject.Type): boolean
    /**
     * Gets a string representing the given state change result.
     * @param state_ret a #GstStateChangeReturn to get the name of.
     */
    static state_change_return_get_name(state_ret: StateChangeReturn): string
    /**
     * Gets a string representing the given state.
     * @param state a #GstState to get the name of.
     */
    static state_get_name(state: State): string
    /**
     * Marks `type` as "documentation should be skipped".
     * Can be useful for dynamically registered element to be excluded from
     * plugin documentation system.
     * 
     * Example:
     * ```c
     * GType my_type;
     * GTypeInfo my_type_info;
     * 
     * // Fill "my_type_info"
     * ...
     * 
     * my_type = g_type_register_static (GST_TYPE_MY_ELEMENT, "my-type-name",
     *    &my_type_info, 0);
     * gst_element_type_set_skip_documentation (my_type);
     * gst_element_register (plugin, "my-plugin-feature-name", rank, my_type);
     * ```
     * @param type a #GType of element
     */
    static type_set_skip_documentation(type: GObject.Type): void
    static $gtype: GObject.Type
}
interface ElementFactory_ConstructProps extends PluginFeature_ConstructProps {
}
class ElementFactory {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.ElementFactory */
    /**
     * Checks if the factory can sink all possible capabilities.
     * @param caps the caps to check
     */
    can_sink_all_caps(caps: Caps): boolean
    /**
     * Checks if the factory can sink any possible capability.
     * @param caps the caps to check
     */
    can_sink_any_caps(caps: Caps): boolean
    /**
     * Checks if the factory can src all possible capabilities.
     * @param caps the caps to check
     */
    can_src_all_caps(caps: Caps): boolean
    /**
     * Checks if the factory can src any possible capability.
     * @param caps the caps to check
     */
    can_src_any_caps(caps: Caps): boolean
    /**
     * Create a new element of the type defined by the given elementfactory.
     * It will be given the name supplied, since all elements require a name as
     * their first argument.
     * @param name name of new element, or %NULL to automatically create    a unique name
     */
    create(name?: string | null): Element | null
    /**
     * Create a new element of the type defined by the given elementfactory.
     * The supplied list of properties, will be passed at object construction.
     * @param names array of properties names
     * @param values array of associated properties values
     */
    create_with_properties(names?: string[] | null, values?: any[] | null): Element | null
    /**
     * Get the #GType for elements managed by this factory. The type can
     * only be retrieved if the element factory is loaded, which can be
     * assured with gst_plugin_feature_load().
     */
    get_element_type(): GObject.Type
    /**
     * Get the metadata on `factory` with `key`.
     * @param key a key
     */
    get_metadata(key: string): string | null
    /**
     * Get the available keys for the metadata on `factory`.
     */
    get_metadata_keys(): string[] | null
    /**
     * Gets the number of pad_templates in this factory.
     */
    get_num_pad_templates(): number
    /**
     * Queries whether registered element managed by `factory` needs to
     * be excluded from documentation system or not.
     */
    get_skip_documentation(): boolean
    /**
     * Gets the #GList of #GstStaticPadTemplate for this factory.
     */
    get_static_pad_templates(): StaticPadTemplate[]
    /**
     * Gets a %NULL-terminated array of protocols this element supports or %NULL if
     * no protocols are supported. You may not change the contents of the returned
     * array, as it is still owned by the element factory. Use g_strdupv() to
     * make a copy of the protocol string array if you need to.
     */
    get_uri_protocols(): string[]
    /**
     * Gets the type of URIs the element supports or #GST_URI_UNKNOWN if none.
     */
    get_uri_type(): URIType
    /**
     * Check if `factory` implements the interface with name `interfacename`.
     * @param interfacename an interface name
     */
    has_interface(interfacename: string): boolean
    /**
     * Check if `factory` is of the given types.
     * @param type a #GstElementFactoryListType
     */
    list_is_type(type: ElementFactoryListType): boolean
    /* Methods of Gst-1.0.Gst.PluginFeature */
    /**
     * Checks whether the given plugin feature is at least
     *  the required version
     * @param min_major minimum required major version
     * @param min_minor minimum required minor version
     * @param min_micro minimum required micro version
     */
    check_version(min_major: number, min_minor: number, min_micro: number): boolean
    /**
     * Get the plugin that provides this feature.
     */
    get_plugin(): Plugin | null
    /**
     * Get the name of the plugin that provides this feature.
     */
    get_plugin_name(): string | null
    /**
     * Gets the rank of a plugin feature.
     */
    get_rank(): number
    /**
     * Loads the plugin containing `feature` if it's not already loaded. `feature` is
     * unaffected; use the return value instead.
     * 
     * Normally this function is used like this:
     * 
     * ```c
     * GstPluginFeature *loaded_feature;
     * 
     * loaded_feature = gst_plugin_feature_load (feature);
     * // presumably, we're no longer interested in the potentially-unloaded feature
     * gst_object_unref (feature);
     * feature = loaded_feature;
     * ```
     * 
     */
    load(): PluginFeature | null
    /**
     * Specifies a rank for a plugin feature, so that autoplugging uses
     * the most appropriate feature.
     * @param rank rank value - higher number means more priority rank
     */
    set_rank(rank: number): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: ElementFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: ElementFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ElementFactory, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ElementFactory, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ElementFactory_ConstructProps)
    _init (config?: ElementFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Search for an element factory of the given name. Refs the returned
     * element factory; caller is responsible for unreffing.
     * @param name name of factory to find
     */
    static find(name: string): ElementFactory | null
    /**
     * Filter out all the elementfactories in `list` that can handle `caps` in
     * the given direction.
     * 
     * If `subsetonly` is %TRUE, then only the elements whose pads templates
     * are a complete superset of `caps` will be returned. Else any element
     * whose pad templates caps can intersect with `caps` will be returned.
     * @param list a #GList of     #GstElementFactory to filter
     * @param caps a #GstCaps
     * @param direction a #GstPadDirection to filter on
     * @param subsetonly whether to filter on caps subsets or not.
     */
    static list_filter(list: ElementFactory[], caps: Caps, direction: PadDirection, subsetonly: boolean): ElementFactory[]
    /**
     * Get a list of factories that match the given `type`. Only elements
     * with a rank greater or equal to `minrank` will be returned.
     * The list of factories is returned by decreasing rank.
     * @param type a #GstElementFactoryListType
     * @param minrank Minimum rank
     */
    static list_get_elements(type: ElementFactoryListType, minrank: Rank): ElementFactory[]
    /**
     * Create a new element of the type defined by the given element factory.
     * If name is %NULL, then the element will receive a guaranteed unique name,
     * consisting of the element factory name and a number.
     * If name is given, it will be given the name supplied.
     * @param factoryname a named factory to instantiate
     * @param name name of new element, or %NULL to automatically create    a unique name
     */
    static make(factoryname: string, name?: string | null): Element | null
    /**
     * Create a new element of the type defined by the given elementfactory.
     * The supplied list of properties, will be passed at object construction.
     * @param factoryname a named factory to instantiate
     * @param names array of properties names
     * @param values array of associated properties values
     */
    static make_with_properties(factoryname: string, names?: string[] | null, values?: any[] | null): Element | null
    static $gtype: GObject.Type
}
class FlagSet {
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Create a new sub-class of #GST_TYPE_FLAG_SET
     * which will pretty-print the human-readable flags
     * when serializing, for easier debugging.
     * @param flags_type a #GType of a #G_TYPE_FLAGS type.
     */
    static register(flags_type: GObject.Type): GObject.Type
}
class Fraction {
    static name: string
}
class FractionRange {
    static name: string
}
interface GhostPad_ConstructProps extends ProxyPad_ConstructProps {
}
class GhostPad {
    /* Properties of Gst-1.0.Gst.Pad */
    readonly caps: Caps
    /**
     * The offset that will be applied to the running time of the pad.
     */
    offset: number
    template: PadTemplate
    /* Fields of Gst-1.0.Gst.ProxyPad */
    pad: Pad
    /* Fields of Gst-1.0.Gst.Pad */
    object: Object
    /**
     * private data owned by the parent element
     */
    element_private: object
    /**
     * padtemplate for this pad
     */
    padtemplate: PadTemplate
    /**
     * the direction of the pad, cannot change after creating
     *             the pad.
     */
    direction: PadDirection
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.GhostPad */
    /**
     * Finish initialization of a newly allocated ghost pad.
     * 
     * This function is most useful in language bindings and when subclassing
     * #GstGhostPad; plugin and application developers normally will not call this
     * function. Call this function directly after a call to g_object_new
     * (GST_TYPE_GHOST_PAD, "direction", `dir,` ..., NULL).
     */
    construct(): boolean
    /**
     * Get the target pad of `gpad`. Unref target pad after usage.
     */
    get_target(): Pad | null
    /**
     * Set the new target of the ghostpad `gpad`. Any existing target
     * is unlinked and links to the new target are established. if `newtarget` is
     * %NULL the target will be cleared.
     * @param newtarget the new pad target
     */
    set_target(newtarget?: Pad | null): boolean
    /* Methods of Gst-1.0.Gst.ProxyPad */
    /**
     * Get the internal pad of `pad`. Unref target pad after usage.
     * 
     * The internal pad of a #GstGhostPad is the internally used
     * pad of opposite direction, which is used to link to the target.
     */
    get_internal(): ProxyPad | null
    /* Methods of Gst-1.0.Gst.Pad */
    /**
     * Activates or deactivates the given pad in `mode` via dispatching to the
     * pad's activatemodefunc. For use from within pad activation functions only.
     * 
     * If you don't know what this is, you probably don't want to call it.
     * @param mode the requested activation mode
     * @param active whether or not the pad should be active.
     */
    activate_mode(mode: PadMode, active: boolean): boolean
    /**
     * Be notified of different states of pads. The provided callback is called for
     * every state that matches `mask`.
     * 
     * Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
     * called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only
     * exception here are GST_PAD_PROBE_TYPE_IDLE probes that are called
     * immediately if the pad is already idle while calling gst_pad_add_probe().
     * In each of the groups, probes are called in the order in which they were
     * added.
     * @param mask the probe mask
     * @param callback #GstPadProbeCallback that will be called with notifications of           the pad state
     */
    add_probe(mask: PadProbeType, callback: PadProbeCallback): number
    /**
     * Checks if the source pad and the sink pad are compatible so they can be
     * linked.
     * @param sinkpad the sink #GstPad.
     */
    can_link(sinkpad: Pad): boolean
    /**
     * Chain a buffer to `pad`.
     * 
     * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
     * 
     * If the buffer type is not acceptable for `pad` (as negotiated with a
     * preceding GST_EVENT_CAPS event), this function returns
     * #GST_FLOW_NOT_NEGOTIATED.
     * 
     * The function proceeds calling the chain function installed on `pad` (see
     * gst_pad_set_chain_function()) and the return value of that function is
     * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
     * chain function.
     * 
     * In all cases, success or failure, the caller loses its reference to `buffer`
     * after calling this function.
     * @param buffer the #GstBuffer to send, return GST_FLOW_ERROR     if not.
     */
    chain(buffer: Buffer): FlowReturn
    /**
     * Chain a bufferlist to `pad`.
     * 
     * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
     * 
     * If `pad` was not negotiated properly with a CAPS event, this function
     * returns #GST_FLOW_NOT_NEGOTIATED.
     * 
     * The function proceeds calling the chainlist function installed on `pad` (see
     * gst_pad_set_chain_list_function()) and the return value of that function is
     * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
     * chainlist function.
     * 
     * In all cases, success or failure, the caller loses its reference to `list`
     * after calling this function.
     * 
     * MT safe.
     * @param list the #GstBufferList to send, return GST_FLOW_ERROR     if not.
     */
    chain_list(list: BufferList): FlowReturn
    /**
     * Check and clear the #GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return %TRUE
     * if the flag was set.
     */
    check_reconfigure(): boolean
    /**
     * Creates a stream-id for the source #GstPad `pad` by combining the
     * upstream information with the optional `stream_id` of the stream
     * of `pad`. `pad` must have a parent #GstElement and which must have zero
     * or one sinkpad. `stream_id` can only be %NULL if the parent element
     * of `pad` has only a single source pad.
     * 
     * This function generates an unique stream-id by getting the upstream
     * stream-start event stream ID and appending `stream_id` to it. If the
     * element has no sinkpad it will generate an upstream stream-id by
     * doing an URI query on the element and in the worst case just uses
     * a random number. Source elements that don't implement the URI
     * handler interface should ideally generate a unique, deterministic
     * stream-id manually instead.
     * 
     * Since stream IDs are sorted alphabetically, any numbers in the
     * stream ID should be printed with a fixed number of characters,
     * preceded by 0's, such as by using the format \%03u instead of \%u.
     * @param parent Parent #GstElement of `pad`
     * @param stream_id The stream-id
     */
    create_stream_id(parent: Element, stream_id?: string | null): string
    /**
     * Invokes the default event handler for the given pad.
     * 
     * The EOS event will pause the task associated with `pad` before it is forwarded
     * to all internally linked pads,
     * 
     * The event is sent to all pads internally linked to `pad`. This function
     * takes ownership of `event`.
     * @param parent the parent of `pad` or %NULL
     * @param event the #GstEvent to handle.
     */
    event_default(parent: Object | null, event: Event): boolean
    /**
     * Calls `forward` for all internally linked pads of `pad`. This function deals with
     * dynamically changing internal pads and will make sure that the `forward`
     * function is only called once for each pad.
     * 
     * When `forward` returns %TRUE, no further pads will be processed.
     * @param forward a #GstPadForwardFunction
     */
    forward(forward: PadForwardFunction): boolean
    /**
     * Gets the capabilities of the allowed media types that can flow through
     * `pad` and its peer.
     * 
     * The allowed capabilities is calculated as the intersection of the results of
     * calling gst_pad_query_caps() on `pad` and its peer. The caller owns a reference
     * on the resulting caps.
     */
    get_allowed_caps(): Caps | null
    /**
     * Gets the capabilities currently configured on `pad` with the last
     * #GST_EVENT_CAPS event.
     */
    get_current_caps(): Caps | null
    /**
     * Gets the direction of the pad. The direction of the pad is
     * decided at construction time so this function does not take
     * the LOCK.
     */
    get_direction(): PadDirection
    /**
     * Gets the private data of a pad.
     * No locking is performed in this function.
     */
    get_element_private(): object | null
    /**
     * Gets the #GstFlowReturn return from the last data passed by this pad.
     */
    get_last_flow_return(): FlowReturn
    /**
     * Get the offset applied to the running time of `pad`. `pad` has to be a source
     * pad.
     */
    get_offset(): number
    /**
     * Gets the template for `pad`.
     */
    get_pad_template(): PadTemplate | null
    /**
     * Gets the capabilities for `pad'`s template.
     */
    get_pad_template_caps(): Caps
    /**
     * Gets the parent of `pad,` cast to a #GstElement. If a `pad` has no parent or
     * its parent is not an element, return %NULL.
     */
    get_parent_element(): Element | null
    /**
     * Gets the peer of `pad`. This function refs the peer pad so
     * you need to unref it after use.
     */
    get_peer(): Pad | null
    /**
     * When `pad` is flushing this function returns #GST_FLOW_FLUSHING
     * immediately and `buffer` is %NULL.
     * 
     * Calls the getrange function of `pad,` see #GstPadGetRangeFunction for a
     * description of a getrange function. If `pad` has no getrange function
     * installed (see gst_pad_set_getrange_function()) this function returns
     * #GST_FLOW_NOT_SUPPORTED.
     * 
     * If `buffer` points to a variable holding %NULL, a valid new #GstBuffer will be
     * placed in `buffer` when this function returns #GST_FLOW_OK. The new buffer
     * must be freed with gst_buffer_unref() after usage.
     * 
     * When `buffer` points to a variable that points to a valid #GstBuffer, the
     * buffer will be filled with the result data when this function returns
     * #GST_FLOW_OK. If the provided buffer is larger than `size,` only
     * `size` bytes will be filled in the result buffer and its size will be updated
     * accordingly.
     * 
     * Note that less than `size` bytes can be returned in `buffer` when, for example,
     * an EOS condition is near or when `buffer` is not large enough to hold `size`
     * bytes. The caller should check the result buffer size to get the result size.
     * 
     * When this function returns any other result value than #GST_FLOW_OK, `buffer`
     * will be unchanged.
     * 
     * This is a lowlevel function. Usually gst_pad_pull_range() is used.
     * @param offset The start offset of the buffer
     * @param size The length of the buffer
     */
    get_range(offset: number, size: number): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * If there is a single internal link of the given pad, this function will
     * return it. Otherwise, it will return NULL.
     */
    get_single_internal_link(): Pad | null
    /**
     * Returns a new reference of the sticky event of type `event_type`
     * from the event.
     * @param event_type the #GstEventType that should be retrieved.
     * @param idx the index of the event
     */
    get_sticky_event(event_type: EventType, idx: number): Event | null
    /**
     * Returns the current #GstStream for the `pad,` or %NULL if none has been
     * set yet, i.e. the pad has not received a stream-start event yet.
     * 
     * This is a convenience wrapper around gst_pad_get_sticky_event() and
     * gst_event_parse_stream().
     */
    get_stream(): Stream | null
    /**
     * Returns the current stream-id for the `pad,` or %NULL if none has been
     * set yet, i.e. the pad has not received a stream-start event yet.
     * 
     * This is a convenience wrapper around gst_pad_get_sticky_event() and
     * gst_event_parse_stream_start().
     * 
     * The returned stream-id string should be treated as an opaque string, its
     * contents should not be interpreted.
     */
    get_stream_id(): string | null
    /**
     * Get `pad` task state. If no task is currently
     * set, #GST_TASK_STOPPED is returned.
     */
    get_task_state(): TaskState
    /**
     * Check if `pad` has caps set on it with a #GST_EVENT_CAPS event.
     */
    has_current_caps(): boolean
    /**
     * Query if a pad is active
     */
    is_active(): boolean
    /**
     * Checks if the pad is blocked or not. This function returns the
     * last requested state of the pad. It is not certain that the pad
     * is actually blocking at this point (see gst_pad_is_blocking()).
     */
    is_blocked(): boolean
    /**
     * Checks if the pad is blocking or not. This is a guaranteed state
     * of whether the pad is actually blocking on a #GstBuffer or a #GstEvent.
     */
    is_blocking(): boolean
    /**
     * Checks if a `pad` is linked to another pad or not.
     */
    is_linked(): boolean
    /**
     * Gets an iterator for the pads to which the given pad is linked to inside
     * of the parent element.
     * 
     * Each #GstPad element yielded by the iterator will have its refcount increased,
     * so unref after use.
     * 
     * Free-function: gst_iterator_free
     */
    iterate_internal_links(): Iterator | null
    /**
     * Iterate the list of pads to which the given pad is linked to inside of
     * the parent element.
     * This is the default handler, and thus returns an iterator of all of the
     * pads inside the parent element with opposite direction.
     * 
     * The caller must free this iterator after use with gst_iterator_free().
     * @param parent the parent of `pad` or %NULL
     */
    iterate_internal_links_default(parent?: Object | null): Iterator | null
    /**
     * Links the source pad and the sink pad.
     * @param sinkpad the sink #GstPad to link.
     */
    link(sinkpad: Pad): PadLinkReturn
    /**
     * Links the source pad and the sink pad.
     * 
     * This variant of #gst_pad_link provides a more granular control on the
     * checks being done when linking. While providing some considerable speedups
     * the caller of this method must be aware that wrong usage of those flags
     * can cause severe issues. Refer to the documentation of #GstPadLinkCheck
     * for more information.
     * 
     * MT Safe.
     * @param sinkpad the sink #GstPad to link.
     * @param flags the checks to validate when linking
     */
    link_full(sinkpad: Pad, flags: PadLinkCheck): PadLinkReturn
    /**
     * Links `src` to `sink,` creating any #GstGhostPad's in between as necessary.
     * 
     * This is a convenience function to save having to create and add intermediate
     * #GstGhostPad's as required for linking across #GstBin boundaries.
     * 
     * If `src` or `sink` pads don't have parent elements or do not share a common
     * ancestor, the link will fail.
     * @param sink a #GstPad
     */
    link_maybe_ghosting(sink: Pad): boolean
    /**
     * Links `src` to `sink,` creating any #GstGhostPad's in between as necessary.
     * 
     * This is a convenience function to save having to create and add intermediate
     * #GstGhostPad's as required for linking across #GstBin boundaries.
     * 
     * If `src` or `sink` pads don't have parent elements or do not share a common
     * ancestor, the link will fail.
     * 
     * Calling gst_pad_link_maybe_ghosting_full() with
     * `flags` == %GST_PAD_LINK_CHECK_DEFAULT is the recommended way of linking
     * pads with safety checks applied.
     * @param sink a #GstPad
     * @param flags some #GstPadLinkCheck flags
     */
    link_maybe_ghosting_full(sink: Pad, flags: PadLinkCheck): boolean
    /**
     * Mark a pad for needing reconfiguration. The next call to
     * gst_pad_check_reconfigure() will return %TRUE after this call.
     */
    mark_reconfigure(): void
    /**
     * Check the #GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return %TRUE
     * if the flag was set.
     */
    needs_reconfigure(): boolean
    /**
     * Pause the task of `pad`. This function will also wait until the
     * function executed by the task is finished if this function is not
     * called from the task function.
     */
    pause_task(): boolean
    /**
     * Performs gst_pad_query() on the peer of `pad`.
     * 
     * The caller is responsible for both the allocation and deallocation of
     * the query structure.
     * @param query the #GstQuery to perform.
     */
    peer_query(query: Query): boolean
    /**
     * Check if the peer of `pad` accepts `caps`. If `pad` has no peer, this function
     * returns %TRUE.
     * @param caps a #GstCaps to check on the pad
     */
    peer_query_accept_caps(caps: Caps): boolean
    /**
     * Gets the capabilities of the peer connected to this pad. Similar to
     * gst_pad_query_caps().
     * 
     * When called on srcpads `filter` contains the caps that
     * upstream could produce in the order preferred by upstream. When
     * called on sinkpads `filter` contains the caps accepted by
     * downstream in the preferred order. `filter` might be %NULL but
     * if it is not %NULL the returned caps will be a subset of `filter`.
     * @param filter a #GstCaps filter, or %NULL.
     */
    peer_query_caps(filter?: Caps | null): Caps
    /**
     * Queries the peer pad of a given sink pad to convert `src_val` in `src_format`
     * to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    peer_query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries the peer pad of a given sink pad for the total stream duration.
     * @param format the #GstFormat requested
     */
    peer_query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries the peer of a given sink pad for the stream position.
     * @param format the #GstFormat requested
     */
    peer_query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Checks if all internally linked pads of `pad` accepts the caps in `query` and
     * returns the intersection of the results.
     * 
     * This function is useful as a default accept caps query function for an element
     * that can handle any stream format, but requires caps that are acceptable for
     * all opposite pads.
     * @param query an ACCEPT_CAPS #GstQuery.
     */
    proxy_query_accept_caps(query: Query): boolean
    /**
     * Calls gst_pad_query_caps() for all internally linked pads of `pad` and returns
     * the intersection of the results.
     * 
     * This function is useful as a default caps query function for an element
     * that can handle any stream format, but requires all its pads to have
     * the same caps.  Two such elements are tee and adder.
     * @param query a CAPS #GstQuery.
     */
    proxy_query_caps(query: Query): boolean
    /**
     * Pulls a `buffer` from the peer pad or fills up a provided buffer.
     * 
     * This function will first trigger the pad block signal if it was
     * installed.
     * 
     * When `pad` is not linked #GST_FLOW_NOT_LINKED is returned else this
     * function returns the result of gst_pad_get_range() on the peer pad.
     * See gst_pad_get_range() for a list of return values and for the
     * semantics of the arguments of this function.
     * 
     * If `buffer` points to a variable holding %NULL, a valid new #GstBuffer will be
     * placed in `buffer` when this function returns #GST_FLOW_OK. The new buffer
     * must be freed with gst_buffer_unref() after usage. When this function
     * returns any other result value, `buffer` will still point to %NULL.
     * 
     * When `buffer` points to a variable that points to a valid #GstBuffer, the
     * buffer will be filled with the result data when this function returns
     * #GST_FLOW_OK. When this function returns any other result value,
     * `buffer` will be unchanged. If the provided buffer is larger than `size,` only
     * `size` bytes will be filled in the result buffer and its size will be updated
     * accordingly.
     * 
     * Note that less than `size` bytes can be returned in `buffer` when, for example,
     * an EOS condition is near or when `buffer` is not large enough to hold `size`
     * bytes. The caller should check the result buffer size to get the result size.
     * @param offset The start offset of the buffer
     * @param size The length of the buffer
     */
    pull_range(offset: number, size: number): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * Pushes a buffer to the peer of `pad`.
     * 
     * This function will call installed block probes before triggering any
     * installed data probes.
     * 
     * The function proceeds calling gst_pad_chain() on the peer pad and returns
     * the value from that function. If `pad` has no peer, #GST_FLOW_NOT_LINKED will
     * be returned.
     * 
     * In all cases, success or failure, the caller loses its reference to `buffer`
     * after calling this function.
     * @param buffer the #GstBuffer to push returns GST_FLOW_ERROR     if not.
     */
    push(buffer: Buffer): FlowReturn
    /**
     * Sends the event to the peer of the given pad. This function is
     * mainly used by elements to send events to their peer
     * elements.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * @param event the #GstEvent to send to the pad.
     */
    push_event(event: Event): boolean
    /**
     * Pushes a buffer list to the peer of `pad`.
     * 
     * This function will call installed block probes before triggering any
     * installed data probes.
     * 
     * The function proceeds calling the chain function on the peer pad and returns
     * the value from that function. If `pad` has no peer, #GST_FLOW_NOT_LINKED will
     * be returned. If the peer pad does not have any installed chainlist function
     * every group buffer of the list will be merged into a normal #GstBuffer and
     * chained via gst_pad_chain().
     * 
     * In all cases, success or failure, the caller loses its reference to `list`
     * after calling this function.
     * @param list the #GstBufferList to push returns GST_FLOW_ERROR     if not.
     */
    push_list(list: BufferList): FlowReturn
    /**
     * Dispatches a query to a pad. The query should have been allocated by the
     * caller via one of the type-specific allocation functions. The element that
     * the pad belongs to is responsible for filling the query with an appropriate
     * response, which should then be parsed with a type-specific query parsing
     * function.
     * 
     * Again, the caller is responsible for both the allocation and deallocation of
     * the query structure.
     * 
     * Please also note that some queries might need a running pipeline to work.
     * @param query the #GstQuery to perform.
     */
    query(query: Query): boolean
    /**
     * Check if the given pad accepts the caps.
     * @param caps a #GstCaps to check on the pad
     */
    query_accept_caps(caps: Caps): boolean
    /**
     * Gets the capabilities this pad can produce or consume.
     * Note that this method doesn't necessarily return the caps set by sending a
     * gst_event_new_caps() - use gst_pad_get_current_caps() for that instead.
     * gst_pad_query_caps returns all possible caps a pad can operate with, using
     * the pad's CAPS query function, If the query fails, this function will return
     * `filter,` if not %NULL, otherwise ANY.
     * 
     * When called on sinkpads `filter` contains the caps that
     * upstream could produce in the order preferred by upstream. When
     * called on srcpads `filter` contains the caps accepted by
     * downstream in the preferred order. `filter` might be %NULL but
     * if it is not %NULL the returned caps will be a subset of `filter`.
     * 
     * Note that this function does not return writable #GstCaps, use
     * gst_caps_make_writable() before modifying the caps.
     * @param filter suggested #GstCaps, or %NULL
     */
    query_caps(filter?: Caps | null): Caps
    /**
     * Queries a pad to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Invokes the default query handler for the given pad.
     * The query is sent to all pads internally linked to `pad`. Note that
     * if there are many possible sink pads that are internally linked to
     * `pad,` only one will be sent the query.
     * Multi-sinkpad elements should implement custom query handlers.
     * @param parent the parent of `pad` or %NULL
     * @param query the #GstQuery to handle.
     */
    query_default(parent: Object | null, query: Query): boolean
    /**
     * Queries a pad for the total stream duration.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries a pad for the stream position.
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Remove the probe with `id` from `pad`.
     * 
     * MT safe.
     * @param id the probe id to remove
     */
    remove_probe(id: number): void
    /**
     * Sends the event to the pad. This function can be used
     * by applications to send events in the pipeline.
     * 
     * If `pad` is a source pad, `event` should be an upstream event. If `pad` is a
     * sink pad, `event` should be a downstream event. For example, you would not
     * send a #GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
     * Furthermore, some downstream events have to be serialized with data flow,
     * like EOS, while some can travel out-of-band, like #GST_EVENT_FLUSH_START. If
     * the event needs to be serialized with data flow, this function will take the
     * pad's stream lock while calling its event function.
     * 
     * To find out whether an event type is upstream, downstream, or downstream and
     * serialized, see #GstEventTypeFlags, gst_event_type_get_flags(),
     * #GST_EVENT_IS_UPSTREAM, #GST_EVENT_IS_DOWNSTREAM, and
     * #GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
     * plugin doesn't need to bother itself with this information; the core handles
     * all necessary locks and checks.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * @param event the #GstEvent to send to the pad.
     */
    send_event(event: Event): boolean
    /**
     * Sets the given activate function for `pad`. The activate function will
     * dispatch to gst_pad_activate_mode() to perform the actual activation.
     * Only makes sense to set on sink pads.
     * 
     * Call this function if your sink pad can start a pull-based task.
     * @param activate the #GstPadActivateFunction to set.
     */
    set_activate_function_full(activate: PadActivateFunction): void
    /**
     * Sets the given activate_mode function for the pad. An activate_mode function
     * prepares the element for data passing.
     * @param activatemode the #GstPadActivateModeFunction to set.
     */
    set_activatemode_function_full(activatemode: PadActivateModeFunction): void
    /**
     * Activates or deactivates the given pad.
     * Normally called from within core state change functions.
     * 
     * If `active,` makes sure the pad is active. If it is already active, either in
     * push or pull mode, just return. Otherwise dispatches to the pad's activate
     * function to perform the actual activation.
     * 
     * If not `active,` calls gst_pad_activate_mode() with the pad's current mode
     * and a %FALSE argument.
     * @param active whether or not the pad should be active.
     */
    set_active(active: boolean): boolean
    /**
     * Sets the given chain function for the pad. The chain function is called to
     * process a #GstBuffer input buffer. see #GstPadChainFunction for more details.
     * @param chain the #GstPadChainFunction to set.
     */
    set_chain_function_full(chain: PadChainFunction): void
    /**
     * Sets the given chain list function for the pad. The chainlist function is
     * called to process a #GstBufferList input buffer list. See
     * #GstPadChainListFunction for more details.
     * @param chainlist the #GstPadChainListFunction to set.
     */
    set_chain_list_function_full(chainlist: PadChainListFunction): void
    /**
     * Set the given private data gpointer on the pad.
     * This function can only be used by the element that owns the pad.
     * No locking is performed in this function.
     * @param priv The private data to attach to the pad.
     */
    set_element_private(priv?: object | null): void
    /**
     * Sets the given event handler for the pad.
     * @param event the #GstPadEventFullFunction to set.
     */
    set_event_full_function_full(event: PadEventFullFunction): void
    /**
     * Sets the given event handler for the pad.
     * @param event the #GstPadEventFunction to set.
     */
    set_event_function_full(event: PadEventFunction): void
    /**
     * Sets the given getrange function for the pad. The getrange function is
     * called to produce a new #GstBuffer to start the processing pipeline. see
     * #GstPadGetRangeFunction for a description of the getrange function.
     * @param get the #GstPadGetRangeFunction to set.
     */
    set_getrange_function_full(get: PadGetRangeFunction): void
    /**
     * Sets the given internal link iterator function for the pad.
     * @param iterintlink the #GstPadIterIntLinkFunction to set.
     */
    set_iterate_internal_links_function_full(iterintlink: PadIterIntLinkFunction): void
    /**
     * Sets the given link function for the pad. It will be called when
     * the pad is linked with another pad.
     * 
     * The return value #GST_PAD_LINK_OK should be used when the connection can be
     * made.
     * 
     * The return value #GST_PAD_LINK_REFUSED should be used when the connection
     * cannot be made for some reason.
     * 
     * If `link` is installed on a source pad, it should call the #GstPadLinkFunction
     * of the peer sink pad, if present.
     * @param link the #GstPadLinkFunction to set.
     */
    set_link_function_full(link: PadLinkFunction): void
    /**
     * Set the offset that will be applied to the running time of `pad`.
     * @param offset the offset
     */
    set_offset(offset: number): void
    /**
     * Set the given query function for the pad.
     * @param query the #GstPadQueryFunction to set.
     */
    set_query_function_full(query: PadQueryFunction): void
    /**
     * Sets the given unlink function for the pad. It will be called
     * when the pad is unlinked.
     * 
     * Note that the pad's lock is already held when the unlink
     * function is called, so most pad functions cannot be called
     * from within the callback.
     * @param unlink the #GstPadUnlinkFunction to set.
     */
    set_unlink_function_full(unlink: PadUnlinkFunction): void
    /**
     * Starts a task that repeatedly calls `func` with `user_data`. This function
     * is mostly used in pad activation functions to start the dataflow.
     * The #GST_PAD_STREAM_LOCK of `pad` will automatically be acquired
     * before `func` is called.
     * @param func the task function to call
     */
    start_task(func: TaskFunction): boolean
    /**
     * Iterates all sticky events on `pad` and calls `foreach_func` for every
     * event. If `foreach_func` returns %FALSE the iteration is immediately stopped.
     * @param foreach_func the #GstPadStickyEventsForeachFunction that                should be called for every event.
     */
    sticky_events_foreach(foreach_func: PadStickyEventsForeachFunction): void
    /**
     * Stop the task of `pad`. This function will also make sure that the
     * function executed by the task will effectively stop if not called
     * from the GstTaskFunction.
     * 
     * This function will deadlock if called from the GstTaskFunction of
     * the task. Use gst_task_pause() instead.
     * 
     * Regardless of whether the pad has a task, the stream lock is acquired and
     * released so as to ensure that streaming through this pad has finished.
     */
    stop_task(): boolean
    /**
     * Store the sticky `event` on `pad`
     * @param event a #GstEvent
     */
    store_sticky_event(event: Event): FlowReturn
    /**
     * Unlinks the source pad from the sink pad. Will emit the #GstPad::unlinked
     * signal on both pads.
     * @param sinkpad the sink #GstPad to unlink.
     */
    unlink(sinkpad: Pad): boolean
    /**
     * A helper function you can use that sets the FIXED_CAPS flag
     * This way the default CAPS query will always return the negotiated caps
     * or in case the pad is not negotiated, the padtemplate caps.
     * 
     * The negotiated caps are the caps of the last CAPS event that passed on the
     * pad. Use this function on a pad that, once it negotiated to a CAPS, cannot
     * be renegotiated to something else.
     */
    use_fixed_caps(): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Pad */
    vfunc_linked(peer: Pad): void
    vfunc_unlinked(peer: Pad): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Pad */
    /**
     * Signals that a pad has been linked to the peer pad.
     * @param peer the peer pad that has been connected
     */
    connect(sigName: "linked", callback: (($obj: GhostPad, peer: Pad) => void)): number
    connect_after(sigName: "linked", callback: (($obj: GhostPad, peer: Pad) => void)): number
    emit(sigName: "linked", peer: Pad): void
    /**
     * Signals that a pad has been unlinked from the peer pad.
     * @param peer the peer pad that has been disconnected
     */
    connect(sigName: "unlinked", callback: (($obj: GhostPad, peer: Pad) => void)): number
    connect_after(sigName: "unlinked", callback: (($obj: GhostPad, peer: Pad) => void)): number
    emit(sigName: "unlinked", peer: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: GhostPad, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: GhostPad, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::caps", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caps", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::offset", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offset", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::template", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::template", callback: (($obj: GhostPad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: GhostPad_ConstructProps)
    _init (config?: GhostPad_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name: string | null, target: Pad): GhostPad
    /* Function overloads */
    static new(name: string | null, direction: PadDirection): GhostPad
    static new_from_template(name: string | null, target: Pad, templ: PadTemplate): GhostPad
    /* Function overloads */
    static new_from_template(templ: PadTemplate, name?: string | null): GhostPad
    static new_no_target(name: string | null, dir: PadDirection): GhostPad
    static new_no_target_from_template(name: string | null, templ: PadTemplate): GhostPad
    /**
     * Invoke the default activate mode function of a ghost pad.
     * @param pad the #GstPad to activate or deactivate.
     * @param parent the parent of `pad` or %NULL
     * @param mode the requested activation mode
     * @param active whether the pad should be active or not.
     */
    static activate_mode_default(pad: Pad, parent: Object | null, mode: PadMode, active: boolean): boolean
    /**
     * Invoke the default activate mode function of a proxy pad that is
     * owned by a ghost pad.
     * @param pad the #GstPad to activate or deactivate.
     * @param parent the parent of `pad` or %NULL
     * @param mode the requested activation mode
     * @param active whether the pad should be active or not.
     */
    static internal_activate_mode_default(pad: Pad, parent: Object | null, mode: PadMode, active: boolean): boolean
    static $gtype: GObject.Type
}
class Int64Range {
    static name: string
}
class IntRange {
    static name: string
}
interface Object_ConstructProps extends GObject.InitiallyUnowned_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Object */
    name?: string
    /**
     * The parent of the object. Please note, that when changing the 'parent'
     * property, we don't emit #GObject::notify and #GstObject::deep-notify
     * signals due to locking issues. In some cases one can use
     * #GstBin::element-added or #GstBin::element-removed signals on the parent to
     * achieve a similar effect.
     */
    parent?: Object
}
class Object {
    /* Properties of Gst-1.0.Gst.Object */
    name: string
    /**
     * The parent of the object. Please note, that when changing the 'parent'
     * property, we don't emit #GObject::notify and #GstObject::deep-notify
     * signals due to locking issues. In some cases one can use
     * #GstBin::element-added or #GstBin::element-removed signals on the parent to
     * achieve a similar effect.
     */
    parent: Object
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Object, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Object, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Object_ConstructProps)
    _init (config?: Object_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Checks to see if there is any object named `name` in `list`. This function
     * does not do any locking of any kind. You might want to protect the
     * provided list with the lock of the owner of the list. This function
     * will lock each #GstObject in the list to compare the name, so be
     * careful when passing a list with a locked object.
     * @param list a list of #GstObject to      check through
     * @param name the name to search for
     */
    static check_uniqueness(list: Object[], name: string): boolean
    /**
     * A default deep_notify signal callback for an object. The user data
     * should contain a pointer to an array of strings that should be excluded
     * from the notify. The default handler will print the new value of the property
     * using g_print.
     * 
     * MT safe. This function grabs and releases `object'`s LOCK for getting its
     *          path string.
     * @param object the #GObject that signalled the notify.
     * @param orig a #GstObject that initiated the notify.
     * @param pspec a #GParamSpec of the property.
     * @param excluded_props      a set of user-specified properties to exclude or %NULL to show     all changes.
     */
    static default_deep_notify(object: GObject.Object, orig: Object, pspec: GObject.ParamSpec, excluded_props?: string[] | null): void
    /**
     * Atomically modifies a pointer to point to a new object.
     * The reference count of `oldobj` is decreased and the reference count of
     * `newobj` is increased.
     * 
     * Either `newobj` and the value pointed to by `oldobj` may be %NULL.
     * @param oldobj pointer to a place of     a #GstObject to replace
     * @param newobj a new #GstObject
     */
    static replace(oldobj?: Object | null, newobj?: Object | null): [ /* returnType */ boolean, /* oldobj */ Object | null ]
    static $gtype: GObject.Type
}
interface Pad_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Pad */
    direction?: PadDirection
    /**
     * The offset that will be applied to the running time of the pad.
     */
    offset?: number
    template?: PadTemplate
}
class Pad {
    /* Properties of Gst-1.0.Gst.Pad */
    readonly caps: Caps
    readonly direction: PadDirection
    /**
     * The offset that will be applied to the running time of the pad.
     */
    offset: number
    template: PadTemplate
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Pad */
    /**
     * Activates or deactivates the given pad in `mode` via dispatching to the
     * pad's activatemodefunc. For use from within pad activation functions only.
     * 
     * If you don't know what this is, you probably don't want to call it.
     * @param mode the requested activation mode
     * @param active whether or not the pad should be active.
     */
    activate_mode(mode: PadMode, active: boolean): boolean
    /**
     * Be notified of different states of pads. The provided callback is called for
     * every state that matches `mask`.
     * 
     * Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
     * called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only
     * exception here are GST_PAD_PROBE_TYPE_IDLE probes that are called
     * immediately if the pad is already idle while calling gst_pad_add_probe().
     * In each of the groups, probes are called in the order in which they were
     * added.
     * @param mask the probe mask
     * @param callback #GstPadProbeCallback that will be called with notifications of           the pad state
     */
    add_probe(mask: PadProbeType, callback: PadProbeCallback): number
    /**
     * Checks if the source pad and the sink pad are compatible so they can be
     * linked.
     * @param sinkpad the sink #GstPad.
     */
    can_link(sinkpad: Pad): boolean
    /**
     * Chain a buffer to `pad`.
     * 
     * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
     * 
     * If the buffer type is not acceptable for `pad` (as negotiated with a
     * preceding GST_EVENT_CAPS event), this function returns
     * #GST_FLOW_NOT_NEGOTIATED.
     * 
     * The function proceeds calling the chain function installed on `pad` (see
     * gst_pad_set_chain_function()) and the return value of that function is
     * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
     * chain function.
     * 
     * In all cases, success or failure, the caller loses its reference to `buffer`
     * after calling this function.
     * @param buffer the #GstBuffer to send, return GST_FLOW_ERROR     if not.
     */
    chain(buffer: Buffer): FlowReturn
    /**
     * Chain a bufferlist to `pad`.
     * 
     * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
     * 
     * If `pad` was not negotiated properly with a CAPS event, this function
     * returns #GST_FLOW_NOT_NEGOTIATED.
     * 
     * The function proceeds calling the chainlist function installed on `pad` (see
     * gst_pad_set_chain_list_function()) and the return value of that function is
     * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
     * chainlist function.
     * 
     * In all cases, success or failure, the caller loses its reference to `list`
     * after calling this function.
     * 
     * MT safe.
     * @param list the #GstBufferList to send, return GST_FLOW_ERROR     if not.
     */
    chain_list(list: BufferList): FlowReturn
    /**
     * Check and clear the #GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return %TRUE
     * if the flag was set.
     */
    check_reconfigure(): boolean
    /**
     * Creates a stream-id for the source #GstPad `pad` by combining the
     * upstream information with the optional `stream_id` of the stream
     * of `pad`. `pad` must have a parent #GstElement and which must have zero
     * or one sinkpad. `stream_id` can only be %NULL if the parent element
     * of `pad` has only a single source pad.
     * 
     * This function generates an unique stream-id by getting the upstream
     * stream-start event stream ID and appending `stream_id` to it. If the
     * element has no sinkpad it will generate an upstream stream-id by
     * doing an URI query on the element and in the worst case just uses
     * a random number. Source elements that don't implement the URI
     * handler interface should ideally generate a unique, deterministic
     * stream-id manually instead.
     * 
     * Since stream IDs are sorted alphabetically, any numbers in the
     * stream ID should be printed with a fixed number of characters,
     * preceded by 0's, such as by using the format \%03u instead of \%u.
     * @param parent Parent #GstElement of `pad`
     * @param stream_id The stream-id
     */
    create_stream_id(parent: Element, stream_id?: string | null): string
    /**
     * Invokes the default event handler for the given pad.
     * 
     * The EOS event will pause the task associated with `pad` before it is forwarded
     * to all internally linked pads,
     * 
     * The event is sent to all pads internally linked to `pad`. This function
     * takes ownership of `event`.
     * @param parent the parent of `pad` or %NULL
     * @param event the #GstEvent to handle.
     */
    event_default(parent: Object | null, event: Event): boolean
    /**
     * Calls `forward` for all internally linked pads of `pad`. This function deals with
     * dynamically changing internal pads and will make sure that the `forward`
     * function is only called once for each pad.
     * 
     * When `forward` returns %TRUE, no further pads will be processed.
     * @param forward a #GstPadForwardFunction
     */
    forward(forward: PadForwardFunction): boolean
    /**
     * Gets the capabilities of the allowed media types that can flow through
     * `pad` and its peer.
     * 
     * The allowed capabilities is calculated as the intersection of the results of
     * calling gst_pad_query_caps() on `pad` and its peer. The caller owns a reference
     * on the resulting caps.
     */
    get_allowed_caps(): Caps | null
    /**
     * Gets the capabilities currently configured on `pad` with the last
     * #GST_EVENT_CAPS event.
     */
    get_current_caps(): Caps | null
    /**
     * Gets the direction of the pad. The direction of the pad is
     * decided at construction time so this function does not take
     * the LOCK.
     */
    get_direction(): PadDirection
    /**
     * Gets the private data of a pad.
     * No locking is performed in this function.
     */
    get_element_private(): object | null
    /**
     * Gets the #GstFlowReturn return from the last data passed by this pad.
     */
    get_last_flow_return(): FlowReturn
    /**
     * Get the offset applied to the running time of `pad`. `pad` has to be a source
     * pad.
     */
    get_offset(): number
    /**
     * Gets the template for `pad`.
     */
    get_pad_template(): PadTemplate | null
    /**
     * Gets the capabilities for `pad'`s template.
     */
    get_pad_template_caps(): Caps
    /**
     * Gets the parent of `pad,` cast to a #GstElement. If a `pad` has no parent or
     * its parent is not an element, return %NULL.
     */
    get_parent_element(): Element | null
    /**
     * Gets the peer of `pad`. This function refs the peer pad so
     * you need to unref it after use.
     */
    get_peer(): Pad | null
    /**
     * When `pad` is flushing this function returns #GST_FLOW_FLUSHING
     * immediately and `buffer` is %NULL.
     * 
     * Calls the getrange function of `pad,` see #GstPadGetRangeFunction for a
     * description of a getrange function. If `pad` has no getrange function
     * installed (see gst_pad_set_getrange_function()) this function returns
     * #GST_FLOW_NOT_SUPPORTED.
     * 
     * If `buffer` points to a variable holding %NULL, a valid new #GstBuffer will be
     * placed in `buffer` when this function returns #GST_FLOW_OK. The new buffer
     * must be freed with gst_buffer_unref() after usage.
     * 
     * When `buffer` points to a variable that points to a valid #GstBuffer, the
     * buffer will be filled with the result data when this function returns
     * #GST_FLOW_OK. If the provided buffer is larger than `size,` only
     * `size` bytes will be filled in the result buffer and its size will be updated
     * accordingly.
     * 
     * Note that less than `size` bytes can be returned in `buffer` when, for example,
     * an EOS condition is near or when `buffer` is not large enough to hold `size`
     * bytes. The caller should check the result buffer size to get the result size.
     * 
     * When this function returns any other result value than #GST_FLOW_OK, `buffer`
     * will be unchanged.
     * 
     * This is a lowlevel function. Usually gst_pad_pull_range() is used.
     * @param offset The start offset of the buffer
     * @param size The length of the buffer
     */
    get_range(offset: number, size: number): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * If there is a single internal link of the given pad, this function will
     * return it. Otherwise, it will return NULL.
     */
    get_single_internal_link(): Pad | null
    /**
     * Returns a new reference of the sticky event of type `event_type`
     * from the event.
     * @param event_type the #GstEventType that should be retrieved.
     * @param idx the index of the event
     */
    get_sticky_event(event_type: EventType, idx: number): Event | null
    /**
     * Returns the current #GstStream for the `pad,` or %NULL if none has been
     * set yet, i.e. the pad has not received a stream-start event yet.
     * 
     * This is a convenience wrapper around gst_pad_get_sticky_event() and
     * gst_event_parse_stream().
     */
    get_stream(): Stream | null
    /**
     * Returns the current stream-id for the `pad,` or %NULL if none has been
     * set yet, i.e. the pad has not received a stream-start event yet.
     * 
     * This is a convenience wrapper around gst_pad_get_sticky_event() and
     * gst_event_parse_stream_start().
     * 
     * The returned stream-id string should be treated as an opaque string, its
     * contents should not be interpreted.
     */
    get_stream_id(): string | null
    /**
     * Get `pad` task state. If no task is currently
     * set, #GST_TASK_STOPPED is returned.
     */
    get_task_state(): TaskState
    /**
     * Check if `pad` has caps set on it with a #GST_EVENT_CAPS event.
     */
    has_current_caps(): boolean
    /**
     * Query if a pad is active
     */
    is_active(): boolean
    /**
     * Checks if the pad is blocked or not. This function returns the
     * last requested state of the pad. It is not certain that the pad
     * is actually blocking at this point (see gst_pad_is_blocking()).
     */
    is_blocked(): boolean
    /**
     * Checks if the pad is blocking or not. This is a guaranteed state
     * of whether the pad is actually blocking on a #GstBuffer or a #GstEvent.
     */
    is_blocking(): boolean
    /**
     * Checks if a `pad` is linked to another pad or not.
     */
    is_linked(): boolean
    /**
     * Gets an iterator for the pads to which the given pad is linked to inside
     * of the parent element.
     * 
     * Each #GstPad element yielded by the iterator will have its refcount increased,
     * so unref after use.
     * 
     * Free-function: gst_iterator_free
     */
    iterate_internal_links(): Iterator | null
    /**
     * Iterate the list of pads to which the given pad is linked to inside of
     * the parent element.
     * This is the default handler, and thus returns an iterator of all of the
     * pads inside the parent element with opposite direction.
     * 
     * The caller must free this iterator after use with gst_iterator_free().
     * @param parent the parent of `pad` or %NULL
     */
    iterate_internal_links_default(parent?: Object | null): Iterator | null
    /**
     * Links the source pad and the sink pad.
     * @param sinkpad the sink #GstPad to link.
     */
    link(sinkpad: Pad): PadLinkReturn
    /**
     * Links the source pad and the sink pad.
     * 
     * This variant of #gst_pad_link provides a more granular control on the
     * checks being done when linking. While providing some considerable speedups
     * the caller of this method must be aware that wrong usage of those flags
     * can cause severe issues. Refer to the documentation of #GstPadLinkCheck
     * for more information.
     * 
     * MT Safe.
     * @param sinkpad the sink #GstPad to link.
     * @param flags the checks to validate when linking
     */
    link_full(sinkpad: Pad, flags: PadLinkCheck): PadLinkReturn
    /**
     * Links `src` to `sink,` creating any #GstGhostPad's in between as necessary.
     * 
     * This is a convenience function to save having to create and add intermediate
     * #GstGhostPad's as required for linking across #GstBin boundaries.
     * 
     * If `src` or `sink` pads don't have parent elements or do not share a common
     * ancestor, the link will fail.
     * @param sink a #GstPad
     */
    link_maybe_ghosting(sink: Pad): boolean
    /**
     * Links `src` to `sink,` creating any #GstGhostPad's in between as necessary.
     * 
     * This is a convenience function to save having to create and add intermediate
     * #GstGhostPad's as required for linking across #GstBin boundaries.
     * 
     * If `src` or `sink` pads don't have parent elements or do not share a common
     * ancestor, the link will fail.
     * 
     * Calling gst_pad_link_maybe_ghosting_full() with
     * `flags` == %GST_PAD_LINK_CHECK_DEFAULT is the recommended way of linking
     * pads with safety checks applied.
     * @param sink a #GstPad
     * @param flags some #GstPadLinkCheck flags
     */
    link_maybe_ghosting_full(sink: Pad, flags: PadLinkCheck): boolean
    /**
     * Mark a pad for needing reconfiguration. The next call to
     * gst_pad_check_reconfigure() will return %TRUE after this call.
     */
    mark_reconfigure(): void
    /**
     * Check the #GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return %TRUE
     * if the flag was set.
     */
    needs_reconfigure(): boolean
    /**
     * Pause the task of `pad`. This function will also wait until the
     * function executed by the task is finished if this function is not
     * called from the task function.
     */
    pause_task(): boolean
    /**
     * Performs gst_pad_query() on the peer of `pad`.
     * 
     * The caller is responsible for both the allocation and deallocation of
     * the query structure.
     * @param query the #GstQuery to perform.
     */
    peer_query(query: Query): boolean
    /**
     * Check if the peer of `pad` accepts `caps`. If `pad` has no peer, this function
     * returns %TRUE.
     * @param caps a #GstCaps to check on the pad
     */
    peer_query_accept_caps(caps: Caps): boolean
    /**
     * Gets the capabilities of the peer connected to this pad. Similar to
     * gst_pad_query_caps().
     * 
     * When called on srcpads `filter` contains the caps that
     * upstream could produce in the order preferred by upstream. When
     * called on sinkpads `filter` contains the caps accepted by
     * downstream in the preferred order. `filter` might be %NULL but
     * if it is not %NULL the returned caps will be a subset of `filter`.
     * @param filter a #GstCaps filter, or %NULL.
     */
    peer_query_caps(filter?: Caps | null): Caps
    /**
     * Queries the peer pad of a given sink pad to convert `src_val` in `src_format`
     * to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    peer_query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries the peer pad of a given sink pad for the total stream duration.
     * @param format the #GstFormat requested
     */
    peer_query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries the peer of a given sink pad for the stream position.
     * @param format the #GstFormat requested
     */
    peer_query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Checks if all internally linked pads of `pad` accepts the caps in `query` and
     * returns the intersection of the results.
     * 
     * This function is useful as a default accept caps query function for an element
     * that can handle any stream format, but requires caps that are acceptable for
     * all opposite pads.
     * @param query an ACCEPT_CAPS #GstQuery.
     */
    proxy_query_accept_caps(query: Query): boolean
    /**
     * Calls gst_pad_query_caps() for all internally linked pads of `pad` and returns
     * the intersection of the results.
     * 
     * This function is useful as a default caps query function for an element
     * that can handle any stream format, but requires all its pads to have
     * the same caps.  Two such elements are tee and adder.
     * @param query a CAPS #GstQuery.
     */
    proxy_query_caps(query: Query): boolean
    /**
     * Pulls a `buffer` from the peer pad or fills up a provided buffer.
     * 
     * This function will first trigger the pad block signal if it was
     * installed.
     * 
     * When `pad` is not linked #GST_FLOW_NOT_LINKED is returned else this
     * function returns the result of gst_pad_get_range() on the peer pad.
     * See gst_pad_get_range() for a list of return values and for the
     * semantics of the arguments of this function.
     * 
     * If `buffer` points to a variable holding %NULL, a valid new #GstBuffer will be
     * placed in `buffer` when this function returns #GST_FLOW_OK. The new buffer
     * must be freed with gst_buffer_unref() after usage. When this function
     * returns any other result value, `buffer` will still point to %NULL.
     * 
     * When `buffer` points to a variable that points to a valid #GstBuffer, the
     * buffer will be filled with the result data when this function returns
     * #GST_FLOW_OK. When this function returns any other result value,
     * `buffer` will be unchanged. If the provided buffer is larger than `size,` only
     * `size` bytes will be filled in the result buffer and its size will be updated
     * accordingly.
     * 
     * Note that less than `size` bytes can be returned in `buffer` when, for example,
     * an EOS condition is near or when `buffer` is not large enough to hold `size`
     * bytes. The caller should check the result buffer size to get the result size.
     * @param offset The start offset of the buffer
     * @param size The length of the buffer
     */
    pull_range(offset: number, size: number): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * Pushes a buffer to the peer of `pad`.
     * 
     * This function will call installed block probes before triggering any
     * installed data probes.
     * 
     * The function proceeds calling gst_pad_chain() on the peer pad and returns
     * the value from that function. If `pad` has no peer, #GST_FLOW_NOT_LINKED will
     * be returned.
     * 
     * In all cases, success or failure, the caller loses its reference to `buffer`
     * after calling this function.
     * @param buffer the #GstBuffer to push returns GST_FLOW_ERROR     if not.
     */
    push(buffer: Buffer): FlowReturn
    /**
     * Sends the event to the peer of the given pad. This function is
     * mainly used by elements to send events to their peer
     * elements.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * @param event the #GstEvent to send to the pad.
     */
    push_event(event: Event): boolean
    /**
     * Pushes a buffer list to the peer of `pad`.
     * 
     * This function will call installed block probes before triggering any
     * installed data probes.
     * 
     * The function proceeds calling the chain function on the peer pad and returns
     * the value from that function. If `pad` has no peer, #GST_FLOW_NOT_LINKED will
     * be returned. If the peer pad does not have any installed chainlist function
     * every group buffer of the list will be merged into a normal #GstBuffer and
     * chained via gst_pad_chain().
     * 
     * In all cases, success or failure, the caller loses its reference to `list`
     * after calling this function.
     * @param list the #GstBufferList to push returns GST_FLOW_ERROR     if not.
     */
    push_list(list: BufferList): FlowReturn
    /**
     * Dispatches a query to a pad. The query should have been allocated by the
     * caller via one of the type-specific allocation functions. The element that
     * the pad belongs to is responsible for filling the query with an appropriate
     * response, which should then be parsed with a type-specific query parsing
     * function.
     * 
     * Again, the caller is responsible for both the allocation and deallocation of
     * the query structure.
     * 
     * Please also note that some queries might need a running pipeline to work.
     * @param query the #GstQuery to perform.
     */
    query(query: Query): boolean
    /**
     * Check if the given pad accepts the caps.
     * @param caps a #GstCaps to check on the pad
     */
    query_accept_caps(caps: Caps): boolean
    /**
     * Gets the capabilities this pad can produce or consume.
     * Note that this method doesn't necessarily return the caps set by sending a
     * gst_event_new_caps() - use gst_pad_get_current_caps() for that instead.
     * gst_pad_query_caps returns all possible caps a pad can operate with, using
     * the pad's CAPS query function, If the query fails, this function will return
     * `filter,` if not %NULL, otherwise ANY.
     * 
     * When called on sinkpads `filter` contains the caps that
     * upstream could produce in the order preferred by upstream. When
     * called on srcpads `filter` contains the caps accepted by
     * downstream in the preferred order. `filter` might be %NULL but
     * if it is not %NULL the returned caps will be a subset of `filter`.
     * 
     * Note that this function does not return writable #GstCaps, use
     * gst_caps_make_writable() before modifying the caps.
     * @param filter suggested #GstCaps, or %NULL
     */
    query_caps(filter?: Caps | null): Caps
    /**
     * Queries a pad to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Invokes the default query handler for the given pad.
     * The query is sent to all pads internally linked to `pad`. Note that
     * if there are many possible sink pads that are internally linked to
     * `pad,` only one will be sent the query.
     * Multi-sinkpad elements should implement custom query handlers.
     * @param parent the parent of `pad` or %NULL
     * @param query the #GstQuery to handle.
     */
    query_default(parent: Object | null, query: Query): boolean
    /**
     * Queries a pad for the total stream duration.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries a pad for the stream position.
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Remove the probe with `id` from `pad`.
     * 
     * MT safe.
     * @param id the probe id to remove
     */
    remove_probe(id: number): void
    /**
     * Sends the event to the pad. This function can be used
     * by applications to send events in the pipeline.
     * 
     * If `pad` is a source pad, `event` should be an upstream event. If `pad` is a
     * sink pad, `event` should be a downstream event. For example, you would not
     * send a #GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
     * Furthermore, some downstream events have to be serialized with data flow,
     * like EOS, while some can travel out-of-band, like #GST_EVENT_FLUSH_START. If
     * the event needs to be serialized with data flow, this function will take the
     * pad's stream lock while calling its event function.
     * 
     * To find out whether an event type is upstream, downstream, or downstream and
     * serialized, see #GstEventTypeFlags, gst_event_type_get_flags(),
     * #GST_EVENT_IS_UPSTREAM, #GST_EVENT_IS_DOWNSTREAM, and
     * #GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
     * plugin doesn't need to bother itself with this information; the core handles
     * all necessary locks and checks.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * @param event the #GstEvent to send to the pad.
     */
    send_event(event: Event): boolean
    /**
     * Sets the given activate function for `pad`. The activate function will
     * dispatch to gst_pad_activate_mode() to perform the actual activation.
     * Only makes sense to set on sink pads.
     * 
     * Call this function if your sink pad can start a pull-based task.
     * @param activate the #GstPadActivateFunction to set.
     */
    set_activate_function_full(activate: PadActivateFunction): void
    /**
     * Sets the given activate_mode function for the pad. An activate_mode function
     * prepares the element for data passing.
     * @param activatemode the #GstPadActivateModeFunction to set.
     */
    set_activatemode_function_full(activatemode: PadActivateModeFunction): void
    /**
     * Activates or deactivates the given pad.
     * Normally called from within core state change functions.
     * 
     * If `active,` makes sure the pad is active. If it is already active, either in
     * push or pull mode, just return. Otherwise dispatches to the pad's activate
     * function to perform the actual activation.
     * 
     * If not `active,` calls gst_pad_activate_mode() with the pad's current mode
     * and a %FALSE argument.
     * @param active whether or not the pad should be active.
     */
    set_active(active: boolean): boolean
    /**
     * Sets the given chain function for the pad. The chain function is called to
     * process a #GstBuffer input buffer. see #GstPadChainFunction for more details.
     * @param chain the #GstPadChainFunction to set.
     */
    set_chain_function_full(chain: PadChainFunction): void
    /**
     * Sets the given chain list function for the pad. The chainlist function is
     * called to process a #GstBufferList input buffer list. See
     * #GstPadChainListFunction for more details.
     * @param chainlist the #GstPadChainListFunction to set.
     */
    set_chain_list_function_full(chainlist: PadChainListFunction): void
    /**
     * Set the given private data gpointer on the pad.
     * This function can only be used by the element that owns the pad.
     * No locking is performed in this function.
     * @param priv The private data to attach to the pad.
     */
    set_element_private(priv?: object | null): void
    /**
     * Sets the given event handler for the pad.
     * @param event the #GstPadEventFullFunction to set.
     */
    set_event_full_function_full(event: PadEventFullFunction): void
    /**
     * Sets the given event handler for the pad.
     * @param event the #GstPadEventFunction to set.
     */
    set_event_function_full(event: PadEventFunction): void
    /**
     * Sets the given getrange function for the pad. The getrange function is
     * called to produce a new #GstBuffer to start the processing pipeline. see
     * #GstPadGetRangeFunction for a description of the getrange function.
     * @param get the #GstPadGetRangeFunction to set.
     */
    set_getrange_function_full(get: PadGetRangeFunction): void
    /**
     * Sets the given internal link iterator function for the pad.
     * @param iterintlink the #GstPadIterIntLinkFunction to set.
     */
    set_iterate_internal_links_function_full(iterintlink: PadIterIntLinkFunction): void
    /**
     * Sets the given link function for the pad. It will be called when
     * the pad is linked with another pad.
     * 
     * The return value #GST_PAD_LINK_OK should be used when the connection can be
     * made.
     * 
     * The return value #GST_PAD_LINK_REFUSED should be used when the connection
     * cannot be made for some reason.
     * 
     * If `link` is installed on a source pad, it should call the #GstPadLinkFunction
     * of the peer sink pad, if present.
     * @param link the #GstPadLinkFunction to set.
     */
    set_link_function_full(link: PadLinkFunction): void
    /**
     * Set the offset that will be applied to the running time of `pad`.
     * @param offset the offset
     */
    set_offset(offset: number): void
    /**
     * Set the given query function for the pad.
     * @param query the #GstPadQueryFunction to set.
     */
    set_query_function_full(query: PadQueryFunction): void
    /**
     * Sets the given unlink function for the pad. It will be called
     * when the pad is unlinked.
     * 
     * Note that the pad's lock is already held when the unlink
     * function is called, so most pad functions cannot be called
     * from within the callback.
     * @param unlink the #GstPadUnlinkFunction to set.
     */
    set_unlink_function_full(unlink: PadUnlinkFunction): void
    /**
     * Starts a task that repeatedly calls `func` with `user_data`. This function
     * is mostly used in pad activation functions to start the dataflow.
     * The #GST_PAD_STREAM_LOCK of `pad` will automatically be acquired
     * before `func` is called.
     * @param func the task function to call
     */
    start_task(func: TaskFunction): boolean
    /**
     * Iterates all sticky events on `pad` and calls `foreach_func` for every
     * event. If `foreach_func` returns %FALSE the iteration is immediately stopped.
     * @param foreach_func the #GstPadStickyEventsForeachFunction that                should be called for every event.
     */
    sticky_events_foreach(foreach_func: PadStickyEventsForeachFunction): void
    /**
     * Stop the task of `pad`. This function will also make sure that the
     * function executed by the task will effectively stop if not called
     * from the GstTaskFunction.
     * 
     * This function will deadlock if called from the GstTaskFunction of
     * the task. Use gst_task_pause() instead.
     * 
     * Regardless of whether the pad has a task, the stream lock is acquired and
     * released so as to ensure that streaming through this pad has finished.
     */
    stop_task(): boolean
    /**
     * Store the sticky `event` on `pad`
     * @param event a #GstEvent
     */
    store_sticky_event(event: Event): FlowReturn
    /**
     * Unlinks the source pad from the sink pad. Will emit the #GstPad::unlinked
     * signal on both pads.
     * @param sinkpad the sink #GstPad to unlink.
     */
    unlink(sinkpad: Pad): boolean
    /**
     * A helper function you can use that sets the FIXED_CAPS flag
     * This way the default CAPS query will always return the negotiated caps
     * or in case the pad is not negotiated, the padtemplate caps.
     * 
     * The negotiated caps are the caps of the last CAPS event that passed on the
     * pad. Use this function on a pad that, once it negotiated to a CAPS, cannot
     * be renegotiated to something else.
     */
    use_fixed_caps(): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Pad */
    vfunc_linked(peer: Pad): void
    vfunc_unlinked(peer: Pad): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Pad */
    /**
     * Signals that a pad has been linked to the peer pad.
     * @param peer the peer pad that has been connected
     */
    connect(sigName: "linked", callback: (($obj: Pad, peer: Pad) => void)): number
    connect_after(sigName: "linked", callback: (($obj: Pad, peer: Pad) => void)): number
    emit(sigName: "linked", peer: Pad): void
    /**
     * Signals that a pad has been unlinked from the peer pad.
     * @param peer the peer pad that has been disconnected
     */
    connect(sigName: "unlinked", callback: (($obj: Pad, peer: Pad) => void)): number
    connect_after(sigName: "unlinked", callback: (($obj: Pad, peer: Pad) => void)): number
    emit(sigName: "unlinked", peer: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Pad, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Pad, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::caps", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caps", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::direction", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::offset", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offset", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::template", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::template", callback: (($obj: Pad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Pad_ConstructProps)
    _init (config?: Pad_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name: string | null, direction: PadDirection): Pad
    static new_from_static_template(templ: StaticPadTemplate, name: string): Pad
    static new_from_template(templ: PadTemplate, name?: string | null): Pad
    /**
     * Gets a string representing the given pad-link return.
     * @param ret a #GstPadLinkReturn to get the name of.
     */
    static link_get_name(ret: PadLinkReturn): string
    static $gtype: GObject.Type
}
interface PadTemplate_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.PadTemplate */
    /**
     * The capabilities of the pad described by the pad template.
     */
    caps?: Caps
    /**
     * The direction of the pad described by the pad template.
     */
    direction?: PadDirection
    /**
     * The type of the pad described by the pad template.
     */
    gtype?: GObject.Type
    /**
     * The name template of the pad template.
     */
    name_template?: string
    /**
     * When the pad described by the pad template will become available.
     */
    presence?: PadPresence
}
class PadTemplate {
    /* Properties of Gst-1.0.Gst.PadTemplate */
    /**
     * The capabilities of the pad described by the pad template.
     */
    readonly caps: Caps
    /**
     * The direction of the pad described by the pad template.
     */
    readonly direction: PadDirection
    /**
     * The type of the pad described by the pad template.
     */
    readonly gtype: GObject.Type
    /**
     * The name template of the pad template.
     */
    readonly name_template: string
    /**
     * When the pad described by the pad template will become available.
     */
    readonly presence: PadPresence
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.PadTemplate */
    /**
     * Gets the capabilities of the pad template.
     */
    get_caps(): Caps
    /**
     * See gst_pad_template_set_documentation_caps().
     */
    get_documentation_caps(): Caps
    /**
     * Emit the pad-created signal for this template when created by this pad.
     * @param pad the #GstPad that created it
     */
    pad_created(pad: Pad): void
    /**
     * Certain elements will dynamically construct the caps of their
     * pad templates. In order not to let environment-specific information
     * into the documentation, element authors should use this method to
     * expose "stable" caps to the reader.
     * @param caps the documented capabilities
     */
    set_documentation_caps(caps: Caps): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.PadTemplate */
    /**
     * Emit the pad-created signal for this template when created by this pad.
     * @param pad the #GstPad that created it
     */
    vfunc_pad_created(pad: Pad): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.PadTemplate */
    /**
     * This signal is fired when an element creates a pad from this template.
     * @param pad the pad that was created.
     */
    connect(sigName: "pad-created", callback: (($obj: PadTemplate, pad: Pad) => void)): number
    connect_after(sigName: "pad-created", callback: (($obj: PadTemplate, pad: Pad) => void)): number
    emit(sigName: "pad-created", pad: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: PadTemplate, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: PadTemplate, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::caps", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caps", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::direction", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::direction", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::gtype", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::gtype", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name-template", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name-template", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::presence", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::presence", callback: (($obj: PadTemplate, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: PadTemplate_ConstructProps)
    _init (config?: PadTemplate_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name_template: string, direction: PadDirection, presence: PadPresence, caps: Caps): PadTemplate
    static new_from_static_pad_template_with_gtype(pad_template: StaticPadTemplate, pad_type: GObject.Type): PadTemplate
    static new_with_gtype(name_template: string, direction: PadDirection, presence: PadPresence, caps: Caps, pad_type: GObject.Type): PadTemplate
    static $gtype: GObject.Type
}
class ParamArray {
    /* Fields of GObject-2.0.GObject.ParamSpec */
    /**
     * private #GTypeInstance portion
     */
    g_type_instance: GObject.TypeInstance
    /**
     * name of this parameter: always an interned string
     */
    name: string
    /**
     * #GParamFlags flags for this parameter
     */
    flags: GObject.ParamFlags
    /**
     * the #GValue type for this parameter
     */
    value_type: GObject.Type
    /**
     * #GType type that uses (introduces) this parameter
     */
    owner_type: GObject.Type
    /* Methods of GObject-2.0.GObject.ParamSpec */
    /**
     * Get the short description of a #GParamSpec.
     */
    get_blurb(): string | null
    /**
     * Gets the default value of `pspec` as a pointer to a #GValue.
     * 
     * The #GValue will remain valid for the life of `pspec`.
     */
    get_default_value(): any
    /**
     * Get the name of a #GParamSpec.
     * 
     * The name is always an "interned" string (as per g_intern_string()).
     * This allows for pointer-value comparisons.
     */
    get_name(): string
    /**
     * Gets the GQuark for the name.
     */
    get_name_quark(): GLib.Quark
    /**
     * Get the nickname of a #GParamSpec.
     */
    get_nick(): string
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata().
     * @param quark a #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * If the paramspec redirects operations to another paramspec,
     * returns that paramspec. Redirect is used typically for
     * providing a new implementation of a property in a derived
     * type while preserving all the properties from the parent
     * type. Redirection is established by creating a property
     * of type #GParamSpecOverride. See g_object_class_override_property()
     * for an example of the use of this capability.
     */
    get_redirect_target(): GObject.ParamSpec | null
    /**
     * Sets an opaque, named pointer on a #GParamSpec. The name is
     * specified through a #GQuark (retrieved e.g. via
     * g_quark_from_static_string()), and the pointer can be gotten back
     * from the `pspec` with g_param_spec_get_qdata().  Setting a
     * previously set user data pointer, overrides (frees) the old pointer
     * set, using %NULL as pointer essentially removes the data stored.
     * @param quark a #GQuark, naming the user data pointer
     * @param data an opaque user data pointer
     */
    set_qdata(quark: GLib.Quark, data?: object | null): void
    /**
     * The initial reference count of a newly created #GParamSpec is 1,
     * even though no one has explicitly called g_param_spec_ref() on it
     * yet. So the initial reference count is flagged as "floating", until
     * someone calls `g_param_spec_ref (pspec); g_param_spec_sink
     * (pspec);` in sequence on it, taking over the initial
     * reference count (thus ending up with a `pspec` that has a reference
     * count of 1 still, but is not flagged "floating" anymore).
     */
    sink(): void
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata()
     * and removes the `data` from `pspec` without invoking its destroy()
     * function (if any was set).  Usually, calling this function is only
     * required to update user data pointers with a destroy notifier.
     * @param quark a #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /* Virtual methods of GObject-2.0.GObject.ParamSpec */
    vfunc_finalize(): void
    vfunc_value_set_default(value: any): void
    vfunc_value_validate(value: any): boolean
    vfunc_values_cmp(value1: any, value2: any): number
    static name: string
}
class ParamFraction {
    /* Fields of GObject-2.0.GObject.ParamSpec */
    /**
     * private #GTypeInstance portion
     */
    g_type_instance: GObject.TypeInstance
    /**
     * name of this parameter: always an interned string
     */
    name: string
    /**
     * #GParamFlags flags for this parameter
     */
    flags: GObject.ParamFlags
    /**
     * the #GValue type for this parameter
     */
    value_type: GObject.Type
    /**
     * #GType type that uses (introduces) this parameter
     */
    owner_type: GObject.Type
    /* Methods of GObject-2.0.GObject.ParamSpec */
    /**
     * Get the short description of a #GParamSpec.
     */
    get_blurb(): string | null
    /**
     * Gets the default value of `pspec` as a pointer to a #GValue.
     * 
     * The #GValue will remain valid for the life of `pspec`.
     */
    get_default_value(): any
    /**
     * Get the name of a #GParamSpec.
     * 
     * The name is always an "interned" string (as per g_intern_string()).
     * This allows for pointer-value comparisons.
     */
    get_name(): string
    /**
     * Gets the GQuark for the name.
     */
    get_name_quark(): GLib.Quark
    /**
     * Get the nickname of a #GParamSpec.
     */
    get_nick(): string
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata().
     * @param quark a #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * If the paramspec redirects operations to another paramspec,
     * returns that paramspec. Redirect is used typically for
     * providing a new implementation of a property in a derived
     * type while preserving all the properties from the parent
     * type. Redirection is established by creating a property
     * of type #GParamSpecOverride. See g_object_class_override_property()
     * for an example of the use of this capability.
     */
    get_redirect_target(): GObject.ParamSpec | null
    /**
     * Sets an opaque, named pointer on a #GParamSpec. The name is
     * specified through a #GQuark (retrieved e.g. via
     * g_quark_from_static_string()), and the pointer can be gotten back
     * from the `pspec` with g_param_spec_get_qdata().  Setting a
     * previously set user data pointer, overrides (frees) the old pointer
     * set, using %NULL as pointer essentially removes the data stored.
     * @param quark a #GQuark, naming the user data pointer
     * @param data an opaque user data pointer
     */
    set_qdata(quark: GLib.Quark, data?: object | null): void
    /**
     * The initial reference count of a newly created #GParamSpec is 1,
     * even though no one has explicitly called g_param_spec_ref() on it
     * yet. So the initial reference count is flagged as "floating", until
     * someone calls `g_param_spec_ref (pspec); g_param_spec_sink
     * (pspec);` in sequence on it, taking over the initial
     * reference count (thus ending up with a `pspec` that has a reference
     * count of 1 still, but is not flagged "floating" anymore).
     */
    sink(): void
    /**
     * Gets back user data pointers stored via g_param_spec_set_qdata()
     * and removes the `data` from `pspec` without invoking its destroy()
     * function (if any was set).  Usually, calling this function is only
     * required to update user data pointers with a destroy notifier.
     * @param quark a #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /* Virtual methods of GObject-2.0.GObject.ParamSpec */
    vfunc_finalize(): void
    vfunc_value_set_default(value: any): void
    vfunc_value_validate(value: any): boolean
    vfunc_values_cmp(value1: any, value2: any): number
    static name: string
}
interface Pipeline_ConstructProps extends Bin_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Pipeline */
    /**
     * Whether or not to automatically flush all messages on the
     * pipeline's bus when going from READY to NULL state. Please see
     * gst_pipeline_set_auto_flush_bus() for more information on this option.
     */
    auto_flush_bus?: boolean
    /**
     * The expected delay needed for elements to spin up to the
     * PLAYING state expressed in nanoseconds.
     * see gst_pipeline_set_delay() for more information on this option.
     */
    delay?: number
    /**
     * Latency to configure on the pipeline. See gst_pipeline_set_latency().
     */
    latency?: number
}
class Pipeline {
    /* Properties of Gst-1.0.Gst.Pipeline */
    /**
     * Whether or not to automatically flush all messages on the
     * pipeline's bus when going from READY to NULL state. Please see
     * gst_pipeline_set_auto_flush_bus() for more information on this option.
     */
    auto_flush_bus: boolean
    /**
     * The expected delay needed for elements to spin up to the
     * PLAYING state expressed in nanoseconds.
     * see gst_pipeline_set_delay() for more information on this option.
     */
    delay: number
    /**
     * Latency to configure on the pipeline. See gst_pipeline_set_latency().
     */
    latency: number
    /* Properties of Gst-1.0.Gst.Bin */
    /**
     * If set to %TRUE, the bin will handle asynchronous state changes.
     * This should be used only if the bin subclass is modifying the state
     * of its children on its own.
     */
    async_handling: boolean
    /**
     * Forward all children messages, even those that would normally be filtered by
     * the bin. This can be interesting when one wants to be notified of the EOS
     * state of individual elements, for example.
     * 
     * The messages are converted to an ELEMENT message with the bin as the
     * source. The structure of the message is named `GstBinForwarded` and contains
     * a field named `message` that contains the original forwarded #GstMessage.
     */
    message_forward: boolean
    /* Fields of Gst-1.0.Gst.Bin */
    element: Element
    /**
     * the number of children in this bin
     */
    numchildren: number
    /**
     * the list of children in this bin
     */
    children: Element[]
    /**
     * updated whenever `children` changes
     */
    children_cookie: number
    /**
     * internal bus for handling child messages
     */
    child_bus: Bus
    /**
     * queued and cached messages
     */
    messages: Message[]
    /**
     * the bin is currently calculating its state
     */
    polling: boolean
    /**
     * the bin needs to recalculate its state (deprecated)
     */
    state_dirty: boolean
    /**
     * the bin needs to select a new clock
     */
    clock_dirty: boolean
    /**
     * the last clock selected
     */
    provided_clock: Clock
    /**
     * the element that provided `provided_clock`
     */
    clock_provider: Element
    /* Fields of Gst-1.0.Gst.Element */
    object: Object
    /**
     * Used to serialize execution of gst_element_set_state()
     */
    state_lock: GLib.RecMutex
    /**
     * Used to signal completion of a state change
     */
    state_cond: GLib.Cond
    /**
     * Used to detect concurrent execution of
     * gst_element_set_state() and gst_element_get_state()
     */
    state_cookie: number
    /**
     * the target state of an element as set by the application
     */
    target_state: State
    /**
     * the current state of an element
     */
    current_state: State
    /**
     * the next state of an element, can be #GST_STATE_VOID_PENDING if
     * the element is in the correct state.
     */
    next_state: State
    /**
     * the final state the element should go to, can be
     * #GST_STATE_VOID_PENDING if the element is in the correct state
     */
    pending_state: State
    /**
     * the last return value of an element state change
     */
    last_return: StateChangeReturn
    /**
     * the bus of the element. This bus is provided to the element by the
     * parent element or the application. A #GstPipeline has a bus of its own.
     */
    bus: Bus
    /**
     * the clock of the element. This clock is usually provided to the
     * element by the toplevel #GstPipeline.
     */
    clock: Clock
    /**
     * the time of the clock right before the element is set to
     * PLAYING. Subtracting `base_time` from the current clock time in the PLAYING
     * state will yield the running_time against the clock.
     */
    base_time: ClockTimeDiff
    /**
     * the running_time of the last PAUSED state
     */
    start_time: ClockTime
    /**
     * number of pads of the element, includes both source and sink pads.
     */
    numpads: number
    /**
     * list of pads
     */
    pads: Pad[]
    /**
     * number of source pads of the element.
     */
    numsrcpads: number
    /**
     * list of source pads
     */
    srcpads: Pad[]
    /**
     * number of sink pads of the element.
     */
    numsinkpads: number
    /**
     * list of sink pads
     */
    sinkpads: Pad[]
    /**
     * updated whenever the a pad is added or removed
     */
    pads_cookie: number
    /**
     * list of contexts
     */
    contexts: Context[]
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Pipeline */
    /**
     * Let `pipeline` select a clock automatically. This is the default
     * behaviour.
     * 
     * Use this function if you previous forced a fixed clock with
     * gst_pipeline_use_clock() and want to restore the default
     * pipeline clock selection algorithm.
     * 
     * MT safe.
     */
    auto_clock(): void
    /**
     * Check if `pipeline` will automatically flush messages when going to
     * the NULL state.
     */
    get_auto_flush_bus(): boolean
    /**
     * Gets the #GstBus of `pipeline`. The bus allows applications to receive
     * #GstMessage packets.
     */
    get_bus(): Bus
    /**
     * Get the configured delay (see gst_pipeline_set_delay()).
     */
    get_delay(): ClockTime
    /**
     * Gets the latency that should be configured on the pipeline. See
     * gst_pipeline_set_latency().
     */
    get_latency(): ClockTime
    /**
     * Gets the current clock used by `pipeline`.
     * 
     * Unlike gst_element_get_clock(), this function will always return a
     * clock, even if the pipeline is not in the PLAYING state.
     */
    get_pipeline_clock(): Clock
    /**
     * Usually, when a pipeline goes from READY to NULL state, it automatically
     * flushes all pending messages on the bus, which is done for refcounting
     * purposes, to break circular references.
     * 
     * This means that applications that update state using (async) bus messages
     * (e.g. do certain things when a pipeline goes from PAUSED to READY) might
     * not get to see messages when the pipeline is shut down, because they might
     * be flushed before they can be dispatched in the main thread. This behaviour
     * can be disabled using this function.
     * 
     * It is important that all messages on the bus are handled when the
     * automatic flushing is disabled else memory leaks will be introduced.
     * 
     * MT safe.
     * @param auto_flush whether or not to automatically flush the bus when the pipeline goes from READY to NULL state
     */
    set_auto_flush_bus(auto_flush: boolean): void
    /**
     * Set the expected delay needed for all elements to perform the
     * PAUSED to PLAYING state change. `delay` will be added to the
     * base time of the elements so that they wait an additional `delay`
     * amount of time before starting to process buffers and cannot be
     * #GST_CLOCK_TIME_NONE.
     * 
     * This option is used for tuning purposes and should normally not be
     * used.
     * 
     * MT safe.
     * @param delay the delay
     */
    set_delay(delay: ClockTime): void
    /**
     * Sets the latency that should be configured on the pipeline. Setting
     * GST_CLOCK_TIME_NONE will restore the default behaviour of using the minimum
     * latency from the LATENCY query. Setting this is usually not required and
     * the pipeline will figure out an appropriate latency automatically.
     * 
     * Setting a too low latency, especially lower than the minimum latency from
     * the LATENCY query, will most likely cause the pipeline to fail.
     * @param latency latency to configure
     */
    set_latency(latency: ClockTime): void
    /**
     * Force `pipeline` to use the given `clock`. The pipeline will
     * always use the given clock even if new clock providers are added
     * to this pipeline.
     * 
     * If `clock` is %NULL all clocking will be disabled which will make
     * the pipeline run as fast as possible.
     * 
     * MT safe.
     * @param clock the clock to use
     */
    use_clock(clock?: Clock | null): void
    /* Methods of Gst-1.0.Gst.Bin */
    /**
     * Adds the given element to the bin.  Sets the element's parent, and thus
     * takes ownership of the element. An element can only be added to one bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is added to the bin.
     * 
     * > When you add an element to an already-running pipeline, you will have to
     * > take care to set the state of the newly-added element to the desired
     * > state (usually PLAYING or PAUSED, same you set the pipeline to originally)
     * > with gst_element_set_state(), or use gst_element_sync_state_with_parent().
     * > The bin or pipeline will not take care of this for you.
     * @param element the #GstElement to add
     */
    add(element: Element): boolean
    /**
     * Recursively looks for elements with an unlinked pad of the given
     * direction within the specified bin and returns an unlinked pad
     * if one is found, or %NULL otherwise. If a pad is found, the caller
     * owns a reference to it and should use gst_object_unref() on the
     * pad when it is not needed any longer.
     * @param direction whether to look for an unlinked source or sink pad
     */
    find_unlinked_pad(direction: PadDirection): Pad | null
    /**
     * Looks for an element inside the bin that implements the given
     * interface. If such an element is found, it returns the element.
     * You can cast this element to the given interface afterwards.  If you want
     * all elements that implement the interface, use
     * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
     * @param iface the #GType of an interface
     */
    get_by_interface(iface: GObject.Type): Element | null
    /**
     * Gets the element with the given name from a bin. This
     * function recurses into child bins.
     * @param name the element name to search for
     */
    get_by_name(name: string): Element | null
    /**
     * Gets the element with the given name from this bin. If the
     * element is not found, a recursion is performed on the parent bin.
     * @param name the element name to search for
     */
    get_by_name_recurse_up(name: string): Element | null
    get_suppressed_flags(): ElementFlags
    /**
     * Looks for all elements inside the bin with the given element factory name.
     * The function recurses inside child bins. The iterator will yield a series of
     * #GstElement.
     * @param factory_name the name of the #GstElementFactory
     */
    iterate_all_by_element_factory_name(factory_name: string): Iterator | null
    /**
     * Looks for all elements inside the bin that implements the given
     * interface. You can safely cast all returned elements to the given interface.
     * The function recurses inside child bins. The iterator will yield a series
     * of #GstElement.
     * @param iface the #GType of an interface
     */
    iterate_all_by_interface(iface: GObject.Type): Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     */
    iterate_elements(): Iterator | null
    /**
     * Gets an iterator for the elements in this bin.
     * This iterator recurses into GstBin children.
     */
    iterate_recurse(): Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SINK flag set.
     */
    iterate_sinks(): Iterator | null
    /**
     * Gets an iterator for the elements in this bin in topologically
     * sorted order. This means that the elements are returned from
     * the most downstream elements (sinks) to the sources.
     * 
     * This function is used internally to perform the state changes
     * of the bin elements and for clock selection.
     */
    iterate_sorted(): Iterator | null
    /**
     * Gets an iterator for all elements in the bin that have the
     * #GST_ELEMENT_FLAG_SOURCE flag set.
     */
    iterate_sources(): Iterator | null
    /**
     * Queries `bin` for the current latency and reconfigures this latency on all the
     * elements using a LATENCY event.
     * 
     * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
     * is posted on the bus.
     * 
     * This function simply emits the #GstBin::do-latency signal so any custom latency
     * calculations will be performed.
     */
    recalculate_latency(): boolean
    /**
     * Removes the element from the bin, unparenting it as well.
     * Unparenting the element means that the element will be dereferenced,
     * so if the bin holds the only reference to the element, the element
     * will be freed in the process of removing it from the bin.  If you
     * want the element to still exist after removing, you need to call
     * gst_object_ref() before removing it from the bin.
     * 
     * If the element's pads are linked to other pads, the pads will be unlinked
     * before the element is removed from the bin.
     * @param element the #GstElement to remove
     */
    remove(element: Element): boolean
    /**
     * Suppresses the given flags on the bin. #GstElementFlags of a
     * child element are propagated when it is added to the bin.
     * When suppressed flags are set, those specified flags will
     * not be propagated to the bin.
     * @param flags the #GstElementFlags to suppress
     */
    set_suppressed_flags(flags: ElementFlags): void
    /**
     * Synchronizes the state of every child of `bin` with the state
     * of `bin`. See also gst_element_sync_state_with_parent().
     */
    sync_children_states(): boolean
    /* Methods of Gst-1.0.Gst.Element */
    /**
     * Abort the state change of the element. This function is used
     * by elements that do asynchronous state changes and find out
     * something is wrong.
     * 
     * This function should be called with the STATE_LOCK held.
     * 
     * MT safe.
     */
    abort_state(): void
    /**
     * Adds a pad (link point) to `element`. `pad'`s parent will be set to `element;`
     * see gst_object_set_parent() for refcounting information.
     * 
     * Pads are automatically activated when added in the PAUSED or PLAYING
     * state.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-added signal on the element.
     * @param pad the #GstPad to add to the element.
     */
    add_pad(pad: Pad): boolean
    add_property_deep_notify_watch(property_name: string | null, include_value: boolean): number
    add_property_notify_watch(property_name: string | null, include_value: boolean): number
    /**
     * Calls `func` from another thread and passes `user_data` to it. This is to be
     * used for cases when a state change has to be performed from a streaming
     * thread, directly via gst_element_set_state() or indirectly e.g. via SEEK
     * events.
     * 
     * Calling those functions directly from the streaming thread will cause
     * deadlocks in many situations, as they might involve waiting for the
     * streaming thread to shut down from this very streaming thread.
     * 
     * MT safe.
     * @param func Function to call asynchronously from another thread
     */
    call_async(func: ElementCallAsyncFunc): void
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    change_state(transition: StateChange): StateChangeReturn
    /**
     * Commit the state change of the element and proceed to the next
     * pending state if any. This function is used
     * by elements that do asynchronous state changes.
     * The core will normally call this method automatically when an
     * element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
     * 
     * If after calling this method the element still has not reached
     * the pending state, the next state change is performed.
     * 
     * This method is used internally and should normally not be called by plugins
     * or applications.
     * 
     * This function must be called with STATE_LOCK held.
     * @param ret The previous state return value
     */
    continue_state(ret: StateChangeReturn): StateChangeReturn
    /**
     * Creates a pad for each pad template that is always available.
     * This function is only useful during object initialization of
     * subclasses of #GstElement.
     */
    create_all_pads(): void
    /**
     * Call `func` with `user_data` for each of `element'`s pads. `func` will be called
     * exactly once for each pad that exists at the time of this call, unless
     * one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new pads are added or pads are removed
     * while pads are being iterated, this will not be taken into account until
     * next time this function is used.
     * @param func function to call for each pad
     */
    foreach_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s sink pads. `func` will be
     * called exactly once for each sink pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new sink pads are added or sink pads
     * are removed while the sink pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each sink pad
     */
    foreach_sink_pad(func: ElementForeachPadFunc): boolean
    /**
     * Call `func` with `user_data` for each of `element'`s source pads. `func` will be
     * called exactly once for each source pad that exists at the time of this call,
     * unless one of the calls to `func` returns %FALSE in which case we will stop
     * iterating pads and return early. If new source pads are added or source pads
     * are removed while the source pads are being iterated, this will not be taken
     * into account until next time this function is used.
     * @param func function to call for each source pad
     */
    foreach_src_pad(func: ElementForeachPadFunc): boolean
    /**
     * Returns the base time of the element. The base time is the
     * absolute time of the clock when this element was last put to
     * PLAYING. Subtracting the base time from the clock time gives
     * the running time of the element.
     */
    get_base_time(): ClockTime
    /**
     * Returns the bus of the element. Note that only a #GstPipeline will provide a
     * bus for the application.
     */
    get_bus(): Bus | null
    /**
     * Gets the currently configured clock of the element. This is the clock as was
     * last set with gst_element_set_clock().
     * 
     * Elements in a pipeline will only have their clock set when the
     * pipeline is in the PLAYING state.
     */
    get_clock(): Clock | null
    /**
     * Looks for an unlinked pad to which the given pad can link. It is not
     * guaranteed that linking the pads will work, though it should work in most
     * cases.
     * 
     * This function will first attempt to find a compatible unlinked ALWAYS pad,
     * and if none can be found, it will request a compatible REQUEST pad by looking
     * at the templates of `element`.
     * @param pad the #GstPad to find a compatible one for.
     * @param caps the #GstCaps to use as a filter.
     */
    get_compatible_pad(pad: Pad, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad template from `element` that is compatible with `compattempl`.
     * Pads from compatible templates can be linked together.
     * @param compattempl the #GstPadTemplate to find a compatible     template for
     */
    get_compatible_pad_template(compattempl: PadTemplate): PadTemplate | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * 
     * MT safe.
     * @param context_type a name of a context to retrieve
     */
    get_context(context_type: string): Context | null
    /**
     * Gets the context with `context_type` set on the element or NULL.
     * @param context_type a name of a context to retrieve
     */
    get_context_unlocked(context_type: string): Context | null
    /**
     * Gets the contexts set on the element.
     * 
     * MT safe.
     */
    get_contexts(): Context[]
    /**
     * Returns the current clock time of the element, as in, the time of the
     * element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
     */
    get_current_clock_time(): ClockTime
    /**
     * Returns the running time of the element. The running time is the
     * element's clock time minus its base time. Will return GST_CLOCK_TIME_NONE
     * if the element has no clock, or if its base time has not been set.
     */
    get_current_running_time(): ClockTime
    /**
     * Retrieves the factory that was used to create this element.
     */
    get_factory(): ElementFactory | null
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    get_metadata(key: string): string
    /**
     * Retrieves a padtemplate from `element` with the given name.
     * @param name the name of the #GstPadTemplate to get.
     */
    get_pad_template(name: string): PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element`. The
     * list must not be modified by the calling code.
     */
    get_pad_template_list(): PadTemplate[]
    /**
     * The name of this function is confusing to people learning GStreamer.
     * gst_element_request_pad_simple() aims at making it more explicit it is
     * a simplified gst_element_request_pad().
     * @param name the name of the request #GstPad to retrieve.
     */
    get_request_pad(name: string): Pad | null
    /**
     * Returns the start time of the element. The start time is the
     * running time of the clock when this element was last put to PAUSED.
     * 
     * Usually the start_time is managed by a toplevel element such as
     * #GstPipeline.
     * 
     * MT safe.
     */
    get_start_time(): ClockTime
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Retrieves a pad from `element` by name. This version only retrieves
     * already-existing (i.e. 'static') pads.
     * @param name the name of the static #GstPad to retrieve.
     */
    get_static_pad(name: string): Pad | null
    /**
     * Checks if the state of an element is locked.
     * If the state of an element is locked, state changes of the parent don't
     * affect the element.
     * This way you can leave currently unused elements inside bins. Just lock their
     * state before changing the state from #GST_STATE_NULL.
     * 
     * MT safe.
     */
    is_locked_state(): boolean
    /**
     * Retrieves an iterator of `element'`s pads. The iterator should
     * be freed after usage. Also more specialized iterators exists such as
     * gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s sink pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_sink_pads(): Iterator
    /**
     * Retrieves an iterator of `element'`s source pads.
     * 
     * The order of pads returned by the iterator will be the order in which
     * the pads were added to the element.
     */
    iterate_src_pads(): Iterator
    /**
     * Links `src` to `dest`. The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * Such pads need to be released manually when unlinking.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     */
    link(dest: Element): boolean
    /**
     * Links `src` to `dest` using the given caps as filtercaps.
     * The link must be from source to
     * destination; the other direction will not be tried. The function looks for
     * existing pads that aren't linked yet. It will request new pads if necessary.
     * If multiple links are possible, only one is established.
     * 
     * Make sure you have added your elements to a bin or pipeline with
     * gst_bin_add() before trying to link them.
     * @param dest the #GstElement containing the destination pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_filtered(dest: Element, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     */
    link_pads(srcpadname: string | null, dest: Element, destpadname?: string | null): boolean
    /**
     * Links the two named pads of the source and destination elements. Side effect
     * is that if one of the pads has no parent, it becomes a child of the parent of
     * the other element. If they have different parents, the link fails. If `caps`
     * is not %NULL, makes sure that the caps of the link is a subset of `caps`.
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element     or %NULL for any pad.
     * @param filter the #GstCaps to filter the link,     or %NULL for no filter.
     */
    link_pads_filtered(srcpadname: string | null, dest: Element, destpadname?: string | null, filter?: Caps | null): boolean
    /**
     * Links the two named pads of the source and destination elements.
     * Side effect is that if one of the pads has no parent, it becomes a
     * child of the parent of the other element.  If they have different
     * parents, the link fails.
     * 
     * Calling gst_element_link_pads_full() with `flags` == %GST_PAD_LINK_CHECK_DEFAULT
     * is the same as calling gst_element_link_pads() and the recommended way of
     * linking pads with safety checks applied.
     * 
     * This is a convenience function for gst_pad_link_full().
     * @param srcpadname the name of the #GstPad in source element     or %NULL for any pad.
     * @param dest the #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element, or %NULL for any pad.
     * @param flags the #GstPadLinkCheck to be performed when linking pads.
     */
    link_pads_full(srcpadname: string | null, dest: Element, destpadname: string | null, flags: PadLinkCheck): boolean
    /**
     * Brings the element to the lost state. The current state of the
     * element is copied to the pending state so that any call to
     * gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
     * 
     * An ASYNC_START message is posted. If the element was PLAYING, it will
     * go to PAUSED. The element will be restored to its PLAYING state by
     * the parent pipeline when it prerolls again.
     * 
     * This is mostly used for elements that lost their preroll buffer
     * in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
     * they will go to their pending state again when a new preroll buffer is
     * queued. This function can only be called when the element is currently
     * not in error or an async state change.
     * 
     * This function is used internally and should normally not be called from
     * plugins or applications.
     */
    lost_state(): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * 
     * MT safe.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     */
    message_full(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number): void
    /**
     * Post an error, warning or info message on the bus from inside an element.
     * 
     * `type` must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
     * #GST_MESSAGE_INFO.
     * @param type the #GstMessageType
     * @param domain the GStreamer GError domain this message belongs to
     * @param code the GError code belonging to the domain
     * @param text an allocated text string to be used            as a replacement for the default message connected to code,            or %NULL
     * @param debug an allocated debug message to be            used as a replacement for the default debugging information,            or %NULL
     * @param file the source code file where the error was generated
     * @param function_ the source code function where the error was generated
     * @param line the source code line where the error was generated
     * @param structure optional details structure
     */
    message_full_with_details(type: MessageType, domain: GLib.Quark, code: number, text: string | null, debug: string | null, file: string, function_: string, line: number, structure: Structure): void
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    no_more_pads(): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    query(query: Query): boolean
    /**
     * Queries an element to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * total stream duration in nanoseconds. This query will only work once the
     * pipeline is prerolled (i.e. reached PAUSED or PLAYING state). The application
     * will receive an ASYNC_DONE message on the pipeline bus when that is the case.
     * 
     * If the duration changes for some reason, you will get a DURATION_CHANGED
     * message on the pipeline bus, in which case you should re-query the duration
     * using this function.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries an element (usually top-level pipeline or playbin element) for the
     * stream position in nanoseconds. This will be a value between 0 and the
     * stream duration (if the stream duration is known). This query will usually
     * only work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING
     * state). The application will receive an ASYNC_DONE message on the pipeline
     * bus when that is the case.
     * 
     * If one repeatedly calls this function one can also create a query and reuse
     * it in gst_element_query().
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Makes the element free the previously requested pad as obtained
     * with gst_element_request_pad().
     * 
     * This does not unref the pad. If the pad was created by using
     * gst_element_request_pad(), gst_element_release_request_pad() needs to be
     * followed by gst_object_unref() to free the `pad`.
     * 
     * MT safe.
     * @param pad the #GstPad to release.
     */
    release_request_pad(pad: Pad): void
    /**
     * Removes `pad` from `element`. `pad` will be destroyed if it has not been
     * referenced elsewhere using gst_object_unparent().
     * 
     * This function is used by plugin developers and should not be used
     * by applications. Pads that were dynamically requested from elements
     * with gst_element_request_pad() should be released with the
     * gst_element_release_request_pad() function instead.
     * 
     * Pads are not automatically deactivated so elements should perform the needed
     * steps to deactivate the pad in case this pad is removed in the PAUSED or
     * PLAYING state. See gst_pad_set_active() for more information about
     * deactivating pads.
     * 
     * The pad and the element should be unlocked when calling this function.
     * 
     * This function will emit the #GstElement::pad-removed signal on the element.
     * @param pad the #GstPad to remove from the element.
     */
    remove_pad(pad: Pad): boolean
    remove_property_notify_watch(watch_id: number): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    request_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
     * retrieves request pads. The pad should be released with
     * gst_element_release_request_pad().
     * 
     * This method is slower than manually getting the pad template and calling
     * gst_element_request_pad() if the pads should have a specific name (e.g.
     * `name` is "src_1" instead of "src_\%u").
     * 
     * Note that this function was introduced in GStreamer 1.20 in order to provide
     * a better name to gst_element_get_request_pad(). Prior to 1.20, users
     * should use gst_element_get_request_pad() which provides the same
     * functionality.
     * @param name the name of the request #GstPad to retrieve.
     */
    request_pad_simple(name: string): Pad | null
    /**
     * Sends a seek event to an element. See gst_event_new_seek() for the details of
     * the parameters. The seek event is sent to the element using
     * gst_element_send_event().
     * 
     * MT safe.
     * @param rate The new playback rate
     * @param format The format of the seek values
     * @param flags The optional seek flags.
     * @param start_type The type and flags for the new start position
     * @param start The value of the new start position
     * @param stop_type The type and flags for the new stop position
     * @param stop The value of the new stop position
     */
    seek(rate: number, format: Format, flags: SeekFlags, start_type: SeekType, start: number, stop_type: SeekType, stop: number): boolean
    /**
     * Simple API to perform a seek on the given element, meaning it just seeks
     * to the given position relative to the start of the stream. For more complex
     * operations like segment seeks (e.g. for looping) or changing the playback
     * rate or seeking relative to the last configured playback segment you should
     * use gst_element_seek().
     * 
     * In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
     * guaranteed to return %TRUE on a seekable media type or %FALSE when the media
     * type is certainly not seekable (such as a live stream).
     * 
     * Some elements allow for seeking in the READY state, in this
     * case they will store the seek event and execute it when they are put to
     * PAUSED. If the element supports seek in READY, it will always return %TRUE when
     * it receives the event in the READY state.
     * @param format a #GstFormat to execute the seek in, such as #GST_FORMAT_TIME
     * @param seek_flags seek options; playback applications will usually want to use            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here
     * @param seek_pos position to seek to (relative to the start); if you are doing            a seek in #GST_FORMAT_TIME this value is in nanoseconds -            multiply with #GST_SECOND to convert seconds to nanoseconds or            with #GST_MSECOND to convert milliseconds to nanoseconds.
     */
    seek_simple(format: Format, seek_flags: SeekFlags, seek_pos: number): boolean
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    send_event(event: Event): boolean
    /**
     * Set the base time of an element. See gst_element_get_base_time().
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_base_time(time: ClockTime): void
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    set_context(context: Context): void
    /**
     * Locks the state of an element, so state changes of the parent don't affect
     * this element anymore.
     * 
     * Note that this is racy if the state lock of the parent bin is not taken.
     * The parent bin might've just checked the flag in another thread and as the
     * next step proceed to change the child element's state.
     * 
     * MT safe.
     * @param locked_state %TRUE to lock the element's state
     */
    set_locked_state(locked_state: boolean): boolean
    /**
     * Set the start time of an element. The start time of the element is the
     * running time of the element when it last went to the PAUSED state. In READY
     * or after a flushing seek, it is set to 0.
     * 
     * Toplevel elements like #GstPipeline will manage the start_time and
     * base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
     * on such a toplevel element will disable the distribution of the base_time to
     * the children and can be useful if the application manages the base_time
     * itself, for example if you want to synchronize capture from multiple
     * pipelines, and you can also ensure that the pipelines have the same clock.
     * 
     * MT safe.
     * @param time the base time to set.
     */
    set_start_time(time: ClockTime): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    set_state(state: State): StateChangeReturn
    /**
     * Tries to change the state of the element to the same as its parent.
     * If this function returns %FALSE, the state of element is undefined.
     */
    sync_state_with_parent(): boolean
    /**
     * Unlinks all source pads of the source element with all sink pads
     * of the sink element to which they are linked.
     * 
     * If the link has been made using gst_element_link(), it could have created an
     * requestpad, which has to be released using gst_element_release_request_pad().
     * @param dest the sink #GstElement to unlink.
     */
    unlink(dest: Element): void
    /**
     * Unlinks the two named pads of the source and destination elements.
     * 
     * This is a convenience function for gst_pad_unlink().
     * @param srcpadname the name of the #GstPad in source element.
     * @param dest a #GstElement containing the destination pad.
     * @param destpadname the name of the #GstPad in destination element.
     */
    unlink_pads(srcpadname: string, dest: Element, destpadname: string): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Bin */
    /**
     * Method to add an element to the bin.
     * @param element the element to be added
     */
    vfunc_add_element(element: Element): boolean
    /**
     * Method called when an element was added somewhere in the bin hierarchy.
     * @param sub_bin the #GstBin to which the element was added
     * @param child the element that was added
     */
    vfunc_deep_element_added(sub_bin: Bin, child: Element): void
    /**
     * Method called when an element was removed somewhere in the bin hierarchy.
     * @param sub_bin the #GstBin from which the element was removed
     * @param child the element that was removed
     */
    vfunc_deep_element_removed(sub_bin: Bin, child: Element): void
    vfunc_do_latency(): boolean
    /**
     * Method called when an element was added to the bin.
     * @param child the element that was added
     */
    vfunc_element_added(child: Element): void
    /**
     * Method called when an element was removed from the bin.
     * @param child the element that was removed
     */
    vfunc_element_removed(child: Element): void
    /**
     * Method to handle a message from the children.
     * @param message the message to be handled
     */
    vfunc_handle_message(message: Message): void
    /**
     * Method to remove an element from the bin.
     * @param element the element to be removed
     */
    vfunc_remove_element(element: Element): boolean
    /* Virtual methods of Gst-1.0.Gst.Element */
    /**
     * Perform `transition` on `element`.
     * 
     * This function must be called with STATE_LOCK held and is mainly used
     * internally.
     * @param transition the requested transition
     */
    vfunc_change_state(transition: StateChange): StateChangeReturn
    /**
     * Gets the state of the element.
     * 
     * For elements that performed an ASYNC state change, as reported by
     * gst_element_set_state(), this function will block up to the
     * specified timeout value for the state change to complete.
     * If the element completes the state change or goes into
     * an error, this function returns immediately with a return value of
     * %GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
     * 
     * For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
     * returns the current and pending state immediately.
     * 
     * This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
     * successfully changed its state but is not able to provide data yet.
     * This mostly happens for live sources that only produce data in
     * %GST_STATE_PLAYING. While the state change return is equivalent to
     * %GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
     * some sink elements might not be able to complete their state change because
     * an element is not producing data to complete the preroll. When setting the
     * element to playing, the preroll will complete and playback will start.
     * @param timeout a #GstClockTime to specify the timeout for an async           state change or %GST_CLOCK_TIME_NONE for infinite timeout.
     */
    vfunc_get_state(timeout: ClockTime): [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    /**
     * Use this function to signal that the element does not expect any more pads
     * to show up in the current pipeline. This function should be called whenever
     * pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
     * pad templates use this in combination with autopluggers to figure out that
     * the element is done initializing its pads.
     * 
     * This function emits the #GstElement::no-more-pads signal.
     * 
     * MT safe.
     */
    vfunc_no_more_pads(): void
    vfunc_pad_added(pad: Pad): void
    vfunc_pad_removed(pad: Pad): void
    /**
     * Post a message on the element's #GstBus. This function takes ownership of the
     * message; if you want to access the message after this call, you should add an
     * additional reference before calling.
     * @param message a #GstMessage to post
     */
    vfunc_post_message(message: Message): boolean
    /**
     * Get the clock provided by the given element.
     * > An element is only required to provide a clock in the PAUSED
     * > state. Some elements can provide a clock in other states.
     */
    vfunc_provide_clock(): Clock | null
    /**
     * Performs a query on the given element.
     * 
     * For elements that don't implement a query handler, this function
     * forwards the query to a random srcpad or to the peer of a
     * random linked sinkpad of this element.
     * 
     * Please note that some queries might need a running pipeline to work.
     * @param query the #GstQuery.
     */
    vfunc_query(query: Query): boolean
    vfunc_release_pad(pad: Pad): void
    /**
     * Retrieves a request pad from the element according to the provided template.
     * Pad templates can be looked up using
     * gst_element_factory_get_static_pad_templates().
     * 
     * The pad should be released with gst_element_release_request_pad().
     * @param templ a #GstPadTemplate of which we want a pad of.
     * @param name the name of the request #GstPad to retrieve. Can be %NULL.
     * @param caps the caps of the pad we want to request. Can be %NULL.
     */
    vfunc_request_new_pad(templ: PadTemplate, name?: string | null, caps?: Caps | null): Pad | null
    /**
     * Sends an event to an element. If the element doesn't implement an
     * event handler, the event will be pushed on a random linked sink pad for
     * downstream events or a random linked source pad for upstream events.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * 
     * MT safe.
     * @param event the #GstEvent to send to the element.
     */
    vfunc_send_event(event: Event): boolean
    /**
     * Sets the bus of the element. Increases the refcount on the bus.
     * For internal use only, unless you're testing elements.
     * 
     * MT safe.
     * @param bus the #GstBus to set.
     */
    vfunc_set_bus(bus?: Bus | null): void
    /**
     * Sets the clock for the element. This function increases the
     * refcount on the clock. Any previously set clock on the object
     * is unreffed.
     * @param clock the #GstClock to set for the element.
     */
    vfunc_set_clock(clock?: Clock | null): boolean
    /**
     * Sets the context of the element. Increases the refcount of the context.
     * 
     * MT safe.
     * @param context the #GstContext to set.
     */
    vfunc_set_context(context: Context): void
    /**
     * Sets the state of the element. This function will try to set the
     * requested state by going through all the intermediary states and calling
     * the class's state change function for each.
     * 
     * This function can return #GST_STATE_CHANGE_ASYNC, in which case the
     * element will perform the remainder of the state change asynchronously in
     * another thread.
     * An application can use gst_element_get_state() to wait for the completion
     * of the state change or it can wait for a %GST_MESSAGE_ASYNC_DONE or
     * %GST_MESSAGE_STATE_CHANGED on the bus.
     * 
     * State changes to %GST_STATE_READY or %GST_STATE_NULL never return
     * #GST_STATE_CHANGE_ASYNC.
     * @param state the element's new #GstState.
     */
    vfunc_set_state(state: State): StateChangeReturn
    vfunc_state_changed(oldstate: State, newstate: State, pending: State): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Bin */
    /**
     * Will be emitted after the element was added to `sub_bin`.
     * @param sub_bin the #GstBin the element was added to
     * @param element the #GstElement that was added to `sub_bin`
     */
    connect(sigName: "deep-element-added", callback: (($obj: Pipeline, sub_bin: Bin, element: Element) => void)): number
    connect_after(sigName: "deep-element-added", callback: (($obj: Pipeline, sub_bin: Bin, element: Element) => void)): number
    emit(sigName: "deep-element-added", sub_bin: Bin, element: Element): void
    /**
     * Will be emitted after the element was removed from `sub_bin`.
     * @param sub_bin the #GstBin the element was removed from
     * @param element the #GstElement that was removed from `sub_bin`
     */
    connect(sigName: "deep-element-removed", callback: (($obj: Pipeline, sub_bin: Bin, element: Element) => void)): number
    connect_after(sigName: "deep-element-removed", callback: (($obj: Pipeline, sub_bin: Bin, element: Element) => void)): number
    emit(sigName: "deep-element-removed", sub_bin: Bin, element: Element): void
    /**
     * Will be emitted when the bin needs to perform latency calculations. This
     * signal is only emitted for toplevel bins or when #GstBin:async-handling is
     * enabled.
     * 
     * Only one signal handler is invoked. If no signals are connected, the
     * default handler is invoked, which will query and distribute the lowest
     * possible latency to all sinks.
     * 
     * Connect to this signal if the default latency calculations are not
     * sufficient, like when you need different latencies for different sinks in
     * the same pipeline.
     */
    connect(sigName: "do-latency", callback: (($obj: Pipeline) => boolean)): number
    connect_after(sigName: "do-latency", callback: (($obj: Pipeline) => boolean)): number
    emit(sigName: "do-latency"): void
    /**
     * Will be emitted after the element was added to the bin.
     * @param element the #GstElement that was added to the bin
     */
    connect(sigName: "element-added", callback: (($obj: Pipeline, element: Element) => void)): number
    connect_after(sigName: "element-added", callback: (($obj: Pipeline, element: Element) => void)): number
    emit(sigName: "element-added", element: Element): void
    /**
     * Will be emitted after the element was removed from the bin.
     * @param element the #GstElement that was removed from the bin
     */
    connect(sigName: "element-removed", callback: (($obj: Pipeline, element: Element) => void)): number
    connect_after(sigName: "element-removed", callback: (($obj: Pipeline, element: Element) => void)): number
    emit(sigName: "element-removed", element: Element): void
    /* Signals of Gst-1.0.Gst.Element */
    /**
     * This signals that the element will not generate more dynamic pads.
     * Note that this signal will usually be emitted from the context of
     * the streaming thread.
     */
    connect(sigName: "no-more-pads", callback: (($obj: Pipeline) => void)): number
    connect_after(sigName: "no-more-pads", callback: (($obj: Pipeline) => void)): number
    emit(sigName: "no-more-pads"): void
    /**
     * a new #GstPad has been added to the element. Note that this signal will
     * usually be emitted from the context of the streaming thread. Also keep in
     * mind that if you add new elements to the pipeline in the signal handler
     * you will need to set them to the desired target state with
     * gst_element_set_state() or gst_element_sync_state_with_parent().
     * @param new_pad the pad that has been added
     */
    connect(sigName: "pad-added", callback: (($obj: Pipeline, new_pad: Pad) => void)): number
    connect_after(sigName: "pad-added", callback: (($obj: Pipeline, new_pad: Pad) => void)): number
    emit(sigName: "pad-added", new_pad: Pad): void
    /**
     * a #GstPad has been removed from the element
     * @param old_pad the pad that has been removed
     */
    connect(sigName: "pad-removed", callback: (($obj: Pipeline, old_pad: Pad) => void)): number
    connect_after(sigName: "pad-removed", callback: (($obj: Pipeline, old_pad: Pad) => void)): number
    emit(sigName: "pad-removed", old_pad: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Pipeline, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Pipeline, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::auto-flush-bus", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-flush-bus", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::delay", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delay", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::latency", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::latency", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::async-handling", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::async-handling", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::message-forward", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-forward", callback: (($obj: Pipeline, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Pipeline_ConstructProps)
    _init (config?: Pipeline_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(name?: string | null): Pipeline
    /* Function overloads */
    static new(name?: string | null): Pipeline
    static $gtype: GObject.Type
}
interface Plugin_ConstructProps extends Object_ConstructProps {
}
class Plugin {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Plugin */
    /**
     * Make GStreamer aware of external dependencies which affect the feature
     * set of this plugin (ie. the elements or typefinders associated with it).
     * 
     * GStreamer will re-inspect plugins with external dependencies whenever any
     * of the external dependencies change. This is useful for plugins which wrap
     * other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
     * library and makes visualisations available as GStreamer elements, or a
     * codec loader which exposes elements and/or caps dependent on what external
     * codec libraries are currently installed.
     * @param env_vars %NULL-terminated array of environment variables affecting the     feature set of the plugin (e.g. an environment variable containing     paths where to look for additional modules/plugins of a library),     or %NULL. Environment variable names may be followed by a path component      which will be added to the content of the environment variable, e.g.      "HOME/.mystuff/plugins".
     * @param paths %NULL-terminated array of directories/paths where dependent files     may be, or %NULL.
     * @param names %NULL-terminated array of file names (or file name suffixes,     depending on `flags)` to be used in combination with the paths from     `paths` and/or the paths extracted from the environment variables in     `env_vars,` or %NULL.
     * @param flags optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE
     */
    add_dependency(env_vars: string[] | null, paths: string[] | null, names: string[] | null, flags: PluginDependencyFlags): void
    /**
     * Make GStreamer aware of external dependencies which affect the feature
     * set of this plugin (ie. the elements or typefinders associated with it).
     * 
     * GStreamer will re-inspect plugins with external dependencies whenever any
     * of the external dependencies change. This is useful for plugins which wrap
     * other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
     * library and makes visualisations available as GStreamer elements, or a
     * codec loader which exposes elements and/or caps dependent on what external
     * codec libraries are currently installed.
     * 
     * Convenience wrapper function for gst_plugin_add_dependency() which
     * takes simple strings as arguments instead of string arrays, with multiple
     * arguments separated by predefined delimiters (see above).
     * @param env_vars one or more environment variables (separated by ':', ';' or ','),      or %NULL. Environment variable names may be followed by a path component      which will be added to the content of the environment variable, e.g.      "HOME/.mystuff/plugins:MYSTUFF_PLUGINS_PATH"
     * @param paths one ore more directory paths (separated by ':' or ';' or ','),      or %NULL. Example: "/usr/lib/mystuff/plugins"
     * @param names one or more file names or file name suffixes (separated by commas),      or %NULL
     * @param flags optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE
     */
    add_dependency_simple(env_vars: string | null, paths: string | null, names: string | null, flags: PluginDependencyFlags): void
    /**
     * Gets the plugin specific data cache. If it is %NULL there is no cached data
     * stored. This is the case when the registry is getting rebuilt.
     */
    get_cache_data(): Structure | null
    /**
     * Get the long descriptive name of the plugin
     */
    get_description(): string
    /**
     * get the filename of the plugin
     */
    get_filename(): string | null
    /**
     * get the license of the plugin
     */
    get_license(): string
    /**
     * Get the short name of the plugin
     */
    get_name(): string
    /**
     * get the URL where the plugin comes from
     */
    get_origin(): string
    /**
     * get the package the plugin belongs to.
     */
    get_package(): string
    /**
     * Get the release date (and possibly time) in form of a string, if available.
     * 
     * For normal GStreamer plugin releases this will usually just be a date in
     * the form of "YYYY-MM-DD", while pre-releases and builds from git may contain
     * a time component after the date as well, in which case the string will be
     * formatted like "YYYY-MM-DDTHH:MMZ" (e.g. "2012-04-30T09:30Z").
     * 
     * There may be plugins that do not have a valid release date set on them.
     */
    get_release_date_string(): string | null
    /**
     * get the source module the plugin belongs to.
     */
    get_source(): string
    /**
     * get the version of the plugin
     */
    get_version(): string
    /**
     * queries if the plugin is loaded into memory
     */
    is_loaded(): boolean
    /**
     * Loads `plugin`. Note that the *return value* is the loaded plugin; `plugin` is
     * untouched. The normal use pattern of this function goes like this:
     * 
     * |[
     * GstPlugin *loaded_plugin;
     * loaded_plugin = gst_plugin_load (plugin);
     * // presumably, we're no longer interested in the potentially-unloaded plugin
     * gst_object_unref (plugin);
     * plugin = loaded_plugin;
     * ```
     * 
     */
    load(): Plugin | null
    /**
     * Adds plugin specific data to cache. Passes the ownership of the structure to
     * the `plugin`.
     * 
     * The cache is flushed every time the registry is rebuilt.
     * @param cache_data a structure containing the data to cache
     */
    set_cache_data(cache_data: Structure): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Plugin, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Plugin, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Plugin, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Plugin, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Plugin_ConstructProps)
    _init (config?: Plugin_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Unrefs each member of `list,` then frees the list.
     * @param list list of #GstPlugin
     */
    static list_free(list: Plugin[]): void
    /**
     * Load the named plugin. Refs the plugin.
     * @param name name of plugin to load
     */
    static load_by_name(name: string): Plugin | null
    /**
     * Loads the given plugin and refs it.  Caller needs to unref after use.
     * @param filename the plugin filename to load
     */
    static load_file(filename: string): Plugin
    /**
     * Registers a static plugin, ie. a plugin which is private to an application
     * or library and contained within the application or library (as opposed to
     * being shipped as a separate module file).
     * 
     * You must make sure that GStreamer has been initialised (with gst_init() or
     * via gst_init_get_option_group()) before calling this function.
     * @param major_version the major version number of the GStreamer core that the     plugin was compiled for, you can just use GST_VERSION_MAJOR here
     * @param minor_version the minor version number of the GStreamer core that the     plugin was compiled for, you can just use GST_VERSION_MINOR here
     * @param name a unique name of the plugin (ideally prefixed with an application- or     library-specific namespace prefix in order to avoid name conflicts in     case a similar plugin with the same name ever gets added to GStreamer)
     * @param description description of the plugin
     * @param init_func pointer to the init function of this plugin.
     * @param version version string of the plugin
     * @param license effective license of plugin. Must be one of the approved licenses     (see #GstPluginDesc above) or the plugin will not be registered.
     * @param source source module plugin belongs to
     * @param package shipped package plugin belongs to
     * @param origin URL to provider of plugin
     */
    static register_static(major_version: number, minor_version: number, name: string, description: string, init_func: PluginInitFunc, version: string, license: string, source: string, package: string, origin: string): boolean
    /**
     * Registers a static plugin, ie. a plugin which is private to an application
     * or library and contained within the application or library (as opposed to
     * being shipped as a separate module file) with a #GstPluginInitFullFunc
     * which allows user data to be passed to the callback function (useful
     * for bindings).
     * 
     * You must make sure that GStreamer has been initialised (with gst_init() or
     * via gst_init_get_option_group()) before calling this function.
     * @param major_version the major version number of the GStreamer core that the     plugin was compiled for, you can just use GST_VERSION_MAJOR here
     * @param minor_version the minor version number of the GStreamer core that the     plugin was compiled for, you can just use GST_VERSION_MINOR here
     * @param name a unique name of the plugin (ideally prefixed with an application- or     library-specific namespace prefix in order to avoid name conflicts in     case a similar plugin with the same name ever gets added to GStreamer)
     * @param description description of the plugin
     * @param init_full_func pointer to the init function with user data     of this plugin.
     * @param version version string of the plugin
     * @param license effective license of plugin. Must be one of the approved licenses     (see #GstPluginDesc above) or the plugin will not be registered.
     * @param source source module plugin belongs to
     * @param package shipped package plugin belongs to
     * @param origin URL to provider of plugin
     */
    static register_static_full(major_version: number, minor_version: number, name: string, description: string, init_full_func: PluginInitFullFunc, version: string, license: string, source: string, package: string, origin: string): boolean
    static $gtype: GObject.Type
}
interface PluginFeature_ConstructProps extends Object_ConstructProps {
}
class PluginFeature {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.PluginFeature */
    /**
     * Checks whether the given plugin feature is at least
     *  the required version
     * @param min_major minimum required major version
     * @param min_minor minimum required minor version
     * @param min_micro minimum required micro version
     */
    check_version(min_major: number, min_minor: number, min_micro: number): boolean
    /**
     * Get the plugin that provides this feature.
     */
    get_plugin(): Plugin | null
    /**
     * Get the name of the plugin that provides this feature.
     */
    get_plugin_name(): string | null
    /**
     * Gets the rank of a plugin feature.
     */
    get_rank(): number
    /**
     * Loads the plugin containing `feature` if it's not already loaded. `feature` is
     * unaffected; use the return value instead.
     * 
     * Normally this function is used like this:
     * 
     * ```c
     * GstPluginFeature *loaded_feature;
     * 
     * loaded_feature = gst_plugin_feature_load (feature);
     * // presumably, we're no longer interested in the potentially-unloaded feature
     * gst_object_unref (feature);
     * feature = loaded_feature;
     * ```
     * 
     */
    load(): PluginFeature | null
    /**
     * Specifies a rank for a plugin feature, so that autoplugging uses
     * the most appropriate feature.
     * @param rank rank value - higher number means more priority rank
     */
    set_rank(rank: number): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: PluginFeature, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: PluginFeature, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: PluginFeature, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: PluginFeature, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: PluginFeature_ConstructProps)
    _init (config?: PluginFeature_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Copies the list of features. Caller should call `gst_plugin_feature_list_free`
     * when done with the list.
     * @param list list     of #GstPluginFeature
     */
    static list_copy(list: PluginFeature[]): PluginFeature[]
    /**
     * Debug the plugin feature names in `list`.
     * @param list a #GList of     plugin features
     */
    static list_debug(list: PluginFeature[]): void
    /**
     * Unrefs each member of `list,` then frees the list.
     * @param list list     of #GstPluginFeature
     */
    static list_free(list: PluginFeature[]): void
    /**
     * Compares the two given #GstPluginFeature instances. This function can be
     * used as a #GCompareFunc when sorting by rank and then by name.
     * @param p1 a #GstPluginFeature
     * @param p2 a #GstPluginFeature
     */
    static rank_compare_func(p1?: object | null, p2?: object | null): number
    static $gtype: GObject.Type
}
interface ProxyPad_ConstructProps extends Pad_ConstructProps {
}
class ProxyPad {
    /* Properties of Gst-1.0.Gst.Pad */
    readonly caps: Caps
    /**
     * The offset that will be applied to the running time of the pad.
     */
    offset: number
    template: PadTemplate
    /* Fields of Gst-1.0.Gst.Pad */
    object: Object
    /**
     * private data owned by the parent element
     */
    element_private: object
    /**
     * padtemplate for this pad
     */
    padtemplate: PadTemplate
    /**
     * the direction of the pad, cannot change after creating
     *             the pad.
     */
    direction: PadDirection
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.ProxyPad */
    /**
     * Get the internal pad of `pad`. Unref target pad after usage.
     * 
     * The internal pad of a #GstGhostPad is the internally used
     * pad of opposite direction, which is used to link to the target.
     */
    get_internal(): ProxyPad | null
    /* Methods of Gst-1.0.Gst.Pad */
    /**
     * Activates or deactivates the given pad in `mode` via dispatching to the
     * pad's activatemodefunc. For use from within pad activation functions only.
     * 
     * If you don't know what this is, you probably don't want to call it.
     * @param mode the requested activation mode
     * @param active whether or not the pad should be active.
     */
    activate_mode(mode: PadMode, active: boolean): boolean
    /**
     * Be notified of different states of pads. The provided callback is called for
     * every state that matches `mask`.
     * 
     * Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
     * called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only
     * exception here are GST_PAD_PROBE_TYPE_IDLE probes that are called
     * immediately if the pad is already idle while calling gst_pad_add_probe().
     * In each of the groups, probes are called in the order in which they were
     * added.
     * @param mask the probe mask
     * @param callback #GstPadProbeCallback that will be called with notifications of           the pad state
     */
    add_probe(mask: PadProbeType, callback: PadProbeCallback): number
    /**
     * Checks if the source pad and the sink pad are compatible so they can be
     * linked.
     * @param sinkpad the sink #GstPad.
     */
    can_link(sinkpad: Pad): boolean
    /**
     * Chain a buffer to `pad`.
     * 
     * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
     * 
     * If the buffer type is not acceptable for `pad` (as negotiated with a
     * preceding GST_EVENT_CAPS event), this function returns
     * #GST_FLOW_NOT_NEGOTIATED.
     * 
     * The function proceeds calling the chain function installed on `pad` (see
     * gst_pad_set_chain_function()) and the return value of that function is
     * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
     * chain function.
     * 
     * In all cases, success or failure, the caller loses its reference to `buffer`
     * after calling this function.
     * @param buffer the #GstBuffer to send, return GST_FLOW_ERROR     if not.
     */
    chain(buffer: Buffer): FlowReturn
    /**
     * Chain a bufferlist to `pad`.
     * 
     * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
     * 
     * If `pad` was not negotiated properly with a CAPS event, this function
     * returns #GST_FLOW_NOT_NEGOTIATED.
     * 
     * The function proceeds calling the chainlist function installed on `pad` (see
     * gst_pad_set_chain_list_function()) and the return value of that function is
     * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if `pad` has no
     * chainlist function.
     * 
     * In all cases, success or failure, the caller loses its reference to `list`
     * after calling this function.
     * 
     * MT safe.
     * @param list the #GstBufferList to send, return GST_FLOW_ERROR     if not.
     */
    chain_list(list: BufferList): FlowReturn
    /**
     * Check and clear the #GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return %TRUE
     * if the flag was set.
     */
    check_reconfigure(): boolean
    /**
     * Creates a stream-id for the source #GstPad `pad` by combining the
     * upstream information with the optional `stream_id` of the stream
     * of `pad`. `pad` must have a parent #GstElement and which must have zero
     * or one sinkpad. `stream_id` can only be %NULL if the parent element
     * of `pad` has only a single source pad.
     * 
     * This function generates an unique stream-id by getting the upstream
     * stream-start event stream ID and appending `stream_id` to it. If the
     * element has no sinkpad it will generate an upstream stream-id by
     * doing an URI query on the element and in the worst case just uses
     * a random number. Source elements that don't implement the URI
     * handler interface should ideally generate a unique, deterministic
     * stream-id manually instead.
     * 
     * Since stream IDs are sorted alphabetically, any numbers in the
     * stream ID should be printed with a fixed number of characters,
     * preceded by 0's, such as by using the format \%03u instead of \%u.
     * @param parent Parent #GstElement of `pad`
     * @param stream_id The stream-id
     */
    create_stream_id(parent: Element, stream_id?: string | null): string
    /**
     * Invokes the default event handler for the given pad.
     * 
     * The EOS event will pause the task associated with `pad` before it is forwarded
     * to all internally linked pads,
     * 
     * The event is sent to all pads internally linked to `pad`. This function
     * takes ownership of `event`.
     * @param parent the parent of `pad` or %NULL
     * @param event the #GstEvent to handle.
     */
    event_default(parent: Object | null, event: Event): boolean
    /**
     * Calls `forward` for all internally linked pads of `pad`. This function deals with
     * dynamically changing internal pads and will make sure that the `forward`
     * function is only called once for each pad.
     * 
     * When `forward` returns %TRUE, no further pads will be processed.
     * @param forward a #GstPadForwardFunction
     */
    forward(forward: PadForwardFunction): boolean
    /**
     * Gets the capabilities of the allowed media types that can flow through
     * `pad` and its peer.
     * 
     * The allowed capabilities is calculated as the intersection of the results of
     * calling gst_pad_query_caps() on `pad` and its peer. The caller owns a reference
     * on the resulting caps.
     */
    get_allowed_caps(): Caps | null
    /**
     * Gets the capabilities currently configured on `pad` with the last
     * #GST_EVENT_CAPS event.
     */
    get_current_caps(): Caps | null
    /**
     * Gets the direction of the pad. The direction of the pad is
     * decided at construction time so this function does not take
     * the LOCK.
     */
    get_direction(): PadDirection
    /**
     * Gets the private data of a pad.
     * No locking is performed in this function.
     */
    get_element_private(): object | null
    /**
     * Gets the #GstFlowReturn return from the last data passed by this pad.
     */
    get_last_flow_return(): FlowReturn
    /**
     * Get the offset applied to the running time of `pad`. `pad` has to be a source
     * pad.
     */
    get_offset(): number
    /**
     * Gets the template for `pad`.
     */
    get_pad_template(): PadTemplate | null
    /**
     * Gets the capabilities for `pad'`s template.
     */
    get_pad_template_caps(): Caps
    /**
     * Gets the parent of `pad,` cast to a #GstElement. If a `pad` has no parent or
     * its parent is not an element, return %NULL.
     */
    get_parent_element(): Element | null
    /**
     * Gets the peer of `pad`. This function refs the peer pad so
     * you need to unref it after use.
     */
    get_peer(): Pad | null
    /**
     * When `pad` is flushing this function returns #GST_FLOW_FLUSHING
     * immediately and `buffer` is %NULL.
     * 
     * Calls the getrange function of `pad,` see #GstPadGetRangeFunction for a
     * description of a getrange function. If `pad` has no getrange function
     * installed (see gst_pad_set_getrange_function()) this function returns
     * #GST_FLOW_NOT_SUPPORTED.
     * 
     * If `buffer` points to a variable holding %NULL, a valid new #GstBuffer will be
     * placed in `buffer` when this function returns #GST_FLOW_OK. The new buffer
     * must be freed with gst_buffer_unref() after usage.
     * 
     * When `buffer` points to a variable that points to a valid #GstBuffer, the
     * buffer will be filled with the result data when this function returns
     * #GST_FLOW_OK. If the provided buffer is larger than `size,` only
     * `size` bytes will be filled in the result buffer and its size will be updated
     * accordingly.
     * 
     * Note that less than `size` bytes can be returned in `buffer` when, for example,
     * an EOS condition is near or when `buffer` is not large enough to hold `size`
     * bytes. The caller should check the result buffer size to get the result size.
     * 
     * When this function returns any other result value than #GST_FLOW_OK, `buffer`
     * will be unchanged.
     * 
     * This is a lowlevel function. Usually gst_pad_pull_range() is used.
     * @param offset The start offset of the buffer
     * @param size The length of the buffer
     */
    get_range(offset: number, size: number): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * If there is a single internal link of the given pad, this function will
     * return it. Otherwise, it will return NULL.
     */
    get_single_internal_link(): Pad | null
    /**
     * Returns a new reference of the sticky event of type `event_type`
     * from the event.
     * @param event_type the #GstEventType that should be retrieved.
     * @param idx the index of the event
     */
    get_sticky_event(event_type: EventType, idx: number): Event | null
    /**
     * Returns the current #GstStream for the `pad,` or %NULL if none has been
     * set yet, i.e. the pad has not received a stream-start event yet.
     * 
     * This is a convenience wrapper around gst_pad_get_sticky_event() and
     * gst_event_parse_stream().
     */
    get_stream(): Stream | null
    /**
     * Returns the current stream-id for the `pad,` or %NULL if none has been
     * set yet, i.e. the pad has not received a stream-start event yet.
     * 
     * This is a convenience wrapper around gst_pad_get_sticky_event() and
     * gst_event_parse_stream_start().
     * 
     * The returned stream-id string should be treated as an opaque string, its
     * contents should not be interpreted.
     */
    get_stream_id(): string | null
    /**
     * Get `pad` task state. If no task is currently
     * set, #GST_TASK_STOPPED is returned.
     */
    get_task_state(): TaskState
    /**
     * Check if `pad` has caps set on it with a #GST_EVENT_CAPS event.
     */
    has_current_caps(): boolean
    /**
     * Query if a pad is active
     */
    is_active(): boolean
    /**
     * Checks if the pad is blocked or not. This function returns the
     * last requested state of the pad. It is not certain that the pad
     * is actually blocking at this point (see gst_pad_is_blocking()).
     */
    is_blocked(): boolean
    /**
     * Checks if the pad is blocking or not. This is a guaranteed state
     * of whether the pad is actually blocking on a #GstBuffer or a #GstEvent.
     */
    is_blocking(): boolean
    /**
     * Checks if a `pad` is linked to another pad or not.
     */
    is_linked(): boolean
    /**
     * Gets an iterator for the pads to which the given pad is linked to inside
     * of the parent element.
     * 
     * Each #GstPad element yielded by the iterator will have its refcount increased,
     * so unref after use.
     * 
     * Free-function: gst_iterator_free
     */
    iterate_internal_links(): Iterator | null
    /**
     * Iterate the list of pads to which the given pad is linked to inside of
     * the parent element.
     * This is the default handler, and thus returns an iterator of all of the
     * pads inside the parent element with opposite direction.
     * 
     * The caller must free this iterator after use with gst_iterator_free().
     * @param parent the parent of `pad` or %NULL
     */
    iterate_internal_links_default(parent?: Object | null): Iterator | null
    /**
     * Links the source pad and the sink pad.
     * @param sinkpad the sink #GstPad to link.
     */
    link(sinkpad: Pad): PadLinkReturn
    /**
     * Links the source pad and the sink pad.
     * 
     * This variant of #gst_pad_link provides a more granular control on the
     * checks being done when linking. While providing some considerable speedups
     * the caller of this method must be aware that wrong usage of those flags
     * can cause severe issues. Refer to the documentation of #GstPadLinkCheck
     * for more information.
     * 
     * MT Safe.
     * @param sinkpad the sink #GstPad to link.
     * @param flags the checks to validate when linking
     */
    link_full(sinkpad: Pad, flags: PadLinkCheck): PadLinkReturn
    /**
     * Links `src` to `sink,` creating any #GstGhostPad's in between as necessary.
     * 
     * This is a convenience function to save having to create and add intermediate
     * #GstGhostPad's as required for linking across #GstBin boundaries.
     * 
     * If `src` or `sink` pads don't have parent elements or do not share a common
     * ancestor, the link will fail.
     * @param sink a #GstPad
     */
    link_maybe_ghosting(sink: Pad): boolean
    /**
     * Links `src` to `sink,` creating any #GstGhostPad's in between as necessary.
     * 
     * This is a convenience function to save having to create and add intermediate
     * #GstGhostPad's as required for linking across #GstBin boundaries.
     * 
     * If `src` or `sink` pads don't have parent elements or do not share a common
     * ancestor, the link will fail.
     * 
     * Calling gst_pad_link_maybe_ghosting_full() with
     * `flags` == %GST_PAD_LINK_CHECK_DEFAULT is the recommended way of linking
     * pads with safety checks applied.
     * @param sink a #GstPad
     * @param flags some #GstPadLinkCheck flags
     */
    link_maybe_ghosting_full(sink: Pad, flags: PadLinkCheck): boolean
    /**
     * Mark a pad for needing reconfiguration. The next call to
     * gst_pad_check_reconfigure() will return %TRUE after this call.
     */
    mark_reconfigure(): void
    /**
     * Check the #GST_PAD_FLAG_NEED_RECONFIGURE flag on `pad` and return %TRUE
     * if the flag was set.
     */
    needs_reconfigure(): boolean
    /**
     * Pause the task of `pad`. This function will also wait until the
     * function executed by the task is finished if this function is not
     * called from the task function.
     */
    pause_task(): boolean
    /**
     * Performs gst_pad_query() on the peer of `pad`.
     * 
     * The caller is responsible for both the allocation and deallocation of
     * the query structure.
     * @param query the #GstQuery to perform.
     */
    peer_query(query: Query): boolean
    /**
     * Check if the peer of `pad` accepts `caps`. If `pad` has no peer, this function
     * returns %TRUE.
     * @param caps a #GstCaps to check on the pad
     */
    peer_query_accept_caps(caps: Caps): boolean
    /**
     * Gets the capabilities of the peer connected to this pad. Similar to
     * gst_pad_query_caps().
     * 
     * When called on srcpads `filter` contains the caps that
     * upstream could produce in the order preferred by upstream. When
     * called on sinkpads `filter` contains the caps accepted by
     * downstream in the preferred order. `filter` might be %NULL but
     * if it is not %NULL the returned caps will be a subset of `filter`.
     * @param filter a #GstCaps filter, or %NULL.
     */
    peer_query_caps(filter?: Caps | null): Caps
    /**
     * Queries the peer pad of a given sink pad to convert `src_val` in `src_format`
     * to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    peer_query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Queries the peer pad of a given sink pad for the total stream duration.
     * @param format the #GstFormat requested
     */
    peer_query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries the peer of a given sink pad for the stream position.
     * @param format the #GstFormat requested
     */
    peer_query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Checks if all internally linked pads of `pad` accepts the caps in `query` and
     * returns the intersection of the results.
     * 
     * This function is useful as a default accept caps query function for an element
     * that can handle any stream format, but requires caps that are acceptable for
     * all opposite pads.
     * @param query an ACCEPT_CAPS #GstQuery.
     */
    proxy_query_accept_caps(query: Query): boolean
    /**
     * Calls gst_pad_query_caps() for all internally linked pads of `pad` and returns
     * the intersection of the results.
     * 
     * This function is useful as a default caps query function for an element
     * that can handle any stream format, but requires all its pads to have
     * the same caps.  Two such elements are tee and adder.
     * @param query a CAPS #GstQuery.
     */
    proxy_query_caps(query: Query): boolean
    /**
     * Pulls a `buffer` from the peer pad or fills up a provided buffer.
     * 
     * This function will first trigger the pad block signal if it was
     * installed.
     * 
     * When `pad` is not linked #GST_FLOW_NOT_LINKED is returned else this
     * function returns the result of gst_pad_get_range() on the peer pad.
     * See gst_pad_get_range() for a list of return values and for the
     * semantics of the arguments of this function.
     * 
     * If `buffer` points to a variable holding %NULL, a valid new #GstBuffer will be
     * placed in `buffer` when this function returns #GST_FLOW_OK. The new buffer
     * must be freed with gst_buffer_unref() after usage. When this function
     * returns any other result value, `buffer` will still point to %NULL.
     * 
     * When `buffer` points to a variable that points to a valid #GstBuffer, the
     * buffer will be filled with the result data when this function returns
     * #GST_FLOW_OK. When this function returns any other result value,
     * `buffer` will be unchanged. If the provided buffer is larger than `size,` only
     * `size` bytes will be filled in the result buffer and its size will be updated
     * accordingly.
     * 
     * Note that less than `size` bytes can be returned in `buffer` when, for example,
     * an EOS condition is near or when `buffer` is not large enough to hold `size`
     * bytes. The caller should check the result buffer size to get the result size.
     * @param offset The start offset of the buffer
     * @param size The length of the buffer
     */
    pull_range(offset: number, size: number): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * Pushes a buffer to the peer of `pad`.
     * 
     * This function will call installed block probes before triggering any
     * installed data probes.
     * 
     * The function proceeds calling gst_pad_chain() on the peer pad and returns
     * the value from that function. If `pad` has no peer, #GST_FLOW_NOT_LINKED will
     * be returned.
     * 
     * In all cases, success or failure, the caller loses its reference to `buffer`
     * after calling this function.
     * @param buffer the #GstBuffer to push returns GST_FLOW_ERROR     if not.
     */
    push(buffer: Buffer): FlowReturn
    /**
     * Sends the event to the peer of the given pad. This function is
     * mainly used by elements to send events to their peer
     * elements.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * @param event the #GstEvent to send to the pad.
     */
    push_event(event: Event): boolean
    /**
     * Pushes a buffer list to the peer of `pad`.
     * 
     * This function will call installed block probes before triggering any
     * installed data probes.
     * 
     * The function proceeds calling the chain function on the peer pad and returns
     * the value from that function. If `pad` has no peer, #GST_FLOW_NOT_LINKED will
     * be returned. If the peer pad does not have any installed chainlist function
     * every group buffer of the list will be merged into a normal #GstBuffer and
     * chained via gst_pad_chain().
     * 
     * In all cases, success or failure, the caller loses its reference to `list`
     * after calling this function.
     * @param list the #GstBufferList to push returns GST_FLOW_ERROR     if not.
     */
    push_list(list: BufferList): FlowReturn
    /**
     * Dispatches a query to a pad. The query should have been allocated by the
     * caller via one of the type-specific allocation functions. The element that
     * the pad belongs to is responsible for filling the query with an appropriate
     * response, which should then be parsed with a type-specific query parsing
     * function.
     * 
     * Again, the caller is responsible for both the allocation and deallocation of
     * the query structure.
     * 
     * Please also note that some queries might need a running pipeline to work.
     * @param query the #GstQuery to perform.
     */
    query(query: Query): boolean
    /**
     * Check if the given pad accepts the caps.
     * @param caps a #GstCaps to check on the pad
     */
    query_accept_caps(caps: Caps): boolean
    /**
     * Gets the capabilities this pad can produce or consume.
     * Note that this method doesn't necessarily return the caps set by sending a
     * gst_event_new_caps() - use gst_pad_get_current_caps() for that instead.
     * gst_pad_query_caps returns all possible caps a pad can operate with, using
     * the pad's CAPS query function, If the query fails, this function will return
     * `filter,` if not %NULL, otherwise ANY.
     * 
     * When called on sinkpads `filter` contains the caps that
     * upstream could produce in the order preferred by upstream. When
     * called on srcpads `filter` contains the caps accepted by
     * downstream in the preferred order. `filter` might be %NULL but
     * if it is not %NULL the returned caps will be a subset of `filter`.
     * 
     * Note that this function does not return writable #GstCaps, use
     * gst_caps_make_writable() before modifying the caps.
     * @param filter suggested #GstCaps, or %NULL
     */
    query_caps(filter?: Caps | null): Caps
    /**
     * Queries a pad to convert `src_val` in `src_format` to `dest_format`.
     * @param src_format a #GstFormat to convert from.
     * @param src_val a value to convert.
     * @param dest_format the #GstFormat to convert to.
     */
    query_convert(src_format: Format, src_val: number, dest_format: Format): [ /* returnType */ boolean, /* dest_val */ number ]
    /**
     * Invokes the default query handler for the given pad.
     * The query is sent to all pads internally linked to `pad`. Note that
     * if there are many possible sink pads that are internally linked to
     * `pad,` only one will be sent the query.
     * Multi-sinkpad elements should implement custom query handlers.
     * @param parent the parent of `pad` or %NULL
     * @param query the #GstQuery to handle.
     */
    query_default(parent: Object | null, query: Query): boolean
    /**
     * Queries a pad for the total stream duration.
     * @param format the #GstFormat requested
     */
    query_duration(format: Format): [ /* returnType */ boolean, /* duration */ number | null ]
    /**
     * Queries a pad for the stream position.
     * @param format the #GstFormat requested
     */
    query_position(format: Format): [ /* returnType */ boolean, /* cur */ number | null ]
    /**
     * Remove the probe with `id` from `pad`.
     * 
     * MT safe.
     * @param id the probe id to remove
     */
    remove_probe(id: number): void
    /**
     * Sends the event to the pad. This function can be used
     * by applications to send events in the pipeline.
     * 
     * If `pad` is a source pad, `event` should be an upstream event. If `pad` is a
     * sink pad, `event` should be a downstream event. For example, you would not
     * send a #GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
     * Furthermore, some downstream events have to be serialized with data flow,
     * like EOS, while some can travel out-of-band, like #GST_EVENT_FLUSH_START. If
     * the event needs to be serialized with data flow, this function will take the
     * pad's stream lock while calling its event function.
     * 
     * To find out whether an event type is upstream, downstream, or downstream and
     * serialized, see #GstEventTypeFlags, gst_event_type_get_flags(),
     * #GST_EVENT_IS_UPSTREAM, #GST_EVENT_IS_DOWNSTREAM, and
     * #GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
     * plugin doesn't need to bother itself with this information; the core handles
     * all necessary locks and checks.
     * 
     * This function takes ownership of the provided event so you should
     * gst_event_ref() it if you want to reuse the event after this call.
     * @param event the #GstEvent to send to the pad.
     */
    send_event(event: Event): boolean
    /**
     * Sets the given activate function for `pad`. The activate function will
     * dispatch to gst_pad_activate_mode() to perform the actual activation.
     * Only makes sense to set on sink pads.
     * 
     * Call this function if your sink pad can start a pull-based task.
     * @param activate the #GstPadActivateFunction to set.
     */
    set_activate_function_full(activate: PadActivateFunction): void
    /**
     * Sets the given activate_mode function for the pad. An activate_mode function
     * prepares the element for data passing.
     * @param activatemode the #GstPadActivateModeFunction to set.
     */
    set_activatemode_function_full(activatemode: PadActivateModeFunction): void
    /**
     * Activates or deactivates the given pad.
     * Normally called from within core state change functions.
     * 
     * If `active,` makes sure the pad is active. If it is already active, either in
     * push or pull mode, just return. Otherwise dispatches to the pad's activate
     * function to perform the actual activation.
     * 
     * If not `active,` calls gst_pad_activate_mode() with the pad's current mode
     * and a %FALSE argument.
     * @param active whether or not the pad should be active.
     */
    set_active(active: boolean): boolean
    /**
     * Sets the given chain function for the pad. The chain function is called to
     * process a #GstBuffer input buffer. see #GstPadChainFunction for more details.
     * @param chain the #GstPadChainFunction to set.
     */
    set_chain_function_full(chain: PadChainFunction): void
    /**
     * Sets the given chain list function for the pad. The chainlist function is
     * called to process a #GstBufferList input buffer list. See
     * #GstPadChainListFunction for more details.
     * @param chainlist the #GstPadChainListFunction to set.
     */
    set_chain_list_function_full(chainlist: PadChainListFunction): void
    /**
     * Set the given private data gpointer on the pad.
     * This function can only be used by the element that owns the pad.
     * No locking is performed in this function.
     * @param priv The private data to attach to the pad.
     */
    set_element_private(priv?: object | null): void
    /**
     * Sets the given event handler for the pad.
     * @param event the #GstPadEventFullFunction to set.
     */
    set_event_full_function_full(event: PadEventFullFunction): void
    /**
     * Sets the given event handler for the pad.
     * @param event the #GstPadEventFunction to set.
     */
    set_event_function_full(event: PadEventFunction): void
    /**
     * Sets the given getrange function for the pad. The getrange function is
     * called to produce a new #GstBuffer to start the processing pipeline. see
     * #GstPadGetRangeFunction for a description of the getrange function.
     * @param get the #GstPadGetRangeFunction to set.
     */
    set_getrange_function_full(get: PadGetRangeFunction): void
    /**
     * Sets the given internal link iterator function for the pad.
     * @param iterintlink the #GstPadIterIntLinkFunction to set.
     */
    set_iterate_internal_links_function_full(iterintlink: PadIterIntLinkFunction): void
    /**
     * Sets the given link function for the pad. It will be called when
     * the pad is linked with another pad.
     * 
     * The return value #GST_PAD_LINK_OK should be used when the connection can be
     * made.
     * 
     * The return value #GST_PAD_LINK_REFUSED should be used when the connection
     * cannot be made for some reason.
     * 
     * If `link` is installed on a source pad, it should call the #GstPadLinkFunction
     * of the peer sink pad, if present.
     * @param link the #GstPadLinkFunction to set.
     */
    set_link_function_full(link: PadLinkFunction): void
    /**
     * Set the offset that will be applied to the running time of `pad`.
     * @param offset the offset
     */
    set_offset(offset: number): void
    /**
     * Set the given query function for the pad.
     * @param query the #GstPadQueryFunction to set.
     */
    set_query_function_full(query: PadQueryFunction): void
    /**
     * Sets the given unlink function for the pad. It will be called
     * when the pad is unlinked.
     * 
     * Note that the pad's lock is already held when the unlink
     * function is called, so most pad functions cannot be called
     * from within the callback.
     * @param unlink the #GstPadUnlinkFunction to set.
     */
    set_unlink_function_full(unlink: PadUnlinkFunction): void
    /**
     * Starts a task that repeatedly calls `func` with `user_data`. This function
     * is mostly used in pad activation functions to start the dataflow.
     * The #GST_PAD_STREAM_LOCK of `pad` will automatically be acquired
     * before `func` is called.
     * @param func the task function to call
     */
    start_task(func: TaskFunction): boolean
    /**
     * Iterates all sticky events on `pad` and calls `foreach_func` for every
     * event. If `foreach_func` returns %FALSE the iteration is immediately stopped.
     * @param foreach_func the #GstPadStickyEventsForeachFunction that                should be called for every event.
     */
    sticky_events_foreach(foreach_func: PadStickyEventsForeachFunction): void
    /**
     * Stop the task of `pad`. This function will also make sure that the
     * function executed by the task will effectively stop if not called
     * from the GstTaskFunction.
     * 
     * This function will deadlock if called from the GstTaskFunction of
     * the task. Use gst_task_pause() instead.
     * 
     * Regardless of whether the pad has a task, the stream lock is acquired and
     * released so as to ensure that streaming through this pad has finished.
     */
    stop_task(): boolean
    /**
     * Store the sticky `event` on `pad`
     * @param event a #GstEvent
     */
    store_sticky_event(event: Event): FlowReturn
    /**
     * Unlinks the source pad from the sink pad. Will emit the #GstPad::unlinked
     * signal on both pads.
     * @param sinkpad the sink #GstPad to unlink.
     */
    unlink(sinkpad: Pad): boolean
    /**
     * A helper function you can use that sets the FIXED_CAPS flag
     * This way the default CAPS query will always return the negotiated caps
     * or in case the pad is not negotiated, the padtemplate caps.
     * 
     * The negotiated caps are the caps of the last CAPS event that passed on the
     * pad. Use this function on a pad that, once it negotiated to a CAPS, cannot
     * be renegotiated to something else.
     */
    use_fixed_caps(): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Pad */
    vfunc_linked(peer: Pad): void
    vfunc_unlinked(peer: Pad): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Pad */
    /**
     * Signals that a pad has been linked to the peer pad.
     * @param peer the peer pad that has been connected
     */
    connect(sigName: "linked", callback: (($obj: ProxyPad, peer: Pad) => void)): number
    connect_after(sigName: "linked", callback: (($obj: ProxyPad, peer: Pad) => void)): number
    emit(sigName: "linked", peer: Pad): void
    /**
     * Signals that a pad has been unlinked from the peer pad.
     * @param peer the peer pad that has been disconnected
     */
    connect(sigName: "unlinked", callback: (($obj: ProxyPad, peer: Pad) => void)): number
    connect_after(sigName: "unlinked", callback: (($obj: ProxyPad, peer: Pad) => void)): number
    emit(sigName: "unlinked", peer: Pad): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: ProxyPad, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: ProxyPad, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::caps", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caps", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::offset", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::offset", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::template", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::template", callback: (($obj: ProxyPad, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ProxyPad_ConstructProps)
    _init (config?: ProxyPad_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Invoke the default chain function of the proxy pad.
     * @param pad a sink #GstPad, returns GST_FLOW_ERROR if not.
     * @param parent the parent of `pad` or %NULL
     * @param buffer the #GstBuffer to send, return GST_FLOW_ERROR     if not.
     */
    static chain_default(pad: Pad, parent: Object | null, buffer: Buffer): FlowReturn
    /**
     * Invoke the default chain list function of the proxy pad.
     * @param pad a sink #GstPad, returns GST_FLOW_ERROR if not.
     * @param parent the parent of `pad` or %NULL
     * @param list the #GstBufferList to send, return GST_FLOW_ERROR     if not.
     */
    static chain_list_default(pad: Pad, parent: Object | null, list: BufferList): FlowReturn
    /**
     * Invoke the default getrange function of the proxy pad.
     * @param pad a src #GstPad, returns #GST_FLOW_ERROR if not.
     * @param parent the parent of `pad`
     * @param offset The start offset of the buffer
     * @param size The length of the buffer
     */
    static getrange_default(pad: Pad, parent: Object, offset: number, size: number): [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    /**
     * Invoke the default iterate internal links function of the proxy pad.
     * @param pad the #GstPad to get the internal links of.
     * @param parent the parent of `pad` or %NULL
     */
    static iterate_internal_links_default(pad: Pad, parent?: Object | null): Iterator | null
    static $gtype: GObject.Type
}
interface Registry_ConstructProps extends Object_ConstructProps {
}
class Registry {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Registry */
    /**
     * Add the feature to the registry. The feature-added signal will be emitted.
     * 
     * `feature'`s reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param feature the feature to add
     */
    add_feature(feature: PluginFeature): boolean
    /**
     * Add the plugin to the registry. The plugin-added signal will be emitted.
     * 
     * `plugin'`s reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param plugin the plugin to add
     */
    add_plugin(plugin: Plugin): boolean
    /**
     * Checks whether a plugin feature by the given name exists in
     * `registry` and whether its version is at least the
     * version required.
     * @param feature_name the name of the feature (e.g. "oggdemux")
     * @param min_major the minimum major version number
     * @param min_minor the minimum minor version number
     * @param min_micro the minimum micro version number
     */
    check_feature_version(feature_name: string, min_major: number, min_minor: number, min_micro: number): boolean
    /**
     * Runs a filter against all features of the plugins in the registry
     * and returns a GList with the results.
     * If the first flag is set, only the first match is
     * returned (as a list with a single object).
     * @param filter the filter to use
     * @param first only return first match
     */
    feature_filter(filter: PluginFeatureFilter, first: boolean): PluginFeature[]
    /**
     * Find the pluginfeature with the given name and type in the registry.
     * @param name the pluginfeature name to find
     * @param type the pluginfeature type to find
     */
    find_feature(name: string, type: GObject.Type): PluginFeature | null
    /**
     * Find the plugin with the given name in the registry.
     * The plugin will be reffed; caller is responsible for unreffing.
     * @param name the plugin name to find
     */
    find_plugin(name: string): Plugin | null
    /**
     * Retrieves a #GList of #GstPluginFeature of `type`.
     * @param type a #GType.
     */
    get_feature_list(type: GObject.Type): PluginFeature[]
    /**
     * Retrieves a #GList of features of the plugin with name `name`.
     * @param name a plugin name.
     */
    get_feature_list_by_plugin(name: string): PluginFeature[]
    /**
     * Returns the registry's feature list cookie. This changes
     * every time a feature is added or removed from the registry.
     */
    get_feature_list_cookie(): number
    /**
     * Get a copy of all plugins registered in the given registry. The refcount
     * of each element in the list in incremented.
     */
    get_plugin_list(): Plugin[]
    /**
     * Look up a plugin in the given registry with the given filename.
     * If found, plugin is reffed.
     * @param filename the name of the file to look up
     */
    lookup(filename: string): Plugin | null
    /**
     * Find a #GstPluginFeature with `name` in `registry`.
     * @param name a #GstPluginFeature name
     */
    lookup_feature(name: string): PluginFeature | null
    /**
     * Runs a filter against all plugins in the registry and returns a #GList with
     * the results. If the first flag is set, only the first match is
     * returned (as a list with a single object).
     * Every plugin is reffed; use gst_plugin_list_free() after use, which
     * will unref again.
     * @param filter the filter to use
     * @param first only return first match
     */
    plugin_filter(filter: PluginFilter, first: boolean): Plugin[]
    /**
     * Remove the feature from the registry.
     * 
     * MT safe.
     * @param feature the feature to remove
     */
    remove_feature(feature: PluginFeature): void
    /**
     * Remove the plugin from the registry.
     * 
     * MT safe.
     * @param plugin the plugin to remove
     */
    remove_plugin(plugin: Plugin): void
    /**
     * Scan the given path for plugins to add to the registry. The syntax of the
     * path is specific to the registry.
     * @param path the path to scan
     */
    scan_path(path: string): boolean
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Registry */
    /**
     * Signals that a feature has been added to the registry (possibly
     * replacing a previously-added one by the same name)
     * @param feature the feature that has been added
     */
    connect(sigName: "feature-added", callback: (($obj: Registry, feature: PluginFeature) => void)): number
    connect_after(sigName: "feature-added", callback: (($obj: Registry, feature: PluginFeature) => void)): number
    emit(sigName: "feature-added", feature: PluginFeature): void
    /**
     * Signals that a plugin has been added to the registry (possibly
     * replacing a previously-added one by the same name)
     * @param plugin the plugin that has been added
     */
    connect(sigName: "plugin-added", callback: (($obj: Registry, plugin: Plugin) => void)): number
    connect_after(sigName: "plugin-added", callback: (($obj: Registry, plugin: Plugin) => void)): number
    emit(sigName: "plugin-added", plugin: Plugin): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Registry, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Registry, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Registry, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Registry, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Registry_ConstructProps)
    _init (config?: Registry_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * By default GStreamer will perform scanning and rebuilding of the
     * registry file using a helper child process.
     * 
     * Applications might want to disable this behaviour with the
     * gst_registry_fork_set_enabled() function, in which case new plugins
     * are scanned (and loaded) into the application process.
     */
    static fork_is_enabled(): boolean
    /**
     * Applications might want to disable/enable spawning of a child helper process
     * when rebuilding the registry. See gst_registry_fork_is_enabled() for more
     * information.
     * @param enabled whether rebuilding the registry can use a temporary child helper process.
     */
    static fork_set_enabled(enabled: boolean): void
    /**
     * Retrieves the singleton plugin registry. The caller does not own a
     * reference on the registry, as it is alive as long as GStreamer is
     * initialized.
     */
    static get(): Registry
    static $gtype: GObject.Type
}
interface SharedTaskPool_ConstructProps extends TaskPool_ConstructProps {
}
class SharedTaskPool {
    /* Fields of Gst-1.0.Gst.TaskPool */
    object: Object
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.SharedTaskPool */
    get_max_threads(): number
    /**
     * Update the maximal number of threads the `pool` may spawn. When
     * the maximal number of threads is reduced, existing threads are not
     * immediately shut down, see g_thread_pool_set_max_threads().
     * 
     * Setting `max_threads` to 0 effectively freezes the pool.
     * @param max_threads Maximum number of threads to spawn.
     */
    set_max_threads(max_threads: number): void
    /* Methods of Gst-1.0.Gst.TaskPool */
    /**
     * Wait for all tasks to be stopped. This is mainly used internally
     * to ensure proper cleanup of internal data structures in test suites.
     * 
     * MT safe.
     */
    cleanup(): void
    /**
     * Dispose of the handle returned by gst_task_pool_push(). This does
     * not need to be called with the default implementation as the default
     * #GstTaskPoolClass::push implementation always returns %NULL. This does not need to be
     * called either when calling gst_task_pool_join(), but should be called
     * when joining is not necessary, but gst_task_pool_push() returned a
     * non-%NULL value.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    dispose_handle(id?: object | null): void
    /**
     * Join a task and/or return it to the pool. `id` is the id obtained from
     * gst_task_pool_push(). The default implementation does nothing, as the
     * default #GstTaskPoolClass::push implementation always returns %NULL.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    join(id?: object | null): void
    /**
     * Prepare the taskpool for accepting gst_task_pool_push() operations.
     * 
     * MT safe.
     */
    prepare(): void
    /**
     * Start the execution of a new thread from `pool`.
     * @param func the function to call
     */
    push(func: TaskPoolFunction): object | null
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.TaskPool */
    /**
     * Wait for all tasks to be stopped. This is mainly used internally
     * to ensure proper cleanup of internal data structures in test suites.
     * 
     * MT safe.
     */
    vfunc_cleanup(): void
    /**
     * Dispose of the handle returned by gst_task_pool_push(). This does
     * not need to be called with the default implementation as the default
     * #GstTaskPoolClass::push implementation always returns %NULL. This does not need to be
     * called either when calling gst_task_pool_join(), but should be called
     * when joining is not necessary, but gst_task_pool_push() returned a
     * non-%NULL value.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    vfunc_dispose_handle(id?: object | null): void
    /**
     * Join a task and/or return it to the pool. `id` is the id obtained from
     * gst_task_pool_push(). The default implementation does nothing, as the
     * default #GstTaskPoolClass::push implementation always returns %NULL.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    vfunc_join(id?: object | null): void
    /**
     * Prepare the taskpool for accepting gst_task_pool_push() operations.
     * 
     * MT safe.
     */
    vfunc_prepare(): void
    /**
     * Start the execution of a new thread from `pool`.
     * @param func the function to call
     */
    vfunc_push(func: TaskPoolFunction): object | null
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: SharedTaskPool, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: SharedTaskPool, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: SharedTaskPool, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SharedTaskPool, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SharedTaskPool_ConstructProps)
    _init (config?: SharedTaskPool_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SharedTaskPool
    static $gtype: GObject.Type
}
interface Stream_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Stream */
    /**
     * The #GstCaps of the #GstStream.
     */
    caps?: Caps
    stream_flags?: StreamFlags
    /**
     * The unique identifier of the #GstStream. Can only be set at construction
     * time.
     */
    stream_id?: string
    /**
     * The #GstStreamType of the #GstStream. Can only be set at construction time.
     */
    stream_type?: StreamType
    /**
     * The #GstTagList of the #GstStream.
     */
    tags?: TagList
}
class Stream {
    /* Properties of Gst-1.0.Gst.Stream */
    /**
     * The #GstCaps of the #GstStream.
     */
    caps: Caps
    stream_flags: StreamFlags
    /**
     * The unique identifier of the #GstStream. Can only be set at construction
     * time.
     */
    readonly stream_id: string
    /**
     * The #GstStreamType of the #GstStream. Can only be set at construction time.
     */
    stream_type: StreamType
    /**
     * The #GstTagList of the #GstStream.
     */
    tags: TagList
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Stream */
    /**
     * Retrieve the caps for `stream,` if any
     */
    get_caps(): Caps | null
    /**
     * Retrieve the current stream flags for `stream`
     */
    get_stream_flags(): StreamFlags
    /**
     * Returns the stream ID of `stream`.
     */
    get_stream_id(): string | null
    /**
     * Retrieve the stream type for `stream`
     */
    get_stream_type(): StreamType
    /**
     * Retrieve the tags for `stream,` if any
     */
    get_tags(): TagList | null
    /**
     * Set the caps for the #GstStream
     * @param caps a #GstCaps
     */
    set_caps(caps?: Caps | null): void
    /**
     * Set the `flags` for the `stream`.
     * @param flags the flags to set on `stream`
     */
    set_stream_flags(flags: StreamFlags): void
    /**
     * Set the stream type of `stream`
     * @param stream_type the type to set on `stream`
     */
    set_stream_type(stream_type: StreamType): void
    /**
     * Set the tags for the #GstStream
     * @param tags a #GstTagList
     */
    set_tags(tags?: TagList | null): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Stream, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Stream, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::caps", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caps", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::stream-flags", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stream-flags", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::stream-id", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stream-id", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::stream-type", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stream-type", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tags", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tags", callback: (($obj: Stream, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Stream_ConstructProps)
    _init (config?: Stream_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(stream_id: string | null, caps: Caps | null, type: StreamType, flags: StreamFlags): Stream
    static $gtype: GObject.Type
}
interface StreamCollection_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.StreamCollection */
    upstream_id?: string
}
class StreamCollection {
    /* Properties of Gst-1.0.Gst.StreamCollection */
    upstream_id: string
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.StreamCollection */
    /**
     * Add the given `stream` to the `collection`.
     * @param stream the #GstStream to add
     */
    add_stream(stream: Stream): boolean
    /**
     * Get the number of streams this collection contains
     */
    get_size(): number
    /**
     * Retrieve the #GstStream with index `index` from the collection.
     * 
     * The caller should not modify the returned #GstStream
     * @param index Index of the stream to retrieve
     */
    get_stream(index: number): Stream | null
    /**
     * Returns the upstream id of the `collection`.
     */
    get_upstream_id(): string | null
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.StreamCollection */
    vfunc_stream_notify(stream: Stream, pspec: GObject.ParamSpec): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.StreamCollection */
    connect(sigName: "stream-notify", callback: (($obj: StreamCollection, object: Stream, p0: GObject.ParamSpec) => void)): number
    connect_after(sigName: "stream-notify", callback: (($obj: StreamCollection, object: Stream, p0: GObject.ParamSpec) => void)): number
    emit(sigName: "stream-notify", object: Stream, p0: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: StreamCollection, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: StreamCollection, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: StreamCollection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: StreamCollection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::upstream-id", callback: (($obj: StreamCollection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::upstream-id", callback: (($obj: StreamCollection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: StreamCollection_ConstructProps)
    _init (config?: StreamCollection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(upstream_id?: string | null): StreamCollection
    static $gtype: GObject.Type
}
interface SystemClock_ConstructProps extends Clock_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.SystemClock */
    clock_type?: ClockType
}
class SystemClock {
    /* Properties of Gst-1.0.Gst.SystemClock */
    clock_type: ClockType
    /* Properties of Gst-1.0.Gst.Clock */
    timeout: number
    window_size: number
    window_threshold: number
    /* Fields of Gst-1.0.Gst.Clock */
    /**
     * the parent structure
     */
    object: Object
    /* Fields of Gst-1.0.Gst.Object */
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Clock */
    /**
     * The time `master` of the master clock and the time `slave` of the slave
     * clock are added to the list of observations. If enough observations
     * are available, a linear regression algorithm is run on the
     * observations and `clock` is recalibrated.
     * 
     * If this functions returns %TRUE, `r_squared` will contain the
     * correlation coefficient of the interpolation. A value of 1.0
     * means a perfect regression was performed. This value can
     * be used to control the sampling frequency of the master and slave
     * clocks.
     * @param slave a time on the slave
     * @param master a time on the master
     */
    add_observation(slave: ClockTime, master: ClockTime): [ /* returnType */ boolean, /* r_squared */ number ]
    /**
     * Add a clock observation to the internal slaving algorithm the same as
     * gst_clock_add_observation(), and return the result of the master clock
     * estimation, without updating the internal calibration.
     * 
     * The caller can then take the results and call gst_clock_set_calibration()
     * with the values, or some modified version of them.
     * @param slave a time on the slave
     * @param master a time on the master
     */
    add_observation_unapplied(slave: ClockTime, master: ClockTime): [ /* returnType */ boolean, /* r_squared */ number, /* internal */ ClockTime | null, /* external */ ClockTime | null, /* rate_num */ ClockTime | null, /* rate_denom */ ClockTime | null ]
    /**
     * Converts the given `internal` clock time to the external time, adjusting for the
     * rate and reference time set with gst_clock_set_calibration() and making sure
     * that the returned time is increasing. This function should be called with the
     * clock's OBJECT_LOCK held and is mainly used by clock subclasses.
     * 
     * This function is the reverse of gst_clock_unadjust_unlocked().
     * @param internal a clock time
     */
    adjust_unlocked(internal: ClockTime): ClockTime
    /**
     * Converts the given `internal_target` clock time to the external time,
     * using the passed calibration parameters. This function performs the
     * same calculation as gst_clock_adjust_unlocked() when called using the
     * current calibration parameters, but doesn't ensure a monotonically
     * increasing result as gst_clock_adjust_unlocked() does.
     * 
     * Note: The `clock` parameter is unused and can be NULL
     * @param internal_target a clock time
     * @param cinternal a reference internal time
     * @param cexternal a reference external time
     * @param cnum the numerator of the rate of the clock relative to its        internal time
     * @param cdenom the denominator of the rate of the clock
     */
    adjust_with_calibration(internal_target: ClockTime, cinternal: ClockTime, cexternal: ClockTime, cnum: ClockTime, cdenom: ClockTime): ClockTime
    /**
     * Gets the internal rate and reference time of `clock`. See
     * gst_clock_set_calibration() for more information.
     * 
     * `internal,` `external,` `rate_num,` and `rate_denom` can be left %NULL if the
     * caller is not interested in the values.
     */
    get_calibration(): [ /* internal */ ClockTime | null, /* external */ ClockTime | null, /* rate_num */ ClockTime | null, /* rate_denom */ ClockTime | null ]
    /**
     * Gets the current internal time of the given clock. The time is returned
     * unadjusted for the offset and the rate.
     */
    get_internal_time(): ClockTime
    /**
     * Gets the master clock that `clock` is slaved to or %NULL when the clock is
     * not slaved to any master clock.
     */
    get_master(): Clock | null
    /**
     * Gets the accuracy of the clock. The accuracy of the clock is the granularity
     * of the values returned by gst_clock_get_time().
     */
    get_resolution(): ClockTime
    /**
     * Gets the current time of the given clock. The time is always
     * monotonically increasing and adjusted according to the current
     * offset and rate.
     */
    get_time(): ClockTime
    /**
     * Gets the amount of time that master and slave clocks are sampled.
     */
    get_timeout(): ClockTime
    /**
     * Checks if the clock is currently synced, by looking at whether
     * %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is set.
     */
    is_synced(): boolean
    /**
     * Gets an ID from `clock` to trigger a periodic notification.
     * The periodic notifications will start at time `start_time` and
     * will then be fired with the given `interval`.
     * @param start_time the requested start time
     * @param interval the requested interval
     */
    new_periodic_id(start_time: ClockTime, interval: ClockTime): ClockID
    /**
     * Gets a #GstClockID from `clock` to trigger a single shot
     * notification at the requested time.
     * @param time the requested time
     */
    new_single_shot_id(time: ClockTime): ClockID
    /**
     * Reinitializes the provided periodic `id` to the provided start time and
     * interval. Does not modify the reference count.
     * @param id a #GstClockID
     * @param start_time the requested start time
     * @param interval the requested interval
     */
    periodic_id_reinit(id: ClockID, start_time: ClockTime, interval: ClockTime): boolean
    /**
     * Adjusts the rate and time of `clock`. A rate of 1/1 is the normal speed of
     * the clock. Values bigger than 1/1 make the clock go faster.
     * 
     * `internal` and `external` are calibration parameters that arrange that
     * gst_clock_get_time() should have been `external` at internal time `internal`.
     * This internal time should not be in the future; that is, it should be less
     * than the value of gst_clock_get_internal_time() when this function is called.
     * 
     * Subsequent calls to gst_clock_get_time() will return clock times computed as
     * follows:
     * 
     * ``` C
     *   time = (internal_time - internal) * rate_num / rate_denom + external
     * ```
     * 
     * This formula is implemented in gst_clock_adjust_unlocked(). Of course, it
     * tries to do the integer arithmetic as precisely as possible.
     * 
     * Note that gst_clock_get_time() always returns increasing values so when you
     * move the clock backwards, gst_clock_get_time() will report the previous value
     * until the clock catches up.
     * @param internal a reference internal time
     * @param external a reference external time
     * @param rate_num the numerator of the rate of the clock relative to its            internal time
     * @param rate_denom the denominator of the rate of the clock
     */
    set_calibration(internal: ClockTime, external: ClockTime, rate_num: ClockTime, rate_denom: ClockTime): void
    /**
     * Sets `master` as the master clock for `clock`. `clock` will be automatically
     * calibrated so that gst_clock_get_time() reports the same time as the
     * master clock.
     * 
     * A clock provider that slaves its clock to a master can get the current
     * calibration values with gst_clock_get_calibration().
     * 
     * `master` can be %NULL in which case `clock` will not be slaved anymore. It will
     * however keep reporting its time adjusted with the last configured rate
     * and time offsets.
     * @param master a master #GstClock
     */
    set_master(master?: Clock | null): boolean
    /**
     * Sets the accuracy of the clock. Some clocks have the possibility to operate
     * with different accuracy at the expense of more resource usage. There is
     * normally no need to change the default resolution of a clock. The resolution
     * of a clock can only be changed if the clock has the
     * #GST_CLOCK_FLAG_CAN_SET_RESOLUTION flag set.
     * @param resolution The resolution to set
     */
    set_resolution(resolution: ClockTime): ClockTime
    /**
     * Sets `clock` to synced and emits the #GstClock::synced signal, and wakes up any
     * thread waiting in gst_clock_wait_for_sync().
     * 
     * This function must only be called if %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC
     * is set on the clock, and is intended to be called by subclasses only.
     * @param synced if the clock is synced
     */
    set_synced(synced: boolean): void
    /**
     * Sets the amount of time, in nanoseconds, to sample master and slave
     * clocks
     * @param timeout a timeout
     */
    set_timeout(timeout: ClockTime): void
    /**
     * Reinitializes the provided single shot `id` to the provided time. Does not
     * modify the reference count.
     * @param id a #GstClockID
     * @param time The requested time.
     */
    single_shot_id_reinit(id: ClockID, time: ClockTime): boolean
    /**
     * Converts the given `external` clock time to the internal time of `clock,`
     * using the rate and reference time set with gst_clock_set_calibration().
     * This function should be called with the clock's OBJECT_LOCK held and
     * is mainly used by clock subclasses.
     * 
     * This function is the reverse of gst_clock_adjust_unlocked().
     * @param external an external clock time
     */
    unadjust_unlocked(external: ClockTime): ClockTime
    /**
     * Converts the given `external_target` clock time to the internal time,
     * using the passed calibration parameters. This function performs the
     * same calculation as gst_clock_unadjust_unlocked() when called using the
     * current calibration parameters.
     * 
     * Note: The `clock` parameter is unused and can be NULL
     * @param external_target a clock time
     * @param cinternal a reference internal time
     * @param cexternal a reference external time
     * @param cnum the numerator of the rate of the clock relative to its        internal time
     * @param cdenom the denominator of the rate of the clock
     */
    unadjust_with_calibration(external_target: ClockTime, cinternal: ClockTime, cexternal: ClockTime, cnum: ClockTime, cdenom: ClockTime): ClockTime
    /**
     * Waits until `clock` is synced for reporting the current time. If `timeout`
     * is %GST_CLOCK_TIME_NONE it will wait forever, otherwise it will time out
     * after `timeout` nanoseconds.
     * 
     * For asynchronous waiting, the #GstClock::synced signal can be used.
     * 
     * This returns immediately with %TRUE if %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC
     * is not set on the clock, or if the clock is already synced.
     * @param timeout timeout for waiting or %GST_CLOCK_TIME_NONE
     */
    wait_for_sync(timeout: ClockTime): boolean
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Clock */
    /**
     * Change the resolution of the clock. Not all values might
     * be acceptable.
     * @param old_resolution the previous resolution
     * @param new_resolution the new resolution
     */
    vfunc_change_resolution(old_resolution: ClockTime, new_resolution: ClockTime): ClockTime
    /**
     * Gets the current internal time of the given clock. The time is returned
     * unadjusted for the offset and the rate.
     */
    vfunc_get_internal_time(): ClockTime
    /**
     * Gets the accuracy of the clock. The accuracy of the clock is the granularity
     * of the values returned by gst_clock_get_time().
     */
    vfunc_get_resolution(): ClockTime
    /**
     * Unblock a blocking or async wait operation.
     * @param entry the entry to unschedule
     */
    vfunc_unschedule(entry: ClockEntry): void
    /**
     * Perform a blocking wait on the given #GstClockEntry and return
     * the jitter.
     * @param entry the entry to wait on
     */
    vfunc_wait(entry: ClockEntry): [ /* returnType */ ClockReturn, /* jitter */ ClockTimeDiff | null ]
    /**
     * Perform an asynchronous wait on the given #GstClockEntry.
     * @param entry the entry to wait on
     */
    vfunc_wait_async(entry: ClockEntry): ClockReturn
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Clock */
    /**
     * Signaled on clocks with %GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC set once
     * the clock is synchronized, or when it completely lost synchronization.
     * This signal will not be emitted on clocks without the flag.
     * 
     * This signal will be emitted from an arbitrary thread, most likely not
     * the application's main thread.
     * @param synced if the clock is synced now
     */
    connect(sigName: "synced", callback: (($obj: SystemClock, synced: boolean) => void)): number
    connect_after(sigName: "synced", callback: (($obj: SystemClock, synced: boolean) => void)): number
    emit(sigName: "synced", synced: boolean): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: SystemClock, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: SystemClock, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::clock-type", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::clock-type", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::timeout", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeout", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::window-size", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::window-size", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::window-threshold", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::window-threshold", callback: (($obj: SystemClock, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SystemClock_ConstructProps)
    _init (config?: SystemClock_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Get a handle to the default system clock. The refcount of the
     * clock will be increased so you need to unref the clock after
     * usage.
     */
    static obtain(): Clock
    /**
     * Sets the default system clock that can be obtained with
     * gst_system_clock_obtain().
     * 
     * This is mostly used for testing and debugging purposes when you
     * want to have control over the time reported by the default system
     * clock.
     * 
     * MT safe.
     * @param new_clock a #GstClock
     */
    static set_default(new_clock?: Clock | null): void
    static $gtype: GObject.Type
}
interface Task_ConstructProps extends Object_ConstructProps {
}
class Task {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Task */
    /**
     * Get the #GstTaskPool that this task will use for its streaming
     * threads.
     * 
     * MT safe.
     */
    get_pool(): TaskPool
    /**
     * Get the current state of the task.
     */
    get_state(): TaskState
    /**
     * Joins `task`. After this call, it is safe to unref the task
     * and clean up the lock set with gst_task_set_lock().
     * 
     * The task will automatically be stopped with this call.
     * 
     * This function cannot be called from within a task function as this
     * would cause a deadlock. The function will detect this and print a
     * g_warning.
     */
    join(): boolean
    /**
     * Pauses `task`. This method can also be called on a task in the
     * stopped state, in which case a thread will be started and will remain
     * in the paused state. This function does not wait for the task to complete
     * the paused state.
     */
    pause(): boolean
    /**
     * Resume `task` in case it was paused. If the task was stopped, it will
     * remain in that state and this function will return %FALSE.
     */
    resume(): boolean
    /**
     * Call `enter_func` when the task function of `task` is entered. `user_data` will
     * be passed to `enter_func` and `notify` will be called when `user_data` is no
     * longer referenced.
     * @param enter_func a #GstTaskThreadFunc
     */
    set_enter_callback(enter_func: TaskThreadFunc): void
    /**
     * Call `leave_func` when the task function of `task` is left. `user_data` will
     * be passed to `leave_func` and `notify` will be called when `user_data` is no
     * longer referenced.
     * @param leave_func a #GstTaskThreadFunc
     */
    set_leave_callback(leave_func: TaskThreadFunc): void
    /**
     * Set the mutex used by the task. The mutex will be acquired before
     * calling the #GstTaskFunction.
     * 
     * This function has to be called before calling gst_task_pause() or
     * gst_task_start().
     * 
     * MT safe.
     * @param mutex The #GRecMutex to use
     */
    set_lock(mutex: GLib.RecMutex): void
    /**
     * Set `pool` as the new GstTaskPool for `task`. Any new streaming threads that
     * will be created by `task` will now use `pool`.
     * 
     * MT safe.
     * @param pool a #GstTaskPool
     */
    set_pool(pool: TaskPool): void
    /**
     * Sets the state of `task` to `state`.
     * 
     * The `task` must have a lock associated with it using
     * gst_task_set_lock() when going to GST_TASK_STARTED or GST_TASK_PAUSED or
     * this function will return %FALSE.
     * 
     * MT safe.
     * @param state the new task state
     */
    set_state(state: TaskState): boolean
    /**
     * Starts `task`. The `task` must have a lock associated with it using
     * gst_task_set_lock() or this function will return %FALSE.
     */
    start(): boolean
    /**
     * Stops `task`. This method merely schedules the task to stop and
     * will not wait for the task to have completely stopped. Use
     * gst_task_join() to stop and wait for completion.
     */
    stop(): boolean
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Task, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Task, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Task, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Task, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Task_ConstructProps)
    _init (config?: Task_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(func: TaskFunction): Task
    /**
     * Wait for all tasks to be stopped. This is mainly used internally
     * to ensure proper cleanup of internal data structures in test suites.
     * 
     * MT safe.
     */
    static cleanup_all(): void
    static $gtype: GObject.Type
}
interface TaskPool_ConstructProps extends Object_ConstructProps {
}
class TaskPool {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.TaskPool */
    /**
     * Wait for all tasks to be stopped. This is mainly used internally
     * to ensure proper cleanup of internal data structures in test suites.
     * 
     * MT safe.
     */
    cleanup(): void
    /**
     * Dispose of the handle returned by gst_task_pool_push(). This does
     * not need to be called with the default implementation as the default
     * #GstTaskPoolClass::push implementation always returns %NULL. This does not need to be
     * called either when calling gst_task_pool_join(), but should be called
     * when joining is not necessary, but gst_task_pool_push() returned a
     * non-%NULL value.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    dispose_handle(id?: object | null): void
    /**
     * Join a task and/or return it to the pool. `id` is the id obtained from
     * gst_task_pool_push(). The default implementation does nothing, as the
     * default #GstTaskPoolClass::push implementation always returns %NULL.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    join(id?: object | null): void
    /**
     * Prepare the taskpool for accepting gst_task_pool_push() operations.
     * 
     * MT safe.
     */
    prepare(): void
    /**
     * Start the execution of a new thread from `pool`.
     * @param func the function to call
     */
    push(func: TaskPoolFunction): object | null
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.TaskPool */
    /**
     * Wait for all tasks to be stopped. This is mainly used internally
     * to ensure proper cleanup of internal data structures in test suites.
     * 
     * MT safe.
     */
    vfunc_cleanup(): void
    /**
     * Dispose of the handle returned by gst_task_pool_push(). This does
     * not need to be called with the default implementation as the default
     * #GstTaskPoolClass::push implementation always returns %NULL. This does not need to be
     * called either when calling gst_task_pool_join(), but should be called
     * when joining is not necessary, but gst_task_pool_push() returned a
     * non-%NULL value.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    vfunc_dispose_handle(id?: object | null): void
    /**
     * Join a task and/or return it to the pool. `id` is the id obtained from
     * gst_task_pool_push(). The default implementation does nothing, as the
     * default #GstTaskPoolClass::push implementation always returns %NULL.
     * 
     * This method should only be called with the same `pool` instance that provided
     * `id`.
     * @param id the id
     */
    vfunc_join(id?: object | null): void
    /**
     * Prepare the taskpool for accepting gst_task_pool_push() operations.
     * 
     * MT safe.
     */
    vfunc_prepare(): void
    /**
     * Start the execution of a new thread from `pool`.
     * @param func the function to call
     */
    vfunc_push(func: TaskPoolFunction): object | null
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: TaskPool, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TaskPool, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: TaskPool, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TaskPool, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TaskPool_ConstructProps)
    _init (config?: TaskPool_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): TaskPool
    static $gtype: GObject.Type
}
interface Tracer_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of Gst-1.0.Gst.Tracer */
    params?: string
}
class Tracer {
    /* Properties of Gst-1.0.Gst.Tracer */
    params: string
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: Tracer, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: Tracer, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: Tracer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Tracer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::params", callback: (($obj: Tracer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::params", callback: (($obj: Tracer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Tracer_ConstructProps)
    _init (config?: Tracer_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Create a new tracer-factory  capable of instantiating objects of the
     * `type` and add the factory to `plugin`.
     * @param plugin A #GstPlugin, or %NULL for a static typefind function
     * @param name The name for registering
     * @param type GType of tracer to register
     */
    static register(plugin: Plugin | null, name: string, type: GObject.Type): boolean
    static $gtype: GObject.Type
}
interface TracerFactory_ConstructProps extends PluginFeature_ConstructProps {
}
class TracerFactory {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.TracerFactory */
    /**
     * Get the #GType for elements managed by this factory. The type can
     * only be retrieved if the element factory is loaded, which can be
     * assured with gst_plugin_feature_load().
     */
    get_tracer_type(): GObject.Type
    /* Methods of Gst-1.0.Gst.PluginFeature */
    /**
     * Checks whether the given plugin feature is at least
     *  the required version
     * @param min_major minimum required major version
     * @param min_minor minimum required minor version
     * @param min_micro minimum required micro version
     */
    check_version(min_major: number, min_minor: number, min_micro: number): boolean
    /**
     * Get the plugin that provides this feature.
     */
    get_plugin(): Plugin | null
    /**
     * Get the name of the plugin that provides this feature.
     */
    get_plugin_name(): string | null
    /**
     * Gets the rank of a plugin feature.
     */
    get_rank(): number
    /**
     * Loads the plugin containing `feature` if it's not already loaded. `feature` is
     * unaffected; use the return value instead.
     * 
     * Normally this function is used like this:
     * 
     * ```c
     * GstPluginFeature *loaded_feature;
     * 
     * loaded_feature = gst_plugin_feature_load (feature);
     * // presumably, we're no longer interested in the potentially-unloaded feature
     * gst_object_unref (feature);
     * feature = loaded_feature;
     * ```
     * 
     */
    load(): PluginFeature | null
    /**
     * Specifies a rank for a plugin feature, so that autoplugging uses
     * the most appropriate feature.
     * @param rank rank value - higher number means more priority rank
     */
    set_rank(rank: number): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: TracerFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TracerFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: TracerFactory, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TracerFactory, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TracerFactory_ConstructProps)
    _init (config?: TracerFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Gets the list of all registered tracer factories. You must free the
     * list using gst_plugin_feature_list_free().
     * 
     * The returned factories are sorted by factory name.
     * 
     * Free-function: gst_plugin_feature_list_free
     */
    static get_list(): TracerFactory[]
    static $gtype: GObject.Type
}
interface TracerRecord_ConstructProps extends Object_ConstructProps {
}
class TracerRecord {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: TracerRecord, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TracerRecord, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: TracerRecord, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TracerRecord, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TracerRecord_ConstructProps)
    _init (config?: TracerRecord_ConstructProps): void
    static $gtype: GObject.Type
}
interface TypeFindFactory_ConstructProps extends PluginFeature_ConstructProps {
}
class TypeFindFactory {
    /* Fields of Gst-1.0.Gst.Object */
    object: GObject.InitiallyUnowned
    /**
     * object LOCK
     */
    lock: GLib.Mutex
    /**
     * The name of the object
     */
    name: string
    /**
     * this object's parent, weak ref
     */
    parent: Object
    /**
     * flags for this object
     */
    flags: number
    /* Fields of GObject-2.0.GObject.InitiallyUnowned */
    g_type_instance: GObject.TypeInstance
    /* Methods of Gst-1.0.Gst.TypeFindFactory */
    /**
     * Calls the #GstTypeFindFunction associated with this factory.
     * @param find a properly setup #GstTypeFind entry. The get_data     and suggest_type members must be set.
     */
    call_function(find: TypeFind): void
    /**
     * Gets the #GstCaps associated with a typefind factory.
     */
    get_caps(): Caps | null
    /**
     * Gets the extensions associated with a #GstTypeFindFactory. The returned
     * array should not be changed. If you need to change stuff in it, you should
     * copy it using g_strdupv().  This function may return %NULL to indicate
     * a 0-length list.
     */
    get_extensions(): string[] | null
    /**
     * Check whether the factory has a typefind function. Typefind factories
     * without typefind functions are a last-effort fallback mechanism to
     * e.g. assume a certain media type based on the file extension.
     */
    has_function(): boolean
    /* Methods of Gst-1.0.Gst.PluginFeature */
    /**
     * Checks whether the given plugin feature is at least
     *  the required version
     * @param min_major minimum required major version
     * @param min_minor minimum required minor version
     * @param min_micro minimum required micro version
     */
    check_version(min_major: number, min_minor: number, min_micro: number): boolean
    /**
     * Get the plugin that provides this feature.
     */
    get_plugin(): Plugin | null
    /**
     * Get the name of the plugin that provides this feature.
     */
    get_plugin_name(): string | null
    /**
     * Gets the rank of a plugin feature.
     */
    get_rank(): number
    /**
     * Loads the plugin containing `feature` if it's not already loaded. `feature` is
     * unaffected; use the return value instead.
     * 
     * Normally this function is used like this:
     * 
     * ```c
     * GstPluginFeature *loaded_feature;
     * 
     * loaded_feature = gst_plugin_feature_load (feature);
     * // presumably, we're no longer interested in the potentially-unloaded feature
     * gst_object_unref (feature);
     * feature = loaded_feature;
     * ```
     * 
     */
    load(): PluginFeature | null
    /**
     * Specifies a rank for a plugin feature, so that autoplugging uses
     * the most appropriate feature.
     * @param rank rank value - higher number means more priority rank
     */
    set_rank(rank: number): void
    /* Methods of Gst-1.0.Gst.Object */
    /**
     * Attach the #GstControlBinding to the object. If there already was a
     * #GstControlBinding for this property it will be replaced.
     * 
     * The object's reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param binding the #GstControlBinding that should be used
     */
    add_control_binding(binding: ControlBinding): boolean
    /**
     * A default error function that uses g_printerr() to display the error message
     * and the optional debug string..
     * 
     * The default handler will simply print the error string using g_print.
     * @param error the GError.
     * @param debug an additional debug information string, or %NULL
     */
    default_error(error: GLib.Error, debug?: string | null): void
    /**
     * Gets the corresponding #GstControlBinding for the property. This should be
     * unreferenced again after use.
     * @param property_name name of the property
     */
    get_control_binding(property_name: string): ControlBinding | null
    /**
     * Obtain the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * If the `object` is not under property control, this will return
     * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
     * 
     * The control-rate is not expected to change if the element is in
     * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
     */
    get_control_rate(): ClockTime
    /**
     * Gets a number of #GValues for the given controlled property starting at the
     * requested time. The array `values` need to hold enough space for `n_values` of
     * #GValue.
     * 
     * This function is useful if one wants to e.g. draw a graph of the control
     * curve or apply a control curve sample by sample.
     * @param property_name the name of the property to get
     * @param timestamp the time that should be processed
     * @param interval the time spacing between subsequent values
     * @param values array to put control-values in
     */
    get_g_value_array(property_name: string, timestamp: ClockTime, interval: ClockTime, values: any[]): boolean
    /**
     * Returns a copy of the name of `object`.
     * Caller should g_free() the return value after usage.
     * For a nameless object, this returns %NULL, which you can safely g_free()
     * as well.
     * 
     * Free-function: g_free
     */
    get_name(): string | null
    /**
     * Returns the parent of `object`. This function increases the refcount
     * of the parent object so you should gst_object_unref() it after usage.
     */
    get_parent(): Object | null
    /**
     * Generates a string describing the path of `object` in
     * the object hierarchy. Only useful (or used) for debugging.
     * 
     * Free-function: g_free
     */
    get_path_string(): string
    /**
     * Gets the value for the given controlled property at the requested time.
     * @param property_name the name of the property to get
     * @param timestamp the time the control-change should be read from
     */
    get_value(property_name: string, timestamp: ClockTime): any | null
    /**
     * Check if the `object` has active controlled properties.
     */
    has_active_control_bindings(): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_ancestor(ancestor: Object): boolean
    /**
     * Check if `object` has an ancestor `ancestor` somewhere up in
     * the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
     * @param ancestor a #GstObject to check as ancestor
     */
    has_as_ancestor(ancestor: Object): boolean
    /**
     * Check if `parent` is the parent of `object`.
     * E.g. a #GstElement can check if it owns a given #GstPad.
     * @param parent a #GstObject to check as parent
     */
    has_as_parent(parent: Object): boolean
    /**
     * Increments the reference count on `object`. This function
     * does not take the lock on `object` because it relies on
     * atomic refcounting.
     * 
     * This object returns the input parameter to ease writing
     * constructs like :
     *  result = gst_object_ref (object->parent);
     */
    ref(): Object
    /**
     * Removes the corresponding #GstControlBinding. If it was the
     * last ref of the binding, it will be disposed.
     * @param binding the binding
     */
    remove_control_binding(binding: ControlBinding): boolean
    /**
     * This function is used to disable the control bindings on a property for
     * some time, i.e. gst_object_sync_values() will do nothing for the
     * property.
     * @param property_name property to disable
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_binding_disabled(property_name: string, disabled: boolean): void
    /**
     * This function is used to disable all controlled properties of the `object` for
     * some time, i.e. gst_object_sync_values() will do nothing.
     * @param disabled boolean that specifies whether to disable the controller or not.
     */
    set_control_bindings_disabled(disabled: boolean): void
    /**
     * Change the control-rate for this `object`. Audio processing #GstElement
     * objects will use this rate to sub-divide their processing loop and call
     * gst_object_sync_values() in between. The length of the processing segment
     * should be up to `control-rate` nanoseconds.
     * 
     * The control-rate should not change if the element is in %GST_STATE_PAUSED or
     * %GST_STATE_PLAYING.
     * @param control_rate the new control-rate in nanoseconds.
     */
    set_control_rate(control_rate: ClockTime): void
    /**
     * Sets the name of `object,` or gives `object` a guaranteed unique
     * name (if `name` is %NULL).
     * This function makes a copy of the provided name, so the caller
     * retains ownership of the name it sent.
     * @param name new name of object
     */
    set_name(name?: string | null): boolean
    /**
     * Sets the parent of `object` to `parent`. The object's reference count will
     * be incremented, and any floating reference will be removed (see gst_object_ref_sink()).
     * @param parent new parent of object
     */
    set_parent(parent: Object): boolean
    /**
     * Returns a suggestion for timestamps where buffers should be split
     * to get best controller results.
     */
    suggest_next_sync(): ClockTime
    /**
     * Sets the properties of the object, according to the #GstControlSources that
     * (maybe) handle them and for the given timestamp.
     * 
     * If this function fails, it is most likely the application developers fault.
     * Most probably the control sources are not setup correctly.
     * @param timestamp the time that should be processed
     */
    sync_values(timestamp: ClockTime): boolean
    /**
     * Clear the parent of `object,` removing the associated reference.
     * This function decreases the refcount of `object`.
     * 
     * MT safe. Grabs and releases `object'`s lock.
     */
    unparent(): void
    /**
     * Decrements the reference count on `object`.  If reference count hits
     * zero, destroy `object`. This function does not take the lock
     * on `object` as it relies on atomic refcounting.
     * 
     * The unref method should never be called with the LOCK held since
     * this might deadlock the dispose function.
     */
    unref(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     * @param source_property the property on `source` to bind
     * @param target the target #GObject
     * @param target_property the property on `target` to bind
     * @param flags flags to pass to #GBinding
     * @param transform_to a #GClosure wrapping the transformation function     from the `source` to the `target,` or %NULL to use the default
     * @param transform_from a #GClosure wrapping the transformation function     from the `target` to the `source,` or %NULL to use the default
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     * @param property_name the name of the property to get
     * @param value return location for the property value
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     * @param names the names of each property to get
     * @param values the values of each property to get
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param property_name the name of a property installed on the class of `object`.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     * @param pspec the #GParamSpec of a property installed on the class of `object`.
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     * @param property_name the name of the property to set
     * @param value the value
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     * @param key name of the key
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     * @param closure #GClosure to watch
     */
    watch_closure(closure: Function): void
    /* Virtual methods of Gst-1.0.Gst.Object */
    vfunc_deep_notify(orig: Object, pspec: GObject.ParamSpec): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     * @param pspec 
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of Gst-1.0.Gst.Object */
    /**
     * The deep notify signal is used to be notified of property changes. It is
     * typically attached to the toplevel bin to receive notifications from all
     * the elements contained in that bin.
     * @param prop_object the object that originated the signal
     * @param prop the property that changed
     */
    connect(sigName: "deep-notify", callback: (($obj: TypeFindFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    connect_after(sigName: "deep-notify", callback: (($obj: TypeFindFactory, prop_object: Object, prop: GObject.ParamSpec) => void)): number
    emit(sigName: "deep-notify", prop_object: Object, prop: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     * @param pspec the #GParamSpec of the property which changed.
     */
    connect(sigName: "notify", callback: (($obj: TypeFindFactory, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: TypeFindFactory, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: TypeFindFactory_ConstructProps)
    _init (config?: TypeFindFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Gets the list of all registered typefind factories. You must free the
     * list using gst_plugin_feature_list_free().
     * 
     * The returned factories are sorted by highest rank first, and then by
     * factory name.
     * 
     * Free-function: gst_plugin_feature_list_free
     */
    static get_list(): TypeFindFactory[]
    static $gtype: GObject.Type
}
class ValueArray {
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Appends `append_value` to the GstValueArray in `value`.
     * @param value a #GValue of type #GST_TYPE_ARRAY
     * @param append_value the value to append
     */
    static append_and_take_value(value: any, append_value: any): void
    /**
     * Appends `append_value` to the GstValueArray in `value`.
     * @param value a #GValue of type #GST_TYPE_ARRAY
     * @param append_value the value to append
     */
    static append_value(value: any, append_value: any): void
    /**
     * Gets the number of values contained in `value`.
     * @param value a #GValue of type #GST_TYPE_ARRAY
     */
    static get_size(value: any): number
    /**
     * Gets the value that is a member of the array contained in `value` and
     * has the index `index`.
     * @param value a #GValue of type #GST_TYPE_ARRAY
     * @param index index of value to get from the array
     */
    static get_value(value: any, index: number): any
    /**
     * Initializes and pre-allocates a #GValue of type #GST_TYPE_ARRAY.
     * @param value A zero-filled (uninitialized) #GValue structure
     * @param prealloc The number of entries to pre-allocate in the array
     */
    static init(value: any, prealloc: number): any
    /**
     * Prepends `prepend_value` to the GstValueArray in `value`.
     * @param value a #GValue of type #GST_TYPE_ARRAY
     * @param prepend_value the value to prepend
     */
    static prepend_value(value: any, prepend_value: any): void
}
class ValueList {
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Appends `append_value` to the GstValueList in `value`.
     * @param value a #GValue of type #GST_TYPE_LIST
     * @param append_value the value to append
     */
    static append_and_take_value(value: any, append_value: any): void
    /**
     * Appends `append_value` to the GstValueList in `value`.
     * @param value a #GValue of type #GST_TYPE_LIST
     * @param append_value the value to append
     */
    static append_value(value: any, append_value: any): void
    /**
     * Concatenates copies of `value1` and `value2` into a list.  Values that are not
     * of type #GST_TYPE_LIST are treated as if they were lists of length 1.
     * `dest` will be initialized to the type #GST_TYPE_LIST.
     * @param value1 a #GValue
     * @param value2 a #GValue
     */
    static concat(value1: any, value2: any): /* dest */ any
    /**
     * Gets the number of values contained in `value`.
     * @param value a #GValue of type #GST_TYPE_LIST
     */
    static get_size(value: any): number
    /**
     * Gets the value that is a member of the list contained in `value` and
     * has the index `index`.
     * @param value a #GValue of type #GST_TYPE_LIST
     * @param index index of value to get from the list
     */
    static get_value(value: any, index: number): any
    /**
     * Initializes and pre-allocates a #GValue of type #GST_TYPE_LIST.
     * @param value A zero-filled (uninitialized) #GValue structure
     * @param prealloc The number of entries to pre-allocate in the list
     */
    static init(value: any, prealloc: number): any
    /**
     * Merges copies of `value1` and `value2`.  Values that are not
     * of type #GST_TYPE_LIST are treated as if they were lists of length 1.
     * 
     * The result will be put into `dest` and will either be a list that will not
     * contain any duplicates, or a non-list type (if `value1` and `value2`
     * were equal).
     * @param value1 a #GValue
     * @param value2 a #GValue
     */
    static merge(value1: any, value2: any): /* dest */ any
    /**
     * Prepends `prepend_value` to the GstValueList in `value`.
     * @param value a #GValue of type #GST_TYPE_LIST
     * @param prepend_value the value to prepend
     */
    static prepend_value(value: any, prepend_value: any): void
}
class AllocationParams {
    /* Fields of Gst-1.0.Gst.AllocationParams */
    /**
     * flags to control allocation
     */
    flags: MemoryFlags
    /**
     * the desired alignment of the memory
     */
    align: number
    /**
     * the desired prefix
     */
    prefix: number
    /**
     * the desired padding
     */
    padding: number
    /* Methods of Gst-1.0.Gst.AllocationParams */
    /**
     * Create a copy of `params`.
     */
    copy(): AllocationParams | null
    /**
     * Free `params`
     */
    free(): void
    /**
     * Initialize `params` to its default values
     */
    init(): void
    static name: string
    static new(): AllocationParams
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): AllocationParams
}
abstract class AllocatorClass {
    /* Fields of Gst-1.0.Gst.AllocatorClass */
    /**
     * Object parent class
     */
    object_class: ObjectClass
    alloc: (allocator: Allocator | null, size: number, params?: AllocationParams | null) => Memory | null
    free: (allocator: Allocator, memory: Memory) => void
    static name: string
}
class AllocatorPrivate {
    static name: string
}
class AtomicQueue {
    /* Methods of Gst-1.0.Gst.AtomicQueue */
    /**
     * Get the amount of items in the queue.
     */
    length(): number
    /**
     * Peek the head element of the queue without removing it from the queue.
     */
    peek(): object | null
    /**
     * Get the head element of the queue.
     */
    pop(): object | null
    /**
     * Append `data` to the tail of the queue.
     * @param data the data
     */
    push(data?: object | null): void
    /**
     * Increase the refcount of `queue`.
     */
    ref(): void
    /**
     * Unref `queue` and free the memory when the refcount reaches 0.
     */
    unref(): void
    static name: string
    static new(initial_size: number): AtomicQueue
    constructor(initial_size: number)
    /* Static methods and pseudo-constructors */
    static new(initial_size: number): AtomicQueue
}
abstract class BinClass {
    /* Fields of Gst-1.0.Gst.BinClass */
    /**
     * bin parent class
     */
    parent_class: ElementClass
    element_added: (bin: Bin, child: Element) => void
    element_removed: (bin: Bin, child: Element) => void
    add_element: (bin: Bin, element: Element) => boolean
    remove_element: (bin: Bin, element: Element) => boolean
    handle_message: (bin: Bin, message: Message) => void
    do_latency: (bin: Bin) => boolean
    deep_element_added: (bin: Bin, sub_bin: Bin, child: Element) => void
    deep_element_removed: (bin: Bin, sub_bin: Bin, child: Element) => void
    static name: string
}
class BinPrivate {
    static name: string
}
class Buffer {
    /* Fields of Gst-1.0.Gst.Buffer */
    /**
     * the parent structure
     */
    mini_object: MiniObject
    /**
     * pointer to the pool owner of the buffer
     */
    pool: BufferPool
    /**
     * presentation timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the
     *     pts is not known or relevant. The pts contains the timestamp when the
     *     media should be presented to the user.
     */
    pts: ClockTime
    /**
     * decoding timestamp of the buffer, can be #GST_CLOCK_TIME_NONE when the
     *     dts is not known or relevant. The dts contains the timestamp when the
     *     media should be processed.
     */
    dts: ClockTime
    /**
     * duration in time of the buffer data, can be #GST_CLOCK_TIME_NONE
     *     when the duration is not known or relevant.
     */
    duration: ClockTime
    /**
     * a media specific offset for the buffer data.
     *     For video frames, this is the frame number of this buffer.
     *     For audio samples, this is the offset of the first sample in this buffer.
     *     For file data or compressed data this is the byte offset of the first
     *       byte in this buffer.
     */
    offset: number
    /**
     * the last offset contained in this buffer. It has the same
     *     format as `offset`.
     */
    offset_end: number
    /* Methods of Gst-1.0.Gst.Buffer */
    /**
     * Creates and adds a #GstCustomMeta for the desired `name`. `name` must have
     * been successfully registered with gst_meta_register_custom().
     * @param name the registered name of the desired custom meta
     */
    add_custom_meta(name: string): CustomMeta | null
    /**
     * Adds metadata for `info` to `buffer` using the parameters in `params`.
     * @param info a #GstMetaInfo
     * @param params params for `info`
     */
    add_meta(info: MetaInfo, params?: object | null): Meta | null
    /**
     * Adds a #GstParentBufferMeta to `buffer` that holds a reference on
     * `ref` until the buffer is freed.
     * @param ref a #GstBuffer to ref
     */
    add_parent_buffer_meta(ref: Buffer): ParentBufferMeta | null
    /**
     * Attaches protection metadata to a #GstBuffer.
     * @param info a #GstStructure holding cryptographic     information relating to the sample contained in `buffer`. This     function takes ownership of `info`.
     */
    add_protection_meta(info: Structure): ProtectionMeta
    /**
     * Adds a #GstReferenceTimestampMeta to `buffer` that holds a `timestamp` and
     * optionally `duration` based on a specific timestamp `reference`. See the
     * documentation of #GstReferenceTimestampMeta for details.
     * @param reference identifier for the timestamp reference.
     * @param timestamp timestamp
     * @param duration duration, or %GST_CLOCK_TIME_NONE
     */
    add_reference_timestamp_meta(reference: Caps, timestamp: ClockTime, duration: ClockTime): ReferenceTimestampMeta | null
    /**
     * Appends all the memory from `buf2` to `buf1`. The result buffer will contain a
     * concatenation of the memory of `buf1` and `buf2`.
     * @param buf2 the second source #GstBuffer to append.
     */
    append(buf2: Buffer): Buffer
    /**
     * Appends the memory block `mem` to `buffer`. This function takes
     * ownership of `mem` and thus doesn't increase its refcount.
     * 
     * This function is identical to gst_buffer_insert_memory() with an index of -1.
     * See gst_buffer_insert_memory() for more details.
     * @param mem a #GstMemory.
     */
    append_memory(mem: Memory): void
    /**
     * Appends `size` bytes at `offset` from `buf2` to `buf1`. The result buffer will
     * contain a concatenation of the memory of `buf1` and the requested region of
     * `buf2`.
     * @param buf2 the second source #GstBuffer to append.
     * @param offset the offset in `buf2`
     * @param size the size or -1 of `buf2`
     */
    append_region(buf2: Buffer, offset: number, size: number): Buffer
    /**
     * Creates a copy of the given buffer. This will make a newly allocated
     * copy of the data the source buffer contains.
     */
    copy_deep(): Buffer
    /**
     * Copies the information from `src` into `dest`.
     * 
     * If `dest` already contains memory and `flags` contains GST_BUFFER_COPY_MEMORY,
     * the memory from `src` will be appended to `dest`.
     * 
     * `flags` indicate which fields will be copied.
     * @param src a source #GstBuffer
     * @param flags flags indicating what metadata fields should be copied.
     * @param offset offset to copy from
     * @param size total size to copy. If -1, all data is copied.
     */
    copy_into(src: Buffer, flags: BufferCopyFlags, offset: number, size: number): boolean
    /**
     * Creates a sub-buffer from `parent` at `offset` and `size`.
     * This sub-buffer uses the actual memory space of the parent buffer.
     * This function will copy the offset and timestamp fields when the
     * offset is 0. If not, they will be set to #GST_CLOCK_TIME_NONE and
     * #GST_BUFFER_OFFSET_NONE.
     * If `offset` equals 0 and `size` equals the total size of `buffer,` the
     * duration and offset end fields are also copied. If not they will be set
     * to #GST_CLOCK_TIME_NONE and #GST_BUFFER_OFFSET_NONE.
     * @param flags the #GstBufferCopyFlags
     * @param offset the offset into parent #GstBuffer at which the new sub-buffer          begins.
     * @param size the size of the new #GstBuffer sub-buffer, in bytes. If -1, all        data is copied.
     */
    copy_region(flags: BufferCopyFlags, offset: number, size: number): Buffer
    /**
     * Copies `size` bytes starting from `offset` in `buffer` to `dest`.
     * @param offset the offset to extract
     */
    extract(offset: number): [ /* returnType */ number, /* dest */ Uint8Array ]
    /**
     * Extracts a copy of at most `size` bytes the data at `offset` into
     * newly-allocated memory. `dest` must be freed using g_free() when done.
     * @param offset the offset to extract
     * @param size the size to extract
     */
    extract_dup(offset: number, size: number): /* dest */ Uint8Array
    /**
     * Copies `size` bytes from `src` to `buffer` at `offset`.
     * @param offset the offset to fill
     * @param src the source address
     */
    fill(offset: number, src: Uint8Array): number
    /**
     * Finds the memory blocks that span `size` bytes starting from `offset`
     * in `buffer`.
     * 
     * When this function returns %TRUE, `idx` will contain the index of the first
     * memory block where the byte for `offset` can be found and `length` contains the
     * number of memory blocks containing the `size` remaining bytes. `skip` contains
     * the number of bytes to skip in the memory block at `idx` to get to the byte
     * for `offset`.
     * 
     * `size` can be -1 to get all the memory blocks after `idx`.
     * @param offset an offset
     * @param size a size
     */
    find_memory(offset: number, size: number): [ /* returnType */ boolean, /* idx */ number, /* length */ number, /* skip */ number ]
    /**
     * Calls `func` with `user_data` for each meta in `buffer`.
     * 
     * `func` can modify the passed meta pointer or its contents. The return value
     * of `func` defines if this function returns or if the remaining metadata items
     * in the buffer should be skipped.
     * @param func a #GstBufferForeachMetaFunc to call
     */
    foreach_meta(func: BufferForeachMetaFunc): boolean
    /**
     * Gets all the memory blocks in `buffer`. The memory blocks will be merged
     * into one large #GstMemory.
     */
    get_all_memory(): Memory | null
    /**
     * Finds the first #GstCustomMeta on `buffer` for the desired `name`.
     * @param name the registered name of the custom meta to retrieve.
     */
    get_custom_meta(name: string): CustomMeta | null
    /**
     * Gets the #GstBufferFlags flags set on this buffer.
     */
    get_flags(): BufferFlags
    /**
     * Gets the memory block at index `idx` in `buffer`.
     * @param idx an index
     */
    get_memory(idx: number): Memory | null
    /**
     * Gets `length` memory blocks in `buffer` starting at `idx`. The memory blocks will
     * be merged into one large #GstMemory.
     * 
     * If `length` is -1, all memory starting from `idx` is merged.
     * @param idx an index
     * @param length a length
     */
    get_memory_range(idx: number, length: number): Memory | null
    /**
     * Gets the metadata for `api` on buffer. When there is no such metadata, %NULL is
     * returned. If multiple metadata with the given `api` are attached to this
     * buffer only the first one is returned.  To handle multiple metadata with a
     * given API use gst_buffer_iterate_meta() or gst_buffer_foreach_meta() instead
     * and check the `meta->info.api` member for the API type.
     * @param api the #GType of an API
     */
    get_meta(api: GObject.Type): Meta | null
    get_n_meta(api_type: GObject.Type): number
    /**
     * Finds the first #GstReferenceTimestampMeta on `buffer` that conforms to
     * `reference`. Conformance is tested by checking if the meta's reference is a
     * subset of `reference`.
     * 
     * Buffers can contain multiple #GstReferenceTimestampMeta metadata items.
     * @param reference a reference #GstCaps
     */
    get_reference_timestamp_meta(reference?: Caps | null): ReferenceTimestampMeta | null
    /**
     * Gets the total size of the memory blocks in `buffer`.
     */
    get_size(): number
    /**
     * Gets the total size of the memory blocks in `buffer`.
     * 
     * When not %NULL, `offset` will contain the offset of the data in the
     * first memory block in `buffer` and `maxsize` will contain the sum of
     * the size and `offset` and the amount of extra padding on the last
     * memory block.  `offset` and `maxsize` can be used to resize the
     * buffer memory blocks with gst_buffer_resize().
     */
    get_sizes(): [ /* returnType */ number, /* offset */ number | null, /* maxsize */ number | null ]
    /**
     * Gets the total size of `length` memory blocks stating from `idx` in `buffer`.
     * 
     * When not %NULL, `offset` will contain the offset of the data in the
     * memory block in `buffer` at `idx` and `maxsize` will contain the sum of the size
     * and `offset` and the amount of extra padding on the memory block at `idx` +
     * `length` -1.
     * `offset` and `maxsize` can be used to resize the buffer memory blocks with
     * gst_buffer_resize_range().
     * @param idx an index
     * @param length a length
     */
    get_sizes_range(idx: number, length: number): [ /* returnType */ number, /* offset */ number | null, /* maxsize */ number | null ]
    /**
     * Gives the status of a specific flag on a buffer.
     * @param flags the #GstBufferFlags flag to check.
     */
    has_flags(flags: BufferFlags): boolean
    /**
     * Inserts the memory block `mem` into `buffer` at `idx`. This function takes ownership
     * of `mem` and thus doesn't increase its refcount.
     * 
     * Only gst_buffer_get_max_memory() can be added to a buffer. If more memory is
     * added, existing memory blocks will automatically be merged to make room for
     * the new memory.
     * @param idx the index to add the memory at, or -1 to append it to the end
     * @param mem a #GstMemory.
     */
    insert_memory(idx: number, mem: Memory): void
    /**
     * Checks if all memory blocks in `buffer` are writable.
     * 
     * Note that this function does not check if `buffer` is writable, use
     * gst_buffer_is_writable() to check that if needed.
     */
    is_all_memory_writable(): boolean
    /**
     * Checks if `length` memory blocks in `buffer` starting from `idx` are writable.
     * 
     * `length` can be -1 to check all the memory blocks after `idx`.
     * 
     * Note that this function does not check if `buffer` is writable, use
     * gst_buffer_is_writable() to check that if needed.
     * @param idx an index
     * @param length a length, should not be 0
     */
    is_memory_range_writable(idx: number, length: number): boolean
    /**
     * Fills `info` with the #GstMapInfo of all merged memory blocks in `buffer`.
     * 
     * `flags` describe the desired access of the memory. When `flags` is
     * #GST_MAP_WRITE, `buffer` should be writable (as returned from
     * gst_buffer_is_writable()).
     * 
     * When `buffer` is writable but the memory isn't, a writable copy will
     * automatically be created and returned. The readonly copy of the
     * buffer memory will then also be replaced with this writable copy.
     * 
     * The memory in `info` should be unmapped with gst_buffer_unmap() after
     * usage.
     * @param flags flags for the mapping
     */
    map(flags: MapFlags): [ /* returnType */ boolean, /* info */ MapInfo ]
    /**
     * Fills `info` with the #GstMapInfo of `length` merged memory blocks
     * starting at `idx` in `buffer`. When `length` is -1, all memory blocks starting
     * from `idx` are merged and mapped.
     * 
     * `flags` describe the desired access of the memory. When `flags` is
     * #GST_MAP_WRITE, `buffer` should be writable (as returned from
     * gst_buffer_is_writable()).
     * 
     * When `buffer` is writable but the memory isn't, a writable copy will
     * automatically be created and returned. The readonly copy of the buffer memory
     * will then also be replaced with this writable copy.
     * 
     * The memory in `info` should be unmapped with gst_buffer_unmap() after usage.
     * @param idx an index
     * @param length a length
     * @param flags flags for the mapping
     */
    map_range(idx: number, length: number, flags: MapFlags): [ /* returnType */ boolean, /* info */ MapInfo ]
    /**
     * Compares `size` bytes starting from `offset` in `buffer` with the memory in `mem`.
     * @param offset the offset in `buffer`
     * @param mem the memory to compare
     */
    memcmp(offset: number, mem: Uint8Array): number
    /**
     * Fills `buf` with `size` bytes with `val` starting from `offset`.
     * @param offset the offset in `buffer`
     * @param val the value to set
     * @param size the size to set
     */
    memset(offset: number, val: number, size: number): number
    /**
     * Gets the amount of memory blocks that this buffer has. This amount is never
     * larger than what gst_buffer_get_max_memory() returns.
     */
    n_memory(): number
    /**
     * Gets the memory block at `idx` in `buffer`. The memory block stays valid until
     * the memory block in `buffer` is removed, replaced or merged, typically with
     * any call that modifies the memory in `buffer`.
     * @param idx an index
     */
    peek_memory(idx: number): Memory | null
    /**
     * Prepends the memory block `mem` to `buffer`. This function takes
     * ownership of `mem` and thus doesn't increase its refcount.
     * 
     * This function is identical to gst_buffer_insert_memory() with an index of 0.
     * See gst_buffer_insert_memory() for more details.
     * @param mem a #GstMemory.
     */
    prepend_memory(mem: Memory): void
    /**
     * Removes all the memory blocks in `buffer`.
     */
    remove_all_memory(): void
    /**
     * Removes the memory block in `b` at index `i`.
     * @param idx an index
     */
    remove_memory(idx: number): void
    /**
     * Removes `length` memory blocks in `buffer` starting from `idx`.
     * 
     * `length` can be -1, in which case all memory starting from `idx` is removed.
     * @param idx an index
     * @param length a length
     */
    remove_memory_range(idx: number, length: number): void
    /**
     * Removes the metadata for `meta` on `buffer`.
     * @param meta a #GstMeta
     */
    remove_meta(meta: Meta): boolean
    /**
     * Replaces all memory in `buffer` with `mem`.
     * @param mem a #GstMemory
     */
    replace_all_memory(mem: Memory): void
    /**
     * Replaces the memory block at index `idx` in `buffer` with `mem`.
     * @param idx an index
     * @param mem a #GstMemory
     */
    replace_memory(idx: number, mem: Memory): void
    /**
     * Replaces `length` memory blocks in `buffer` starting at `idx` with `mem`.
     * 
     * If `length` is -1, all memory starting from `idx` will be removed and
     * replaced with `mem`.
     * 
     * `buffer` should be writable.
     * @param idx an index
     * @param length a length, should not be 0
     * @param mem a #GstMemory
     */
    replace_memory_range(idx: number, length: number, mem: Memory): void
    /**
     * Sets the offset and total size of the memory blocks in `buffer`.
     * @param offset the offset adjustment
     * @param size the new size or -1 to just adjust the offset
     */
    resize(offset: number, size: number): void
    /**
     * Sets the total size of the `length` memory blocks starting at `idx` in
     * `buffer`
     * @param idx an index
     * @param length a length
     * @param offset the offset adjustment
     * @param size the new size or -1 to just adjust the offset
     */
    resize_range(idx: number, length: number, offset: number, size: number): boolean
    /**
     * Sets one or more buffer flags on a buffer.
     * @param flags the #GstBufferFlags to set.
     */
    set_flags(flags: BufferFlags): boolean
    /**
     * Sets the total size of the memory blocks in `buffer`.
     * @param size the new size
     */
    set_size(size: number): void
    /**
     * Releases the memory previously mapped with gst_buffer_map().
     * @param info a #GstMapInfo
     */
    unmap(info: MapInfo): void
    /**
     * Clears one or more buffer flags.
     * @param flags the #GstBufferFlags to clear
     */
    unset_flags(flags: BufferFlags): boolean
    static name: string
    static new(): Buffer
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): Buffer
    static new_allocate(allocator: Allocator | null, size: number, params?: AllocationParams | null): Buffer
    static new_memdup(data: Uint8Array): Buffer
    static new_wrapped(data: Uint8Array): Buffer
    static new_wrapped_bytes(bytes: GLib.Bytes): Buffer
    static new_wrapped_full(flags: MemoryFlags, data: Uint8Array, maxsize: number, offset: number, notify?: GLib.DestroyNotify | null): Buffer
    /**
     * Gets the maximum amount of memory blocks that a buffer can hold. This is a
     * compile time constant that can be queried with the function.
     * 
     * When more memory blocks are added, existing memory blocks will be merged
     * together to make room for the new block.
     */
    static get_max_memory(): number
}
class BufferList {
    /* Methods of Gst-1.0.Gst.BufferList */
    /**
     * Calculates the size of the data contained in `list` by adding the
     * size of all buffers.
     */
    calculate_size(): number
    /**
     * Creates a copy of the given buffer list. This will make a newly allocated
     * copy of the buffers that the source buffer list contains.
     */
    copy_deep(): BufferList
    /**
     * Calls `func` with `data` for each buffer in `list`.
     * 
     * `func` can modify the passed buffer pointer or its contents. The return value
     * of `func` defines if this function returns or if the remaining buffers in
     * the list should be skipped.
     * @param func a #GstBufferListFunc to call
     */
    foreach(func: BufferListFunc): boolean
    /**
     * Gets the buffer at `idx`.
     * 
     * You must make sure that `idx` does not exceed the number of
     * buffers available.
     * @param idx the index
     */
    get(idx: number): Buffer | null
    /**
     * Gets the buffer at `idx,` ensuring it is a writable buffer.
     * 
     * You must make sure that `idx` does not exceed the number of
     * buffers available.
     * @param idx the index
     */
    get_writable(idx: number): Buffer | null
    /**
     * Inserts `buffer` at `idx` in `list`. Other buffers are moved to make room for
     * this new buffer.
     * 
     * A -1 value for `idx` will append the buffer at the end.
     * @param idx the index
     * @param buffer a #GstBuffer
     */
    insert(idx: number, buffer: Buffer): void
    /**
     * Returns the number of buffers in `list`.
     */
    length(): number
    /**
     * Removes `length` buffers starting from `idx` in `list`. The following buffers
     * are moved to close the gap.
     * @param idx the index
     * @param length the amount to remove
     */
    remove(idx: number, length: number): void
    static name: string
    static new(): BufferList
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): BufferList
    static new_sized(size: number): BufferList
    /**
     * Modifies a pointer to a #GstBufferList to point to a different
     * #GstBufferList. The modification is done atomically (so this is useful for
     * ensuring thread safety in some cases), and the reference counts are updated
     * appropriately (the old buffer list is unreffed, the new is reffed).
     * 
     * Either `new_list` or the #GstBufferList pointed to by `old_list` may be %NULL.
     * @param old_list pointer to a pointer to a     #GstBufferList to be replaced.
     * @param new_list pointer to a #GstBufferList that     will replace the buffer list pointed to by `old_list`.
     */
    static replace(old_list?: BufferList | null, new_list?: BufferList | null): [ /* returnType */ boolean, /* old_list */ BufferList | null ]
    /**
     * Modifies a pointer to a #GstBufferList to point to a different
     * #GstBufferList. This function is similar to gst_buffer_list_replace() except
     * that it takes ownership of `new_list`.
     * @param old_list pointer to a pointer to a #GstBufferList     to be replaced.
     * @param new_list pointer to a #GstBufferList     that will replace the bufferlist pointed to by `old_list`.
     */
    static take(old_list: BufferList, new_list?: BufferList | null): [ /* returnType */ boolean, /* old_list */ BufferList ]
}
class BufferPoolAcquireParams {
    /* Fields of Gst-1.0.Gst.BufferPoolAcquireParams */
    /**
     * the format of `start` and `stop`
     */
    format: Format
    /**
     * the start position
     */
    start: number
    /**
     * the stop position
     */
    stop: number
    /**
     * additional flags
     */
    flags: BufferPoolAcquireFlags
    static name: string
}
abstract class BufferPoolClass {
    /* Fields of Gst-1.0.Gst.BufferPoolClass */
    /**
     * Object parent class
     */
    object_class: ObjectClass
    get_options: (pool: BufferPool) => string[]
    set_config: (pool: BufferPool, config: Structure) => boolean
    start: (pool: BufferPool) => boolean
    stop: (pool: BufferPool) => boolean
    acquire_buffer: (pool: BufferPool, params?: BufferPoolAcquireParams | null) => [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    alloc_buffer: (pool: BufferPool, params?: BufferPoolAcquireParams | null) => [ /* returnType */ FlowReturn, /* buffer */ Buffer ]
    reset_buffer: (pool: BufferPool, buffer: Buffer) => void
    release_buffer: (pool: BufferPool, buffer: Buffer) => void
    free_buffer: (pool: BufferPool, buffer: Buffer) => void
    flush_start: (pool: BufferPool) => void
    flush_stop: (pool: BufferPool) => void
    static name: string
}
class BufferPoolPrivate {
    static name: string
}
abstract class BusClass {
    /* Fields of Gst-1.0.Gst.BusClass */
    /**
     * the parent class structure
     */
    parent_class: ObjectClass
    message: (bus: Bus, message: Message) => void
    sync_message: (bus: Bus, message: Message) => void
    static name: string
}
class BusPrivate {
    static name: string
}
class Caps {
    /* Fields of Gst-1.0.Gst.Caps */
    /**
     * the parent type
     */
    mini_object: MiniObject
    /* Methods of Gst-1.0.Gst.Caps */
    /**
     * Appends the structures contained in `caps2` to `caps1`. The structures in
     * `caps2` are not copied -- they are transferred to `caps1`, and then `caps2` is
     * freed. If either caps is ANY, the resulting caps will be ANY.
     * @param caps2 the #GstCaps to append
     */
    append(caps2: Caps): void
    /**
     * Appends `structure` to `caps`.  The structure is not copied; `caps`
     * becomes the owner of `structure`.
     * @param structure the #GstStructure to append
     */
    append_structure(structure: Structure): void
    /**
     * Appends `structure` with `features` to `caps`.  The structure is not copied; `caps`
     * becomes the owner of `structure`.
     * @param structure the #GstStructure to append
     * @param features the #GstCapsFeatures to append
     */
    append_structure_full(structure: Structure, features?: CapsFeatures | null): void
    /**
     * Tries intersecting `caps1` and `caps2` and reports whether the result would not
     * be empty
     * @param caps2 a #GstCaps to intersect
     */
    can_intersect(caps2: Caps): boolean
    /**
     * Creates a new #GstCaps as a copy of the old `caps`. The new caps will have a
     * refcount of 1, owned by the caller. The structures are copied as well.
     * 
     * Note that this function is the semantic equivalent of a gst_caps_ref()
     * followed by a gst_caps_make_writable(). If you only want to hold on to a
     * reference to the data, you should use gst_caps_ref().
     */
    copy(): Caps
    /**
     * Creates a new #GstCaps and appends a copy of the nth structure
     * contained in `caps`.
     * @param nth the nth structure to copy
     */
    copy_nth(nth: number): Caps
    /**
     * Calls the provided function once for each structure and caps feature in the
     * #GstCaps. In contrast to gst_caps_foreach(), the function may modify the
     * structure and features. In contrast to gst_caps_filter_and_map_in_place(),
     * the structure and features are removed from the caps if %FALSE is returned
     * from the function.
     * The caps must be mutable.
     * @param func a function to call for each field
     */
    filter_and_map_in_place(func: CapsFilterMapFunc): void
    /**
     * Modifies the given `caps` into a representation with only fixed
     * values. First the caps will be truncated and then the first structure will be
     * fixated with gst_structure_fixate().
     * 
     * This function takes ownership of `caps` and will call gst_caps_make_writable()
     * on it so you must not use `caps` afterwards unless you keep an additional
     * reference to it with gst_caps_ref().
     * 
     * Note that it is not guaranteed that the returned caps have exactly one
     * structure. If `caps` are empty caps then the returned caps will be
     * the empty too and contain no structure at all.
     * 
     * Calling this function with ANY caps is not allowed.
     */
    fixate(): Caps
    /**
     * Calls the provided function once for each structure and caps feature in the
     * #GstCaps. The function must not modify the fields.
     * Also see gst_caps_map_in_place() and gst_caps_filter_and_map_in_place().
     * @param func a function to call for each field
     */
    foreach(func: CapsForeachFunc): boolean
    /**
     * Finds the features in `caps` at `index,` and returns it.
     * 
     * WARNING: This function takes a `const GstCaps *`, but returns a
     * non-const `GstCapsFeatures *`.  This is for programming convenience --
     * the caller should be aware that features inside a constant
     * #GstCaps should not be modified. However, if you know the caps
     * are writable, either because you have just copied them or made
     * them writable with gst_caps_make_writable(), you may modify the
     * features returned in the usual way, e.g. with functions like
     * gst_caps_features_add().
     * @param index the index of the structure
     */
    get_features(index: number): CapsFeatures | null
    /**
     * Gets the number of structures contained in `caps`.
     */
    get_size(): number
    /**
     * Finds the structure in `caps` at `index,` and returns it.
     * 
     * WARNING: This function takes a `const GstCaps *`, but returns a
     * non-const `GstStructure *`.  This is for programming convenience --
     * the caller should be aware that structures inside a constant
     * #GstCaps should not be modified. However, if you know the caps
     * are writable, either because you have just copied them or made
     * them writable with gst_caps_make_writable(), you may modify the
     * structure returned in the usual way, e.g. with functions like
     * gst_structure_set().
     * @param index the index of the structure
     */
    get_structure(index: number): Structure
    /**
     * Creates a new #GstCaps that contains all the formats that are common
     * to both `caps1` and `caps2`. Defaults to %GST_CAPS_INTERSECT_ZIG_ZAG mode.
     * @param caps2 a #GstCaps to intersect
     */
    intersect(caps2: Caps): Caps
    /**
     * Creates a new #GstCaps that contains all the formats that are common
     * to both `caps1` and `caps2`, the order is defined by the #GstCapsIntersectMode
     * used.
     * @param caps2 a #GstCaps to intersect
     * @param mode The intersection algorithm/mode to use
     */
    intersect_full(caps2: Caps, mode: CapsIntersectMode): Caps
    /**
     * A given #GstCaps structure is always compatible with another if
     * every media format that is in the first is also contained in the
     * second.  That is, `caps1` is a subset of `caps2`.
     * @param caps2 the #GstCaps to test
     */
    is_always_compatible(caps2: Caps): boolean
    /**
     * Determines if `caps` represents any media format.
     */
    is_any(): boolean
    /**
     * Determines if `caps` represents no media formats.
     */
    is_empty(): boolean
    /**
     * Checks if the given caps represent the same set of caps.
     * @param caps2 another #GstCaps
     */
    is_equal(caps2: Caps): boolean
    /**
     * Tests if two #GstCaps are equal.  This function only works on fixed
     * #GstCaps.
     * @param caps2 the #GstCaps to test
     */
    is_equal_fixed(caps2: Caps): boolean
    /**
     * Fixed #GstCaps describe exactly one format, that is, they have exactly
     * one structure, and each field in the structure describes a fixed type.
     * Examples of non-fixed types are GST_TYPE_INT_RANGE and GST_TYPE_LIST.
     */
    is_fixed(): boolean
    /**
     * Checks if the given caps are exactly the same set of caps.
     * @param caps2 another #GstCaps
     */
    is_strictly_equal(caps2: Caps): boolean
    /**
     * Checks if all caps represented by `subset` are also represented by `superset`.
     * @param superset a potentially greater #GstCaps
     */
    is_subset(superset: Caps): boolean
    /**
     * Checks if `structure` is a subset of `caps`. See gst_caps_is_subset()
     * for more information.
     * @param structure a potential #GstStructure subset of `caps`
     */
    is_subset_structure(structure: Structure): boolean
    /**
     * Checks if `structure` is a subset of `caps`. See gst_caps_is_subset()
     * for more information.
     * @param structure a potential #GstStructure subset of `caps`
     * @param features a #GstCapsFeatures for `structure`
     */
    is_subset_structure_full(structure: Structure, features?: CapsFeatures | null): boolean
    /**
     * Calls the provided function once for each structure and caps feature in the
     * #GstCaps. In contrast to gst_caps_foreach(), the function may modify but not
     * delete the structures and features. The caps must be mutable.
     * @param func a function to call for each field
     */
    map_in_place(func: CapsMapFunc): boolean
    /**
     * Appends the structures contained in `caps2` to `caps1` if they are not yet
     * expressed by `caps1`. The structures in `caps2` are not copied -- they are
     * transferred to a writable copy of `caps1`, and then `caps2` is freed.
     * If either caps is ANY, the resulting caps will be ANY.
     * @param caps2 the #GstCaps to merge in
     */
    merge(caps2: Caps): Caps
    /**
     * Appends `structure` to `caps` if it is not already expressed by `caps`.
     * @param structure the #GstStructure to merge
     */
    merge_structure(structure: Structure): Caps
    /**
     * Appends `structure` with `features` to `caps` if its not already expressed by `caps`.
     * @param structure the #GstStructure to merge
     * @param features the #GstCapsFeatures to merge
     */
    merge_structure_full(structure: Structure, features?: CapsFeatures | null): Caps
    /**
     * Returns a #GstCaps that represents the same set of formats as
     * `caps,` but contains no lists.  Each list is expanded into separate
     * #GstStructure.
     * 
     * This function takes ownership of `caps` and will call gst_caps_make_writable()
     * on it so you must not use `caps` afterwards unless you keep an additional
     * reference to it with gst_caps_ref().
     */
    normalize(): Caps
    /**
     * Removes the structure with the given index from the list of structures
     * contained in `caps`.
     * @param idx Index of the structure to remove
     */
    remove_structure(idx: number): void
    /**
     * Converts `caps` to a string representation.  This string representation can be
     * converted back to a #GstCaps by gst_caps_from_string().
     * 
     * This prints the caps in human readable form.
     * 
     * This version of the caps serialization function introduces support for nested
     * structures and caps but the resulting strings won't be parsable with
     * GStreamer prior to 1.20 unless #GST_SERIALIZE_FLAG_BACKWARD_COMPAT is passed
     * as `flag`.
     * @param flags a #GstSerializeFlags
     */
    serialize(flags: SerializeFlags): string
    /**
     * Sets the `features` for the structure at `index`.
     * @param index the index of the structure
     * @param features the #GstCapsFeatures to set
     */
    set_features(index: number, features?: CapsFeatures | null): void
    /**
     * Sets the `features` for all the structures of `caps`.
     * @param features the #GstCapsFeatures to set
     */
    set_features_simple(features?: CapsFeatures | null): void
    /**
     * Sets the given `field` on all structures of `caps` to the given `value`.
     * This is a convenience function for calling gst_structure_set_value() on
     * all structures of `caps`.
     * @param field name of the field to set
     * @param value value to set the field to
     */
    set_value(field: string, value: any): void
    /**
     * Converts the given `caps` into a representation that represents the
     * same set of formats, but in a simpler form.  Component structures that are
     * identical are merged.  Component structures that have values that can be
     * merged are also merged.
     * 
     * This function takes ownership of `caps` and will call gst_caps_make_writable()
     * on it if necessary, so you must not use `caps` afterwards unless you keep an
     * additional reference to it with gst_caps_ref().
     * 
     * This method does not preserve the original order of `caps`.
     */
    simplify(): Caps
    /**
     * Retrieves the structure with the given index from the list of structures
     * contained in `caps`. The caller becomes the owner of the returned structure.
     * @param index Index of the structure to retrieve
     */
    steal_structure(index: number): Structure | null
    /**
     * Subtracts the `subtrahend` from the `minuend`.
     * > This function does not work reliably if optional properties for caps
     * > are included on one caps and omitted on the other.
     * @param subtrahend #GstCaps to subtract
     */
    subtract(subtrahend: Caps): Caps
    /**
     * Converts `caps` to a string representation.  This string representation
     * can be converted back to a #GstCaps by gst_caps_from_string().
     * 
     * For debugging purposes its easier to do something like this:
     * 
     * ``` C
     * GST_LOG ("caps are %" GST_PTR_FORMAT, caps);
     * ```
     * 
     * This prints the caps in human readable form.
     * 
     * The implementation of serialization up to 1.20 would lead to unexpected results
     * when there were nested #GstCaps / #GstStructure deeper than one level.
     */
    to_string(): string
    /**
     * Discards all but the first structure from `caps`. Useful when
     * fixating.
     * 
     * This function takes ownership of `caps` and will call gst_caps_make_writable()
     * on it if necessary, so you must not use `caps` afterwards unless you keep an
     * additional reference to it with gst_caps_ref().
     * 
     * Note that it is not guaranteed that the returned caps have exactly one
     * structure. If `caps` is any or empty caps then the returned caps will be
     * the same and contain no structure at all.
     */
    truncate(): Caps
    static name: string
    /* Static methods and pseudo-constructors */
    static new_any(): Caps
    static new_empty(): Caps
    static new_empty_simple(media_type: string): Caps
    /**
     * Converts `caps` from a string representation.
     * 
     * The implementation of serialization up to 1.20 would lead to unexpected results
     * when there were nested #GstCaps / #GstStructure deeper than one level.
     * @param string a string to convert to #GstCaps
     */
    static from_string(string: string): Caps | null
}
class CapsFeatures {
    /* Methods of Gst-1.0.Gst.CapsFeatures */
    /**
     * Adds `feature` to `features`.
     * @param feature a feature.
     */
    add(feature: string): void
    /**
     * Adds `feature` to `features`.
     * @param feature a feature.
     */
    add_id(feature: GLib.Quark): void
    /**
     * Checks if `features` contains `feature`.
     * @param feature a feature
     */
    contains(feature: string): boolean
    /**
     * Checks if `features` contains `feature`.
     * @param feature a feature
     */
    contains_id(feature: GLib.Quark): boolean
    /**
     * Duplicates a #GstCapsFeatures and all its values.
     */
    copy(): CapsFeatures
    /**
     * Frees a #GstCapsFeatures and all its values. The caps features must not
     * have a parent when this function is called.
     */
    free(): void
    /**
     * Returns the `i-th` feature of `features`.
     * @param i index of the feature
     */
    get_nth(i: number): string | null
    /**
     * Returns the `i-th` feature of `features`.
     * @param i index of the feature
     */
    get_nth_id(i: number): GLib.Quark
    /**
     * Returns the number of features in `features`.
     */
    get_size(): number
    /**
     * Checks if `features` is %GST_CAPS_FEATURES_ANY.
     */
    is_any(): boolean
    /**
     * Checks if `features1` and `features2` are equal.
     * @param features2 a #GstCapsFeatures.
     */
    is_equal(features2: CapsFeatures): boolean
    /**
     * Removes `feature` from `features`.
     * @param feature a feature.
     */
    remove(feature: string): void
    /**
     * Removes `feature` from `features`.
     * @param feature a feature.
     */
    remove_id(feature: GLib.Quark): void
    /**
     * Sets the parent_refcount field of #GstCapsFeatures. This field is used to
     * determine whether a caps features is mutable or not. This function should only be
     * called by code implementing parent objects of #GstCapsFeatures, as described in
     * [the MT refcounting design document](additional/design/MT-refcounting.md).
     * @param refcount a pointer to the parent's refcount
     */
    set_parent_refcount(refcount: number): boolean
    /**
     * Converts `features` to a human-readable string representation.
     * 
     * For debugging purposes its easier to do something like this:
     * 
     * ``` C
     * GST_LOG ("features is %" GST_PTR_FORMAT, features);
     * ```
     * 
     * This prints the features in human readable form.
     */
    to_string(): string
    static name: string
    /* Static methods and pseudo-constructors */
    static new_any(): CapsFeatures
    static new_empty(): CapsFeatures
    static new_single(feature: string): CapsFeatures
    /**
     * Creates a #GstCapsFeatures from a string representation.
     * @param features a string representation of a #GstCapsFeatures.
     */
    static from_string(features: string): CapsFeatures | null
}
abstract class ChildProxyInterface {
    /* Fields of Gst-1.0.Gst.ChildProxyInterface */
    /**
     * parent interface type.
     */
    parent: GObject.TypeInterface
    get_child_by_name: (parent: ChildProxy, name: string) => GObject.Object | null
    get_child_by_index: (parent: ChildProxy, index: number) => GObject.Object | null
    get_children_count: (parent: ChildProxy) => number
    child_added: (parent: ChildProxy, child: GObject.Object, name: string) => void
    child_removed: (parent: ChildProxy, child: GObject.Object, name: string) => void
    static name: string
}
abstract class ClockClass {
    /* Fields of Gst-1.0.Gst.ClockClass */
    /**
     * the parent class structure
     */
    parent_class: ObjectClass
    change_resolution: (clock: Clock, old_resolution: ClockTime, new_resolution: ClockTime) => ClockTime
    get_resolution: (clock: Clock) => ClockTime
    get_internal_time: (clock: Clock) => ClockTime
    wait: (clock: Clock, entry: ClockEntry) => [ /* returnType */ ClockReturn, /* jitter */ ClockTimeDiff | null ]
    wait_async: (clock: Clock, entry: ClockEntry) => ClockReturn
    unschedule: (clock: Clock, entry: ClockEntry) => void
    static name: string
}
class ClockEntry {
    /* Fields of Gst-1.0.Gst.ClockEntry */
    /**
     * reference counter (read-only)
     */
    refcount: number
    static name: string
}
class ClockPrivate {
    static name: string
}
class Context {
    /* Methods of Gst-1.0.Gst.Context */
    /**
     * Creates a copy of the context. Returns a copy of the context.
     */
    copy(): Context
    /**
     * Gets the type of `context`.
     */
    get_context_type(): string
    /**
     * Accesses the structure of the context.
     */
    get_structure(): Structure
    /**
     * Checks if `context` has `context_type`.
     * @param context_type Context type to check.
     */
    has_context_type(context_type: string): boolean
    /**
     * Checks if `context` is persistent.
     */
    is_persistent(): boolean
    /**
     * Convenience macro to increase the reference count of the context.
     */
    ref(): Context
    /**
     * Convenience macro to decrease the reference count of the context, possibly
     * freeing it.
     */
    unref(): void
    /**
     * Gets a writable version of the structure.
     */
    writable_structure(): Structure
    static name: string
    static new(context_type: string, persistent: boolean): Context
    constructor(context_type: string, persistent: boolean)
    /* Static methods and pseudo-constructors */
    static new(context_type: string, persistent: boolean): Context
    /**
     * Modifies a pointer to a #GstContext to point to a different #GstContext. The
     * modification is done atomically (so this is useful for ensuring thread safety
     * in some cases), and the reference counts are updated appropriately (the old
     * context is unreffed, the new one is reffed).
     * 
     * Either `new_context` or the #GstContext pointed to by `old_context` may be %NULL.
     * @param old_context pointer to a pointer to a #GstContext     to be replaced.
     * @param new_context pointer to a #GstContext that will     replace the context pointed to by `old_context`.
     */
    static replace(old_context: Context, new_context?: Context | null): [ /* returnType */ boolean, /* old_context */ Context ]
}
abstract class ControlBindingClass {
    /* Fields of Gst-1.0.Gst.ControlBindingClass */
    /**
     * Parent class
     */
    parent_class: ObjectClass
    sync_values: (binding: ControlBinding, object: Object, timestamp: ClockTime, last_sync: ClockTime) => boolean
    get_value: (binding: ControlBinding, timestamp: ClockTime) => any | null
    get_g_value_array: (binding: ControlBinding, timestamp: ClockTime, interval: ClockTime, values: any[]) => boolean
    static name: string
}
class ControlBindingPrivate {
    static name: string
}
abstract class ControlSourceClass {
    /* Fields of Gst-1.0.Gst.ControlSourceClass */
    /**
     * Parent class
     */
    parent_class: ObjectClass
    static name: string
}
class CustomMeta {
    /* Fields of Gst-1.0.Gst.CustomMeta */
    meta: Meta
    /* Methods of Gst-1.0.Gst.CustomMeta */
    /**
     * Retrieve the #GstStructure backing a custom meta, the structure's mutability
     * is conditioned to the writability of the #GstBuffer `meta` is attached to.
     */
    get_structure(): Structure
    /**
     * Checks whether the name of the custom meta is `name`
     * @param name 
     */
    has_name(name: string): boolean
    static name: string
}
class DateTime {
    /* Methods of Gst-1.0.Gst.DateTime */
    /**
     * Returns the day of the month of this #GstDateTime.
     */
    get_day(): number
    /**
     * Retrieves the hour of the day represented by `datetime` in the gregorian
     * calendar. The return is in the range of 0 to 23.
     */
    get_hour(): number
    /**
     * Retrieves the fractional part of the seconds in microseconds represented by
     * `datetime` in the gregorian calendar.
     */
    get_microsecond(): number
    /**
     * Retrieves the minute of the hour represented by `datetime` in the gregorian
     * calendar.
     */
    get_minute(): number
    /**
     * Returns the month of this #GstDateTime. January is 1, February is 2, etc..
     */
    get_month(): number
    /**
     * Retrieves the second of the minute represented by `datetime` in the gregorian
     * calendar.
     */
    get_second(): number
    /**
     * Retrieves the offset from UTC in hours that the timezone specified
     * by `datetime` represents. Timezones ahead (to the east) of UTC have positive
     * values, timezones before (to the west) of UTC have negative values.
     * If `datetime` represents UTC time, then the offset is zero.
     */
    get_time_zone_offset(): number
    /**
     * Returns the year of this #GstDateTime.
     * Call gst_date_time_has_year() before, to avoid warnings.
     */
    get_year(): number
    has_day(): boolean
    has_month(): boolean
    has_second(): boolean
    has_time(): boolean
    has_year(): boolean
    /**
     * Atomically increments the reference count of `datetime` by one.
     */
    ref(): DateTime
    /**
     * Creates a new #GDateTime from a fully defined #GstDateTime object.
     */
    to_g_date_time(): GLib.DateTime | null
    /**
     * Create a minimal string compatible with ISO-8601. Possible output formats
     * are (for example): `2012`, `2012-06`, `2012-06-23`, `2012-06-23T23:30Z`,
     * `2012-06-23T23:30+0100`, `2012-06-23T23:30:59Z`, `2012-06-23T23:30:59+0100`
     */
    to_iso8601_string(): string | null
    /**
     * Atomically decrements the reference count of `datetime` by one.  When the
     * reference count reaches zero, the structure is freed.
     */
    unref(): void
    static name: string
    static new(tzoffset: number, year: number, month: number, day: number, hour: number, minute: number, seconds: number): DateTime
    constructor(tzoffset: number, year: number, month: number, day: number, hour: number, minute: number, seconds: number)
    /* Static methods and pseudo-constructors */
    static new(tzoffset: number, year: number, month: number, day: number, hour: number, minute: number, seconds: number): DateTime
    static new_from_g_date_time(dt?: GLib.DateTime | null): DateTime
    static new_from_iso8601_string(string: string): DateTime
    static new_from_unix_epoch_local_time(secs: number): DateTime
    static new_from_unix_epoch_local_time_usecs(usecs: number): DateTime
    static new_from_unix_epoch_utc(secs: number): DateTime
    static new_from_unix_epoch_utc_usecs(usecs: number): DateTime
    static new_local_time(year: number, month: number, day: number, hour: number, minute: number, seconds: number): DateTime
    static new_now_local_time(): DateTime
    static new_now_utc(): DateTime
    static new_y(year: number): DateTime
    static new_ym(year: number, month: number): DateTime
    static new_ymd(year: number, month: number, day: number): DateTime
}
class DebugCategory {
    /* Methods of Gst-1.0.Gst.DebugCategory */
    /**
     * Removes and frees the category and all associated resources.
     */
    free(): void
    /**
     * Returns the color of a debug category used when printing output in this
     * category.
     */
    get_color(): number
    /**
     * Returns the description of a debug category.
     */
    get_description(): string
    /**
     * Returns the name of a debug category.
     */
    get_name(): string
    /**
     * Returns the threshold of a #GstDebugCategory.
     */
    get_threshold(): DebugLevel
    /**
     * Resets the threshold of the category to the default level. Debug information
     * will only be output if the threshold is lower or equal to the level of the
     * debugging message.
     * Use this function to set the threshold back to where it was after using
     * gst_debug_category_set_threshold().
     */
    reset_threshold(): void
    /**
     * Sets the threshold of the category to the given level. Debug information will
     * only be output if the threshold is lower or equal to the level of the
     * debugging message.
     * > Do not use this function in production code, because other functions may
     * > change the threshold of categories as side effect. It is however a nice
     * > function to use when debugging (even from gdb).
     * @param level the #GstDebugLevel threshold to set.
     */
    set_threshold(level: DebugLevel): void
    static name: string
}
class DebugMessage {
    /* Methods of Gst-1.0.Gst.DebugMessage */
    /**
     * Gets the string representation of a #GstDebugMessage. This function is used
     * in debug handlers to extract the message.
     */
    get(): string | null
    static name: string
}
abstract class DeviceClass {
    /* Fields of Gst-1.0.Gst.DeviceClass */
    /**
     * The parent #GstObjectClass structure.
     */
    parent_class: ObjectClass
    create_element: (device: Device, name?: string | null) => Element | null
    reconfigure_element: (device: Device, element: Element) => boolean
    static name: string
}
abstract class DeviceMonitorClass {
    /* Fields of Gst-1.0.Gst.DeviceMonitorClass */
    /**
     * the parent #GstObjectClass structure
     */
    parent_class: ObjectClass
    static name: string
}
class DeviceMonitorPrivate {
    static name: string
}
class DevicePrivate {
    static name: string
}
abstract class DeviceProviderClass {
    /* Fields of Gst-1.0.Gst.DeviceProviderClass */
    /**
     * the parent #GstObjectClass structure
     */
    parent_class: ObjectClass
    /**
     * a pointer to the #GstDeviceProviderFactory that creates this
     *  provider
     */
    factory: DeviceProviderFactory
    start: (provider: DeviceProvider) => boolean
    stop: (provider: DeviceProvider) => void
    /* Methods of Gst-1.0.Gst.DeviceProviderClass */
    /**
     * Set `key` with `value` as metadata in `klass`.
     * @param key the key to set
     * @param value the value to set
     */
    static add_metadata(klass: DeviceProvider | Function | GObject.Type, key: string, value: string): void
    /**
     * Set `key` with `value` as metadata in `klass`.
     * 
     * Same as gst_device_provider_class_add_metadata(), but `value` must be a static string
     * or an inlined string, as it will not be copied. (GStreamer plugins will
     * be made resident once loaded, so this function can be used even from
     * dynamically loaded plugins.)
     * @param key the key to set
     * @param value the value to set
     */
    static add_static_metadata(klass: DeviceProvider | Function | GObject.Type, key: string, value: string): void
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    static get_metadata(klass: DeviceProvider | Function | GObject.Type, key: string): string | null
    /**
     * Sets the detailed information for a #GstDeviceProviderClass.
     * 
     * > This function is for use in _class_init functions only.
     * @param longname The long English name of the device provider. E.g. "File Sink"
     * @param classification String describing the type of device provider, as an  unordered list separated with slashes ('/'). See draft-klass.txt of the  design docs for more details and common types. E.g: "Sink/File"
     * @param description Sentence describing the purpose of the device provider. E.g: "Write stream to a file"
     * @param author Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;"
     */
    static set_metadata(klass: DeviceProvider | Function | GObject.Type, longname: string, classification: string, description: string, author: string): void
    /**
     * Sets the detailed information for a #GstDeviceProviderClass.
     * 
     * > This function is for use in _class_init functions only.
     * 
     * Same as gst_device_provider_class_set_metadata(), but `longname,` `classification,`
     * `description,` and `author` must be static strings or inlined strings, as
     * they will not be copied. (GStreamer plugins will be made resident once
     * loaded, so this function can be used even from dynamically loaded plugins.)
     * @param longname The long English name of the element. E.g. "File Sink"
     * @param classification String describing the type of element, as an unordered list separated with slashes ('/'). See draft-klass.txt of the design docs for more details and common types. E.g: "Sink/File"
     * @param description Sentence describing the purpose of the element.  E.g: "Write stream to a file"
     * @param author Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;"
     */
    static set_static_metadata(klass: DeviceProvider | Function | GObject.Type, longname: string, classification: string, description: string, author: string): void
    static name: string
}
abstract class DeviceProviderFactoryClass {
    static name: string
}
class DeviceProviderPrivate {
    static name: string
}
abstract class DynamicTypeFactoryClass {
    static name: string
}
abstract class ElementClass {
    /* Fields of Gst-1.0.Gst.ElementClass */
    /**
     * the parent class structure
     */
    parent_class: ObjectClass
    /**
     * metadata for elements of this class
     */
    metadata: object
    /**
     * the #GstElementFactory that creates these elements
     */
    elementfactory: ElementFactory
    /**
     * a #GList of #GstPadTemplate
     */
    padtemplates: object[]
    /**
     * the number of padtemplates
     */
    numpadtemplates: number
    /**
     * changed whenever the padtemplates change
     */
    pad_templ_cookie: number
    pad_added: (element: Element, pad: Pad) => void
    pad_removed: (element: Element, pad: Pad) => void
    no_more_pads: (element: Element) => void
    request_new_pad: (element: Element, templ: PadTemplate, name?: string | null, caps?: Caps | null) => Pad | null
    release_pad: (element: Element, pad: Pad) => void
    get_state: (element: Element, timeout: ClockTime) => [ /* returnType */ StateChangeReturn, /* state */ State | null, /* pending */ State | null ]
    set_state: (element: Element, state: State) => StateChangeReturn
    change_state: (element: Element, transition: StateChange) => StateChangeReturn
    state_changed: (element: Element, oldstate: State, newstate: State, pending: State) => void
    set_bus: (element: Element, bus?: Bus | null) => void
    provide_clock: (element: Element) => Clock | null
    set_clock: (element: Element, clock?: Clock | null) => boolean
    send_event: (element: Element, event: Event) => boolean
    query: (element: Element, query: Query) => boolean
    post_message: (element: Element, message: Message) => boolean
    set_context: (element: Element, context: Context) => void
    /* Methods of Gst-1.0.Gst.ElementClass */
    /**
     * Set `key` with `value` as metadata in `klass`.
     * @param key the key to set
     * @param value the value to set
     */
    static add_metadata(klass: Element | Function | GObject.Type, key: string, value: string): void
    /**
     * Adds a padtemplate to an element class. This is mainly used in the _class_init
     * functions of classes. If a pad template with the same name as an already
     * existing one is added the old one is replaced by the new one.
     * 
     * `templ'`s reference count will be incremented, and any floating
     * reference will be removed (see gst_object_ref_sink())
     * @param templ a #GstPadTemplate to add to the element class.
     */
    static add_pad_template(klass: Element | Function | GObject.Type, templ: PadTemplate): void
    /**
     * Set `key` with `value` as metadata in `klass`.
     * 
     * Same as gst_element_class_add_metadata(), but `value` must be a static string
     * or an inlined string, as it will not be copied. (GStreamer plugins will
     * be made resident once loaded, so this function can be used even from
     * dynamically loaded plugins.)
     * @param key the key to set
     * @param value the value to set
     */
    static add_static_metadata(klass: Element | Function | GObject.Type, key: string, value: string): void
    /**
     * Adds a pad template to an element class based on the static pad template
     * `templ`. This is mainly used in the _class_init functions of element
     * implementations. If a pad template with the same name already exists,
     * the old one is replaced by the new one.
     * @param static_templ #GstStaticPadTemplate to add as pad template to the element class.
     */
    static add_static_pad_template(klass: Element | Function | GObject.Type, static_templ: StaticPadTemplate): void
    /**
     * Adds a pad template to an element class based on the static pad template
     * `templ`. This is mainly used in the _class_init functions of element
     * implementations. If a pad template with the same name already exists,
     * the old one is replaced by the new one.
     * @param static_templ #GstStaticPadTemplate to add as pad template to the element class.
     * @param pad_type The #GType of the pad to create
     */
    static add_static_pad_template_with_gtype(klass: Element | Function | GObject.Type, static_templ: StaticPadTemplate, pad_type: GObject.Type): void
    /**
     * Get metadata with `key` in `klass`.
     * @param key the key to get
     */
    static get_metadata(klass: Element | Function | GObject.Type, key: string): string
    /**
     * Retrieves a padtemplate from `element_class` with the given name.
     * > If you use this function in the #GInstanceInitFunc of an object class
     * > that has subclasses, make sure to pass the g_class parameter of the
     * > #GInstanceInitFunc here.
     * @param name the name of the #GstPadTemplate to get.
     */
    static get_pad_template(element_class: Element | Function | GObject.Type, name: string): PadTemplate | null
    /**
     * Retrieves a list of the pad templates associated with `element_class`. The
     * list must not be modified by the calling code.
     * > If you use this function in the #GInstanceInitFunc of an object class
     * > that has subclasses, make sure to pass the g_class parameter of the
     * > #GInstanceInitFunc here.
     */
    static get_pad_template_list(element_class: Element | Function | GObject.Type): PadTemplate[]
    /**
     * Sets the detailed information for a #GstElementClass.
     * > This function is for use in _class_init functions only.
     * @param longname The long English name of the element. E.g. "File Sink"
     * @param classification String describing the type of element, as an unordered list separated with slashes ('/'). See draft-klass.txt of the design docs for more details and common types. E.g: "Sink/File"
     * @param description Sentence describing the purpose of the element. E.g: "Write stream to a file"
     * @param author Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;"
     */
    static set_metadata(klass: Element | Function | GObject.Type, longname: string, classification: string, description: string, author: string): void
    /**
     * Sets the detailed information for a #GstElementClass.
     * 
     * > This function is for use in _class_init functions only.
     * 
     * Same as gst_element_class_set_metadata(), but `longname,` `classification,`
     * `description,` and `author` must be static strings or inlined strings, as
     * they will not be copied. (GStreamer plugins will be made resident once
     * loaded, so this function can be used even from dynamically loaded plugins.)
     * @param longname The long English name of the element. E.g. "File Sink"
     * @param classification String describing the type of element, as an unordered list separated with slashes ('/'). See draft-klass.txt of the design docs for more details and common types. E.g: "Sink/File"
     * @param description Sentence describing the purpose of the element. E.g: "Write stream to a file"
     * @param author Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;"
     */
    static set_static_metadata(klass: Element | Function | GObject.Type, longname: string, classification: string, description: string, author: string): void
    static name: string
}
abstract class ElementFactoryClass {
    static name: string
}
class Event {
    /* Fields of Gst-1.0.Gst.Event */
    /**
     * the parent structure
     */
    mini_object: MiniObject
    /**
     * the #GstEventType of the event
     */
    type: EventType
    /**
     * the timestamp of the event
     */
    timestamp: number
    /**
     * the sequence number of the event
     */
    seqnum: number
    /* Methods of Gst-1.0.Gst.Event */
    /**
     * Parses a segment `event` and copies the #GstSegment into the location
     * given by `segment`.
     * @param segment a pointer to a #GstSegment
     */
    copy_segment(segment: Segment): void
    /**
     * Retrieve the accumulated running time offset of the event.
     * 
     * Events passing through #GstPads that have a running time
     * offset set via gst_pad_set_offset() will get their offset
     * adjusted according to the pad's offset.
     * 
     * If the event contains any information that related to the
     * running time, this information will need to be updated
     * before usage with this offset.
     */
    get_running_time_offset(): number
    /**
     * Retrieve the sequence number of a event.
     * 
     * Events have ever-incrementing sequence numbers, which may also be set
     * explicitly via gst_event_set_seqnum(). Sequence numbers are typically used to
     * indicate that a event corresponds to some other set of events or messages,
     * for example an EOS event corresponding to a SEEK event. It is considered good
     * practice to make this correspondence when possible, though it is not
     * required.
     * 
     * Note that events and messages share the same sequence number incrementor;
     * two events or messages will never have the same sequence number unless
     * that correspondence was made explicitly.
     */
    get_seqnum(): number
    /**
     * Access the structure of the event.
     */
    get_structure(): Structure | null
    /**
     * Checks if `event` has the given `name`. This function is usually used to
     * check the name of a custom event.
     * @param name name to check
     */
    has_name(name: string): boolean
    /**
     * Checks if `event` has the given `name`. This function is usually used to
     * check the name of a custom event.
     * @param name name to check as a GQuark
     */
    has_name_id(name: GLib.Quark): boolean
    /**
     * Get the format, minsize, maxsize and async-flag in the buffersize event.
     */
    parse_buffer_size(): [ /* format */ Format, /* minsize */ number, /* maxsize */ number, /* async */ boolean ]
    /**
     * Get the caps from `event`. The caps remains valid as long as `event` remains
     * valid.
     */
    parse_caps(): /* caps */ Caps
    /**
     * Parse the FLUSH_STOP event and retrieve the `reset_time` member.
     */
    parse_flush_stop(): /* reset_time */ boolean
    /**
     * Extract timestamp and duration from a new GAP event.
     */
    parse_gap(): [ /* timestamp */ ClockTime | null, /* duration */ ClockTime | null ]
    /**
     * Retrieve the gap flags that may have been set on a gap event with
     * gst_event_set_gap_flags().
     */
    parse_gap_flags(): /* flags */ GapFlags
    parse_group_id(): [ /* returnType */ boolean, /* group_id */ number ]
    /**
     * Extract rate and flags from an instant-rate-change event.
     */
    parse_instant_rate_change(): [ /* rate_multiplier */ number | null, /* new_flags */ SegmentFlags | null ]
    /**
     * Extract the rate multiplier and running times from an instant-rate-sync-time event.
     */
    parse_instant_rate_sync_time(): [ /* rate_multiplier */ number | null, /* running_time */ ClockTime | null, /* upstream_running_time */ ClockTime | null ]
    /**
     * Get the latency in the latency event.
     */
    parse_latency(): /* latency */ ClockTime
    /**
     * Parses an event containing protection system specific information and stores
     * the results in `system_id,` `data` and `origin`. The data stored in `system_id,`
     * `origin` and `data` are valid until `event` is released.
     */
    parse_protection(): [ /* system_id */ string | null, /* data */ Buffer | null, /* origin */ string | null ]
    /**
     * Get the type, proportion, diff and timestamp in the qos event. See
     * gst_event_new_qos() for more information about the different QoS values.
     * 
     * `timestamp` will be adjusted for any pad offsets of pads it was passing through.
     */
    parse_qos(): [ /* type */ QOSType, /* proportion */ number, /* diff */ ClockTimeDiff, /* timestamp */ ClockTime ]
    /**
     * Parses a seek `event` and stores the results in the given result locations.
     */
    parse_seek(): [ /* rate */ number, /* format */ Format, /* flags */ SeekFlags, /* start_type */ SeekType, /* start */ number, /* stop_type */ SeekType, /* stop */ number ]
    /**
     * Retrieve the trickmode interval that may have been set on a
     * seek event with gst_event_set_seek_trickmode_interval().
     */
    parse_seek_trickmode_interval(): /* interval */ ClockTime
    /**
     * Parses a segment `event` and stores the result in the given `segment` location.
     * `segment` remains valid only until the `event` is freed. Don't modify the segment
     * and make a copy if you want to modify it or store it for later use.
     */
    parse_segment(): /* segment */ Segment
    /**
     * Extracts the position and format from the segment done message.
     */
    parse_segment_done(): [ /* format */ Format | null, /* position */ number | null ]
    /**
     * Parse the SELECT_STREAMS event and retrieve the contained streams.
     */
    parse_select_streams(): /* streams */ string[]
    /**
     * Parse the sink-message event. Unref `msg` after usage.
     */
    parse_sink_message(): /* msg */ Message
    /**
     * Parse the step event.
     */
    parse_step(): [ /* format */ Format | null, /* amount */ number | null, /* rate */ number | null, /* flush */ boolean | null, /* intermediate */ boolean | null ]
    /**
     * Parse a stream-start `event` and extract the #GstStream from it.
     */
    parse_stream(): /* stream */ Stream
    /**
     * Retrieve new #GstStreamCollection from STREAM_COLLECTION event `event`.
     */
    parse_stream_collection(): /* collection */ StreamCollection
    parse_stream_flags(): /* flags */ StreamFlags
    /**
     * Parse a stream-group-done `event` and store the result in the given
     * `group_id` location.
     */
    parse_stream_group_done(): /* group_id */ number
    /**
     * Parse a stream-id `event` and store the result in the given `stream_id`
     * location. The string stored in `stream_id` must not be modified and will
     * remain valid only until `event` gets freed. Make a copy if you want to
     * modify it or store it for later use.
     */
    parse_stream_start(): /* stream_id */ string
    /**
     * Parses a tag `event` and stores the results in the given `taglist` location.
     * No reference to the taglist will be returned, it remains valid only until
     * the `event` is freed. Don't modify or free the taglist, make a copy if you
     * want to modify it or store it for later use.
     */
    parse_tag(): /* taglist */ TagList
    /**
     * Parse a TOC `event` and store the results in the given `toc` and `updated` locations.
     */
    parse_toc(): [ /* toc */ Toc, /* updated */ boolean ]
    /**
     * Parse a TOC select `event` and store the results in the given `uid` location.
     */
    parse_toc_select(): /* uid */ string | null
    /**
     * Sets `flags` on `event` to give additional information about the reason for
     * the #GST_EVENT_GAP.
     * @param flags a #GstGapFlags
     */
    set_gap_flags(flags: GapFlags): void
    /**
     * All streams that have the same group id are supposed to be played
     * together, i.e. all streams inside a container file should have the
     * same group id but different stream ids. The group id should change
     * each time the stream is started, resulting in different group ids
     * each time a file is played for example.
     * 
     * Use gst_util_group_id_next() to get a new group id.
     * @param group_id the group id to set
     */
    set_group_id(group_id: number): void
    /**
     * Set the running time offset of a event. See
     * gst_event_get_running_time_offset() for more information.
     * 
     * MT safe.
     * @param offset A the new running time offset
     */
    set_running_time_offset(offset: number): void
    /**
     * Sets a trickmode interval on a (writable) seek event. Elements
     * that support TRICKMODE_KEY_UNITS seeks SHOULD use this as the minimal
     * interval between each frame they may output.
     * @param interval 
     */
    set_seek_trickmode_interval(interval: ClockTime): void
    /**
     * Set the sequence number of a event.
     * 
     * This function might be called by the creator of a event to indicate that the
     * event relates to other events or messages. See gst_event_get_seqnum() for
     * more information.
     * 
     * MT safe.
     * @param seqnum A sequence number.
     */
    set_seqnum(seqnum: number): void
    /**
     * Set the `stream` on the stream-start `event`
     * @param stream the stream object to set
     */
    set_stream(stream: Stream): void
    set_stream_flags(flags: StreamFlags): void
    /**
     * Get a writable version of the structure.
     */
    writable_structure(): Structure
    static name: string
    /* Static methods and pseudo-constructors */
    static new_buffer_size(format: Format, minsize: number, maxsize: number, async: boolean): Event
    static new_caps(caps: Caps): Event
    static new_custom(type: EventType, structure: Structure): Event
    static new_eos(): Event
    static new_flush_start(): Event
    static new_flush_stop(reset_time: boolean): Event
    static new_gap(timestamp: ClockTime, duration: ClockTime): Event
    static new_instant_rate_change(rate_multiplier: number, new_flags: SegmentFlags): Event
    static new_instant_rate_sync_time(rate_multiplier: number, running_time: ClockTime, upstream_running_time: ClockTime): Event
    static new_latency(latency: ClockTime): Event
    static new_navigation(structure: Structure): Event
    static new_protection(system_id: string, data: Buffer, origin: string): Event
    static new_qos(type: QOSType, proportion: number, diff: ClockTimeDiff, timestamp: ClockTime): Event
    static new_reconfigure(): Event
    static new_seek(rate: number, format: Format, flags: SeekFlags, start_type: SeekType, start: number, stop_type: SeekType, stop: number): Event
    static new_segment(segment: Segment): Event
    static new_segment_done(format: Format, position: number): Event
    static new_select_streams(streams: string[]): Event
    static new_sink_message(name: string, msg: Message): Event
    static new_step(format: Format, amount: number, rate: number, flush: boolean, intermediate: boolean): Event
    static new_stream_collection(collection: StreamCollection): Event
    static new_stream_group_done(group_id: number): Event
    static new_stream_start(stream_id: string): Event
    static new_tag(taglist: TagList): Event
    static new_toc(toc: Toc, updated: boolean): Event
    static new_toc_select(uid: string): Event
}
class FormatDefinition {
    /* Fields of Gst-1.0.Gst.FormatDefinition */
    /**
     * The unique id of this format
     */
    value: Format
    /**
     * A short nick of the format
     */
    nick: string
    /**
     * A longer description of the format
     */
    description: string
    /**
     * A quark for the nick
     */
    quark: GLib.Quark
    static name: string
}
abstract class GhostPadClass {
    /* Fields of Gst-1.0.Gst.GhostPadClass */
    parent_class: ProxyPadClass
    static name: string
}
class GhostPadPrivate {
    static name: string
}
class Iterator {
    /* Fields of Gst-1.0.Gst.Iterator */
    /**
     * The function to copy the iterator
     */
    copy: IteratorCopyFunction
    /**
     * The function to get the next item in the iterator
     */
    next: IteratorNextFunction
    /**
     * The function to be called for each item retrieved
     */
    item: IteratorItemFunction
    /**
     * The function to call when a resync is needed.
     */
    resync: IteratorResyncFunction
    /**
     * The function to call when the iterator is freed
     */
    free: IteratorFreeFunction
    /**
     * The iterator that is currently pushed with gst_iterator_push()
     */
    pushed: Iterator
    /**
     * The type of the object that this iterator will return
     */
    type: GObject.Type
    /**
     * The lock protecting the data structure and the cookie.
     */
    lock: GLib.Mutex
    /**
     * The cookie; the value of the master_cookie when this iterator was
     *          created.
     */
    cookie: number
    /**
     * A pointer to the master cookie.
     */
    master_cookie: number
    /**
     * the size of the iterator
     */
    size: number
    /* Methods of Gst-1.0.Gst.Iterator */
    /**
     * Create a new iterator from an existing iterator. The new iterator
     * will only return those elements that match the given compare function `func`.
     * The first parameter that is passed to `func` is the #GValue of the current
     * iterator element and the second parameter is `user_data`. `func` should
     * return 0 for elements that should be included in the filtered iterator.
     * 
     * When this iterator is freed, `it` will also be freed.
     * @param func the compare function to select elements
     * @param user_data user data passed to the compare function
     */
    filter(func: GLib.CompareFunc, user_data: any): Iterator
    /**
     * Find the first element in `it` that matches the compare function `func`.
     * `func` should return 0 when the element is found. The first parameter
     * to `func` will be the current element of the iterator and the
     * second parameter will be `user_data`.
     * The result will be stored in `elem` if a result is found.
     * 
     * The iterator will not be freed.
     * 
     * This function will return %FALSE if an error happened to the iterator
     * or if the element wasn't found.
     * @param func the compare function to use
     */
    find_custom(func: GLib.CompareFunc): [ /* returnType */ boolean, /* elem */ any ]
    /**
     * Folds `func` over the elements of `iter`. That is to say, `func` will be called
     * as `func` (object, `ret,` `user_data)` for each object in `it`. The normal use
     * of this procedure is to accumulate the results of operating on the objects in
     * `ret`.
     * 
     * This procedure can be used (and is used internally) to implement the
     * gst_iterator_foreach() and gst_iterator_find_custom() operations.
     * 
     * The fold will proceed as long as `func` returns %TRUE. When the iterator has no
     * more arguments, %GST_ITERATOR_DONE will be returned. If `func` returns %FALSE,
     * the fold will stop, and %GST_ITERATOR_OK will be returned. Errors or resyncs
     * will cause fold to return %GST_ITERATOR_ERROR or %GST_ITERATOR_RESYNC as
     * appropriate.
     * 
     * The iterator will not be freed.
     * @param func the fold function
     * @param ret the seed value passed to the fold function
     */
    fold(func: IteratorFoldFunction, ret: any): IteratorResult
    /**
     * Iterate over all element of `it` and call the given function `func` for
     * each element.
     * @param func the function to call for each element.
     */
    foreach(func: IteratorForeachFunction): IteratorResult
    /**
     * Pushes `other` iterator onto `it`. All calls performed on `it` are
     * forwarded to `other`. If `other` returns %GST_ITERATOR_DONE, it is
     * popped again and calls are handled by `it` again.
     * 
     * This function is mainly used by objects implementing the iterator
     * next function to recurse into substructures.
     * 
     * When gst_iterator_resync() is called on `it,` `other` will automatically be
     * popped.
     * 
     * MT safe.
     * @param other The #GstIterator to push
     */
    push(other: Iterator): void
    static name: string
    /* Static methods and pseudo-constructors */
    static new_single(type: GObject.Type, object: any): Iterator
}
class MapInfo {
    /* Fields of Gst-1.0.Gst.MapInfo */
    /**
     * a pointer to the mapped memory
     */
    memory: Memory
    /**
     * flags used when mapping the memory
     */
    flags: MapFlags
    /**
     * a pointer to the mapped data
     */
    data: Uint8Array
    /**
     * the valid size in `data`
     */
    size: number
    /**
     * the maximum bytes in `data`
     */
    maxsize: number
    /**
     * extra private user_data that the implementation of the memory
     *             can use to store extra info.
     */
    user_data: object[]
    static name: string
}
class Memory {
    /* Fields of Gst-1.0.Gst.Memory */
    /**
     * parent structure
     */
    mini_object: MiniObject
    /**
     * pointer to the #GstAllocator
     */
    allocator: Allocator
    /**
     * parent memory block
     */
    parent: Memory
    /**
     * the maximum size allocated
     */
    maxsize: number
    /**
     * the alignment of the memory
     */
    align: number
    /**
     * the offset where valid data starts
     */
    offset: number
    /**
     * the size of valid data
     */
    size: number
    /* Methods of Gst-1.0.Gst.Memory */
    /**
     * Return a copy of `size` bytes from `mem` starting from `offset`. This copy is
     * guaranteed to be writable. `size` can be set to -1 to return a copy
     * from `offset` to the end of the memory region.
     * @param offset offset to copy from
     * @param size size to copy, or -1 to copy to the end of the memory region
     */
    copy(offset: number, size: number): Memory
    /**
     * Get the current `size,` `offset` and `maxsize` of `mem`.
     */
    get_sizes(): [ /* returnType */ number, /* offset */ number | null, /* maxsize */ number | null ]
    /**
     * Check if `mem1` and mem2 share the memory with a common parent memory object
     * and that the memory is contiguous.
     * 
     * If this is the case, the memory of `mem1` and `mem2` can be merged
     * efficiently by performing gst_memory_share() on the parent object from
     * the returned `offset`.
     * @param mem2 a #GstMemory
     */
    is_span(mem2: Memory): [ /* returnType */ boolean, /* offset */ number ]
    /**
     * Check if `mem` if allocated with an allocator for `mem_type`.
     * @param mem_type a memory type
     */
    is_type(mem_type: string): boolean
    /**
     * Create a #GstMemory object that is mapped with `flags`. If `mem` is mappable
     * with `flags,` this function returns the mapped `mem` directly. Otherwise a
     * mapped copy of `mem` is returned.
     * 
     * This function takes ownership of old `mem` and returns a reference to a new
     * #GstMemory.
     * @param flags mapping flags
     */
    make_mapped(flags: MapFlags): [ /* returnType */ Memory | null, /* info */ MapInfo ]
    /**
     * Fill `info` with the pointer and sizes of the memory in `mem` that can be
     * accessed according to `flags`.
     * 
     * This function can return %FALSE for various reasons:
     * - the memory backed by `mem` is not accessible with the given `flags`.
     * - the memory was already mapped with a different mapping.
     * 
     * `info` and its contents remain valid for as long as `mem` is valid and
     * until gst_memory_unmap() is called.
     * 
     * For each gst_memory_map() call, a corresponding gst_memory_unmap() call
     * should be done.
     * @param flags mapping flags
     */
    map(flags: MapFlags): [ /* returnType */ boolean, /* info */ MapInfo ]
    /**
     * Resize the memory region. `mem` should be writable and offset + size should be
     * less than the maxsize of `mem`.
     * 
     * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED will be
     * cleared when offset or padding is increased respectively.
     * @param offset a new offset
     * @param size a new size
     */
    resize(offset: number, size: number): void
    /**
     * Return a shared copy of `size` bytes from `mem` starting from `offset`. No
     * memory copy is performed and the memory region is simply shared. The result
     * is guaranteed to be non-writable. `size` can be set to -1 to return a shared
     * copy from `offset` to the end of the memory region.
     * @param offset offset to share from
     * @param size size to share, or -1 to share to the end of the memory region
     */
    share(offset: number, size: number): Memory
    /**
     * Release the memory obtained with gst_memory_map()
     * @param info a #GstMapInfo
     */
    unmap(info: MapInfo): void
    static name: string
    /* Static methods and pseudo-constructors */
    static new_wrapped(flags: MemoryFlags, data: Uint8Array, maxsize: number, offset: number, notify?: GLib.DestroyNotify | null): Memory
}
class Message {
    /* Fields of Gst-1.0.Gst.Message */
    /**
     * the parent structure
     */
    mini_object: MiniObject
    /**
     * the #GstMessageType of the message
     */
    type: MessageType
    /**
     * the timestamp of the message
     */
    timestamp: number
    /**
     * the src of the message
     */
    src: Object
    /**
     * the sequence number of the message
     */
    seqnum: number
    /* Methods of Gst-1.0.Gst.Message */
    /**
     * Creates and appends a new entry.
     * 
     * The specified location string is copied. However, ownership over the tag
     * list and structure are transferred to the message.
     * @param location location string for the new entry
     * @param tag_list tag list for the new entry
     * @param entry_struct structure for the new entry
     */
    add_redirect_entry(location: string, tag_list?: TagList | null, entry_struct?: Structure | null): void
    get_num_redirect_entries(): number
    /**
     * Retrieve the sequence number of a message.
     * 
     * Messages have ever-incrementing sequence numbers, which may also be set
     * explicitly via gst_message_set_seqnum(). Sequence numbers are typically used
     * to indicate that a message corresponds to some other set of messages or
     * events, for example a SEGMENT_DONE message corresponding to a SEEK event. It
     * is considered good practice to make this correspondence when possible, though
     * it is not required.
     * 
     * Note that events and messages share the same sequence number incrementor;
     * two events or messages will never have the same sequence number unless
     * that correspondence was made explicitly.
     */
    get_seqnum(): number
    /**
     * Extracts the object managing the streaming thread from `message`.
     */
    get_stream_status_object(): any | null
    /**
     * Access the structure of the message.
     */
    get_structure(): Structure | null
    /**
     * Checks if `message` has the given `name`. This function is usually used to
     * check the name of a custom message.
     * @param name name to check
     */
    has_name(name: string): boolean
    /**
     * Extract the running_time from the async_done message.
     * 
     * MT safe.
     */
    parse_async_done(): /* running_time */ ClockTime | null
    /**
     * Extracts the buffering percent from the GstMessage. see also
     * gst_message_new_buffering().
     * 
     * MT safe.
     */
    parse_buffering(): /* percent */ number | null
    /**
     * Extracts the buffering stats values from `message`.
     */
    parse_buffering_stats(): [ /* mode */ BufferingMode | null, /* avg_in */ number | null, /* avg_out */ number | null, /* buffering_left */ number | null ]
    /**
     * Extracts the lost clock from the GstMessage.
     * The clock object returned remains valid until the message is freed.
     * 
     * MT safe.
     */
    parse_clock_lost(): /* clock */ Clock | null
    /**
     * Extracts the clock and ready flag from the GstMessage.
     * The clock object returned remains valid until the message is freed.
     * 
     * MT safe.
     */
    parse_clock_provide(): [ /* clock */ Clock | null, /* ready */ boolean | null ]
    /**
     * Parse a context type from an existing GST_MESSAGE_NEED_CONTEXT message.
     */
    parse_context_type(): [ /* returnType */ boolean, /* context_type */ string | null ]
    /**
     * Parses a device-added message. The device-added message is produced by
     * #GstDeviceProvider or a #GstDeviceMonitor. It announces the appearance
     * of monitored devices.
     */
    parse_device_added(): /* device */ Device | null
    /**
     * Parses a device-changed message. The device-changed message is produced by
     * #GstDeviceProvider or a #GstDeviceMonitor. It announces the
     * disappearance of monitored devices. * It announce that a device properties has
     * changed and `device` represents the new modified version of `changed_device`.
     */
    parse_device_changed(): [ /* device */ Device | null, /* changed_device */ Device | null ]
    /**
     * Parses a device-removed message. The device-removed message is produced by
     * #GstDeviceProvider or a #GstDeviceMonitor. It announces the
     * disappearance of monitored devices.
     */
    parse_device_removed(): /* device */ Device | null
    /**
     * Extracts the GError and debug string from the GstMessage. The values returned
     * in the output arguments are copies; the caller must free them when done.
     * 
     * Typical usage of this function might be:
     * 
     * ```c
     *   ...
     *   switch (GST_MESSAGE_TYPE (msg)) {
     *     case GST_MESSAGE_ERROR: {
     *       GError *err = NULL;
     *       gchar *dbg_info = NULL;
     * 
     *       gst_message_parse_error (msg, &err, &dbg_info);
     *       g_printerr ("ERROR from element %s: %s\n",
     *           GST_OBJECT_NAME (msg->src), err->message);
     *       g_printerr ("Debugging info: %s\n", (dbg_info) ? dbg_info : "none");
     *       g_error_free (err);
     *       g_free (dbg_info);
     *       break;
     *     }
     *     ...
     *   }
     *   ...
     * ```
     * 
     * 
     * MT safe.
     */
    parse_error(): [ /* gerror */ GLib.Error | null, /* debug */ string | null ]
    /**
     * Returns the optional details structure, may be NULL if none.
     * The returned structure must not be freed.
     */
    parse_error_details(): /* structure */ Structure
    /**
     * Extract the group from the STREAM_START message.
     */
    parse_group_id(): [ /* returnType */ boolean, /* group_id */ number | null ]
    /**
     * Extract the context from the HAVE_CONTEXT message.
     * 
     * MT safe.
     */
    parse_have_context(): /* context */ Context | null
    /**
     * Extracts the GError and debug string from the GstMessage. The values returned
     * in the output arguments are copies; the caller must free them when done.
     * 
     * MT safe.
     */
    parse_info(): [ /* gerror */ GLib.Error | null, /* debug */ string | null ]
    /**
     * Returns the optional details structure, may be NULL if none
     * The returned structure must not be freed.
     */
    parse_info_details(): /* structure */ Structure
    /**
     * Parses the rate_multiplier from the instant-rate-request message.
     */
    parse_instant_rate_request(): /* rate_multiplier */ number | null
    /**
     * Extracts the new clock from the GstMessage.
     * The clock object returned remains valid until the message is freed.
     * 
     * MT safe.
     */
    parse_new_clock(): /* clock */ Clock | null
    /**
     * Parses the progress `type,` `code` and `text`.
     */
    parse_progress(): [ /* type */ ProgressType | null, /* code */ string | null, /* text */ string | null ]
    /**
     * Parses a property-notify message. These will be posted on the bus only
     * when set up with gst_element_add_property_notify_watch() or
     * gst_element_add_property_deep_notify_watch().
     */
    parse_property_notify(): [ /* object */ Object | null, /* property_name */ string | null, /* property_value */ any | null ]
    /**
     * Extract the timestamps and live status from the QoS message.
     * 
     * The returned values give the running_time, stream_time, timestamp and
     * duration of the dropped buffer. Values of GST_CLOCK_TIME_NONE mean unknown
     * values.
     * 
     * MT safe.
     */
    parse_qos(): [ /* live */ boolean | null, /* running_time */ number | null, /* stream_time */ number | null, /* timestamp */ number | null, /* duration */ number | null ]
    /**
     * Extract the QoS stats representing the history of the current continuous
     * pipeline playback period.
     * 
     * When `format` is `GST_FORMAT_UNDEFINED` both `dropped` and `processed` are
     * invalid. Values of -1 for either `processed` or `dropped` mean unknown values.
     * 
     * MT safe.
     */
    parse_qos_stats(): [ /* format */ Format | null, /* processed */ number | null, /* dropped */ number | null ]
    /**
     * Extract the QoS values that have been calculated/analysed from the QoS data
     * 
     * MT safe.
     */
    parse_qos_values(): [ /* jitter */ number | null, /* proportion */ number | null, /* quality */ number | null ]
    /**
     * Parses the location and/or structure from the entry with the given index.
     * The index must be between 0 and gst_message_get_num_redirect_entries() - 1.
     * Returned pointers are valid for as long as this message exists.
     * @param entry_index index of the entry to parse
     */
    parse_redirect_entry(entry_index: number): [ /* location */ string | null, /* tag_list */ TagList | null, /* entry_struct */ Structure | null ]
    /**
     * Extract the requested state from the request_state message.
     * 
     * MT safe.
     */
    parse_request_state(): /* state */ State | null
    /**
     * Extract the running-time from the RESET_TIME message.
     * 
     * MT safe.
     */
    parse_reset_time(): /* running_time */ ClockTime | null
    /**
     * Extracts the position and format from the segment done message.
     * 
     * MT safe.
     */
    parse_segment_done(): [ /* format */ Format | null, /* position */ number | null ]
    /**
     * Extracts the position and format from the segment start message.
     * 
     * MT safe.
     */
    parse_segment_start(): [ /* format */ Format | null, /* position */ number | null ]
    /**
     * Extracts the old and new states from the GstMessage.
     * 
     * Typical usage of this function might be:
     * 
     * ```c
     *   ...
     *   switch (GST_MESSAGE_TYPE (msg)) {
     *     case GST_MESSAGE_STATE_CHANGED: {
     *       GstState old_state, new_state;
     * 
     *       gst_message_parse_state_changed (msg, &old_state, &new_state, NULL);
     *       g_print ("Element %s changed state from %s to %s.\n",
     *           GST_OBJECT_NAME (msg->src),
     *           gst_element_state_get_name (old_state),
     *           gst_element_state_get_name (new_state));
     *       break;
     *     }
     *     ...
     *   }
     *   ...
     * ```
     * 
     * 
     * MT safe.
     */
    parse_state_changed(): [ /* oldstate */ State | null, /* newstate */ State | null, /* pending */ State | null ]
    /**
     * Extract the values the step_done message.
     * 
     * MT safe.
     */
    parse_step_done(): [ /* format */ Format | null, /* amount */ number | null, /* rate */ number | null, /* flush */ boolean | null, /* intermediate */ boolean | null, /* duration */ number | null, /* eos */ boolean | null ]
    /**
     * Extract the values from step_start message.
     * 
     * MT safe.
     */
    parse_step_start(): [ /* active */ boolean | null, /* format */ Format | null, /* amount */ number | null, /* rate */ number | null, /* flush */ boolean | null, /* intermediate */ boolean | null ]
    /**
     * Parses a stream-collection message.
     */
    parse_stream_collection(): /* collection */ StreamCollection | null
    /**
     * Extracts the stream status type and owner the GstMessage. The returned
     * owner remains valid for as long as the reference to `message` is valid and
     * should thus not be unreffed.
     * 
     * MT safe.
     */
    parse_stream_status(): [ /* type */ StreamStatusType, /* owner */ Element ]
    /**
     * Parses a streams-selected message.
     */
    parse_streams_selected(): /* collection */ StreamCollection | null
    /**
     * Extracts the change type and completion status from the GstMessage.
     * 
     * MT safe.
     */
    parse_structure_change(): [ /* type */ StructureChangeType, /* owner */ Element | null, /* busy */ boolean | null ]
    /**
     * Extracts the tag list from the GstMessage. The tag list returned in the
     * output argument is a copy; the caller must free it when done.
     * 
     * Typical usage of this function might be:
     * 
     * ```c
     *   ...
     *   switch (GST_MESSAGE_TYPE (msg)) {
     *     case GST_MESSAGE_TAG: {
     *       GstTagList *tags = NULL;
     * 
     *       gst_message_parse_tag (msg, &tags);
     *       g_print ("Got tags from element %s\n", GST_OBJECT_NAME (msg->src));
     *       handle_tags (tags);
     *       gst_tag_list_unref (tags);
     *       break;
     *     }
     *     ...
     *   }
     *   ...
     * ```
     * 
     * 
     * MT safe.
     */
    parse_tag(): /* tag_list */ TagList
    /**
     * Extract the TOC from the #GstMessage. The TOC returned in the
     * output argument is a copy; the caller must free it with
     * gst_toc_unref() when done.
     * 
     * MT safe.
     */
    parse_toc(): [ /* toc */ Toc, /* updated */ boolean ]
    /**
     * Extracts the GError and debug string from the GstMessage. The values returned
     * in the output arguments are copies; the caller must free them when done.
     * 
     * MT safe.
     */
    parse_warning(): [ /* gerror */ GLib.Error | null, /* debug */ string | null ]
    /**
     * Returns the optional details structure, may be NULL if none
     * The returned structure must not be freed.
     */
    parse_warning_details(): /* structure */ Structure
    /**
     * Configures the buffering stats values in `message`.
     * @param mode a buffering mode
     * @param avg_in the average input rate
     * @param avg_out the average output rate
     * @param buffering_left amount of buffering time left in milliseconds
     */
    set_buffering_stats(mode: BufferingMode, avg_in: number, avg_out: number, buffering_left: number): void
    /**
     * Sets the group id on the stream-start message.
     * 
     * All streams that have the same group id are supposed to be played
     * together, i.e. all streams inside a container file should have the
     * same group id but different stream ids. The group id should change
     * each time the stream is started, resulting in different group ids
     * each time a file is played for example.
     * 
     * MT safe.
     * @param group_id the group id
     */
    set_group_id(group_id: number): void
    /**
     * Set the QoS stats representing the history of the current continuous pipeline
     * playback period.
     * 
     * When `format` is `GST_FORMAT_UNDEFINED` both `dropped` and `processed` are
     * invalid. Values of -1 for either `processed` or `dropped` mean unknown values.
     * 
     * MT safe.
     * @param format Units of the 'processed' and 'dropped' fields. Video sinks and video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks and audio filters will likely use GST_FORMAT_DEFAULT (samples).
     * @param processed Total number of units correctly processed since the last state change to READY or a flushing operation.
     * @param dropped Total number of units dropped since the last state change to READY or a flushing operation.
     */
    set_qos_stats(format: Format, processed: number, dropped: number): void
    /**
     * Set the QoS values that have been calculated/analysed from the QoS data
     * 
     * MT safe.
     * @param jitter The difference of the running-time against the deadline.
     * @param proportion Long term prediction of the ideal rate relative to normal rate to get optimal quality.
     * @param quality An element dependent integer value that specifies the current quality level of the element. The default maximum quality is 1000000.
     */
    set_qos_values(jitter: number, proportion: number, quality: number): void
    /**
     * Set the sequence number of a message.
     * 
     * This function might be called by the creator of a message to indicate that
     * the message relates to other messages or events. See gst_message_get_seqnum()
     * for more information.
     * 
     * MT safe.
     * @param seqnum A sequence number.
     */
    set_seqnum(seqnum: number): void
    /**
     * Configures the object handling the streaming thread. This is usually a
     * GstTask object but other objects might be added in the future.
     * @param object the object controlling the streaming
     */
    set_stream_status_object(object: any): void
    /**
     * Adds the `stream` to the `message`.
     * @param stream a #GstStream to add to `message`
     */
    streams_selected_add(stream: Stream): void
    /**
     * Returns the number of streams contained in the `message`.
     */
    streams_selected_get_size(): number
    /**
     * Retrieves the #GstStream with index `index` from the `message`.
     * @param idx Index of the stream to retrieve
     */
    streams_selected_get_stream(idx: number): Stream | null
    /**
     * Get a writable version of the structure.
     */
    writable_structure(): Structure
    static name: string
    /* Static methods and pseudo-constructors */
    static new_application(src: Object | null, structure: Structure): Message
    static new_async_done(src: Object | null, running_time: ClockTime): Message
    static new_async_start(src?: Object | null): Message
    static new_buffering(src: Object | null, percent: number): Message
    static new_clock_lost(src: Object | null, clock: Clock): Message
    static new_clock_provide(src: Object | null, clock: Clock, ready: boolean): Message
    static new_custom(type: MessageType, src?: Object | null, structure?: Structure | null): Message
    static new_device_added(src: Object, device: Device): Message
    static new_device_changed(src: Object, device: Device, changed_device: Device): Message
    static new_device_removed(src: Object, device: Device): Message
    static new_duration_changed(src?: Object | null): Message
    static new_element(src: Object | null, structure: Structure): Message
    static new_eos(src?: Object | null): Message
    static new_error(src: Object | null, error: GLib.Error, debug: string): Message
    static new_error_with_details(src: Object | null, error: GLib.Error, debug: string, details?: Structure | null): Message
    static new_have_context(src: Object | null, context: Context): Message
    static new_info(src: Object | null, error: GLib.Error, debug: string): Message
    static new_info_with_details(src: Object | null, error: GLib.Error, debug: string, details?: Structure | null): Message
    static new_instant_rate_request(src: Object, rate_multiplier: number): Message
    static new_latency(src?: Object | null): Message
    static new_need_context(src: Object | null, context_type: string): Message
    static new_new_clock(src: Object | null, clock: Clock): Message
    static new_progress(src: Object, type: ProgressType, code: string, text: string): Message
    static new_property_notify(src: Object, property_name: string, val?: any | null): Message
    static new_qos(src: Object, live: boolean, running_time: number, stream_time: number, timestamp: number, duration: number): Message
    static new_redirect(src: Object, location: string, tag_list?: TagList | null, entry_struct?: Structure | null): Message
    static new_request_state(src: Object | null, state: State): Message
    static new_reset_time(src: Object | null, running_time: ClockTime): Message
    static new_segment_done(src: Object | null, format: Format, position: number): Message
    static new_segment_start(src: Object | null, format: Format, position: number): Message
    static new_state_changed(src: Object | null, oldstate: State, newstate: State, pending: State): Message
    static new_state_dirty(src?: Object | null): Message
    static new_step_done(src: Object, format: Format, amount: number, rate: number, flush: boolean, intermediate: boolean, duration: number, eos: boolean): Message
    static new_step_start(src: Object, active: boolean, format: Format, amount: number, rate: number, flush: boolean, intermediate: boolean): Message
    static new_stream_collection(src: Object, collection: StreamCollection): Message
    static new_stream_start(src?: Object | null): Message
    static new_stream_status(src: Object, type: StreamStatusType, owner: Element): Message
    static new_streams_selected(src: Object, collection: StreamCollection): Message
    static new_structure_change(src: Object | null, type: StructureChangeType, owner: Element, busy: boolean): Message
    static new_tag(src: Object | null, tag_list: TagList): Message
    static new_toc(src: Object, toc: Toc, updated: boolean): Message
    static new_warning(src: Object | null, error: GLib.Error, debug: string): Message
    static new_warning_with_details(src: Object | null, error: GLib.Error, debug: string, details?: Structure | null): Message
    /**
     * Modifies a pointer to a #GstMessage to point to a different #GstMessage. This
     * function is similar to gst_message_replace() except that it takes ownership
     * of `new_message`.
     * @param old_message pointer to a pointer to a #GstMessage     to be replaced.
     * @param new_message pointer to a #GstMessage that     will replace the message pointed to by `old_message`.
     */
    static take(old_message: Message, new_message?: Message | null): [ /* returnType */ boolean, /* old_message */ Message ]
}
class Meta {
    /* Fields of Gst-1.0.Gst.Meta */
    /**
     * extra flags for the metadata
     */
    flags: MetaFlags
    /**
     * pointer to the #GstMetaInfo
     */
    info: MetaInfo
    /* Methods of Gst-1.0.Gst.Meta */
    /**
     * Meta sequence number compare function. Can be used as #GCompareFunc
     * or a #GCompareDataFunc.
     * @param meta2 a #GstMeta
     */
    compare_seqnum(meta2: Meta): number
    /**
     * Gets seqnum for this meta.
     */
    get_seqnum(): number
    static name: string
    /* Static methods and pseudo-constructors */
    static api_type_get_tags(api: GObject.Type): string[]
    /**
     * Check if `api` was registered with `tag`.
     * @param api an API
     * @param tag the tag to check
     */
    static api_type_has_tag(api: GObject.Type, tag: GLib.Quark): boolean
    /**
     * Register and return a GType for the `api` and associate it with
     * `tags`.
     * @param api an API to register
     * @param tags tags for `api`
     */
    static api_type_register(api: string, tags: string[]): GObject.Type
    /**
     * Lookup a previously registered meta info structure by its implementation name
     * `impl`.
     * @param impl the name
     */
    static get_info(impl: string): MetaInfo | null
    /**
     * Register a new #GstMeta implementation.
     * 
     * The same `info` can be retrieved later with gst_meta_get_info() by using
     * `impl` as the key.
     * @param api the type of the #GstMeta API
     * @param impl the name of the #GstMeta implementation
     * @param size the size of the #GstMeta structure
     * @param init_func a #GstMetaInitFunction
     * @param free_func a #GstMetaFreeFunction
     * @param transform_func a #GstMetaTransformFunction
     */
    static register(api: GObject.Type, impl: string, size: number, init_func: MetaInitFunction, free_func: MetaFreeFunction, transform_func: MetaTransformFunction): MetaInfo
    /**
     * Register a new custom #GstMeta implementation, backed by an opaque
     * structure holding a #GstStructure.
     * 
     * The registered info can be retrieved later with gst_meta_get_info() by using
     * `name` as the key.
     * 
     * The backing #GstStructure can be retrieved with
     * gst_custom_meta_get_structure(), its mutability is conditioned by the
     * writability of the buffer the meta is attached to.
     * 
     * When `transform_func` is %NULL, the meta and its backing #GstStructure
     * will always be copied when the transform operation is copy, other operations
     * are discarded, copy regions are ignored.
     * @param name the name of the #GstMeta implementation
     * @param tags tags for `api`
     * @param transform_func a #GstMetaTransformFunction
     */
    static register_custom(name: string, tags: string[], transform_func: CustomMetaTransformFunction | null): MetaInfo
}
class MetaInfo {
    /* Fields of Gst-1.0.Gst.MetaInfo */
    /**
     * tag identifying the metadata structure and api
     */
    api: GObject.Type
    /**
     * type identifying the implementor of the api
     */
    type: GObject.Type
    /**
     * size of the metadata
     */
    size: number
    /**
     * function for initializing the metadata
     */
    init_func: MetaInitFunction
    /**
     * function for freeing the metadata
     */
    free_func: MetaFreeFunction
    /**
     * function for transforming the metadata
     */
    transform_func: MetaTransformFunction
    /* Methods of Gst-1.0.Gst.MetaInfo */
    is_custom(): boolean
    static name: string
}
class MetaTransformCopy {
    /* Fields of Gst-1.0.Gst.MetaTransformCopy */
    /**
     * %TRUE if only region is copied
     */
    region: boolean
    /**
     * the offset to copy, 0 if `region` is %FALSE, otherwise > 0
     */
    offset: number
    /**
     * the size to copy, -1 or the buffer size when `region` is %FALSE
     */
    size: number
    static name: string
}
class MiniObject {
    /* Fields of Gst-1.0.Gst.MiniObject */
    /**
     * the GType of the object
     */
    type: GObject.Type
    /**
     * atomic refcount
     */
    refcount: number
    /**
     * atomic state of the locks
     */
    lockstate: number
    /**
     * extra flags.
     */
    flags: number
    /**
     * a copy function
     */
    copy: MiniObjectCopyFunction
    /**
     * a dispose function
     */
    dispose: MiniObjectDisposeFunction
    /**
     * the free function
     */
    free: MiniObjectFreeFunction
    /* Methods of Gst-1.0.Gst.MiniObject */
    /**
     * This adds `parent` as a parent for `object`. Having one ore more parents affects the
     * writability of `object:` if a `parent` is not writable, `object` is also not
     * writable, regardless of its refcount. `object` is only writable if all
     * the parents are writable and its own refcount is exactly 1.
     * 
     * Note: This function does not take ownership of `parent` and also does not
     * take an additional reference. It is the responsibility of the caller to
     * remove the parent again at a later time.
     * @param parent a parent #GstMiniObject
     */
    add_parent(parent: MiniObject): void
    /**
     * This function gets back user data pointers stored via
     * gst_mini_object_set_qdata().
     * @param quark A #GQuark, naming the user data pointer
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * If `mini_object` has the LOCKABLE flag set, check if the current EXCLUSIVE
     * lock on `object` is the only one, this means that changes to the object will
     * not be visible to any other object.
     * 
     * If the LOCKABLE flag is not set, check if the refcount of `mini_object` is
     * exactly 1, meaning that no other reference exists to the object and that the
     * object is therefore writable.
     * 
     * Modification of a mini-object should only be done after verifying that it
     * is writable.
     */
    is_writable(): boolean
    /**
     * Lock the mini-object with the specified access mode in `flags`.
     * @param flags #GstLockFlags
     */
    lock(flags: LockFlags): boolean
    /**
     * This removes `parent` as a parent for `object`. See
     * gst_mini_object_add_parent().
     * @param parent a parent #GstMiniObject
     */
    remove_parent(parent: MiniObject): void
    /**
     * This sets an opaque, named pointer on a miniobject.
     * The name is specified through a #GQuark (retrieved e.g. via
     * g_quark_from_static_string()), and the pointer
     * can be gotten back from the `object` with gst_mini_object_get_qdata()
     * until the `object` is disposed.
     * Setting a previously set user data pointer, overrides (frees)
     * the old pointer set, using %NULL as pointer essentially
     * removes the data stored.
     * 
     * `destroy` may be specified which is called with `data` as argument
     * when the `object` is disposed, or the data is being overwritten by
     * a call to gst_mini_object_set_qdata() with the same `quark`.
     * @param quark A #GQuark, naming the user data pointer
     * @param data An opaque user data pointer
     * @param destroy Function to invoke with `data` as argument, when `data`           needs to be freed
     */
    set_qdata(quark: GLib.Quark, data: object | null, destroy: GLib.DestroyNotify): void
    /**
     * This function gets back user data pointers stored via gst_mini_object_set_qdata()
     * and removes the data from `object` without invoking its `destroy()` function (if
     * any was set).
     * @param quark A #GQuark, naming the user data pointer
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Unlock the mini-object with the specified access mode in `flags`.
     * @param flags #GstLockFlags
     */
    unlock(flags: LockFlags): void
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Atomically modifies a pointer to point to a new mini-object.
     * The reference count of `olddata` is decreased and the reference count of
     * `newdata` is increased.
     * 
     * Either `newdata` and the value pointed to by `olddata` may be %NULL.
     * @param olddata pointer to a pointer to a     mini-object to be replaced
     * @param newdata pointer to new mini-object
     */
    static replace(olddata?: MiniObject | null, newdata?: MiniObject | null): [ /* returnType */ boolean, /* olddata */ MiniObject | null ]
    /**
     * Modifies a pointer to point to a new mini-object. The modification
     * is done atomically. This version is similar to gst_mini_object_replace()
     * except that it does not increase the refcount of `newdata` and thus
     * takes ownership of `newdata`.
     * 
     * Either `newdata` and the value pointed to by `olddata` may be %NULL.
     * @param olddata pointer to a pointer to a mini-object to     be replaced
     * @param newdata pointer to new mini-object
     */
    static take(olddata: MiniObject, newdata: MiniObject): [ /* returnType */ boolean, /* olddata */ MiniObject ]
}
abstract class ObjectClass {
    /* Fields of Gst-1.0.Gst.ObjectClass */
    /**
     * parent
     */
    parent_class: GObject.InitiallyUnownedClass
    /**
     * separator used by gst_object_get_path_string()
     */
    path_string_separator: string
    deep_notify: (object: Object, orig: Object, pspec: GObject.ParamSpec) => void
    static name: string
}
abstract class PadClass {
    /* Fields of Gst-1.0.Gst.PadClass */
    parent_class: ObjectClass
    linked: (pad: Pad, peer: Pad) => void
    unlinked: (pad: Pad, peer: Pad) => void
    static name: string
}
class PadPrivate {
    static name: string
}
class PadProbeInfo {
    /* Fields of Gst-1.0.Gst.PadProbeInfo */
    /**
     * the current probe type
     */
    type: PadProbeType
    /**
     * the id of the probe
     */
    id: number
    /**
     * type specific data, check the `type` field to know the
     *    datatype.  This field can be %NULL.
     */
    data: object
    /**
     * offset of pull probe, this field is valid when `type` contains
     *    #GST_PAD_PROBE_TYPE_PULL
     */
    offset: number
    /**
     * size of pull probe, this field is valid when `type` contains
     *    #GST_PAD_PROBE_TYPE_PULL
     */
    size: number
    /* Methods of Gst-1.0.Gst.PadProbeInfo */
    get_buffer(): Buffer | null
    get_buffer_list(): BufferList | null
    get_event(): Event | null
    get_query(): Query | null
    static name: string
}
abstract class PadTemplateClass {
    /* Fields of Gst-1.0.Gst.PadTemplateClass */
    parent_class: ObjectClass
    pad_created: (templ: PadTemplate, pad: Pad) => void
    static name: string
}
class ParamSpecArray {
    /* Fields of Gst-1.0.Gst.ParamSpecArray */
    /**
     * super class
     */
    parent_instance: GObject.ParamSpec
    /**
     * the #GParamSpec of the type of values in the array
     */
    element_spec: GObject.ParamSpec
    static name: string
}
class ParamSpecFraction {
    /* Fields of Gst-1.0.Gst.ParamSpecFraction */
    /**
     * super class
     */
    parent_instance: GObject.ParamSpec
    /**
     * minimal numerator
     */
    min_num: number
    /**
     * minimal denominator
     */
    min_den: number
    /**
     * maximal numerator
     */
    max_num: number
    /**
     * maximal denominator
     */
    max_den: number
    /**
     * default numerator
     */
    def_num: number
    /**
     * default denominator
     */
    def_den: number
    static name: string
}
class ParentBufferMeta {
    /* Fields of Gst-1.0.Gst.ParentBufferMeta */
    /**
     * the parent #GstMeta structure
     */
    parent: Meta
    /**
     * the #GstBuffer on which a reference is being held.
     */
    buffer: Buffer
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Gets the global #GstMetaInfo describing  the #GstParentBufferMeta meta.
     */
    static get_info(): MetaInfo
}
class ParseContext {
    /* Methods of Gst-1.0.Gst.ParseContext */
    /**
     * Copies the `context`.
     */
    copy(): ParseContext | null
    /**
     * Frees a parse context previously allocated with gst_parse_context_new().
     */
    free(): void
    /**
     * Retrieve missing elements from a previous run of gst_parse_launch_full()
     * or gst_parse_launchv_full(). Will only return results if an error code
     * of %GST_PARSE_ERROR_NO_SUCH_ELEMENT was returned.
     */
    get_missing_elements(): string[] | null
    static name: string
    static new(): ParseContext
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): ParseContext
}
abstract class PipelineClass {
    /* Fields of Gst-1.0.Gst.PipelineClass */
    parent_class: BinClass
    static name: string
}
class PipelinePrivate {
    static name: string
}
abstract class PluginClass {
    static name: string
}
class PluginDesc {
    /* Fields of Gst-1.0.Gst.PluginDesc */
    /**
     * the major version number of core that plugin was compiled for
     */
    major_version: number
    /**
     * the minor version number of core that plugin was compiled for
     */
    minor_version: number
    /**
     * a unique name of the plugin
     */
    name: string
    /**
     * description of plugin
     */
    description: string
    /**
     * pointer to the init function of this plugin.
     */
    plugin_init: PluginInitFunc
    /**
     * version of the plugin
     */
    version: string
    /**
     * effective license of plugin
     */
    license: string
    /**
     * source module plugin belongs to
     */
    source: string
    /**
     * shipped package plugin belongs to
     */
    package: string
    /**
     * URL to provider of plugin
     */
    origin: string
    /**
     * date time string in ISO 8601
     *     format (or rather, a subset thereof), or %NULL. Allowed are the
     *     following formats: "YYYY-MM-DD" and "YYY-MM-DDTHH:MMZ" (with
     *     'T' a separator and 'Z' indicating UTC/Zulu time). This field
     *     should be set via the GST_PACKAGE_RELEASE_DATETIME
     *     preprocessor macro.
     */
    release_datetime: string
    static name: string
}
abstract class PluginFeatureClass {
    static name: string
}
class Poll {
    /* Methods of Gst-1.0.Gst.Poll */
    /**
     * Add a file descriptor to the file descriptor set.
     * @param fd a file descriptor.
     */
    add_fd(fd: PollFD): boolean
    /**
     * Check if `fd` in `set` has data to be read.
     * @param fd a file descriptor.
     */
    fd_can_read(fd: PollFD): boolean
    /**
     * Check if `fd` in `set` can be used for writing.
     * @param fd a file descriptor.
     */
    fd_can_write(fd: PollFD): boolean
    /**
     * Control whether the descriptor `fd` in `set` will be monitored for
     * exceptional conditions (POLLPRI).
     * 
     * Not implemented on Windows (will just return %FALSE there).
     * @param fd a file descriptor.
     * @param active a new status.
     */
    fd_ctl_pri(fd: PollFD, active: boolean): boolean
    /**
     * Control whether the descriptor `fd` in `set` will be monitored for
     * readability.
     * @param fd a file descriptor.
     * @param active a new status.
     */
    fd_ctl_read(fd: PollFD, active: boolean): boolean
    /**
     * Control whether the descriptor `fd` in `set` will be monitored for
     * writability.
     * @param fd a file descriptor.
     * @param active a new status.
     */
    fd_ctl_write(fd: PollFD, active: boolean): boolean
    /**
     * Check if `fd` in `set` has closed the connection.
     * @param fd a file descriptor.
     */
    fd_has_closed(fd: PollFD): boolean
    /**
     * Check if `fd` in `set` has an error.
     * @param fd a file descriptor.
     */
    fd_has_error(fd: PollFD): boolean
    /**
     * Check if `fd` in `set` has an exceptional condition (POLLPRI).
     * 
     * Not implemented on Windows (will just return %FALSE there).
     * @param fd a file descriptor.
     */
    fd_has_pri(fd: PollFD): boolean
    /**
     * Mark `fd` as ignored so that the next call to gst_poll_wait() will yield
     * the same result for `fd` as last time. This function must be called if no
     * operation (read/write/recv/send/etc.) will be performed on `fd` before
     * the next call to gst_poll_wait().
     * 
     * The reason why this is needed is because the underlying implementation
     * might not allow querying the fd more than once between calls to one of
     * the re-enabling operations.
     * @param fd a file descriptor.
     */
    fd_ignored(fd: PollFD): void
    /**
     * Free a file descriptor set.
     */
    free(): void
    /**
     * Get a GPollFD for the reading part of the control socket. This is useful when
     * integrating with a GSource and GMainLoop.
     * @param fd a #GPollFD
     */
    get_read_gpollfd(fd: GLib.PollFD): void
    /**
     * Read a byte from the control socket of the controllable `set`.
     * 
     * This function only works for timer #GstPoll objects created with
     * gst_poll_new_timer().
     */
    read_control(): boolean
    /**
     * Remove a file descriptor from the file descriptor set.
     * @param fd a file descriptor.
     */
    remove_fd(fd: PollFD): boolean
    /**
     * Restart any gst_poll_wait() that is in progress. This function is typically
     * used after adding or removing descriptors to `set`.
     * 
     * If `set` is not controllable, then this call will have no effect.
     * 
     * This function only works for non-timer #GstPoll objects created with
     * gst_poll_new().
     */
    restart(): void
    /**
     * When `controllable` is %TRUE, this function ensures that future calls to
     * gst_poll_wait() will be affected by gst_poll_restart() and
     * gst_poll_set_flushing().
     * 
     * This function only works for non-timer #GstPoll objects created with
     * gst_poll_new().
     * @param controllable new controllable state.
     */
    set_controllable(controllable: boolean): boolean
    /**
     * When `flushing` is %TRUE, this function ensures that current and future calls
     * to gst_poll_wait() will return -1, with errno set to EBUSY.
     * 
     * Unsetting the flushing state will restore normal operation of `set`.
     * 
     * This function only works for non-timer #GstPoll objects created with
     * gst_poll_new().
     * @param flushing new flushing state.
     */
    set_flushing(flushing: boolean): void
    /**
     * Wait for activity on the file descriptors in `set`. This function waits up to
     * the specified `timeout`.  A timeout of #GST_CLOCK_TIME_NONE waits forever.
     * 
     * For #GstPoll objects created with gst_poll_new(), this function can only be
     * called from a single thread at a time.  If called from multiple threads,
     * -1 will be returned with errno set to EPERM.
     * 
     * This is not true for timer #GstPoll objects created with
     * gst_poll_new_timer(), where it is allowed to have multiple threads waiting
     * simultaneously.
     * @param timeout a timeout in nanoseconds.
     */
    wait(timeout: ClockTime): number
    /**
     * Write a byte to the control socket of the controllable `set`.
     * This function is mostly useful for timer #GstPoll objects created with
     * gst_poll_new_timer().
     * 
     * It will make any current and future gst_poll_wait() function return with
     * 1, meaning the control socket is set. After an equal amount of calls to
     * gst_poll_read_control() have been performed, calls to gst_poll_wait() will
     * block again until their timeout expired.
     * 
     * This function only works for timer #GstPoll objects created with
     * gst_poll_new_timer().
     */
    write_control(): boolean
    static name: string
}
class PollFD {
    /* Fields of Gst-1.0.Gst.PollFD */
    /**
     * a file descriptor
     */
    fd: number
    /* Methods of Gst-1.0.Gst.PollFD */
    /**
     * Initializes `fd`. Alternatively you can initialize it with
     * #GST_POLL_FD_INIT.
     */
    init(): void
    static name: string
}
abstract class PresetInterface {
    /* Fields of Gst-1.0.Gst.PresetInterface */
    /**
     * parent interface type.
     */
    parent: GObject.TypeInterface
    get_preset_names: (preset: Preset) => string[]
    get_property_names: (preset: Preset) => string[]
    load_preset: (preset: Preset, name: string) => boolean
    save_preset: (preset: Preset, name: string) => boolean
    rename_preset: (preset: Preset, old_name: string, new_name: string) => boolean
    delete_preset: (preset: Preset, name: string) => boolean
    set_meta: (preset: Preset, name: string, tag: string, value?: string | null) => boolean
    get_meta: (preset: Preset, name: string, tag: string) => [ /* returnType */ boolean, /* value */ string ]
    static name: string
}
class Promise {
    /* Fields of Gst-1.0.Gst.Promise */
    /**
     * parent #GstMiniObject
     */
    parent: MiniObject
    /* Methods of Gst-1.0.Gst.Promise */
    /**
     * Expire a `promise`.  This will wake up any waiters with
     * %GST_PROMISE_RESULT_EXPIRED.  Called by a message loop when the parent
     * message is handled and/or destroyed (possibly unanswered).
     */
    expire(): void
    /**
     * Retrieve the reply set on `promise`.  `promise` must be in
     * %GST_PROMISE_RESULT_REPLIED and the returned structure is owned by `promise`
     */
    get_reply(): Structure | null
    /**
     * Interrupt waiting for a `promise`.  This will wake up any waiters with
     * %GST_PROMISE_RESULT_INTERRUPTED.  Called when the consumer does not want
     * the value produced anymore.
     */
    interrupt(): void
    /**
     * Increases the refcount of the given `promise` by one.
     */
    ref(): Promise
    /**
     * Set a reply on `promise`.  This will wake up any waiters with
     * %GST_PROMISE_RESULT_REPLIED.  Called by the producer of the value to
     * indicate success (or failure).
     * 
     * If `promise` has already been interrupted by the consumer, then this reply
     * is not visible to the consumer.
     * @param s a #GstStructure with the the reply contents
     */
    reply(s?: Structure | null): void
    /**
     * Decreases the refcount of the promise. If the refcount reaches 0, the
     * promise will be freed.
     */
    unref(): void
    /**
     * Wait for `promise` to move out of the %GST_PROMISE_RESULT_PENDING state.
     * If `promise` is not in %GST_PROMISE_RESULT_PENDING then it will return
     * immediately with the current result.
     */
    wait(): PromiseResult
    static name: string
    static new(): Promise
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): Promise
    static new_with_change_func(func: PromiseChangeFunc): Promise
}
class ProtectionMeta {
    /* Fields of Gst-1.0.Gst.ProtectionMeta */
    /**
     * the parent #GstMeta.
     */
    meta: Meta
    /**
     * the cryptographic information needed to decrypt the sample.
     */
    info: Structure
    static name: string
    /* Static methods and pseudo-constructors */
    static get_info(): MetaInfo
}
abstract class ProxyPadClass {
    /* Fields of Gst-1.0.Gst.ProxyPadClass */
    parent_class: PadClass
    static name: string
}
class ProxyPadPrivate {
    static name: string
}
class Query {
    /* Fields of Gst-1.0.Gst.Query */
    /**
     * The parent #GstMiniObject type
     */
    mini_object: MiniObject
    /**
     * the #GstQueryType
     */
    type: QueryType
    /* Methods of Gst-1.0.Gst.Query */
    /**
     * Add `api` with `params` as one of the supported metadata API to `query`.
     * @param api the metadata API
     * @param params API specific parameters
     */
    add_allocation_meta(api: GObject.Type, params?: Structure | null): void
    /**
     * Add `allocator` and its `params` as a supported memory allocator.
     * @param allocator the memory allocator
     * @param params a #GstAllocationParams
     */
    add_allocation_param(allocator?: Allocator | null, params?: AllocationParams | null): void
    /**
     * Set the pool parameters in `query`.
     * @param pool the #GstBufferPool
     * @param size the buffer size
     * @param min_buffers the min buffers
     * @param max_buffers the max buffers
     */
    add_allocation_pool(pool: BufferPool | null, size: number, min_buffers: number, max_buffers: number): void
    /**
     * Set the buffering-ranges array field in `query`. The current last
     * start position of the array should be inferior to `start`.
     * @param start start position of the range
     * @param stop stop position of the range
     */
    add_buffering_range(start: number, stop: number): boolean
    /**
     * Add `mode` as one of the supported scheduling modes to `query`.
     * @param mode a #GstPadMode
     */
    add_scheduling_mode(mode: PadMode): void
    /**
     * Check if `query` has metadata `api` set. When this function returns %TRUE,
     * `index` will contain the index where the requested API and the parameters
     * can be found.
     * @param api the metadata API
     */
    find_allocation_meta(api: GObject.Type): [ /* returnType */ boolean, /* index */ number | null ]
    /**
     * Retrieve the number of values currently stored in the
     * meta API array of the query's structure.
     */
    get_n_allocation_metas(): number
    /**
     * Retrieve the number of values currently stored in the
     * allocator params array of the query's structure.
     * 
     * If no memory allocator is specified, the downstream element can handle
     * the default memory allocator. The first memory allocator in the query
     * should be generic and allow mapping to system memory, all following
     * allocators should be ordered by preference with the preferred one first.
     */
    get_n_allocation_params(): number
    /**
     * Retrieve the number of values currently stored in the
     * pool array of the query's structure.
     */
    get_n_allocation_pools(): number
    /**
     * Retrieve the number of values currently stored in the
     * buffered-ranges array of the query's structure.
     */
    get_n_buffering_ranges(): number
    /**
     * Retrieve the number of values currently stored in the
     * scheduling mode array of the query's structure.
     */
    get_n_scheduling_modes(): number
    /**
     * Get the structure of a query.
     */
    get_structure(): Structure | null
    /**
     * Check if `query` has scheduling mode set.
     * 
     * > When checking if upstream supports pull mode, it is usually not
     * > enough to just check for GST_PAD_MODE_PULL with this function, you
     * > also want to check whether the scheduling flags returned by
     * > gst_query_parse_scheduling() have the seeking flag set (meaning
     * > random access is supported, not only sequential pulls).
     * @param mode the scheduling mode
     */
    has_scheduling_mode(mode: PadMode): boolean
    /**
     * Check if `query` has scheduling mode set and `flags` is set in
     * query scheduling flags.
     * @param mode the scheduling mode
     * @param flags #GstSchedulingFlags
     */
    has_scheduling_mode_with_flags(mode: PadMode, flags: SchedulingFlags): boolean
    /**
     * Get the caps from `query`. The caps remains valid as long as `query` remains
     * valid.
     */
    parse_accept_caps(): /* caps */ Caps
    /**
     * Parse the result from `query` and store in `result`.
     */
    parse_accept_caps_result(): /* result */ boolean | null
    /**
     * Parse an allocation query, writing the requested caps in `caps` and
     * whether a pool is needed in `need_pool,` if the respective parameters
     * are non-%NULL.
     * 
     * Pool details can be retrieved using gst_query_get_n_allocation_pools() and
     * gst_query_parse_nth_allocation_pool().
     */
    parse_allocation(): [ /* caps */ Caps | null, /* need_pool */ boolean | null ]
    /**
     * Get the results of a bitrate query. See also gst_query_set_bitrate().
     */
    parse_bitrate(): /* nominal_bitrate */ number | null
    /**
     * Get the percentage of buffered data. This is a value between 0 and 100.
     * The `busy` indicator is %TRUE when the buffering is in progress.
     */
    parse_buffering_percent(): [ /* busy */ boolean | null, /* percent */ number | null ]
    /**
     * Parse an available query, writing the format into `format,` and
     * other results into the passed parameters, if the respective parameters
     * are non-%NULL
     */
    parse_buffering_range(): [ /* format */ Format | null, /* start */ number | null, /* stop */ number | null, /* estimated_total */ number | null ]
    /**
     * Extracts the buffering stats values from `query`.
     */
    parse_buffering_stats(): [ /* mode */ BufferingMode | null, /* avg_in */ number | null, /* avg_out */ number | null, /* buffering_left */ number | null ]
    /**
     * Get the filter from the caps `query`. The caps remains valid as long as
     * `query` remains valid.
     */
    parse_caps(): /* filter */ Caps
    /**
     * Get the caps result from `query`. The caps remains valid as long as
     * `query` remains valid.
     */
    parse_caps_result(): /* caps */ Caps
    /**
     * Get the context from the context `query`. The context remains valid as long as
     * `query` remains valid.
     */
    parse_context(): /* context */ Context
    /**
     * Parse a context type from an existing GST_QUERY_CONTEXT query.
     */
    parse_context_type(): [ /* returnType */ boolean, /* context_type */ string | null ]
    /**
     * Parse a convert query answer. Any of `src_format,` `src_value,` `dest_format,`
     * and `dest_value` may be %NULL, in which case that value is omitted.
     */
    parse_convert(): [ /* src_format */ Format | null, /* src_value */ number | null, /* dest_format */ Format | null, /* dest_value */ number | null ]
    /**
     * Parse a duration query answer. Write the format of the duration into `format,`
     * and the value into `duration,` if the respective variables are non-%NULL.
     */
    parse_duration(): [ /* format */ Format | null, /* duration */ number | null ]
    /**
     * Parse a latency query answer.
     */
    parse_latency(): [ /* live */ boolean | null, /* min_latency */ ClockTime | null, /* max_latency */ ClockTime | null ]
    /**
     * Parse the number of formats in the formats `query`.
     */
    parse_n_formats(): /* n_formats */ number | null
    /**
     * Parse an available query and get the metadata API
     * at `index` of the metadata API array.
     * @param index position in the metadata API array to read
     */
    parse_nth_allocation_meta(index: number): [ /* returnType */ GObject.Type, /* params */ Structure | null ]
    /**
     * Parse an available query and get the allocator and its params
     * at `index` of the allocator array.
     * @param index position in the allocator array to read
     */
    parse_nth_allocation_param(index: number): [ /* allocator */ Allocator | null, /* params */ AllocationParams | null ]
    /**
     * Get the pool parameters in `query`.
     * 
     * Unref `pool` with gst_object_unref() when it's not needed any more.
     * @param index index to parse
     */
    parse_nth_allocation_pool(index: number): [ /* pool */ BufferPool | null, /* size */ number | null, /* min_buffers */ number | null, /* max_buffers */ number | null ]
    /**
     * Parse an available query and get the start and stop values stored
     * at the `index` of the buffered ranges array.
     * @param index position in the buffered-ranges array to read
     */
    parse_nth_buffering_range(index: number): [ /* returnType */ boolean, /* start */ number | null, /* stop */ number | null ]
    /**
     * Parse the format query and retrieve the `nth` format from it into
     * `format`. If the list contains less elements than `nth,` `format` will be
     * set to GST_FORMAT_UNDEFINED.
     * @param nth the nth format to retrieve.
     */
    parse_nth_format(nth: number): /* format */ Format | null
    /**
     * Parse an available query and get the scheduling mode
     * at `index` of the scheduling modes array.
     * @param index position in the scheduling modes array to read
     */
    parse_nth_scheduling_mode(index: number): PadMode
    /**
     * Parse a position query, writing the format into `format,` and the position
     * into `cur,` if the respective parameters are non-%NULL.
     */
    parse_position(): [ /* format */ Format | null, /* cur */ number | null ]
    /**
     * Set the scheduling properties.
     */
    parse_scheduling(): [ /* flags */ SchedulingFlags | null, /* minsize */ number | null, /* maxsize */ number | null, /* align */ number | null ]
    /**
     * Parse a seeking query, writing the format into `format,` and
     * other results into the passed parameters, if the respective parameters
     * are non-%NULL
     */
    parse_seeking(): [ /* format */ Format | null, /* seekable */ boolean | null, /* segment_start */ number | null, /* segment_end */ number | null ]
    /**
     * Parse a segment query answer. Any of `rate,` `format,` `start_value,` and
     * `stop_value` may be %NULL, which will cause this value to be omitted.
     * 
     * See gst_query_set_segment() for an explanation of the function arguments.
     */
    parse_segment(): [ /* rate */ number | null, /* format */ Format | null, /* start_value */ number | null, /* stop_value */ number | null ]
    /**
     * Parse an URI query, writing the URI into `uri` as a newly
     * allocated string, if the respective parameters are non-%NULL.
     * Free the string with g_free() after usage.
     */
    parse_uri(): /* uri */ string | null
    /**
     * Parse an URI query, writing the URI into `uri` as a newly
     * allocated string, if the respective parameters are non-%NULL.
     * Free the string with g_free() after usage.
     */
    parse_uri_redirection(): /* uri */ string | null
    /**
     * Parse an URI query, and set `permanent` to %TRUE if there is a redirection
     * and it should be considered permanent. If a redirection is permanent,
     * applications should update their internal storage of the URI, otherwise
     * they should make all future requests to the original URI.
     */
    parse_uri_redirection_permanent(): /* permanent */ boolean | null
    /**
     * Increases the refcount of the given query by one.
     */
    ref(): Query
    /**
     * Remove the metadata API at `index` of the metadata API array.
     * @param index position in the metadata API array to remove
     */
    remove_nth_allocation_meta(index: number): void
    /**
     * Remove the allocation param at `index` of the allocation param array.
     * @param index position in the allocation param array to remove
     */
    remove_nth_allocation_param(index: number): void
    /**
     * Remove the allocation pool at `index` of the allocation pool array.
     * @param index position in the allocation pool array to remove
     */
    remove_nth_allocation_pool(index: number): void
    /**
     * Set `result` as the result for the `query`.
     * @param result the result to set
     */
    set_accept_caps_result(result: boolean): void
    /**
     * Set the results of a bitrate query.  The nominal bitrate is the average
     * bitrate expected over the length of the stream as advertised in file
     * headers (or similar).
     * @param nominal_bitrate the nominal bitrate in bits per second
     */
    set_bitrate(nominal_bitrate: number): void
    /**
     * Set the percentage of buffered data. This is a value between 0 and 100.
     * The `busy` indicator is %TRUE when the buffering is in progress.
     * @param busy if buffering is busy
     * @param percent a buffering percent
     */
    set_buffering_percent(busy: boolean, percent: number): void
    /**
     * Set the available query result fields in `query`.
     * @param format the format to set for the `start` and `stop` values
     * @param start the start to set
     * @param stop the stop to set
     * @param estimated_total estimated total amount of download time remaining in     milliseconds
     */
    set_buffering_range(format: Format, start: number, stop: number, estimated_total: number): void
    /**
     * Configures the buffering stats values in `query`.
     * @param mode a buffering mode
     * @param avg_in the average input rate
     * @param avg_out the average output rate
     * @param buffering_left amount of buffering time left in milliseconds
     */
    set_buffering_stats(mode: BufferingMode, avg_in: number, avg_out: number, buffering_left: number): void
    /**
     * Set the `caps` result in `query`.
     * @param caps A pointer to the caps
     */
    set_caps_result(caps: Caps): void
    /**
     * Answer a context query by setting the requested context.
     * @param context the requested #GstContext
     */
    set_context(context: Context): void
    /**
     * Answer a convert query by setting the requested values.
     * @param src_format the source #GstFormat
     * @param src_value the source value
     * @param dest_format the destination #GstFormat
     * @param dest_value the destination value
     */
    set_convert(src_format: Format, src_value: number, dest_format: Format, dest_value: number): void
    /**
     * Answer a duration query by setting the requested value in the given format.
     * @param format the #GstFormat for the duration
     * @param duration the duration of the stream
     */
    set_duration(format: Format, duration: number): void
    /**
     * Set the formats query result fields in `query`. The number of formats passed
     * in the `formats` array must be equal to `n_formats`.
     * @param formats an array containing `n_formats`     `GstFormat` values.
     */
    set_formatsv(formats: Format[]): void
    /**
     * Answer a latency query by setting the requested values in the given format.
     * @param live if there is a live element upstream
     * @param min_latency the minimal latency of the upstream elements
     * @param max_latency the maximal latency of the upstream elements
     */
    set_latency(live: boolean, min_latency: ClockTime, max_latency: ClockTime): void
    /**
     * Parse an available query and get the allocator and its params
     * at `index` of the allocator array.
     * @param index position in the allocator array to set
     * @param allocator new allocator to set
     * @param params parameters for the allocator
     */
    set_nth_allocation_param(index: number, allocator?: Allocator | null, params?: AllocationParams | null): void
    /**
     * Set the pool parameters in `query`.
     * @param index index to modify
     * @param pool the #GstBufferPool
     * @param size the buffer size
     * @param min_buffers the min buffers
     * @param max_buffers the max buffers
     */
    set_nth_allocation_pool(index: number, pool: BufferPool | null, size: number, min_buffers: number, max_buffers: number): void
    /**
     * Answer a position query by setting the requested value in the given format.
     * @param format the requested #GstFormat
     * @param cur the position to set
     */
    set_position(format: Format, cur: number): void
    /**
     * Set the scheduling properties.
     * @param flags #GstSchedulingFlags
     * @param minsize the suggested minimum size of pull requests
     * @param maxsize the suggested maximum size of pull requests
     * @param align the suggested alignment of pull requests
     */
    set_scheduling(flags: SchedulingFlags, minsize: number, maxsize: number, align: number): void
    /**
     * Set the seeking query result fields in `query`.
     * @param format the format to set for the `segment_start` and `segment_end` values
     * @param seekable the seekable flag to set
     * @param segment_start the segment_start to set
     * @param segment_end the segment_end to set
     */
    set_seeking(format: Format, seekable: boolean, segment_start: number, segment_end: number): void
    /**
     * Answer a segment query by setting the requested values. The normal
     * playback segment of a pipeline is 0 to duration at the default rate of
     * 1.0. If a seek was performed on the pipeline to play a different
     * segment, this query will return the range specified in the last seek.
     * 
     * `start_value` and `stop_value` will respectively contain the configured
     * playback range start and stop values expressed in `format`.
     * The values are always between 0 and the duration of the media and
     * `start_value` <= `stop_value`. `rate` will contain the playback rate. For
     * negative rates, playback will actually happen from `stop_value` to
     * `start_value`.
     * @param rate the rate of the segment
     * @param format the #GstFormat of the segment values (`start_value` and `stop_value)`
     * @param start_value the start value
     * @param stop_value the stop value
     */
    set_segment(rate: number, format: Format, start_value: number, stop_value: number): void
    /**
     * Answer a URI query by setting the requested URI.
     * @param uri the URI to set
     */
    set_uri(uri: string): void
    /**
     * Answer a URI query by setting the requested URI redirection.
     * @param uri the URI to set
     */
    set_uri_redirection(uri: string): void
    /**
     * Answer a URI query by setting the requested URI redirection
     * to permanent or not.
     * @param permanent whether the redirect is permanent or not
     */
    set_uri_redirection_permanent(permanent: boolean): void
    /**
     * Get the structure of a query. This method should be called with a writable
     * `query` so that the returned structure is guaranteed to be writable.
     */
    writable_structure(): Structure
    static name: string
    /* Static methods and pseudo-constructors */
    static new_accept_caps(caps: Caps): Query
    static new_allocation(caps: Caps, need_pool: boolean): Query
    static new_bitrate(): Query
    static new_buffering(format: Format): Query
    static new_caps(filter: Caps): Query
    static new_context(context_type: string): Query
    static new_convert(src_format: Format, value: number, dest_format: Format): Query
    static new_custom(type: QueryType, structure?: Structure | null): Query
    static new_drain(): Query
    static new_duration(format: Format): Query
    static new_formats(): Query
    static new_latency(): Query
    static new_position(format: Format): Query
    static new_scheduling(): Query
    static new_seeking(format: Format): Query
    static new_segment(format: Format): Query
    static new_uri(): Query
    /**
     * Modifies a pointer to a #GstQuery to point to a different #GstQuery. This
     * function is similar to gst_query_replace() except that it takes ownership of
     * `new_query`.
     * 
     * Either `new_query` or the #GstQuery pointed to by `old_query` may be %NULL.
     * @param old_query pointer to a     pointer to a #GstQuery to be stolen.
     * @param new_query pointer to a #GstQuery that will     replace the query pointed to by `old_query`.
     */
    static take(old_query?: Query | null, new_query?: Query | null): [ /* returnType */ boolean, /* old_query */ Query | null ]
}
class ReferenceTimestampMeta {
    /* Fields of Gst-1.0.Gst.ReferenceTimestampMeta */
    /**
     * the parent #GstMeta structure
     */
    parent: Meta
    /**
     * identifier for the timestamp reference.
     */
    reference: Caps
    /**
     * timestamp
     */
    timestamp: ClockTime
    /**
     * duration, or %GST_CLOCK_TIME_NONE
     */
    duration: ClockTime
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Gets the global #GstMetaInfo describing the #GstReferenceTimestampMeta meta.
     */
    static get_info(): MetaInfo
}
abstract class RegistryClass {
    /* Fields of Gst-1.0.Gst.RegistryClass */
    parent_class: ObjectClass
    static name: string
}
class RegistryPrivate {
    static name: string
}
class Sample {
    /* Methods of Gst-1.0.Gst.Sample */
    /**
     * Get the buffer associated with `sample`
     */
    get_buffer(): Buffer | null
    /**
     * Get the buffer list associated with `sample`
     */
    get_buffer_list(): BufferList | null
    /**
     * Get the caps associated with `sample`
     */
    get_caps(): Caps | null
    /**
     * Get extra information associated with `sample`.
     */
    get_info(): Structure | null
    /**
     * Get the segment associated with `sample`
     */
    get_segment(): Segment
    /**
     * Set the buffer associated with `sample`. `sample` must be writable.
     * @param buffer A #GstBuffer
     */
    set_buffer(buffer: Buffer): void
    /**
     * Set the buffer list associated with `sample`. `sample` must be writable.
     * @param buffer_list a #GstBufferList
     */
    set_buffer_list(buffer_list: BufferList): void
    /**
     * Set the caps associated with `sample`. `sample` must be writable.
     * @param caps A #GstCaps
     */
    set_caps(caps: Caps): void
    /**
     * Set the info structure associated with `sample`. `sample` must be writable,
     * and `info` must not have a parent set already.
     * @param info A #GstStructure
     */
    set_info(info: Structure): boolean
    /**
     * Set the segment associated with `sample`. `sample` must be writable.
     * @param segment A #GstSegment
     */
    set_segment(segment: Segment): void
    static name: string
    static new(buffer?: Buffer | null, caps?: Caps | null, segment?: Segment | null, info?: Structure | null): Sample
    constructor(buffer?: Buffer | null, caps?: Caps | null, segment?: Segment | null, info?: Structure | null)
    /* Static methods and pseudo-constructors */
    static new(buffer?: Buffer | null, caps?: Caps | null, segment?: Segment | null, info?: Structure | null): Sample
}
class Segment {
    /* Fields of Gst-1.0.Gst.Segment */
    /**
     * flags for this segment
     */
    flags: SegmentFlags
    /**
     * the playback rate of the segment is set in response to a seek
     *                event and, without any seek, the value should be `1.0`. This
     *                value is used by elements that synchronize buffer [running
     *                times](additional/design/synchronisation.md#running-time) on
     *                the clock (usually the sink elements), leading to consuming
     *                buffers faster (for a value `> 1.0`) or slower (for `0.0 <
     *                value < 1.0`) than normal playback speed. The rate also
     *                defines the playback direction, meaning that when the value is
     *                lower than `0.0`, the playback happens in reverse, and the
     *                [stream-time](additional/design/synchronisation.md#stream-time)
     *                is going backward. The `rate` value should never be `0.0`.
     */
    rate: number
    /**
     * The applied rate is the rate that has been applied to the stream.
     *                The effective/resulting playback rate of a stream is
     *                `rate * applied_rate`.
     *                The applied rate can be set by source elements when a server is
     *                sending the stream with an already modified playback speed
     *                rate. Filter elements that modify the stream in a way that
     *                modifies the playback speed should also modify the applied
     *                rate. For example the #videorate element when its
     *                #videorate:rate property is set will set the applied rate of
     *                the segment it pushed downstream. Also #scaletempo applies the
     *                input segment rate to the stream and outputs a segment with
     *                rate=1.0 and applied_rate=<inputsegment.rate>.
     */
    applied_rate: number
    /**
     * the unit used for all of the segment's values.
     */
    format: Format
    /**
     * the running time (plus elapsed time, see offset) of the
     *                segment [start](GstSegment.start) ([stop](GstSegment.stop) if
     *                rate < 0.0).
     */
    base: number
    /**
     * the offset expresses the elapsed time (in buffer timestamps)
     *                before a seek with its start (stop if rate < 0.0) seek type
     *                set to #GST_SEEK_TYPE_NONE, the value is set to the position
     *                of the segment at the time of the seek.
     */
    offset: number
    /**
     * the start time of the segment (in buffer timestamps)
     *                [(PTS)](GstBuffer.pts), that is the timestamp of the first
     *                buffer to output inside the segment (last one during
     *                reverse playback). For example decoders will
     *                [clip](gst_segment_clip) out the buffers before the start
     *                time.
     */
    start: number
    /**
     * the stop time of the segment (in buffer timestamps)
     *                [(PTS)](GstBuffer.pts), that is the timestamp of the last
     *                buffer to output inside the segment (first one during
     *                reverse playback). For example decoders will
     *                [clip](gst_segment_clip) out buffers after the stop time.
     */
    stop: number
    /**
     * the stream time of the segment [start](GstSegment.start)
     *                ([stop](GstSegment.stop) if rate < 0.0).
     */
    time: number
    /**
     * the buffer timestamp position in the segment is supposed to be
     *                updated by elements such as sources, demuxers or parsers to
     *                track progress by setting it to the last pushed buffer' end time
     *                ([timestamp](GstBuffer.pts) + #GstBuffer.duration) for that
     *                specific segment. The position is used when reconfiguring the
     *                segment with #gst_segment_do_seek when the seek is only
     *                updating the segment (see [offset](GstSegment.offset)).
     */
    position: number
    /**
     * the duration of the segment is the maximum absolute difference
     *                between #GstSegment.start and #GstSegment.stop if stop is not
     *                set, otherwise it should be the difference between those
     *                two values. This should be set by elements that know the
     *                overall stream duration (like demuxers) and will be used when
     *                seeking with #GST_SEEK_TYPE_END.
     */
    duration: number
    /* Methods of Gst-1.0.Gst.Segment */
    /**
     * Clip the given `start` and `stop` values to the segment boundaries given
     * in `segment`. `start` and `stop` are compared and clipped to `segment`
     * start and stop values.
     * 
     * If the function returns %FALSE, `start` and `stop` are known to fall
     * outside of `segment` and `clip_start` and `clip_stop` are not updated.
     * 
     * When the function returns %TRUE, `clip_start` and `clip_stop` will be
     * updated. If `clip_start` or `clip_stop` are different from `start` or `stop`
     * respectively, the region fell partially in the segment.
     * 
     * Note that when `stop` is -1, `clip_stop` will be set to the end of the
     * segment. Depending on the use case, this may or may not be what you want.
     * @param format the format of the segment.
     * @param start the start position in the segment
     * @param stop the stop position in the segment
     */
    clip(format: Format, start: number, stop: number): [ /* returnType */ boolean, /* clip_start */ number | null, /* clip_stop */ number | null ]
    /**
     * Create a copy of given `segment`.
     * 
     * Free-function: gst_segment_free
     */
    copy(): Segment
    /**
     * Copy the contents of `src` into `dest`.
     * @param dest a #GstSegment
     */
    copy_into(dest: Segment): void
    /**
     * Update the segment structure with the field values of a seek event (see
     * gst_event_new_seek()).
     * 
     * After calling this method, the segment field position and time will
     * contain the requested new position in the segment. The new requested
     * position in the segment depends on `rate` and `start_type` and `stop_type`.
     * 
     * For positive `rate,` the new position in the segment is the new `segment`
     * start field when it was updated with a `start_type` different from
     * #GST_SEEK_TYPE_NONE. If no update was performed on `segment` start position
     * (#GST_SEEK_TYPE_NONE), `start` is ignored and `segment` position is
     * unmodified.
     * 
     * For negative `rate,` the new position in the segment is the new `segment`
     * stop field when it was updated with a `stop_type` different from
     * #GST_SEEK_TYPE_NONE. If no stop was previously configured in the segment, the
     * duration of the segment will be used to update the stop position.
     * If no update was performed on `segment` stop position (#GST_SEEK_TYPE_NONE),
     * `stop` is ignored and `segment` position is unmodified.
     * 
     * The applied rate of the segment will be set to 1.0 by default.
     * If the caller can apply a rate change, it should update `segment`
     * rate and applied_rate after calling this function.
     * 
     * `update` will be set to %TRUE if a seek should be performed to the segment
     * position field. This field can be %FALSE if, for example, only the `rate`
     * has been changed but not the playback position.
     * @param rate the rate of the segment.
     * @param format the format of the segment.
     * @param flags the segment flags for the segment
     * @param start_type the seek method
     * @param start the seek start value
     * @param stop_type the seek method
     * @param stop the seek stop value
     */
    do_seek(rate: number, format: Format, flags: SeekFlags, start_type: SeekType, start: number, stop_type: SeekType, stop: number): [ /* returnType */ boolean, /* update */ boolean | null ]
    /**
     * Free the allocated segment `segment`.
     */
    free(): void
    /**
     * The start/position fields are set to 0 and the stop/duration
     * fields are set to -1 (unknown). The default rate of 1.0 and no
     * flags are set.
     * 
     * Initialize `segment` to its default values.
     * @param format the format of the segment.
     */
    init(format: Format): void
    /**
     * Checks for two segments being equal. Equality here is defined
     * as perfect equality, including floating point values.
     * @param s1 a #GstSegment structure.
     */
    is_equal(s1: Segment): boolean
    /**
     * Adjust the values in `segment` so that `offset` is applied to all
     * future running-time calculations.
     * @param format the format of the segment.
     * @param offset the offset to apply in the segment
     */
    offset_running_time(format: Format, offset: number): boolean
    /**
     * Convert `running_time` into a position in the segment so that
     * gst_segment_to_running_time() with that position returns `running_time`.
     * @param format the format of the segment.
     * @param running_time the running_time in the segment
     */
    position_from_running_time(format: Format, running_time: number): number
    /**
     * Translate `running_time` to the segment position using the currently configured
     * segment. Compared to gst_segment_position_from_running_time() this function can
     * return negative segment position.
     * 
     * This function is typically used by elements that need to synchronize buffers
     * against the clock or each other.
     * 
     * `running_time` can be any value and the result of this function for values
     * outside of the segment is extrapolated.
     * 
     * When 1 is returned, `running_time` resulted in a positive position returned
     * in `position`.
     * 
     * When this function returns -1, the returned `position` was < 0, and the value
     * in the position variable should be negated to get the real negative segment
     * position.
     * @param format the format of the segment.
     * @param running_time the running-time
     */
    position_from_running_time_full(format: Format, running_time: number): [ /* returnType */ number, /* position */ number ]
    /**
     * Convert `stream_time` into a position in the segment so that
     * gst_segment_to_stream_time() with that position returns `stream_time`.
     * @param format the format of the segment.
     * @param stream_time the stream_time in the segment
     */
    position_from_stream_time(format: Format, stream_time: number): number
    /**
     * Translate `stream_time` to the segment position using the currently configured
     * segment. Compared to gst_segment_position_from_stream_time() this function can
     * return negative segment position.
     * 
     * This function is typically used by elements that need to synchronize buffers
     * against the clock or each other.
     * 
     * `stream_time` can be any value and the result of this function for values outside
     * of the segment is extrapolated.
     * 
     * When 1 is returned, `stream_time` resulted in a positive position returned
     * in `position`.
     * 
     * When this function returns -1, the returned `position` should be negated
     * to get the real negative segment position.
     * @param format the format of the segment.
     * @param stream_time the stream-time
     */
    position_from_stream_time_full(format: Format, stream_time: number): [ /* returnType */ number, /* position */ number ]
    /**
     * Adjust the start/stop and base values of `segment` such that the next valid
     * buffer will be one with `running_time`.
     * @param format the format of the segment.
     * @param running_time the running_time in the segment
     */
    set_running_time(format: Format, running_time: number): boolean
    /**
     * Convert `running_time` into a position in the segment so that
     * gst_segment_to_running_time() with that position returns `running_time`.
     * @param format the format of the segment.
     * @param running_time the running_time in the segment
     */
    to_position(format: Format, running_time: number): number
    /**
     * Translate `position` to the total running time using the currently configured
     * segment. Position is a value between `segment` start and stop time.
     * 
     * This function is typically used by elements that need to synchronize to the
     * global clock in a pipeline. The running time is a constantly increasing value
     * starting from 0. When gst_segment_init() is called, this value will reset to
     * 0.
     * 
     * This function returns -1 if the position is outside of `segment` start and stop.
     * @param format the format of the segment.
     * @param position the position in the segment
     */
    to_running_time(format: Format, position: number): number
    /**
     * Translate `position` to the total running time using the currently configured
     * segment. Compared to gst_segment_to_running_time() this function can return
     * negative running-time.
     * 
     * This function is typically used by elements that need to synchronize buffers
     * against the clock or each other.
     * 
     * `position` can be any value and the result of this function for values outside
     * of the segment is extrapolated.
     * 
     * When 1 is returned, `position` resulted in a positive running-time returned
     * in `running_time`.
     * 
     * When this function returns -1, the returned `running_time` should be negated
     * to get the real negative running time.
     * @param format the format of the segment.
     * @param position the position in the segment
     */
    to_running_time_full(format: Format, position: number): [ /* returnType */ number, /* running_time */ number | null ]
    /**
     * Translate `position` to stream time using the currently configured
     * segment. The `position` value must be between `segment` start and
     * stop value.
     * 
     * This function is typically used by elements that need to operate on
     * the stream time of the buffers it receives, such as effect plugins.
     * In those use cases, `position` is typically the buffer timestamp or
     * clock time that one wants to convert to the stream time.
     * The stream time is always between 0 and the total duration of the
     * media stream.
     * @param format the format of the segment.
     * @param position the position in the segment
     */
    to_stream_time(format: Format, position: number): number
    /**
     * Translate `position` to the total stream time using the currently configured
     * segment. Compared to gst_segment_to_stream_time() this function can return
     * negative stream-time.
     * 
     * This function is typically used by elements that need to synchronize buffers
     * against the clock or each other.
     * 
     * `position` can be any value and the result of this function for values outside
     * of the segment is extrapolated.
     * 
     * When 1 is returned, `position` resulted in a positive stream-time returned
     * in `stream_time`.
     * 
     * When this function returns -1, the returned `stream_time` should be negated
     * to get the real negative stream time.
     * @param format the format of the segment.
     * @param position the position in the segment
     */
    to_stream_time_full(format: Format, position: number): [ /* returnType */ number, /* stream_time */ number ]
    static name: string
    static new(): Segment
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): Segment
}
abstract class SharedTaskPoolClass {
    /* Fields of Gst-1.0.Gst.SharedTaskPoolClass */
    parent_class: TaskPoolClass
    static name: string
}
class SharedTaskPoolPrivate {
    static name: string
}
class StaticCaps {
    /* Fields of Gst-1.0.Gst.StaticCaps */
    /**
     * the cached #GstCaps
     */
    caps: Caps
    /**
     * a string describing a caps
     */
    string: string
    /* Methods of Gst-1.0.Gst.StaticCaps */
    /**
     * Cleans up the cached caps contained in `static_caps`.
     */
    cleanup(): void
    /**
     * Converts a #GstStaticCaps to a #GstCaps.
     */
    get(): Caps | null
    static name: string
}
class StaticPadTemplate {
    /* Fields of Gst-1.0.Gst.StaticPadTemplate */
    /**
     * the name of the template
     */
    name_template: string
    /**
     * the direction of the template
     */
    direction: PadDirection
    /**
     * the presence of the template
     */
    presence: PadPresence
    /**
     * the caps of the template.
     */
    static_caps: StaticCaps
    /* Methods of Gst-1.0.Gst.StaticPadTemplate */
    /**
     * Converts a #GstStaticPadTemplate into a #GstPadTemplate.
     */
    get(): PadTemplate | null
    /**
     * Gets the capabilities of the static pad template.
     */
    get_caps(): Caps
    static name: string
}
abstract class StreamClass {
    /* Fields of Gst-1.0.Gst.StreamClass */
    /**
     * the parent class structure
     */
    parent_class: ObjectClass
    static name: string
}
abstract class StreamCollectionClass {
    /* Fields of Gst-1.0.Gst.StreamCollectionClass */
    /**
     * the parent class structure
     */
    parent_class: ObjectClass
    stream_notify: (collection: StreamCollection, stream: Stream, pspec: GObject.ParamSpec) => void
    static name: string
}
class StreamCollectionPrivate {
    static name: string
}
class StreamPrivate {
    static name: string
}
class Structure {
    /* Fields of Gst-1.0.Gst.Structure */
    /**
     * the GType of a structure
     */
    type: GObject.Type
    /* Methods of Gst-1.0.Gst.Structure */
    /**
     * Tries intersecting `struct1` and `struct2` and reports whether the result
     * would not be empty.
     * @param struct2 a #GstStructure
     */
    can_intersect(struct2: Structure): boolean
    /**
     * Duplicates a #GstStructure and all its fields and values.
     * 
     * Free-function: gst_structure_free
     */
    copy(): Structure
    /**
     * Calls the provided function once for each field in the #GstStructure. In
     * contrast to gst_structure_foreach(), the function may modify the fields.
     * In contrast to gst_structure_map_in_place(), the field is removed from
     * the structure if %FALSE is returned from the function.
     * The structure must be mutable.
     * @param func a function to call for each field
     */
    filter_and_map_in_place(func: StructureFilterMapFunc): void
    /**
     * Fixate all values in `structure` using gst_value_fixate().
     * `structure` will be modified in-place and should be writable.
     */
    fixate(): void
    /**
     * Fixates a #GstStructure by changing the given field with its fixated value.
     * @param field_name a field in `structure`
     */
    fixate_field(field_name: string): boolean
    /**
     * Fixates a #GstStructure by changing the given `field_name` field to the given
     * `target` boolean if that field is not fixed yet.
     * @param field_name a field in `structure`
     * @param target the target value of the fixation
     */
    fixate_field_boolean(field_name: string, target: boolean): boolean
    /**
     * Fixates a #GstStructure by changing the given field to the nearest
     * double to `target` that is a subset of the existing field.
     * @param field_name a field in `structure`
     * @param target the target value of the fixation
     */
    fixate_field_nearest_double(field_name: string, target: number): boolean
    /**
     * Fixates a #GstStructure by changing the given field to the nearest
     * fraction to `target_numerator/``target_denominator` that is a subset
     * of the existing field.
     * @param field_name a field in `structure`
     * @param target_numerator The numerator of the target value of the fixation
     * @param target_denominator The denominator of the target value of the fixation
     */
    fixate_field_nearest_fraction(field_name: string, target_numerator: number, target_denominator: number): boolean
    /**
     * Fixates a #GstStructure by changing the given field to the nearest
     * integer to `target` that is a subset of the existing field.
     * @param field_name a field in `structure`
     * @param target the target value of the fixation
     */
    fixate_field_nearest_int(field_name: string, target: number): boolean
    /**
     * Fixates a #GstStructure by changing the given `field_name` field to the given
     * `target` string if that field is not fixed yet.
     * @param field_name a field in `structure`
     * @param target the target value of the fixation
     */
    fixate_field_string(field_name: string, target: string): boolean
    /**
     * Calls the provided function once for each field in the #GstStructure. The
     * function must not modify the fields. Also see gst_structure_map_in_place()
     * and gst_structure_filter_and_map_in_place().
     * @param func a function to call for each field
     */
    foreach(func: StructureForeachFunc): boolean
    /**
     * Frees a #GstStructure and all its fields and values. The structure must not
     * have a parent when this function is called.
     */
    free(): void
    /**
     * This is useful in language bindings where unknown #GValue types are not
     * supported. This function will convert the %GST_TYPE_ARRAY into a newly
     * allocated #GValueArray and return it through `array`. Be aware that this is
     * slower then getting the #GValue directly.
     * @param fieldname the name of a field
     */
    get_array(fieldname: string): [ /* returnType */ boolean, /* array */ GObject.ValueArray ]
    /**
     * Sets the boolean pointed to by `value` corresponding to the value of the
     * given field.  Caller is responsible for making sure the field exists
     * and has the correct type.
     * @param fieldname the name of a field
     */
    get_boolean(fieldname: string): [ /* returnType */ boolean, /* value */ boolean ]
    /**
     * Sets the clock time pointed to by `value` corresponding to the clock time
     * of the given field.  Caller is responsible for making sure the field exists
     * and has the correct type.
     * @param fieldname the name of a field
     */
    get_clock_time(fieldname: string): [ /* returnType */ boolean, /* value */ ClockTime ]
    /**
     * Sets the date pointed to by `value` corresponding to the date of the
     * given field.  Caller is responsible for making sure the field exists
     * and has the correct type.
     * 
     * On success `value` will point to a newly-allocated copy of the date which
     * should be freed with g_date_free() when no longer needed (note: this is
     * inconsistent with e.g. gst_structure_get_string() which doesn't return a
     * copy of the string).
     * @param fieldname the name of a field
     */
    get_date(fieldname: string): [ /* returnType */ boolean, /* value */ GLib.Date ]
    /**
     * Sets the datetime pointed to by `value` corresponding to the datetime of the
     * given field. Caller is responsible for making sure the field exists
     * and has the correct type.
     * 
     * On success `value` will point to a reference of the datetime which
     * should be unreffed with gst_date_time_unref() when no longer needed
     * (note: this is inconsistent with e.g. gst_structure_get_string()
     * which doesn't return a copy of the string).
     * @param fieldname the name of a field
     */
    get_date_time(fieldname: string): [ /* returnType */ boolean, /* value */ DateTime ]
    /**
     * Sets the double pointed to by `value` corresponding to the value of the
     * given field.  Caller is responsible for making sure the field exists
     * and has the correct type.
     * @param fieldname the name of a field
     */
    get_double(fieldname: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Sets the int pointed to by `value` corresponding to the value of the
     * given field.  Caller is responsible for making sure the field exists,
     * has the correct type and that the enumtype is correct.
     * @param fieldname the name of a field
     * @param enumtype the enum type of a field
     */
    get_enum(fieldname: string, enumtype: GObject.Type): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Finds the field with the given name, and returns the type of the
     * value it contains.  If the field is not found, G_TYPE_INVALID is
     * returned.
     * @param fieldname the name of the field
     */
    get_field_type(fieldname: string): GObject.Type
    /**
     * Read the GstFlagSet flags and mask out of the structure into the
     * provided pointers.
     * @param fieldname the name of a field
     */
    get_flagset(fieldname: string): [ /* returnType */ boolean, /* value_flags */ number | null, /* value_mask */ number | null ]
    /**
     * Sets the integers pointed to by `value_numerator` and `value_denominator`
     * corresponding to the value of the given field.  Caller is responsible
     * for making sure the field exists and has the correct type.
     * @param fieldname the name of a field
     */
    get_fraction(fieldname: string): [ /* returnType */ boolean, /* value_numerator */ number, /* value_denominator */ number ]
    /**
     * Sets the int pointed to by `value` corresponding to the value of the
     * given field.  Caller is responsible for making sure the field exists
     * and has the correct type.
     * @param fieldname the name of a field
     */
    get_int(fieldname: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Sets the #gint64 pointed to by `value` corresponding to the value of the
     * given field. Caller is responsible for making sure the field exists
     * and has the correct type.
     * @param fieldname the name of a field
     */
    get_int64(fieldname: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * This is useful in language bindings where unknown #GValue types are not
     * supported. This function will convert the %GST_TYPE_LIST into a newly
     * allocated GValueArray and return it through `array`. Be aware that this is
     * slower then getting the #GValue directly.
     * @param fieldname the name of a field
     */
    get_list(fieldname: string): [ /* returnType */ boolean, /* array */ GObject.ValueArray ]
    /**
     * Get the name of `structure` as a string.
     */
    get_name(): string
    /**
     * Get the name of `structure` as a GQuark.
     */
    get_name_id(): GLib.Quark
    /**
     * Finds the field corresponding to `fieldname,` and returns the string
     * contained in the field's value.  Caller is responsible for making
     * sure the field exists and has the correct type.
     * 
     * The string should not be modified, and remains valid until the next
     * call to a gst_structure_*() function with the given structure.
     * @param fieldname the name of a field
     */
    get_string(fieldname: string): string | null
    /**
     * Sets the uint pointed to by `value` corresponding to the value of the
     * given field.  Caller is responsible for making sure the field exists
     * and has the correct type.
     * @param fieldname the name of a field
     */
    get_uint(fieldname: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Sets the #guint64 pointed to by `value` corresponding to the value of the
     * given field. Caller is responsible for making sure the field exists
     * and has the correct type.
     * @param fieldname the name of a field
     */
    get_uint64(fieldname: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Get the value of the field with name `fieldname`.
     * @param fieldname the name of the field to get
     */
    get_value(fieldname: string): any | null
    /**
     * Check if `structure` contains a field named `fieldname`.
     * @param fieldname the name of a field
     */
    has_field(fieldname: string): boolean
    /**
     * Check if `structure` contains a field named `fieldname` and with GType `type`.
     * @param fieldname the name of a field
     * @param type the type of a value
     */
    has_field_typed(fieldname: string, type: GObject.Type): boolean
    /**
     * Checks if the structure has the given name
     * @param name structure name to check for
     */
    has_name(name: string): boolean
    /**
     * Get the value of the field with GQuark `field`.
     * @param field the #GQuark of the field to get
     */
    id_get_value(field: GLib.Quark): any | null
    /**
     * Check if `structure` contains a field named `field`.
     * @param field #GQuark of the field name
     */
    id_has_field(field: GLib.Quark): boolean
    /**
     * Check if `structure` contains a field named `field` and with GType `type`.
     * @param field #GQuark of the field name
     * @param type the type of a value
     */
    id_has_field_typed(field: GLib.Quark, type: GObject.Type): boolean
    /**
     * Sets the field with the given GQuark `field` to `value`.  If the field
     * does not exist, it is created.  If the field exists, the previous
     * value is replaced and freed.
     * @param field a #GQuark representing a field
     * @param value the new value of the field
     */
    id_set_value(field: GLib.Quark, value: any): void
    /**
     * Sets the field with the given GQuark `field` to `value`.  If the field
     * does not exist, it is created.  If the field exists, the previous
     * value is replaced and freed.
     * @param field a #GQuark representing a field
     * @param value the new value of the field
     */
    id_take_value(field: GLib.Quark, value: any): void
    /**
     * Intersects `struct1` and `struct2` and returns the intersection.
     * @param struct2 a #GstStructure
     */
    intersect(struct2: Structure): Structure | null
    /**
     * Tests if the two #GstStructure are equal.
     * @param structure2 a #GstStructure.
     */
    is_equal(structure2: Structure): boolean
    /**
     * Checks if `subset` is a subset of `superset,` i.e. has the same
     * structure name and for all fields that are existing in `superset,`
     * `subset` has a value that is a subset of the value in `superset`.
     * @param superset a potentially greater #GstStructure
     */
    is_subset(superset: Structure): boolean
    /**
     * Calls the provided function once for each field in the #GstStructure. In
     * contrast to gst_structure_foreach(), the function may modify but not delete the
     * fields. The structure must be mutable.
     * @param func a function to call for each field
     */
    map_in_place(func: StructureMapFunc): boolean
    /**
     * Get the number of fields in the structure.
     */
    n_fields(): number
    /**
     * Get the name of the given field number, counting from 0 onwards.
     * @param index the index to get the name of
     */
    nth_field_name(index: number): string
    /**
     * Removes all fields in a GstStructure.
     */
    remove_all_fields(): void
    /**
     * Removes the field with the given name.  If the field with the given
     * name does not exist, the structure is unchanged.
     * @param fieldname the name of the field to remove
     */
    remove_field(fieldname: string): void
    /**
     * Converts `structure` to a human-readable string representation.
     * 
     * This version of the caps serialization function introduces support for nested
     * structures and caps but the resulting strings won't be parsable with
     * GStreamer prior to 1.20 unless #GST_SERIALIZE_FLAG_BACKWARD_COMPAT is passed
     * as `flag`.
     * 
     * Free-function: g_free
     * @param flags The flags to use to serialize structure
     */
    serialize(flags: SerializeFlags): string
    /**
     * This is useful in language bindings where unknown GValue types are not
     * supported. This function will convert a `array` to %GST_TYPE_ARRAY and set
     * the field specified by `fieldname`.  Be aware that this is slower then using
     * %GST_TYPE_ARRAY in a #GValue directly.
     * @param fieldname the name of a field
     * @param array a pointer to a #GValueArray
     */
    set_array(fieldname: string, array: GObject.ValueArray): void
    /**
     * This is useful in language bindings where unknown GValue types are not
     * supported. This function will convert a `array` to %GST_TYPE_LIST and set
     * the field specified by `fieldname`. Be aware that this is slower then using
     * %GST_TYPE_LIST in a #GValue directly.
     * @param fieldname the name of a field
     * @param array a pointer to a #GValueArray
     */
    set_list(fieldname: string, array: GObject.ValueArray): void
    /**
     * Sets the name of the structure to the given `name`.  The string
     * provided is copied before being used. It must not be empty, start with a
     * letter and can be followed by letters, numbers and any of "/-_.:".
     * @param name the new name of the structure
     */
    set_name(name: string): void
    /**
     * Sets the parent_refcount field of #GstStructure. This field is used to
     * determine whether a structure is mutable or not. This function should only be
     * called by code implementing parent objects of #GstStructure, as described in
     * the MT Refcounting section of the design documents.
     * @param refcount a pointer to the parent's refcount
     */
    set_parent_refcount(refcount: number): boolean
    /**
     * Sets the field with the given name `field` to `value`.  If the field
     * does not exist, it is created.  If the field exists, the previous
     * value is replaced and freed.
     * @param fieldname the name of the field to set
     * @param value the new value of the field
     */
    set_value(fieldname: string, value: any): void
    /**
     * Sets the field with the given name `field` to `value`.  If the field
     * does not exist, it is created.  If the field exists, the previous
     * value is replaced and freed. The function will take ownership of `value`.
     * @param fieldname the name of the field to set
     * @param value the new value of the field
     */
    take_value(fieldname: string, value: any): void
    /**
     * Converts `structure` to a human-readable string representation.
     * 
     * For debugging purposes its easier to do something like this: |[<!--
     * language="C" --> GST_LOG ("structure is %" GST_PTR_FORMAT, structure);
     * ```
     * 
     * This prints the structure in human readable form.
     * 
     * This function will lead to unexpected results when there are nested #GstCaps
     * / #GstStructure deeper than one level, you should user
     * gst_structure_serialize() instead for those cases.
     * 
     * Free-function: g_free
     */
    to_string(): string
    static name: string
    /* Static methods and pseudo-constructors */
    static from_string(string: string): Structure
    static new_empty(name: string): Structure
    static new_from_string(string: string): Structure
    static new_id_empty(quark: GLib.Quark): Structure
    /**
     * Atomically modifies a pointer to point to a new structure.
     * The #GstStructure `oldstr_ptr` is pointing to is freed and
     * `newstr` is taken ownership over.
     * 
     * Either `newstr` and the value pointed to by `oldstr_ptr` may be %NULL.
     * 
     * It is a programming error if both `newstr` and the value pointed to by
     * `oldstr_ptr` refer to the same, non-%NULL structure.
     * @param oldstr_ptr pointer to a place of     a #GstStructure to take
     * @param newstr a new #GstStructure
     */
    static take(oldstr_ptr?: Structure | null, newstr?: Structure | null): [ /* returnType */ boolean, /* oldstr_ptr */ Structure | null ]
}
abstract class SystemClockClass {
    /* Fields of Gst-1.0.Gst.SystemClockClass */
    parent_class: ClockClass
    static name: string
}
class SystemClockPrivate {
    static name: string
}
class TagList {
    /* Fields of Gst-1.0.Gst.TagList */
    /**
     * the parent type
     */
    mini_object: MiniObject
    /* Methods of Gst-1.0.Gst.TagList */
    /**
     * Sets the GValue for a given tag using the specified mode.
     * @param mode the mode to use
     * @param tag tag
     * @param value GValue for this tag
     */
    add_value(mode: TagMergeMode, tag: string, value: any): void
    /**
     * Creates a new #GstTagList as a copy of the old `taglist`. The new taglist
     * will have a refcount of 1, owned by the caller, and will be writable as
     * a result.
     * 
     * Note that this function is the semantic equivalent of a gst_tag_list_ref()
     * followed by a gst_tag_list_make_writable(). If you only want to hold on to a
     * reference to the data, you should use gst_tag_list_ref().
     * 
     * When you are finished with the taglist, call gst_tag_list_unref() on it.
     */
    copy(): TagList
    /**
     * Calls the given function for each tag inside the tag list. Note that if there
     * is no tag, the function won't be called at all.
     * @param func function to be called for each tag
     */
    foreach(func: TagForeachFunc): void
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_boolean(tag: string): [ /* returnType */ boolean, /* value */ boolean ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_boolean_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ boolean ]
    /**
     * Copies the first date for the given tag in the taglist into the variable
     * pointed to by `value`. Free the date with g_date_free() when it is no longer
     * needed.
     * 
     * Free-function: g_date_free
     * @param tag tag to read out
     */
    get_date(tag: string): [ /* returnType */ boolean, /* value */ GLib.Date ]
    /**
     * Gets the date that is at the given index for the given tag in the given
     * list and copies it into the variable pointed to by `value`. Free the date
     * with g_date_free() when it is no longer needed.
     * 
     * Free-function: g_date_free
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_date_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ GLib.Date ]
    /**
     * Copies the first datetime for the given tag in the taglist into the variable
     * pointed to by `value`. Unref the date with gst_date_time_unref() when
     * it is no longer needed.
     * 
     * Free-function: gst_date_time_unref
     * @param tag tag to read out
     */
    get_date_time(tag: string): [ /* returnType */ boolean, /* value */ DateTime ]
    /**
     * Gets the datetime that is at the given index for the given tag in the given
     * list and copies it into the variable pointed to by `value`. Unref the datetime
     * with gst_date_time_unref() when it is no longer needed.
     * 
     * Free-function: gst_date_time_unref
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_date_time_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ DateTime ]
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_double(tag: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_double_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_float(tag: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_float_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_int(tag: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_int64(tag: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_int64_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_int_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_pointer(tag: string): [ /* returnType */ boolean, /* value */ object | null ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_pointer_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ object | null ]
    /**
     * Copies the first sample for the given tag in the taglist into the variable
     * pointed to by `sample`. Free the sample with gst_sample_unref() when it is
     * no longer needed. You can retrieve the buffer from the sample using
     * gst_sample_get_buffer() and the associated caps (if any) with
     * gst_sample_get_caps().
     * 
     * Free-function: gst_sample_unref
     * @param tag tag to read out
     */
    get_sample(tag: string): [ /* returnType */ boolean, /* sample */ Sample ]
    /**
     * Gets the sample that is at the given index for the given tag in the given
     * list and copies it into the variable pointed to by `sample`. Free the sample
     * with gst_sample_unref() when it is no longer needed. You can retrieve the
     * buffer from the sample using gst_sample_get_buffer() and the associated
     * caps (if any) with gst_sample_get_caps().
     * 
     * Free-function: gst_sample_unref
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_sample_index(tag: string, index: number): [ /* returnType */ boolean, /* sample */ Sample ]
    /**
     * Gets the scope of `list`.
     */
    get_scope(): TagScope
    /**
     * Copies the contents for the given tag into the value, possibly merging
     * multiple values into one if multiple values are associated with the tag.
     * 
     * Use gst_tag_list_get_string_index (list, tag, 0, value) if you want
     * to retrieve the first string associated with this tag unmodified.
     * 
     * The resulting string in `value` will be in UTF-8 encoding and should be
     * freed by the caller using g_free when no longer needed. The
     * returned string is also guaranteed to be non-%NULL and non-empty.
     * 
     * Free-function: g_free
     * @param tag tag to read out
     */
    get_string(tag: string): [ /* returnType */ boolean, /* value */ string ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * 
     * The resulting string in `value` will be in UTF-8 encoding and should be
     * freed by the caller using g_free when no longer needed. The
     * returned string is also guaranteed to be non-%NULL and non-empty.
     * 
     * Free-function: g_free
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_string_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ string ]
    /**
     * Checks how many value are stored in this tag list for the given tag.
     * @param tag the tag to query
     */
    get_tag_size(tag: string): number
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_uint(tag: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Copies the contents for the given tag into the value, merging multiple values
     * into one if multiple values are associated with the tag.
     * @param tag tag to read out
     */
    get_uint64(tag: string): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_uint64_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_uint_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ number ]
    /**
     * Gets the value that is at the given index for the given tag in the given
     * list.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    get_value_index(tag: string, index: number): any | null
    /**
     * Inserts the tags of the `from` list into the first list using the given mode.
     * @param from list to merge from
     * @param mode the mode to use
     */
    insert(from: TagList, mode: TagMergeMode): void
    /**
     * Checks if the given taglist is empty.
     */
    is_empty(): boolean
    /**
     * Checks if the two given taglists are equal.
     * @param list2 a #GstTagList.
     */
    is_equal(list2: TagList): boolean
    /**
     * Merges the two given lists into a new list. If one of the lists is %NULL, a
     * copy of the other is returned. If both lists are %NULL, %NULL is returned.
     * 
     * Free-function: gst_tag_list_unref
     * @param list2 second list to merge
     * @param mode the mode to use
     */
    merge(list2: TagList | null, mode: TagMergeMode): TagList | null
    /**
     * Get the number of tags in `list`.
     */
    n_tags(): number
    /**
     * Get the name of the tag in `list` at `index`.
     * @param index the index
     */
    nth_tag_name(index: number): string
    /**
     * Peeks at the value that is at the given index for the given tag in the given
     * list.
     * 
     * The resulting string in `value` will be in UTF-8 encoding and doesn't need
     * to be freed by the caller. The returned string is also guaranteed to
     * be non-%NULL and non-empty.
     * @param tag tag to read out
     * @param index number of entry to read out
     */
    peek_string_index(tag: string, index: number): [ /* returnType */ boolean, /* value */ string ]
    /**
     * Removes the given tag from the taglist.
     * @param tag tag to remove
     */
    remove_tag(tag: string): void
    /**
     * Sets the scope of `list` to `scope`. By default the scope
     * of a taglist is stream scope.
     * @param scope new scope for `list`
     */
    set_scope(scope: TagScope): void
    /**
     * Serializes a tag list to a string.
     */
    to_string(): string | null
    static name: string
    /* Static methods and pseudo-constructors */
    static new_empty(): TagList
    static new_from_string(str: string): TagList
    /**
     * Copies the contents for the given tag into the value,
     * merging multiple values into one if multiple values are associated
     * with the tag.
     * You must g_value_unset() the value after use.
     * @param list list to get the tag from
     * @param tag tag to read out
     */
    static copy_value(list: TagList, tag: string): [ /* returnType */ boolean, /* dest */ any ]
    /**
     * Modifies a pointer to a #GstTagList to point to a different #GstTagList. The
     * modification is done atomically (so this is useful for ensuring thread
     * safety in some cases), and the reference counts are updated appropriately
     * (the old tag list is unreffed, the new is reffed).
     * 
     * Either `new_taglist` or the #GstTagList pointed to by `old_taglist` may be
     * %NULL.
     * @param old_taglist pointer to a pointer to a     #GstTagList to be replaced.
     * @param new_taglist pointer to a #GstTagList that     will replace the tag list pointed to by `old_taglist`.
     */
    static replace(old_taglist?: TagList | null, new_taglist?: TagList | null): [ /* returnType */ boolean, /* old_taglist */ TagList | null ]
    /**
     * Modifies a pointer to a #GstTagList to point to a different #GstTagList.
     * This function is similar to gst_tag_list_replace() except that it takes
     * ownership of `new_taglist`.
     * @param old_taglist pointer to a pointer to a #GstTagList     to be replaced.
     * @param new_taglist pointer to a #GstTagList that     will replace the taglist pointed to by `old_taglist`.
     */
    static take(old_taglist: TagList, new_taglist?: TagList | null): [ /* returnType */ boolean, /* old_taglist */ TagList ]
}
abstract class TagSetterInterface {
    /* Fields of Gst-1.0.Gst.TagSetterInterface */
    /**
     * parent interface type.
     */
    g_iface: GObject.TypeInterface
    static name: string
}
abstract class TaskClass {
    /* Fields of Gst-1.0.Gst.TaskClass */
    parent_class: ObjectClass
    static name: string
}
abstract class TaskPoolClass {
    /* Fields of Gst-1.0.Gst.TaskPoolClass */
    /**
     * the parent class structure
     */
    parent_class: ObjectClass
    prepare: (pool: TaskPool) => void
    cleanup: (pool: TaskPool) => void
    push: (pool: TaskPool, func: TaskPoolFunction) => object | null
    join: (pool: TaskPool, id?: object | null) => void
    dispose_handle: (pool: TaskPool, id?: object | null) => void
    static name: string
}
class TaskPrivate {
    static name: string
}
class TimedValue {
    /* Fields of Gst-1.0.Gst.TimedValue */
    /**
     * timestamp of the value change
     */
    timestamp: ClockTime
    /**
     * the corresponding value
     */
    value: number
    static name: string
}
class Toc {
    /* Methods of Gst-1.0.Gst.Toc */
    /**
     * Appends the #GstTocEntry `entry` to `toc`.
     * @param entry A #GstTocEntry
     */
    append_entry(entry: TocEntry): void
    dump(): void
    /**
     * Find #GstTocEntry with given `uid` in the `toc`.
     * @param uid UID to find #GstTocEntry with.
     */
    find_entry(uid: string): TocEntry | null
    /**
     * Gets the list of #GstTocEntry of `toc`.
     */
    get_entries(): TocEntry[]
    get_scope(): TocScope
    /**
     * Gets the tags for `toc`.
     */
    get_tags(): TagList
    /**
     * Merge `tags` into the existing tags of `toc` using `mode`.
     * @param tags A #GstTagList or %NULL
     * @param mode A #GstTagMergeMode
     */
    merge_tags(tags: TagList | null, mode: TagMergeMode): void
    /**
     * Set a #GstTagList with tags for the complete `toc`.
     * @param tags A #GstTagList or %NULL
     */
    set_tags(tags?: TagList | null): void
    static name: string
    static new(scope: TocScope): Toc
    constructor(scope: TocScope)
    /* Static methods and pseudo-constructors */
    static new(scope: TocScope): Toc
}
class TocEntry {
    /* Methods of Gst-1.0.Gst.TocEntry */
    /**
     * Appends the #GstTocEntry `subentry` to `entry`.
     * @param subentry A #GstTocEntry
     */
    append_sub_entry(subentry: TocEntry): void
    get_entry_type(): TocEntryType
    /**
     * Get `loop_type` and `repeat_count` values from the `entry` and write them into
     * appropriate storages. Loops are e.g. used by sampled instruments. GStreamer
     * is not automatically applying the loop. The application can process this
     * meta data and use it e.g. to send a seek-event to loop a section.
     */
    get_loop(): [ /* returnType */ boolean, /* loop_type */ TocLoopType | null, /* repeat_count */ number | null ]
    /**
     * Gets the parent #GstTocEntry of `entry`.
     */
    get_parent(): TocEntry | null
    /**
     * Get `start` and `stop` values from the `entry` and write them into appropriate
     * storages.
     */
    get_start_stop_times(): [ /* returnType */ boolean, /* start */ number | null, /* stop */ number | null ]
    /**
     * Gets the sub-entries of `entry`.
     */
    get_sub_entries(): TocEntry[]
    /**
     * Gets the tags for `entry`.
     */
    get_tags(): TagList
    /**
     * Gets the parent #GstToc of `entry`.
     */
    get_toc(): Toc
    /**
     * Gets the UID of `entry`.
     */
    get_uid(): string
    is_alternative(): boolean
    is_sequence(): boolean
    /**
     * Merge `tags` into the existing tags of `entry` using `mode`.
     * @param tags A #GstTagList or %NULL
     * @param mode A #GstTagMergeMode
     */
    merge_tags(tags: TagList | null, mode: TagMergeMode): void
    /**
     * Set `loop_type` and `repeat_count` values for the `entry`.
     * @param loop_type loop_type value to set.
     * @param repeat_count repeat_count value to set.
     */
    set_loop(loop_type: TocLoopType, repeat_count: number): void
    /**
     * Set `start` and `stop` values for the `entry`.
     * @param start start value to set.
     * @param stop stop value to set.
     */
    set_start_stop_times(start: number, stop: number): void
    /**
     * Set a #GstTagList with tags for the complete `entry`.
     * @param tags A #GstTagList or %NULL
     */
    set_tags(tags?: TagList | null): void
    static name: string
    static new(type: TocEntryType, uid: string): TocEntry
    constructor(type: TocEntryType, uid: string)
    /* Static methods and pseudo-constructors */
    static new(type: TocEntryType, uid: string): TocEntry
}
abstract class TocSetterInterface {
    /* Fields of Gst-1.0.Gst.TocSetterInterface */
    /**
     * parent interface type.
     */
    g_iface: GObject.TypeInterface
    static name: string
}
abstract class TracerClass {
    /* Fields of Gst-1.0.Gst.TracerClass */
    parent_class: ObjectClass
    static name: string
}
abstract class TracerFactoryClass {
    static name: string
}
class TracerPrivate {
    static name: string
}
abstract class TracerRecordClass {
    static name: string
}
class TypeFind {
    /* Fields of Gst-1.0.Gst.TypeFind */
    peek: (data: object, offset: number, size: number) => number
    suggest: (data: object, probability: number, caps: Caps) => void
    /**
     * The data used by the caller of the typefinding function.
     */
    data: object
    get_length: (data: object) => number
    /* Methods of Gst-1.0.Gst.TypeFind */
    /**
     * If a #GstTypeFindFunction calls this function it suggests caps of the
     * given `media_type` with the given `probability`.
     * 
     * This function is similar to gst_type_find_suggest_simple(), but uses
     * a #GstCaps with no fields.
     * @param probability The probability in percent that the suggestion is right
     * @param media_type the media type of the suggested caps
     */
    suggest_empty_simple(probability: number, media_type: string): void
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Registers a new typefind function to be used for typefinding. After
     * registering this function will be available for typefinding.
     * This function is typically called during an element's plugin initialization.
     * @param plugin A #GstPlugin, or %NULL for a static typefind function
     * @param name The name for registering
     * @param rank The rank (or importance) of this typefind function
     * @param func The #GstTypeFindFunction to use
     * @param extensions Optional comma-separated list of extensions     that could belong to this type
     * @param possible_caps Optionally the caps that could be returned when typefinding                 succeeds
     */
    static register(plugin: Plugin | null, name: string, rank: number, func: TypeFindFunction, extensions: string | null, possible_caps: Caps | null): boolean
}
abstract class TypeFindFactoryClass {
    static name: string
}
abstract class URIHandlerInterface {
    /* Fields of Gst-1.0.Gst.URIHandlerInterface */
    /**
     * The parent interface type
     */
    parent: GObject.TypeInterface
    get_type: (type: GObject.Type) => URIType
    get_protocols: (type: GObject.Type) => string[]
    get_uri: (handler: URIHandler) => string | null
    set_uri: (handler: URIHandler, uri: string) => boolean
    static name: string
}
class Uri {
    /* Methods of Gst-1.0.Gst.Uri */
    /**
     * Append a path onto the end of the path in the URI. The path is not
     * normalized, call #gst_uri_normalize() to normalize the path.
     * @param relative_path Relative path to append to the end of the current path.
     */
    append_path(relative_path: string): boolean
    /**
     * Append a single path segment onto the end of the URI path.
     * @param path_segment The path segment string to append to the URI path.
     */
    append_path_segment(path_segment: string): boolean
    /**
     * Create a new #GstUri object with the same data as this #GstUri object.
     * If `uri` is %NULL then returns %NULL.
     */
    copy(): Uri
    /**
     * Compares two #GstUri objects to see if they represent the same normalized
     * URI.
     * @param second Second #GstUri to compare.
     */
    equal(second: Uri): boolean
    /**
     * Like gst_uri_from_string() but also joins with a base URI.
     * @param uri The URI string to parse.
     */
    from_string_with_base(uri: string): Uri
    /**
     * Get the fragment name from the URI or %NULL if it doesn't exist.
     * If `uri` is %NULL then returns %NULL.
     */
    get_fragment(): string | null
    /**
     * Get the host name from the URI or %NULL if it doesn't exist.
     * If `uri` is %NULL then returns %NULL.
     */
    get_host(): string | null
    /**
     * Get the media fragment table from the URI, as defined by "Media Fragments URI 1.0".
     * Hash table returned by this API is a list of "key-value" pairs, and the each
     * pair is generated by splitting "URI fragment" per "&" sub-delims, then "key"
     * and "value" are split by "=" sub-delims. The "key" returned by this API may
     * be undefined keyword by standard.
     * A value may be %NULL to indicate that the key should appear in the fragment
     * string in the URI, but does not have a value. Free the returned #GHashTable
     * with #g_hash_table_unref() when it is no longer required.
     * Modifying this hash table does not affect the fragment in the URI.
     * 
     * See more about Media Fragments URI 1.0 (W3C) at https://www.w3.org/TR/media-frags/
     */
    get_media_fragment_table(): GLib.HashTable | null
    /**
     * Extract the path string from the URI object.
     */
    get_path(): string | null
    /**
     * Get a list of path segments from the URI.
     */
    get_path_segments(): string[]
    /**
     * Extract the path string from the URI object as a percent encoded URI path.
     */
    get_path_string(): string | null
    /**
     * Get the port number from the URI or %GST_URI_NO_PORT if it doesn't exist.
     * If `uri` is %NULL then returns %GST_URI_NO_PORT.
     */
    get_port(): number
    /**
     * Get a list of the query keys from the URI.
     */
    get_query_keys(): string[]
    /**
     * Get a percent encoded URI query string from the `uri`.
     */
    get_query_string(): string | null
    /**
     * Get the query table from the URI. Keys and values in the table are freed
     * with g_free when they are deleted. A value may be %NULL to indicate that
     * the key should appear in the query string in the URI, but does not have a
     * value. Free the returned #GHashTable with #g_hash_table_unref() when it is
     * no longer required. Modifying this hash table will modify the query in the
     * URI.
     */
    get_query_table(): GLib.HashTable | null
    /**
     * Get the value associated with the `query_key` key. Will return %NULL if the
     * key has no value or if the key does not exist in the URI query table. Because
     * %NULL is returned for both missing keys and keys with no value, you should
     * use gst_uri_query_has_key() to determine if a key is present in the URI
     * query.
     * @param query_key The key to lookup.
     */
    get_query_value(query_key: string): string | null
    /**
     * Get the scheme name from the URI or %NULL if it doesn't exist.
     * If `uri` is %NULL then returns %NULL.
     */
    get_scheme(): string | null
    /**
     * Get the userinfo (usually in the form "username:password") from the URI
     * or %NULL if it doesn't exist. If `uri` is %NULL then returns %NULL.
     */
    get_userinfo(): string | null
    /**
     * Tests the `uri` to see if it is normalized. A %NULL `uri` is considered to be
     * normalized.
     */
    is_normalized(): boolean
    /**
     * Check if it is safe to write to this #GstUri.
     * 
     * Check if the refcount of `uri` is exactly 1, meaning that no other
     * reference exists to the #GstUri and that the #GstUri is therefore writable.
     * 
     * Modification of a #GstUri should only be done after verifying that it is
     * writable.
     */
    is_writable(): boolean
    /**
     * Join a reference URI onto a base URI using the method from RFC 3986.
     * If either URI is %NULL then the other URI will be returned with the ref count
     * increased.
     * @param ref_uri The reference URI to join onto the                                       base URI.
     */
    join(ref_uri?: Uri | null): Uri | null
    /**
     * Make the #GstUri writable.
     * 
     * Checks if `uri` is writable, and if so the original object is returned. If
     * not, then a writable copy is made and returned. This gives away the
     * reference to `uri` and returns a reference to the new #GstUri.
     * If `uri` is %NULL then %NULL is returned.
     */
    make_writable(): Uri
    /**
     * Like gst_uri_new(), but joins the new URI onto a base URI.
     * @param scheme The scheme for the new URI.
     * @param userinfo The user-info for the new URI.
     * @param host The host name for the new URI.
     * @param port The port number for the new URI or %GST_URI_NO_PORT.
     * @param path The path for the new URI with '/' separating path                      elements.
     * @param query The query string for the new URI with '&' separating                       query elements. Elements containing '&' characters                       should encode them as "&percnt;26".
     * @param fragment The fragment name for the new URI.
     */
    new_with_base(scheme: string | null, userinfo: string | null, host: string | null, port: number, path?: string | null, query?: string | null, fragment?: string | null): Uri
    /**
     * Normalization will remove extra path segments ("." and "..") from the URI. It
     * will also convert the scheme and host name to lower case and any
     * percent-encoded values to uppercase.
     * 
     * The #GstUri object must be writable. Check with gst_uri_is_writable() or use
     * gst_uri_make_writable() first.
     */
    normalize(): boolean
    /**
     * Check if there is a query table entry for the `query_key` key.
     * @param query_key The key to lookup.
     */
    query_has_key(query_key: string): boolean
    /**
     * Add a reference to this #GstUri object. See gst_mini_object_ref() for further
     * info.
     */
    ref(): Uri
    /**
     * Remove an entry from the query table by key.
     * @param query_key The key to remove.
     */
    remove_query_key(query_key: string): boolean
    /**
     * Sets the fragment string in the URI. Use a value of %NULL in `fragment` to
     * unset the fragment string.
     * @param fragment The fragment string to set.
     */
    set_fragment(fragment?: string | null): boolean
    /**
     * Set or unset the host for the URI.
     * @param host The new host string to set or %NULL to unset.
     */
    set_host(host: string): boolean
    /**
     * Sets or unsets the path in the URI.
     * @param path The new path to set with path segments separated by '/', or use %NULL        to unset the path.
     */
    set_path(path: string): boolean
    /**
     * Replace the path segments list in the URI.
     * @param path_segments The new                 path list to set.
     */
    set_path_segments(path_segments?: string[] | null): boolean
    /**
     * Sets or unsets the path in the URI.
     * @param path The new percent encoded path to set with path segments separated by '/', or use %NULL to unset the path.
     */
    set_path_string(path: string): boolean
    /**
     * Set or unset the port number for the URI.
     * @param port The new port number to set or %GST_URI_NO_PORT to unset.
     */
    set_port(port: number): boolean
    /**
     * Sets or unsets the query table in the URI.
     * @param query The new percent encoded query string to use to populate the query        table, or use %NULL to unset the query table.
     */
    set_query_string(query: string): boolean
    /**
     * Set the query table to use in the URI. The old table is unreferenced and a
     * reference to the new one is used instead. A value if %NULL for `query_table`
     * will remove the query string from the URI.
     * @param query_table The new               query table to use.
     */
    set_query_table(query_table?: GLib.HashTable | null): boolean
    /**
     * This inserts or replaces a key in the query table. A `query_value` of %NULL
     * indicates that the key has no associated value, but will still be present in
     * the query string.
     * @param query_key The key for the query entry.
     * @param query_value The value for the key.
     */
    set_query_value(query_key: string, query_value?: string | null): boolean
    /**
     * Set or unset the scheme for the URI.
     * @param scheme The new scheme to set or %NULL to unset the scheme.
     */
    set_scheme(scheme: string): boolean
    /**
     * Set or unset the user information for the URI.
     * @param userinfo The new user-information string to set or %NULL to unset.
     */
    set_userinfo(userinfo: string): boolean
    /**
     * Convert the URI to a string.
     * 
     * Returns the URI as held in this object as a #gchar* nul-terminated string.
     * The caller should g_free() the string once they are finished with it.
     * The string is put together as described in RFC 3986.
     */
    to_string(): string
    /**
     * Decrement the reference count to this #GstUri object.
     * 
     * If the reference count drops to 0 then finalize this object.
     * 
     * See gst_mini_object_unref() for further info.
     */
    unref(): void
    static name: string
    static new(scheme: string | null, userinfo: string | null, host: string | null, port: number, path?: string | null, query?: string | null, fragment?: string | null): Uri
    constructor(scheme: string | null, userinfo: string | null, host: string | null, port: number, path?: string | null, query?: string | null, fragment?: string | null)
    /* Static methods and pseudo-constructors */
    static new(scheme: string | null, userinfo: string | null, host: string | null, port: number, path?: string | null, query?: string | null, fragment?: string | null): Uri
    /**
     * Constructs a URI for a given valid protocol and location.
     * 
     * Free-function: g_free
     * @param protocol Protocol for URI
     * @param location Location for URI
     */
    static construct(protocol: string, location: string): string
    /**
     * Parses a URI string into a new #GstUri object. Will return NULL if the URI
     * cannot be parsed.
     * @param uri The URI string to parse.
     */
    static from_string(uri: string): Uri | null
    /**
     * Parses a URI string into a new #GstUri object. Will return NULL if the URI
     * cannot be parsed. This is identical to gst_uri_from_string() except that
     * the userinfo and fragment components of the URI will not be unescaped while
     * parsing.
     * 
     * Use this when you need to extract a username and password from the userinfo
     * such as https://user:password`example`.com since either may contain
     * a URI-escaped ':' character. gst_uri_from_string() will unescape the entire
     * userinfo component, which will make it impossible to know which ':'
     * delineates the username and password.
     * 
     * The same applies to the fragment component of the URI, such as
     * https://example.com/path#fragment which may contain a URI-escaped '#'.
     * @param uri The URI string to parse.
     */
    static from_string_escaped(uri: string): Uri | null
    /**
     * Extracts the location out of a given valid URI, ie. the protocol and "://"
     * are stripped from the URI, which means that the location returned includes
     * the hostname if one is specified. The returned string must be freed using
     * g_free().
     * 
     * Free-function: g_free
     * @param uri A URI string
     */
    static get_location(uri: string): string | null
    /**
     * Extracts the protocol out of a given valid URI. The returned string must be
     * freed using g_free().
     * @param uri A URI string
     */
    static get_protocol(uri: string): string | null
    /**
     * Checks if the protocol of a given valid URI matches `protocol`.
     * @param uri a URI string
     * @param protocol a protocol string (e.g. "http")
     */
    static has_protocol(uri: string, protocol: string): boolean
    /**
     * Tests if the given string is a valid URI identifier. URIs start with a valid
     * scheme followed by ":" and maybe a string identifying the location.
     * @param uri A URI string
     */
    static is_valid(uri: string): boolean
    /**
     * This is a convenience function to join two URI strings and return the result.
     * The returned string should be g_free()'d after use.
     * @param base_uri The percent-encoded base URI.
     * @param ref_uri The percent-encoded reference URI to join to the `base_uri`.
     */
    static join_strings(base_uri: string, ref_uri: string): string
    /**
     * Checks if an element exists that supports the given URI protocol. Note
     * that a positive return value does not imply that a subsequent call to
     * gst_element_make_from_uri() is guaranteed to work.
     * @param type Whether to check for a source or a sink
     * @param protocol Protocol that should be checked for (e.g. "http" or "smb")
     */
    static protocol_is_supported(type: URIType, protocol: string): boolean
    /**
     * Tests if the given string is a valid protocol identifier. Protocols
     * must consist of alphanumeric characters, '+', '-' and '.' and must
     * start with a alphabetic character. See RFC 3986 Section 3.1.
     * @param protocol A string
     */
    static protocol_is_valid(protocol: string): boolean
}
class ValueTable {
    /* Fields of Gst-1.0.Gst.ValueTable */
    /**
     * a #GType
     */
    type: GObject.Type
    /**
     * a #GstValueCompareFunc
     */
    compare: ValueCompareFunc
    /**
     * a #GstValueSerializeFunc
     */
    serialize: ValueSerializeFunc
    /**
     * a #GstValueDeserializeFunc
     */
    deserialize: ValueDeserializeFunc
    /**
     * a #GstValueDeserializeWithPSpecFunc
     */
    deserialize_with_pspec: ValueDeserializeWithPSpecFunc
    static name: string
}
    type ClockID = object
    type ClockTime = number
    type ClockTimeDiff = number
    type ElementFactoryListType = number
}
export default Gst;