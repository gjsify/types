/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * NM-1.0
 */

import type * as Gjs from './Gjs';
import type Gio from './Gio-2.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';

export namespace NM {

/**
 * Indicates the 802.11 mode an access point or device is currently in.
 */
enum TODO_80211Mode {
    /**
     * the device or access point mode is unknown
     */
    UNKNOWN,
    /**
     * for both devices and access point objects, indicates
     *   the object is part of an Ad-Hoc 802.11 network without a central
     *   coordinating access point.
     */
    ADHOC,
    /**
     * the device or access point is in infrastructure mode.
     *   For devices, this indicates the device is an 802.11 client/station.  For
     *   access point objects, this indicates the object is an access point that
     *   provides connectivity to clients.
     */
    INFRA,
    /**
     * the device is an access point/hotspot.  Not valid for
     *   access point objects; used only for hotspot mode on the local machine.
     */
    AP,
    /**
     * the device is a 802.11s mesh point. Since: 1.20.
     */
    MESH,
}
/**
 * #NMActiveConnectionState values indicate the state of a connection to a
 * specific network while it is starting, connected, or disconnecting from that
 * network.
 */
enum ActiveConnectionState {
    /**
     * the state of the connection is unknown
     */
    UNKNOWN,
    /**
     * a network connection is being prepared
     */
    ACTIVATING,
    /**
     * there is a connection to the network
     */
    ACTIVATED,
    /**
     * the network connection is being
     *   torn down and cleaned up
     */
    DEACTIVATING,
    /**
     * the network connection is disconnected
     *   and will be removed
     */
    DEACTIVATED,
}
/**
 * Active connection state reasons.
 */
enum ActiveConnectionStateReason {
    /**
     * The reason for the active connection
     *   state change is unknown.
     */
    UNKNOWN,
    /**
     * No reason was given for the active
     *   connection state change.
     */
    NONE,
    /**
     * The active connection changed
     *   state because the user disconnected it.
     */
    USER_DISCONNECTED,
    /**
     * The active connection
     *   changed state because the device it was using was disconnected.
     */
    DEVICE_DISCONNECTED,
    /**
     * The service providing the
     *   VPN connection was stopped.
     */
    SERVICE_STOPPED,
    /**
     * The IP config of the active
     *   connection was invalid.
     */
    IP_CONFIG_INVALID,
    /**
     * The connection attempt to
     *   the VPN service timed out.
     */
    CONNECT_TIMEOUT,
    /**
     * A timeout occurred
     *   while starting the service providing the VPN connection.
     */
    SERVICE_START_TIMEOUT,
    /**
     * Starting the service
     *   providing the VPN connection failed.
     */
    SERVICE_START_FAILED,
    /**
     * Necessary secrets for the
     *   connection were not provided.
     */
    NO_SECRETS,
    /**
     * Authentication to the
     *   server failed.
     */
    LOGIN_FAILED,
    /**
     * The connection was
     *   deleted from settings.
     */
    CONNECTION_REMOVED,
    /**
     * Master connection of this
     *   connection failed to activate.
     */
    DEPENDENCY_FAILED,
    /**
     * Could not create the
     *   software device link.
     */
    DEVICE_REALIZE_FAILED,
    /**
     * The device this connection
     *   depended on disappeared.
     */
    DEVICE_REMOVED,
}
/**
 * Errors returned from the secret-agent manager.
 * 
 * These errors may be returned from operations that could cause secrets to be
 * requested (such as nm_client_activate_connection()), and correspond to D-Bus
 * errors in the "org.freedesktop.NetworkManager.AgentManager" namespace.
 */
enum AgentManagerError {
    /**
     * unknown or unspecified error
     */
    FAILED,
    /**
     * The caller does not have permission
     *   to register a secret agent, or is trying to register the same secret agent
     *   twice.
     */
    PERMISSIONDENIED,
    /**
     * The identifier is not a valid
     *   secret agent identifier.
     */
    INVALIDIDENTIFIER,
    /**
     * The caller tried to unregister an agent
     *   that was not registered.
     */
    NOTREGISTERED,
    /**
     * No secret agent returned secrets for this
     *   request
     */
    NOSECRETS,
    /**
     * The user canceled the secrets request.
     */
    USERCANCELED,
}
/**
 * #NMCapability names the numbers in the Capabilities property.
 * Capabilities are positive numbers. They are part of stable API
 * and a certain capability number is guaranteed not to change.
 * 
 * The range 0x7000 - 0x7FFF of capabilities is guaranteed not to be
 * used by upstream NetworkManager. It could thus be used for downstream
 * extensions.
 */
enum Capability {
    /**
     * Teams can be managed. This means the team device plugin
     *   is loaded.
     */
    TEAM,
    /**
     * OpenVSwitch can be managed. This means the OVS device plugin
     *   is loaded. Since: 1.24.
     */
    OVS,
}
/**
 * Describes errors that may result from operations involving a #NMClient.
 * 
 * D-Bus operations may also return errors from other domains, including
 * #NMManagerError, #NMSettingsError, #NMAgentManagerError, and #NMConnectionError.
 */
enum ClientError {
    /**
     * unknown or unclassified error
     */
    FAILED,
    /**
     * an operation that requires NetworkManager
     *   failed because NetworkManager is not running
     */
    MANAGER_NOT_RUNNING,
    /**
     * NetworkManager claimed that an
     *   operation succeeded, but the object that was allegedly created (eg,
     *   #NMRemoteConnection, #NMActiveConnection) was apparently destroyed before
     *   #NMClient could create a representation of it.
     */
    OBJECT_CREATION_FAILED,
}
/**
 * #NMClientPermission values indicate various permissions that NetworkManager
 * clients can obtain to perform certain tasks on behalf of the current user.
 */
enum ClientPermission {
    /**
     * unknown or no permission
     */
    NONE,
    /**
     * controls whether networking
     *  can be globally enabled or disabled
     */
    ENABLE_DISABLE_NETWORK,
    /**
     * controls whether Wi-Fi can be
     *  globally enabled or disabled
     */
    ENABLE_DISABLE_WIFI,
    /**
     * controls whether WWAN (3G) can be
     *  globally enabled or disabled
     */
    ENABLE_DISABLE_WWAN,
    /**
     * controls whether WiMAX can be
     *  globally enabled or disabled
     */
    ENABLE_DISABLE_WIMAX,
    /**
     * controls whether the client can ask
     *  NetworkManager to sleep and wake
     */
    SLEEP_WAKE,
    /**
     * controls whether networking connections
     *  can be started, stopped, and changed
     */
    NETWORK_CONTROL,
    /**
     * controls whether a password
     *  protected Wi-Fi hotspot can be created
     */
    WIFI_SHARE_PROTECTED,
    /**
     * controls whether an open Wi-Fi hotspot
     *  can be created
     */
    WIFI_SHARE_OPEN,
    /**
     * controls whether connections
     *  that are available to all users can be modified
     */
    SETTINGS_MODIFY_SYSTEM,
    /**
     * controls whether connections
     *  owned by the current user can be modified
     */
    SETTINGS_MODIFY_OWN,
    /**
     * controls whether the
     *  persistent hostname can be changed
     */
    SETTINGS_MODIFY_HOSTNAME,
    /**
     * modify persistent global
     *  DNS configuration
     */
    SETTINGS_MODIFY_GLOBAL_DNS,
    /**
     * controls access to Reload.
     */
    RELOAD,
    /**
     * permission to create checkpoints.
     */
    CHECKPOINT_ROLLBACK,
    /**
     * controls whether device
     *  statistics can be globally enabled or disabled
     */
    ENABLE_DISABLE_STATISTICS,
    /**
     * controls whether
     *  connectivity check can be enabled or disabled
     */
    ENABLE_DISABLE_CONNECTIVITY_CHECK,
    /**
     * controls whether wifi scans can be performed
     */
    WIFI_SCAN,
    /**
     * a reserved boundary value
     */
    LAST,
}
/**
 * #NMClientPermissionResult values indicate what authorizations and permissions
 * the user requires to obtain a given #NMClientPermission
 */
enum ClientPermissionResult {
    /**
     * unknown or no authorization
     */
    UNKNOWN,
    /**
     * the permission is available
     */
    YES,
    /**
     * authorization is necessary before the
     *  permission is available
     */
    AUTH,
    /**
     * permission to perform the operation is
     *  denied by system policy
     */
    NO,
}
/**
 * Describes errors that may result from operations involving a #NMConnection
 * or its #NMSettings.
 * 
 * These errors may be returned directly from #NMConnection and #NMSetting
 * methods, or may be returned from D-Bus operations (eg on #NMClient or
 * #NMDevice), where they correspond to errors in the
 * "org.freedesktop.NetworkManager.Settings.Connection" namespace.
 */
enum ConnectionError {
    /**
     * unknown or unclassified error
     */
    FAILED,
    /**
     * the #NMConnection object
     *   did not contain the specified #NMSetting object
     */
    SETTINGNOTFOUND,
    /**
     * the #NMConnection did not contain the
     *   requested #NMSetting property
     */
    PROPERTYNOTFOUND,
    /**
     * an operation which requires a secret
     *   was attempted on a non-secret property
     */
    PROPERTYNOTSECRET,
    /**
     * the #NMConnection object is missing an
     *   #NMSetting which is required for its configuration. The error message will
     *   always be prefixed with "&lt;setting-name>: ", where "&lt;setting-name>" is the
     *   name of the setting that is missing.
     */
    MISSINGSETTING,
    /**
     * the #NMConnection object contains an
     *   invalid or inappropriate #NMSetting. The error message will always be
     *   prefixed with "&lt;setting-name>: ", where "&lt;setting-name>" is the name of the
     *   setting that is invalid.
     */
    INVALIDSETTING,
    /**
     * the #NMConnection object is invalid
     *   because it is missing a required property. The error message will always be
     *   prefixed with "&lt;setting-name>.&lt;property-name>: ", where "&lt;setting-name>" is
     *   the name of the setting with the missing property, and "&lt;property-name>" is
     *   the property that is missing.
     */
    MISSINGPROPERTY,
    /**
     * the #NMConnection object is invalid
     *   because a property has an invalid value. The error message will always be
     *   prefixed with "&lt;setting-name>.&lt;property-name>: ", where "&lt;setting-name>" is
     *   the name of the setting with the invalid property, and "&lt;property-name>" is
     *   the property that is invalid.
     */
    INVALIDPROPERTY,
}
enum ConnectionMultiConnect {
    /**
     * indicates that the per-connection
     *   setting is unspecified. In this case, it will fallback to the default
     *   value, which is %NM_CONNECTION_MULTI_CONNECT_SINGLE.
     */
    DEFAULT,
    /**
     * the connection profile can only
     *   be active once at each moment. Activating a profile that is already active,
     *   will first deactivate it.
     */
    SINGLE,
    /**
     * the profile can
     *   be manually activated multiple times on different devices. However,
     *   regarding autoconnect, the profile will autoconnect only if it is
     *   currently not connected otherwise.
     */
    MANUAL_MULTIPLE,
    /**
     * the profile can autoactivate
     *   and be manually activated multiple times together.
     */
    MULTIPLE,
}
enum ConnectivityState {
    /**
     * Network connectivity is unknown. This means the
     *   connectivity checks are disabled (e.g. on server installations) or has
     *   not run yet. The graphical shell should assume the Internet connection
     *   might be available and not present a captive portal window.
     */
    UNKNOWN,
    /**
     * The host is not connected to any network. There's
     *   no active connection that contains a default route to the internet and
     *   thus it makes no sense to even attempt a connectivity check. The graphical
     *   shell should use this state to indicate the network connection is unavailable.
     */
    NONE,
    /**
     * The Internet connection is hijacked by a captive
     *   portal gateway. The graphical shell may open a sandboxed web browser window
     *   (because the captive portals typically attempt a man-in-the-middle attacks
     *   against the https connections) for the purpose of authenticating to a gateway
     *   and retrigger the connectivity check with CheckConnectivity() when the
     *   browser window is dismissed.
     */
    PORTAL,
    /**
     * The host is connected to a network, does not appear
     *   to be able to reach the full Internet, but a captive portal has not been
     *   detected.
     */
    LIMITED,
    /**
     * The host is connected to a network, and
     *   appears to be able to reach the full Internet.
     */
    FULL,
}
/**
 * Cryptography-related errors that can be returned from some nm-utils methods,
 * and some #NMSetting8021x operations.
 */
enum CryptoError {
    /**
     * generic failure
     */
    FAILED,
    /**
     * the certificate or key data provided
     *   was invalid
     */
    INVALID_DATA,
    /**
     * the password was invalid
     */
    INVALID_PASSWORD,
    /**
     * the data uses an unknown cipher
     */
    UNKNOWN_CIPHER,
    /**
     * decryption failed
     */
    DECRYPTION_FAILED,
    /**
     * encryption failed
     */
    ENCRYPTION_FAILED,
}
/**
 * Device-related errors.
 * 
 * These errors may be returned directly from #NMDevice methods, or may be
 * returned from D-Bus operations (where they correspond to errors in the
 * "org.freedesktop.NetworkManager.Device" namespace).
 */
enum DeviceError {
    /**
     * unknown or unclassified error
     */
    FAILED,
    /**
     * NetworkManager failed to create the device
     */
    CREATIONFAILED,
    /**
     * the specified connection is not valid
     */
    INVALIDCONNECTION,
    /**
     * the specified connection is not
     *   compatible with this device.
     */
    INCOMPATIBLECONNECTION,
    /**
     * the device does not have an active connection
     */
    NOTACTIVE,
    /**
     * the requested operation is only valid on
     *   software devices.
     */
    NOTSOFTWARE,
    /**
     * the requested operation is not allowed at
     *   this time.
     */
    NOTALLOWED,
    /**
     * the "specific object" in the
     *   activation request (eg, the #NMAccessPoint or #NMWimaxNsp) was not
     *   found.
     */
    SPECIFICOBJECTNOTFOUND,
    /**
     * the version id did not match.
     */
    VERSIONIDMISMATCH,
    /**
     * the requested operation could not
     *   be completed due to missing dependencies.
     */
    MISSINGDEPENDENCIES,
    /**
     * invalid argument. Since: 1.16.
     */
    INVALIDARGUMENT,
}
enum DeviceState {
    /**
     * the device's state is unknown
     */
    UNKNOWN,
    /**
     * the device is recognized, but not managed by
     *   NetworkManager
     */
    UNMANAGED,
    /**
     * the device is managed by NetworkManager, but
     *   is not available for use.  Reasons may include the wireless switched off,
     *   missing firmware, no ethernet carrier, missing supplicant or modem manager,
     *   etc.
     */
    UNAVAILABLE,
    /**
     * the device can be activated, but is currently
     *   idle and not connected to a network.
     */
    DISCONNECTED,
    /**
     * the device is preparing the connection to the
     *   network.  This may include operations like changing the MAC address,
     *   setting physical link properties, and anything else required to connect
     *   to the requested network.
     */
    PREPARE,
    /**
     * the device is connecting to the requested network.
     *   This may include operations like associating with the Wi-Fi AP, dialing
     *   the modem, connecting to the remote Bluetooth device, etc.
     */
    CONFIG,
    /**
     * the device requires more information to continue
     *   connecting to the requested network.  This includes secrets like WiFi
     *   passphrases, login passwords, PIN codes, etc.
     */
    NEED_AUTH,
    /**
     * the device is requesting IPv4 and/or IPv6
     *   addresses and routing information from the network.
     */
    IP_CONFIG,
    /**
     * the device is checking whether further action is
     *   required for the requested network connection.  This may include checking
     *   whether only local network access is available, whether a captive portal
     *   is blocking access to the Internet, etc.
     */
    IP_CHECK,
    /**
     * the device is waiting for a secondary
     *   connection (like a VPN) which must activated before the device can be
     *   activated
     */
    SECONDARIES,
    /**
     * the device has a network connection, either local
     *   or global.
     */
    ACTIVATED,
    /**
     * a disconnection from the current network
     *   connection was requested, and the device is cleaning up resources used for
     *   that connection.  The network connection may still be valid.
     */
    DEACTIVATING,
    /**
     * the device failed to connect to the requested
     *   network and is cleaning up the connection request
     */
    FAILED,
}
/**
 * Device state change reason codes
 */
enum DeviceStateReason {
    /**
     * No reason given
     */
    NONE,
    /**
     * Unknown error
     */
    UNKNOWN,
    /**
     * Device is now managed
     */
    NOW_MANAGED,
    /**
     * Device is now unmanaged
     */
    NOW_UNMANAGED,
    /**
     * The device could not be readied for configuration
     */
    CONFIG_FAILED,
    /**
     * IP configuration could not be reserved (no available address, timeout, etc)
     */
    IP_CONFIG_UNAVAILABLE,
    /**
     * The IP config is no longer valid
     */
    IP_CONFIG_EXPIRED,
    /**
     * Secrets were required, but not provided
     */
    NO_SECRETS,
    /**
     * 802.1x supplicant disconnected
     */
    SUPPLICANT_DISCONNECT,
    /**
     * 802.1x supplicant configuration failed
     */
    SUPPLICANT_CONFIG_FAILED,
    /**
     * 802.1x supplicant failed
     */
    SUPPLICANT_FAILED,
    /**
     * 802.1x supplicant took too long to authenticate
     */
    SUPPLICANT_TIMEOUT,
    /**
     * PPP service failed to start
     */
    PPP_START_FAILED,
    /**
     * PPP service disconnected
     */
    PPP_DISCONNECT,
    /**
     * PPP failed
     */
    PPP_FAILED,
    /**
     * DHCP client failed to start
     */
    DHCP_START_FAILED,
    /**
     * DHCP client error
     */
    DHCP_ERROR,
    /**
     * DHCP client failed
     */
    DHCP_FAILED,
    /**
     * Shared connection service failed to start
     */
    SHARED_START_FAILED,
    /**
     * Shared connection service failed
     */
    SHARED_FAILED,
    /**
     * AutoIP service failed to start
     */
    AUTOIP_START_FAILED,
    /**
     * AutoIP service error
     */
    AUTOIP_ERROR,
    /**
     * AutoIP service failed
     */
    AUTOIP_FAILED,
    /**
     * The line is busy
     */
    MODEM_BUSY,
    /**
     * No dial tone
     */
    MODEM_NO_DIAL_TONE,
    /**
     * No carrier could be established
     */
    MODEM_NO_CARRIER,
    /**
     * The dialing request timed out
     */
    MODEM_DIAL_TIMEOUT,
    /**
     * The dialing attempt failed
     */
    MODEM_DIAL_FAILED,
    /**
     * Modem initialization failed
     */
    MODEM_INIT_FAILED,
    /**
     * Failed to select the specified APN
     */
    GSM_APN_FAILED,
    /**
     * Not searching for networks
     */
    GSM_REGISTRATION_NOT_SEARCHING,
    /**
     * Network registration denied
     */
    GSM_REGISTRATION_DENIED,
    /**
     * Network registration timed out
     */
    GSM_REGISTRATION_TIMEOUT,
    /**
     * Failed to register with the requested network
     */
    GSM_REGISTRATION_FAILED,
    /**
     * PIN check failed
     */
    GSM_PIN_CHECK_FAILED,
    /**
     * Necessary firmware for the device may be missing
     */
    FIRMWARE_MISSING,
    /**
     * The device was removed
     */
    REMOVED,
    /**
     * NetworkManager went to sleep
     */
    SLEEPING,
    /**
     * The device's active connection disappeared
     */
    CONNECTION_REMOVED,
    /**
     * Device disconnected by user or client
     */
    USER_REQUESTED,
    /**
     * Carrier/link changed
     */
    CARRIER,
    /**
     * The device's existing connection was assumed
     */
    CONNECTION_ASSUMED,
    /**
     * The supplicant is now available
     */
    SUPPLICANT_AVAILABLE,
    /**
     * The modem could not be found
     */
    MODEM_NOT_FOUND,
    /**
     * The Bluetooth connection failed or timed out
     */
    BT_FAILED,
    /**
     * GSM Modem's SIM Card not inserted
     */
    GSM_SIM_NOT_INSERTED,
    /**
     * GSM Modem's SIM Pin required
     */
    GSM_SIM_PIN_REQUIRED,
    /**
     * GSM Modem's SIM Puk required
     */
    GSM_SIM_PUK_REQUIRED,
    /**
     * GSM Modem's SIM wrong
     */
    GSM_SIM_WRONG,
    /**
     * InfiniBand device does not support connected mode
     */
    INFINIBAND_MODE,
    /**
     * A dependency of the connection failed
     */
    DEPENDENCY_FAILED,
    /**
     * Problem with the RFC 2684 Ethernet over ADSL bridge
     */
    BR2684_FAILED,
    /**
     * ModemManager not running
     */
    MODEM_MANAGER_UNAVAILABLE,
    /**
     * The Wi-Fi network could not be found
     */
    SSID_NOT_FOUND,
    /**
     * A secondary connection of the base connection failed
     */
    SECONDARY_CONNECTION_FAILED,
    /**
     * DCB or FCoE setup failed
     */
    DCB_FCOE_FAILED,
    /**
     * teamd control failed
     */
    TEAMD_CONTROL_FAILED,
    /**
     * Modem failed or no longer available
     */
    MODEM_FAILED,
    /**
     * Modem now ready and available
     */
    MODEM_AVAILABLE,
    /**
     * SIM PIN was incorrect
     */
    SIM_PIN_INCORRECT,
    /**
     * New connection activation was enqueued
     */
    NEW_ACTIVATION,
    /**
     * the device's parent changed
     */
    PARENT_CHANGED,
    /**
     * the device parent's management changed
     */
    PARENT_MANAGED_CHANGED,
    /**
     * problem communicating with Open vSwitch database
     */
    OVSDB_FAILED,
    /**
     * a duplicate IP address was detected
     */
    IP_ADDRESS_DUPLICATE,
    /**
     * The selected IP method is not supported
     */
    IP_METHOD_UNSUPPORTED,
    /**
     * configuration of SR-IOV parameters failed
     */
    SRIOV_CONFIGURATION_FAILED,
    /**
     * The Wi-Fi P2P peer could not be found
     */
    PEER_NOT_FOUND,
}
/**
 * #NMDeviceType values indicate the type of hardware represented by a
 * device object.
 */
enum DeviceType {
    /**
     * unknown device
     */
    UNKNOWN,
    /**
     * a wired ethernet device
     */
    ETHERNET,
    /**
     * an 802.11 Wi-Fi device
     */
    WIFI,
    /**
     * not used
     */
    UNUSED1,
    /**
     * not used
     */
    UNUSED2,
    /**
     * a Bluetooth device supporting PAN or DUN access protocols
     */
    BT,
    /**
     * an OLPC XO mesh networking device
     */
    OLPC_MESH,
    /**
     * an 802.16e Mobile WiMAX broadband device
     */
    WIMAX,
    /**
     * a modem supporting analog telephone, CDMA/EVDO,
     * GSM/UMTS, or LTE network access protocols
     */
    MODEM,
    /**
     * an IP-over-InfiniBand device
     */
    INFINIBAND,
    /**
     * a bond master interface
     */
    BOND,
    /**
     * an 802.1Q VLAN interface
     */
    VLAN,
    /**
     * ADSL modem
     */
    ADSL,
    /**
     * a bridge master interface
     */
    BRIDGE,
    /**
     * generic support for unrecognized device types
     */
    GENERIC,
    /**
     * a team master interface
     */
    TEAM,
    /**
     * a TUN or TAP interface
     */
    TUN,
    /**
     * a IP tunnel interface
     */
    IP_TUNNEL,
    /**
     * a MACVLAN interface
     */
    MACVLAN,
    /**
     * a VXLAN interface
     */
    VXLAN,
    /**
     * a VETH interface
     */
    VETH,
    /**
     * a MACsec interface
     */
    MACSEC,
    /**
     * a dummy interface
     */
    DUMMY,
    /**
     * a PPP interface
     */
    PPP,
    /**
     * a Open vSwitch interface
     */
    OVS_INTERFACE,
    /**
     * a Open vSwitch port
     */
    OVS_PORT,
    /**
     * a Open vSwitch bridge
     */
    OVS_BRIDGE,
    /**
     * a IEEE 802.15.4 (WPAN) MAC Layer Device
     */
    WPAN,
    /**
     * 6LoWPAN interface
     */
    TODO_6LOWPAN,
    /**
     * a WireGuard interface
     */
    WIREGUARD,
    /**
     * an 802.11 Wi-Fi P2P device. Since: 1.16.
     */
    WIFI_P2P,
    /**
     * A VRF (Virtual Routing and Forwarding) interface. Since: 1.24.
     */
    VRF,
}
/**
 * The tunneling mode.
 */
enum IPTunnelMode {
    /**
     * Unknown/unset tunnel mode
     */
    UNKNOWN,
    /**
     * IP in IP tunnel
     */
    IPIP,
    /**
     * GRE tunnel
     */
    GRE,
    /**
     * SIT tunnel
     */
    SIT,
    /**
     * ISATAP tunnel
     */
    ISATAP,
    /**
     * VTI tunnel
     */
    VTI,
    /**
     * IPv6 in IPv6 tunnel
     */
    IP6IP6,
    /**
     * IPv4 in IPv6 tunnel
     */
    IPIP6,
    /**
     * IPv6 GRE tunnel
     */
    IP6GRE,
    /**
     * IPv6 VTI tunnel
     */
    VTI6,
    /**
     * GRETAP tunnel
     */
    GRETAP,
    /**
     * IPv6 GRETAP tunnel
     */
    IP6GRETAP,
}
/**
 * The type of the callback for %NMKeyfileReadHandler and %NMKeyfileWriteHandler.
 * Depending on the type, you can interpret %NMKeyfileHandlerData.
 */
enum KeyfileHandlerType {
    /**
     * a warning.
     */
    WARN,
    /**
     * for handling certificates while writing
     *   a connection to keyfile.
     */
    WRITE_CERT,
}
/**
 * The severity level of %NM_KEYFILE_HANDLER_TYPE_WARN events.
 */
enum KeyfileWarnSeverity {
    /**
     * debug message
     */
    DEBUG,
    /**
     * info message
     */
    INFO,
    /**
     * info message about a missing file
     */
    INFO_MISSING_FILE,
    /**
     * a warning message
     */
    WARN,
}
/**
 * Errors related to the main "network management" interface of NetworkManager.
 * These may be returned from #NMClient methods that invoke D-Bus operations on
 * the "org.freedesktop.NetworkManager" interface, and correspond to D-Bus
 * errors in that namespace.
 */
enum ManagerError {
    /**
     * unknown or unclassified error
     */
    FAILED,
    /**
     * Permission denied.
     */
    PERMISSIONDENIED,
    /**
     * The requested connection is not known.
     */
    UNKNOWNCONNECTION,
    /**
     * The requested device is not known.
     */
    UNKNOWNDEVICE,
    /**
     * The requested connection cannot be
     *   activated at this time.
     */
    CONNECTIONNOTAVAILABLE,
    /**
     * The request could not be completed
     *   because a required connection is not active.
     */
    CONNECTIONNOTACTIVE,
    /**
     * The connection to be activated was
     *   already active on another device.
     */
    CONNECTIONALREADYACTIVE,
    /**
     * An activation request failed due to a
     *   dependency being unavailable.
     */
    DEPENDENCYFAILED,
    /**
     * The manager is already in the requested
     *   sleep/wake state.
     */
    ALREADYASLEEPORAWAKE,
    /**
     * The network is already
     *   enabled/disabled.
     */
    ALREADYENABLEDORDISABLED,
    /**
     * Unknown log level in SetLogging
     */
    UNKNOWNLOGLEVEL,
    /**
     * Unknown log domain in SetLogging
     */
    UNKNOWNLOGDOMAIN,
    /**
     * Invalid arguments for D-Bus request
     */
    INVALIDARGUMENTS,
    /**
     * A plug-in was needed to complete the
     *   activation but is not available.
     */
    MISSINGPLUGIN,
}
/**
 * The NMMetered enum has two different purposes: one is to configure
 * "connection.metered" setting of a connection profile in #NMSettingConnection, and
 * the other is to express the actual metered state of the #NMDevice at a given moment.
 * 
 * For the connection profile only #NM_METERED_UNKNOWN, #NM_METERED_NO
 * and #NM_METERED_YES are allowed.
 * 
 * The device's metered state at runtime is determined by the profile
 * which is currently active. If the profile explicitly specifies #NM_METERED_NO
 * or #NM_METERED_YES, then the device's metered state is as such.
 * If the connection profile leaves it undecided at #NM_METERED_UNKNOWN (the default),
 * then NetworkManager tries to guess the metered state, for example based on the
 * device type or on DHCP options (like Android devices exposing a "ANDROID_METERED"
 * DHCP vendor option). This then leads to either #NM_METERED_GUESS_NO or #NM_METERED_GUESS_YES.
 * 
 * Most applications probably should treat the runtime state #NM_METERED_GUESS_YES
 * like #NM_METERED_YES, and all other states as not metered.
 * 
 * Note that the per-device metered states are then combined to a global metered
 * state. This is basically the metered state of the device with the best default
 * route. However, that generalization of a global metered state may not be correct
 * if the default routes for IPv4 and IPv6 are on different devices, or if policy
 * routing is configured. In general, the global metered state tries to express whether
 * the traffic is likely metered, but since that depends on the traffic itself,
 * there is not one answer in all cases. Hence, an application may want to consider
 * the per-device's metered states.
 */
enum Metered {
    /**
     * The metered status is unknown
     */
    UNKNOWN,
    /**
     * Metered, the value was explicitly configured
     */
    YES,
    /**
     * Not metered, the value was explicitly configured
     */
    NO,
    /**
     * Metered, the value was guessed
     */
    GUESS_YES,
    /**
     * Not metered, the value was guessed
     */
    GUESS_NO,
}
/**
 * The result of a checkpoint Rollback() operation for a specific device.
 */
enum RollbackResult {
    /**
     * the rollback succeeded.
     */
    OK,
    /**
     * the device no longer exists.
     */
    ERR_NO_DEVICE,
    /**
     * the device is now unmanaged.
     */
    ERR_DEVICE_UNMANAGED,
    /**
     * other errors during rollback.
     */
    ERR_FAILED,
}
/**
 * #NMSecretAgentError values are passed by secret agents back to NetworkManager
 * when they encounter problems retrieving secrets on behalf of NM. They
 * correspond to errors in the "org.freedesktop.NetworkManager.SecretManager"
 * namespace.
 * 
 * Client APIs such as nm_client_activate_connection() will not see these error
 * codes; instead, the secret agent manager will translate them to the
 * corresponding #NMAgentManagerError codes.
 */
enum SecretAgentError {
    /**
     * unknown or unclassified error
     */
    FAILED,
    /**
     * the caller (ie, NetworkManager) is
     *   not authorized to make this request
     */
    PERMISSIONDENIED,
    /**
     * the connection for which secrets
     *   were requested is invalid
     */
    INVALIDCONNECTION,
    /**
     * the request was canceled by the user
     */
    USERCANCELED,
    /**
     * the agent canceled the request
     *   because it was requested to do so by NetworkManager
     */
    AGENTCANCELED,
    /**
     * the agent cannot find any secrets for this
     *   connection
     */
    NOSECRETS,
}
/**
 * #NMSetting8021xCKFormat values indicate the general type of a certificate
 * or private key
 */
enum Setting8021xCKFormat {
    /**
     * unknown file format
     */
    UNKNOWN,
    /**
     * file contains an X.509 format certificate
     */
    X509,
    /**
     * file contains an old-style OpenSSL PEM
     * or DER private key
     */
    RAW_KEY,
    /**
     * file contains a PKCS#<!-- -->12 certificate
     * and private key
     */
    PKCS12,
}
/**
 * #NMSetting8021xCKScheme values indicate how a certificate or private key is
 * stored in the setting properties, either as a blob of the item's data, or as
 * a path to a certificate or private key file on the filesystem
 */
enum Setting8021xCKScheme {
    /**
     * unknown certificate or private key
     * scheme
     */
    UNKNOWN,
    /**
     * certificate or key is stored as the raw
     * item data
     */
    BLOB,
    /**
     * certificate or key is stored as a path
     * to a file containing the certificate or key data
     */
    PATH,
    /**
     * certificate or key is stored as a
     * URI of an object on a PKCS#11 token
     */
    PKCS11,
}
/**
 * These flags modify the comparison behavior when comparing two settings or
 * two connections.
 */
enum SettingCompareFlags {
    /**
     * match all properties exactly
     */
    EXACT,
    /**
     * match only important attributes, like SSID,
     *   type, security settings, etc.  Does not match, for example, connection ID
     *   or UUID.
     */
    FUZZY,
    /**
     * ignore the connection's ID
     */
    IGNORE_ID,
    /**
     * ignore all secrets
     */
    IGNORE_SECRETS,
    /**
     * ignore secrets for which
     *   the secret's flags indicate the secret is owned by a user secret agent
     *   (ie, the secret's flag includes `NM_SETTING_SECRET_FLAG_AGENT_OWNED)`
     */
    IGNORE_AGENT_OWNED_SECRETS,
    /**
     * ignore secrets for which
     *   the secret's flags indicate the secret should not be saved to persistent
     *   storage (ie, the secret's flag includes `NM_SETTING_SECRET_FLAG_NOT_SAVED)`
     */
    IGNORE_NOT_SAVED_SECRETS,
    /**
     * if this flag is set,
     *   nm_setting_diff() and nm_connection_diff() will also include properties that
     *   are set to their default value. See also `NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT`.
     */
    DIFF_RESULT_WITH_DEFAULT,
    /**
     * if this flag is set,
     *   nm_setting_diff() and nm_connection_diff() will not include properties that
     *   are set to their default value. This is the opposite of
     *   `NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT`. If both flags are set together,
     *   `NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT` wins. If both flags are unset,
     *   this means to exclude default properties if there is a setting to compare,
     *   but include all properties, if the setting 'b' is missing. This is the legacy
     *   behaviour of libnm-util, where nm_setting_diff() behaved differently depending
     *   on whether the setting 'b' was available. If `NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT`
     *   is set, nm_setting_diff() will also set the flags `NM_SETTING_DIFF_RESULT_IN_A_DEFAULT`
     *   and `NM_SETTING_DIFF_RESULT_IN_B_DEFAULT,` if the values are default values.
     */
    DIFF_RESULT_NO_DEFAULT,
    /**
     * ignore the connection's timestamp
     */
    IGNORE_TIMESTAMP,
}
/**
 * #NMSettingConnectionAutoconnectSlaves values indicate whether slave connections
 * should be activated when master is activated.
 */
enum SettingConnectionAutoconnectSlaves {
    /**
     * default value
     */
    DEFAULT,
    /**
     * slaves are not brought up when
     *   master is activated
     */
    NO,
    /**
     * slaves are brought up when
     *   master is activated
     */
    YES,
}
/**
 * #NMSettingConnectionDnsOverTls values indicate whether DNSOverTls should be enabled.
 */
enum SettingConnectionDnsOverTls {
    /**
     * default value
     */
    DEFAULT,
    /**
     * disable DNSOverTls
     */
    NO,
    /**
     * enable opportunistic mode
     */
    OPPORTUNISTIC,
    /**
     * enable strict mode
     */
    YES,
}
/**
 * #NMSettingConnectionLldp values indicate whether LLDP should be enabled.
 */
enum SettingConnectionLldp {
    /**
     * default value
     */
    DEFAULT,
    /**
     * disable LLDP
     */
    DISABLE,
    /**
     * enable reception of LLDP frames
     */
    ENABLE_RX,
}
/**
 * #NMSettingConnectionLlmnr values indicate whether LLMNR should be enabled.
 */
enum SettingConnectionLlmnr {
    /**
     * default value
     */
    DEFAULT,
    /**
     * disable LLMNR
     */
    NO,
    /**
     * support only resolving, do not register hostname
     */
    RESOLVE,
    /**
     * enable LLMNR
     */
    YES,
}
/**
 * #NMSettingConnectionMdns values indicate whether mDNS should be enabled.
 */
enum SettingConnectionMdns {
    /**
     * default value
     */
    DEFAULT,
    /**
     * disable mDNS
     */
    NO,
    /**
     * support only resolving, do not register hostname
     */
    RESOLVE,
    /**
     * enable mDNS
     */
    YES,
}
/**
 * These values indicate the result of a setting difference operation.
 */
enum SettingDiffResult {
    /**
     * unknown result
     */
    UNKNOWN,
    /**
     * the property is present in setting A
     */
    IN_A,
    /**
     * the property is present in setting B
     */
    IN_B,
    /**
     * the property is present in
     * setting A but is set to the default value. This flag is only set,
     * if you specify `NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT`.
     */
    IN_A_DEFAULT,
    /**
     * analog to `NM_SETTING_DIFF_RESULT_IN_A_DEFAULT`.
     */
    IN_B_DEFAULT,
}
/**
 * #NMSettingIP6ConfigAddrGenMode controls how the Interface Identifier for
 * RFC4862 Stateless Address Autoconfiguration is created.
 */
enum SettingIP6ConfigAddrGenMode {
    /**
     * The Interface Identifier is derived
     * from the interface hardware address.
     */
    EUI64,
    /**
     * The Interface Identifier
     * is created by using a cryptographically secure hash of a secret host-specific
     * key along with the connection identification and the network address as
     * specified by RFC7217.
     */
    STABLE_PRIVACY,
}
/**
 * #NMSettingIP6ConfigPrivacy values indicate if and how IPv6 Privacy
 * Extensions are used (RFC4941).
 */
enum SettingIP6ConfigPrivacy {
    /**
     * unknown or no value specified
     */
    UNKNOWN,
    /**
     * IPv6 Privacy Extensions are disabled
     */
    DISABLED,
    /**
     * IPv6 Privacy Extensions
     * are enabled, but public addresses are preferred over temporary addresses
     */
    PREFER_PUBLIC_ADDR,
    /**
     * IPv6 Privacy Extensions
     * are enabled and temporary addresses are preferred over public addresses
     */
    PREFER_TEMP_ADDR,
}
/**
 * Controls if and how the MAC address of a device is randomzied.
 */
enum SettingMacRandomization {
    /**
     * the default value, which unless
     * overridden by user-controlled defaults configuration, is "never".
     */
    DEFAULT,
    /**
     * the device's MAC address is always used.
     */
    NEVER,
    /**
     * a random MAC address is used.
     */
    ALWAYS,
}
/**
 * #NMSettingMacsecMode controls how the CAK (Connectivity Association Key) used
 * in MKA (MACsec Key Agreement) is obtained.
 */
enum SettingMacsecMode {
    /**
     * The CAK is pre-shared
     */
    PSK,
    /**
     * The CAK is the result of participation in EAP
     */
    EAP,
}
/**
 * #NMSettingMacsecValidation specifies a validation mode for incoming frames.
 */
enum SettingMacsecValidation {
    /**
     * All incoming frames are accepted if
     *   possible
     */
    DISABLE,
    /**
     * Non protected, invalid, or impossible to
     *   verify frames are accepted and counted as "invalid"
     */
    CHECK,
    /**
     * Non protected, invalid, or impossible to
     *   verify frames are dropped
     */
    STRICT,
}
enum SettingMacvlanMode {
    /**
     * unknown/unset mode
     */
    UNKNOWN,
    /**
     * Virtual Ethernet Port Aggregator mode
     */
    VEPA,
    /**
     * bridge mode
     */
    BRIDGE,
    /**
     * private mode
     */
    PRIVATE,
    /**
     * passthru mode
     */
    PASSTHRU,
    /**
     * source mode
     */
    SOURCE,
}
/**
 * The Proxy method.
 */
enum SettingProxyMethod {
    /**
     * No Proxy for the Connection
     */
    NONE,
    /**
     * DHCP obtained Proxy/ Manual override
     */
    AUTO,
}
/**
 * The parity setting of a serial port.
 */
enum SettingSerialParity {
    /**
     * No parity bits (default)
     */
    NONE,
    /**
     * Even parity
     */
    EVEN,
    /**
     * Odd parity
     */
    ODD,
}
/**
 * #NMSettingTunMode values indicate the device type (TUN/TAP)
 */
enum SettingTunMode {
    /**
     * an unknown device type
     */
    UNKNOWN,
    /**
     * a TUN device
     */
    TUN,
    /**
     * a TAP device
     */
    TAP,
}
/**
 * These flags indicate whether wireless powersave must be enabled.
 */
enum SettingWirelessPowersave {
    /**
     * use the default value
     */
    DEFAULT,
    /**
     * don't touch existing setting
     */
    IGNORE,
    /**
     * disable powersave
     */
    DISABLE,
    /**
     * enable powersave
     */
    ENABLE,
}
/**
 * These flags indicate whether FILS must be enabled.
 */
enum SettingWirelessSecurityFils {
    /**
     * use the default value
     */
    DEFAULT,
    /**
     * disable FILS
     */
    DISABLE,
    /**
     * enable FILS if the supplicant and the AP support it
     */
    OPTIONAL,
    /**
     * require FILS and fail if not available
     */
    REQUIRED,
}
/**
 * These flags indicate whether PMF must be enabled.
 */
enum SettingWirelessSecurityPmf {
    /**
     * use the default value
     */
    DEFAULT,
    /**
     * disable PMF
     */
    DISABLE,
    /**
     * enable PMF if the supplicant and the AP support it
     */
    OPTIONAL,
    /**
     * require PMF and fail if not available
     */
    REQUIRED,
}
/**
 * Errors related to the settings/persistent configuration interface of
 * NetworkManager.
 * 
 * These may be returned from #NMClient methods that invoke D-Bus operations on
 * the "org.freedesktop.NetworkManager.Settings" interface, and correspond to
 * D-Bus errors in that namespace.
 */
enum SettingsError {
    /**
     * unknown or unclassified error
     */
    FAILED,
    /**
     * permission denied
     */
    PERMISSIONDENIED,
    /**
     * the requested operation is not supported by any
     *   active settings backend
     */
    NOTSUPPORTED,
    /**
     * the connection was invalid
     */
    INVALIDCONNECTION,
    /**
     * attempted to modify a read-only connection
     */
    READONLYCONNECTION,
    /**
     * a connection with that UUID already exists
     */
    UUIDEXISTS,
    /**
     * attempted to set an invalid hostname
     */
    INVALIDHOSTNAME,
    /**
     * invalid arguments
     */
    INVALIDARGUMENTS,
}
/**
 * #NMSriovVFVlanProtocol indicates the VLAN protocol to use.
 */
enum SriovVFVlanProtocol {
    /**
     * use 802.1Q
     */
    TODO_1Q,
    /**
     * use 802.1ad
     */
    TODO_1AD,
}
/**
 * #NMState values indicate the current overall networking state.
 */
enum State {
    /**
     * Networking state is unknown. This indicates a daemon error
     *    that makes it unable to reasonably assess the state. In such event the
     *    applications are expected to assume Internet connectivity might be present
     *    and not disable controls that require network access.
     *    The graphical shells may hide the network accessibility indicator altogether
     *    since no meaningful status indication can be provided.
     */
    UNKNOWN,
    /**
     * Networking is not enabled, the system is being suspended or
     *    resumed from suspend.
     */
    ASLEEP,
    /**
     * There is no active network connection.
     *    The graphical shell should indicate  no network connectivity and the
     *    applications should not attempt to access the network.
     */
    DISCONNECTED,
    /**
     * Network connections are being cleaned up.
     *    The applications should tear down their network sessions.
     */
    DISCONNECTING,
    /**
     * A network connection is being started
     *    The graphical shell should indicate the network is being connected while
     *    the applications should still make no attempts to connect the network.
     */
    CONNECTING,
    /**
     * There is only local IPv4 and/or IPv6 connectivity,
     *    but no default route to access the Internet. The graphical shell should
     *    indicate no network connectivity.
     */
    CONNECTED_LOCAL,
    /**
     * There is only site-wide IPv4 and/or IPv6 connectivity.
     *    This means a default route is available, but the Internet connectivity check
     *    (see "Connectivity" property) did not succeed. The graphical shell should
     *    indicate limited network connectivity.
     */
    CONNECTED_SITE,
    /**
     * There is global IPv4 and/or IPv6 Internet connectivity
     *    This means the Internet connectivity check succeeded, the graphical shell should
     *    indicate full network connectivity.
     */
    CONNECTED_GLOBAL,
}
/**
 * An boolean value that can be overridden by a default.
 */
enum Ternary {
    /**
     * use the globally-configured default value.
     */
    DEFAULT,
    /**
     * the option is disabled.
     */
    FALSE,
    /**
     * the option is enabled.
     */
    TRUE,
}
/**
 * Describes generic security mechanisms that 802.11 access points may offer.
 * Used with nm_utils_security_valid() for checking whether a given access
 * point is compatible with a network device.
 */
enum UtilsSecurityType {
    /**
     * unknown or invalid security, placeholder and not used
     */
    INVALID,
    /**
     * unencrypted and open
     */
    NONE,
    /**
     * static WEP keys are used for encryption
     */
    STATIC_WEP,
    /**
     * Cisco LEAP is used for authentication and for generating the
     * dynamic WEP keys automatically
     */
    LEAP,
    /**
     * standard 802.1x is used for authentication and
     * generating the dynamic WEP keys automatically
     */
    DYNAMIC_WEP,
    /**
     * WPA1 is used with Pre-Shared Keys (PSK)
     */
    WPA_PSK,
    /**
     * WPA1 is used with 802.1x authentication
     */
    WPA_ENTERPRISE,
    /**
     * WPA2/RSN is used with Pre-Shared Keys (PSK)
     */
    WPA2_PSK,
    /**
     * WPA2 is used with 802.1x authentication
     */
    WPA2_ENTERPRISE,
    /**
     * is used with WPA3 Enterprise
     */
    SAE,
    /**
     * is used with Enhanced Open
     */
    OWE,
    /**
     * is used with WPA3 Enterprise Suite-B 192 bit mode. Since: 1.30.
     */
    WPA3_SUITE_B_192,
}
/**
 * A selector for traffic priority maps; these map Linux SKB priorities
 * to 802.1p priorities used in VLANs.
 */
enum VlanPriorityMap {
    /**
     * map for incoming data
     */
    INGRESS_MAP,
    /**
     * map for outgoing data
     */
    EGRESS_MAP,
}
/**
 * VPN connection states
 */
enum VpnConnectionState {
    /**
     * The state of the VPN connection is
     *   unknown.
     */
    UNKNOWN,
    /**
     * The VPN connection is preparing to
     *   connect.
     */
    PREPARE,
    /**
     * The VPN connection needs authorization
     *   credentials.
     */
    NEED_AUTH,
    /**
     * The VPN connection is being established.
     */
    CONNECT,
    /**
     * The VPN connection is getting an IP
     *   address.
     */
    IP_CONFIG_GET,
    /**
     * The VPN connection is active.
     */
    ACTIVATED,
    /**
     * The VPN connection failed.
     */
    FAILED,
    /**
     * The VPN connection is disconnected.
     */
    DISCONNECTED,
}
/**
 * VPN connection state reasons
 */
enum VpnConnectionStateReason {
    /**
     * The reason for the VPN connection
     *   state change is unknown.
     */
    UNKNOWN,
    /**
     * No reason was given for the VPN
     *   connection state change.
     */
    NONE,
    /**
     * The VPN connection changed
     *   state because the user disconnected it.
     */
    USER_DISCONNECTED,
    /**
     * The VPN connection
     *   changed state because the device it was using was disconnected.
     */
    DEVICE_DISCONNECTED,
    /**
     * The service providing the
     *   VPN connection was stopped.
     */
    SERVICE_STOPPED,
    /**
     * The IP config of the VPN
     *   connection was invalid.
     */
    IP_CONFIG_INVALID,
    /**
     * The connection attempt to
     *   the VPN service timed out.
     */
    CONNECT_TIMEOUT,
    /**
     * A timeout occurred
     *   while starting the service providing the VPN connection.
     */
    SERVICE_START_TIMEOUT,
    /**
     * Starting the service
     *   starting the service providing the VPN connection failed.
     */
    SERVICE_START_FAILED,
    /**
     * Necessary secrets for the VPN
     *   connection were not provided.
     */
    NO_SECRETS,
    /**
     * Authentication to the VPN
     *   server failed.
     */
    LOGIN_FAILED,
    /**
     * The connection was
     *   deleted from settings.
     */
    CONNECTION_REMOVED,
}
/**
 * Returned by the VPN service plugin to indicate errors. These codes correspond
 * to errors in the "org.freedesktop.NetworkManager.VPN.Error" namespace.
 */
enum VpnPluginError {
    /**
     * unknown or unclassified error
     */
    FAILED,
    /**
     * the plugin is already starting,
     *   and another connect request was received
     */
    STARTINGINPROGRESS,
    /**
     * the plugin is already connected, and
     *   another connect request was received
     */
    ALREADYSTARTED,
    /**
     * the plugin is already stopping,
     *   and another stop request was received
     */
    STOPPINGINPROGRESS,
    /**
     * the plugin is already stopped, and
     *   another disconnect request was received
     */
    ALREADYSTOPPED,
    /**
     * the operation could not be performed in
     *   this state
     */
    WRONGSTATE,
    /**
     * the operation could not be performed as
     *   the request contained malformed arguments, or arguments of unexpected type.
     *   Usually means that one of the VPN setting data items or secrets was not of
     *   the expected type (ie int, string, bool, etc).
     */
    BADARGUMENTS,
    /**
     * a child process failed to launch
     */
    LAUNCHFAILED,
    /**
     * the operation could not be performed
     *   because the connection was invalid.  Usually means that the connection's
     *   VPN setting was missing some required data item or secret.
     */
    INVALIDCONNECTION,
    /**
     * the operation could not be
     *   performed as the plugin does not support interactive operations, such as
     *   ConnectInteractive() or NewSecrets()
     */
    INTERACTIVENOTSUPPORTED,
}
/**
 * VPN plugin failure reasons
 */
enum VpnPluginFailure {
    /**
     * Login failed.
     */
    LOGIN_FAILED,
    /**
     * Connect failed.
     */
    CONNECT_FAILED,
    /**
     * Invalid IP configuration returned from
     *   the VPN plugin.
     */
    BAD_IP_CONFIG,
}
/**
 * VPN daemon states
 */
enum VpnServiceState {
    /**
     * The state of the VPN plugin is unknown.
     */
    UNKNOWN,
    /**
     * The VPN plugin is initialized.
     */
    INIT,
    /**
     * Not used.
     */
    SHUTDOWN,
    /**
     * The plugin is attempting to connect to a VPN server.
     */
    STARTING,
    /**
     * The plugin has connected to a VPN server.
     */
    STARTED,
    /**
     * The plugin is disconnecting from the VPN server.
     */
    STOPPING,
    /**
     * The plugin has disconnected from the VPN server.
     */
    STOPPED,
}
/**
 * The #NMWepKeyType values specify how any WEP keys present in the setting
 * are interpreted.  There are no standards governing how to hash the various WEP
 * key/passphrase formats into the actual WEP key.  Unfortunately some WEP keys
 * can be interpreted in multiple ways, requiring the setting to specify how to
 * interpret the any WEP keys.  For example, the key "732f2d712e4a394a375d366931"
 * is both a valid Hexadecimal WEP key and a WEP passphrase.  Further, many
 * ASCII keys are also valid WEP passphrases, but since passphrases and ASCII
 * keys are hashed differently to determine the actual WEP key the type must be
 * specified.
 */
enum WepKeyType {
    /**
     * unknown WEP key type
     */
    UNKNOWN,
    /**
     * indicates a hexadecimal or ASCII formatted WEP key.
     * Hex keys are either 10 or 26 hexadecimal characters (ie "5f782f2f5f" or
     * "732f2d712e4a394a375d366931"), while ASCII keys are either 5 or 13 ASCII
     * characters (ie "abcde" or "blahblah99$*1").
     */
    KEY,
    /**
     * indicates a WEP passphrase (ex "I bought a duck
     * on my way back from the market 235Q&^%^*%") instead of a hexadecimal or ASCII
     * key.  Passphrases are between 8 and 64 characters inclusive and are hashed
     * the actual WEP key using the MD5 hash algorithm.
     */
    PASSPHRASE,
}
/**
 * WiMAX network type.
 */
enum WimaxNspNetworkType {
    /**
     * unknown network type
     */
    UNKNOWN,
    /**
     * home network
     */
    HOME,
    /**
     * partner network
     */
    PARTNER,
    /**
     * roaming partner network
     */
    ROAMING_PARTNER,
}
/**
 * 802.11 access point flags.
 */
enum TODO_80211ApFlags {
    /**
     * access point has no special capabilities
     */
    NONE,
    /**
     * access point requires authentication and
     * encryption (usually means WEP)
     */
    PRIVACY,
    /**
     * access point supports some WPS method
     */
    WPS,
    /**
     * access point supports push-button WPS
     */
    WPS_PBC,
    /**
     * access point supports PIN-based WPS
     */
    WPS_PIN,
}
/**
 * 802.11 access point security and authentication flags.  These flags describe
 * the current security requirements of an access point as determined from the
 * access point's beacon.
 */
enum TODO_80211ApSecurityFlags {
    /**
     * the access point has no special security requirements
     */
    NONE,
    /**
     * 40/64-bit WEP is supported for
     * pairwise/unicast encryption
     */
    PAIR_WEP40,
    /**
     * 104/128-bit WEP is supported for
     * pairwise/unicast encryption
     */
    PAIR_WEP104,
    /**
     * TKIP is supported for pairwise/unicast encryption
     */
    PAIR_TKIP,
    /**
     * AES/CCMP is supported for pairwise/unicast encryption
     */
    PAIR_CCMP,
    /**
     * 40/64-bit WEP is supported for group/broadcast
     * encryption
     */
    GROUP_WEP40,
    /**
     * 104/128-bit WEP is supported for
     * group/broadcast encryption
     */
    GROUP_WEP104,
    /**
     * TKIP is supported for group/broadcast encryption
     */
    GROUP_TKIP,
    /**
     * AES/CCMP is supported for group/broadcast
     * encryption
     */
    GROUP_CCMP,
    /**
     * WPA/RSN Pre-Shared Key encryption is
     * supported
     */
    KEY_MGMT_PSK,
    /**
     * 802.1x authentication and key management
     * is supported
     */
    KEY_MGMT_802_1X,
    /**
     * WPA/RSN Simultaneous Authentication of Equals is
     * supported
     */
    KEY_MGMT_SAE,
    /**
     * WPA/RSN Opportunistic Wireless Encryption is
     * supported
     */
    KEY_MGMT_OWE,
    /**
     * WPA/RSN Opportunistic Wireless Encryption
     * transition mode is supported. Since: 1.26.
     */
    KEY_MGMT_OWE_TM,
    /**
     * WPA3 Enterprise Suite-B 192 bit mode
     * is supported. Since: 1.30.
     */
    KEY_MGMT_EAP_SUITE_B_192,
}
/**
 * Flags describing the current activation state.
 */
enum ActivationStateFlags {
    /**
     * an alias for numeric zero, no flags set.
     */
    NONE,
    /**
     * the device is a master.
     */
    IS_MASTER,
    /**
     * the device is a slave.
     */
    IS_SLAVE,
    /**
     * layer2 is activated and ready.
     */
    LAYER2_READY,
    /**
     * IPv4 setting is completed.
     */
    IP4_READY,
    /**
     * IPv6 setting is completed.
     */
    IP6_READY,
    /**
     * The master has any slave devices attached.
     *   This only makes sense if the device is a master.
     */
    MASTER_HAS_SLAVES,
    /**
     * the lifetime
     *   of the activation is bound to the visibility of the connection profile,
     *   which in turn depends on "connection.permissions" and whether a session
     *   for the user exists. Since: 1.16.
     */
    LIFETIME_BOUND_TO_PROFILE_VISIBILITY,
    /**
     * the active connection was generated to
     *  represent an external configuration of a networking device. Since: 1.26.
     */
    EXTERNAL,
}
/**
 * #NMBluetoothCapabilities values indicate the usable capabilities of a
 * Bluetooth device.
 */
enum BluetoothCapabilities {
    /**
     * device has no usable capabilities
     */
    NONE,
    /**
     * device provides Dial-Up Networking capability
     */
    DUN,
    /**
     * device provides Network Access Point capability
     */
    NAP,
}
/**
 * The flags for CheckpointCreate call
 */
enum CheckpointCreateFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * when creating
     *   a new checkpoint, destroy all existing ones.
     */
    DESTROY_ALL,
    /**
     * upon rollback,
     *   delete any new connection added after the checkpoint. Since: 1.6.
     */
    DELETE_NEW_CONNECTIONS,
    /**
     * upon rollback,
     *   disconnect any new device appeared after the checkpoint. Since: 1.6.
     */
    DISCONNECT_NEW_DEVICES,
    /**
     * by default, creating
     *   a checkpoint fails if there are already existing checkoints that
     *   reference the same devices. With this flag, creation of such
     *   checkpoints is allowed, however, if an older checkpoint
     *   that references overlapping devices gets rolled back, it will
     *   automatically destroy this checkpoint during rollback. This
     *   allows to create several overlapping checkpoints in parallel,
     *   and rollback to them at will. With the special case that
     *   rolling back to an older checkpoint will invalidate all
     *   overlapping younger checkpoints. This opts-in that the
     *   checkpoint can be automatically destroyed by the rollback
     *   of an older checkpoint. Since: 1.12.
     */
    ALLOW_OVERLAPPING,
    /**
     * during rollback,
     *   by default externally added ports attached to bridge devices are preserved.
     *   With this flag, the rollback detaches all external ports.
     *   This only has an effect for bridge ports. Before 1.38, this was the default
     *   behavior. Since: 1.38.
     */
    NO_PRESERVE_EXTERNAL_PORTS,
}
enum ClientInstanceFlags {
    /**
     * special value to indicate no flags.
     */
    NONE,
    /**
     * by default, NMClient
     *   will fetch the permissions via "GetPermissions" and refetch them when
     *   "CheckPermissions" signal gets received. By setting this flag, this behavior
     *   can be disabled. You can toggle this flag to enable and disable automatic
     *   fetching of the permissions. Watch also nm_client_get_permissions_state()
     *   to know whether the permissions are up to date.
     */
    NO_AUTO_FETCH_PERMISSIONS,
}
/**
 * These flags determine which properties are serialized when calling
 * nm_connection_to_dbus().
 */
enum ConnectionSerializationFlags {
    /**
     * serialize all properties (including secrets)
     */
    ALL,
    /**
     * serialize properties that are
     *   not secrets. Since 1.32.
     */
    WITH_NON_SECRET,
    /**
     * this is a deprecated alias for
     *   `NM_CONNECTION_SERIALIZE_WITH_NON_SECRET`.
     */
    NO_SECRETS,
    /**
     * serialize all secrets. This flag is
     *   ignored if any of `NM_CONNECTION_SERIALIZE_WITH_SECRETS_AGENT_OWNED,`
     *   `NM_CONNECTION_SERIALIZE_WITH_SECRETS_SYSTEM_OWNED` or
     *   `NM_CONNECTION_SERIALIZE_WITH_SECRETS_NOT_SAVED` is set. Since 1.32.
     */
    WITH_SECRETS,
    /**
     * a deprecated alias for
     *   `NM_CONNECTION_SERIALIZE_WITH_SECRETS`.
     */
    ONLY_SECRETS,
    /**
     * serialize agent-owned
     *   secrets. Since: 1.20.
     */
    WITH_SECRETS_AGENT_OWNED,
    /**
     * serialize system-owned
     *   secrets. Since: 1.32.
     */
    WITH_SECRETS_SYSTEM_OWNED,
    /**
     * serialize secrets that
     *   are marked as never saved. Since: 1.32.
     */
    WITH_SECRETS_NOT_SAVED,
}
/**
 * General device capability flags.
 */
enum DeviceCapabilities {
    /**
     * device has no special capabilities
     */
    NONE,
    /**
     * NetworkManager supports this device
     */
    NM_SUPPORTED,
    /**
     * this device can indicate carrier status
     */
    CARRIER_DETECT,
    /**
     * this device is a software device
     */
    IS_SOFTWARE,
    /**
     * this device supports single-root I/O virtualization
     */
    SRIOV,
}
/**
 * Flags for a network interface.
 */
enum DeviceInterfaceFlags {
    /**
     * the interface is enabled from the
     *   administrative point of view. Corresponds to kernel IFF_UP.
     */
    UP,
    /**
     * the physical link is up. Corresponds
     *   to kernel IFF_LOWER_UP.
     */
    LOWER_UP,
    /**
     * receive all packets. Corresponds to
     *   kernel IFF_PROMISC. Since: 1.32.
     */
    PROMISC,
    /**
     * the interface has carrier. In most
     *   cases this is equal to the value of `NM_DEVICE_INTERFACE_FLAG_LOWER_UP`.
     *   However some devices have a non-standard carrier detection mechanism.
     */
    CARRIER,
    /**
     * the flag to indicate device
     *   LLDP status. Since: 1.32.
     */
    LLDP_CLIENT_ENABLED,
}
/**
 * #NMDeviceModemCapabilities values indicate the generic radio access
 * technology families a modem device supports.  For more information on the
 * specific access technologies the device supports use the ModemManager D-Bus
 * API.
 */
enum DeviceModemCapabilities {
    /**
     * modem has no usable capabilities
     */
    NONE,
    /**
     * modem uses the analog wired telephone
     * network and is not a wireless/cellular device
     */
    POTS,
    /**
     * modem supports at least one of CDMA
     * 1xRTT, EVDO revision 0, EVDO revision A, or EVDO revision B
     */
    CDMA_EVDO,
    /**
     * modem supports at least one of GSM,
     * GPRS, EDGE, UMTS, HSDPA, HSUPA, or HSPA+ packet switched data capability
     */
    GSM_UMTS,
    /**
     * modem has LTE data capability
     */
    LTE,
    /**
     * modem has 5GNR data capability (Since: 1.36)
     */
    TODO_5GNR,
}
/**
 * 802.11 specific device encryption and authentication capabilities.
 */
enum DeviceWifiCapabilities {
    /**
     * device has no encryption/authentication capabilities
     */
    NONE,
    /**
     * device supports 40/64-bit WEP encryption
     */
    CIPHER_WEP40,
    /**
     * device supports 104/128-bit WEP encryption
     */
    CIPHER_WEP104,
    /**
     * device supports TKIP encryption
     */
    CIPHER_TKIP,
    /**
     * device supports AES/CCMP encryption
     */
    CIPHER_CCMP,
    /**
     * device supports WPA1 authentication
     */
    WPA,
    /**
     * device supports WPA2/RSN authentication
     */
    RSN,
    /**
     * device supports Access Point mode
     */
    AP,
    /**
     * device supports Ad-Hoc mode
     */
    ADHOC,
    /**
     * device reports frequency capabilities
     */
    FREQ_VALID,
    /**
     * device supports 2.4GHz frequencies
     */
    FREQ_2GHZ,
    /**
     * device supports 5GHz frequencies
     */
    FREQ_5GHZ,
    /**
     * device supports acting as a mesh point. Since: 1.20.
     */
    MESH,
    /**
     * device supports WPA2/RSN in an IBSS network. Since: 1.22.
     */
    IBSS_RSN,
}
/**
 * #NMDhcpHostnameFlags describe flags related to the DHCP hostname and
 * FQDN.
 */
enum DhcpHostnameFlags {
    /**
     * no flag set. The default value from
     *   Networkmanager global configuration is used. If such value is unset
     *   or still zero, the DHCP request will use standard FQDN flags, i.e.
     *   %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE and
     *   %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED for IPv4 and
     *   %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE for IPv6.
     */
    NONE,
    /**
     * whether the server should
     *   do the A RR (FQDN-to-address) DNS updates.
     */
    FQDN_SERV_UPDATE,
    /**
     * if set, the FQDN is encoded
     *   using canonical wire format. Otherwise it uses the deprecated
     *   ASCII encoding. This flag is allowed only for DHCPv4.
     */
    FQDN_ENCODED,
    /**
     * when not set, request the
     *   server to perform updates (the PTR RR and possibly the A RR
     *   based on the %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE flag). If
     *   this is set, the %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE flag
     *   should be cleared.
     */
    FQDN_NO_UPDATE,
    /**
     * when set, no FQDN flags are
     *   sent in the DHCP FQDN option. When cleared and all other FQDN
     *   flags are zero, standard FQDN flags are sent. This flag is
     *   incompatible with any other FQDN flag.
     */
    FQDN_CLEAR_FLAGS,
}
/**
 * Compare flags for nm_ip_address_cmp_full().
 */
enum IPAddressCmpFlags {
    /**
     * no flags.
     */
    NONE,
    /**
     * when comparing two addresses,
     *   also consider their attributes. Warning: note that attributes are GVariants
     *   and they don't have a total order. In other words, if the address differs only
     *   by their attributes, the returned compare order is not total. In that case,
     *   the return value merely indicates equality (zero) or inequality.
     */
    WITH_ATTRS,
}
enum IPRoutingRuleAsStringFlags {
    /**
     * no flags selected.
     */
    NONE,
    /**
     * whether to allow parsing
     *   IPv4 addresses.
     */
    AF_INET,
    /**
     * whether to allow parsing
     *   IPv6 addresses. If both `NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET` and
     *   `NM_IP_ROUTING_RULE_AS_STRING_FLAGS_AF_INET6` are unset, it's the same
     *   as setting them both.
     */
    AF_INET6,
    /**
     * if set, ensure that the
     *   rule verfies or fail.
     */
    VALIDATE,
}
enum IPTunnelFlags {
    NONE,
    IP6_IGN_ENCAP_LIMIT,
    IP6_USE_ORIG_TCLASS,
    IP6_USE_ORIG_FLOWLABEL,
    IP6_MIP6_DEV,
    IP6_RCV_DSCP_COPY,
    IP6_USE_ORIG_FWMARK,
}
/**
 * Flags for customizing nm_keyfile_read() and nm_keyfile_write().
 * 
 * Currently no flags are implemented.
 */
enum KeyfileHandlerFlags {
    /**
     * no flags set.
     */
    NONE,
}
/**
 * Flags for the manager Reload() call.
 */
enum ManagerReloadFlags {
    /**
     * reload the NetworkManager.conf configuration
     *   from disk. Note that this does not include connections, which can be
     *   reloaded via Setting's ReloadConnections().
     */
    CONF,
    /**
     * update DNS configuration, which usually
     *   involves writing /etc/resolv.conf anew.
     */
    DNS_RC,
    /**
     * means to restart the DNS plugin. This
     *   is for example useful when using dnsmasq plugin, which uses additional
     *   configuration in /etc/NetworkManager/dnsmasq.d. If you edit those files,
     *   you can restart the DNS plugin. This action shortly interrupts name
     *   resolution.
     */
    DNS_FULL,
}
/**
 * #NMSecretAgentCapabilities indicate various capabilities of the agent.
 */
enum SecretAgentCapabilities {
    /**
     * the agent supports no special capabilities
     */
    NONE,
    /**
     * the agent supports passing hints to
     * VPN plugin authentication dialogs.
     */
    VPN_HINTS,
    /**
     * bounds checking value; should not be used.
     */
    LAST,
}
/**
 * #NMSecretAgentGetSecretsFlags values modify the behavior of a GetSecrets request.
 */
enum SecretAgentGetSecretsFlags {
    /**
     * no special behavior; by default no
     *   user interaction is allowed and requests for secrets are fulfilled from
     *   persistent storage, or if no secrets are available an error is returned.
     */
    NONE,
    /**
     * allows the request to
     *   interact with the user, possibly prompting via UI for secrets if any are
     *   required, or if none are found in persistent storage.
     */
    ALLOW_INTERACTION,
    /**
     * explicitly prompt for new
     *   secrets from the user.  This flag signals that NetworkManager thinks any
     *   existing secrets are invalid or wrong.  This flag implies that interaction
     *   is allowed.
     */
    REQUEST_NEW,
    /**
     * set if the request was
     *   initiated by user-requested action via the D-Bus interface, as opposed to
     *   automatically initiated by NetworkManager in response to (for example) scan
     *   results or carrier changes.
     */
    USER_REQUESTED,
    /**
     * indicates that WPS enrollment
     *   is active with PBC method. The agent may suggest that the user pushes a button
     *   on the router instead of supplying a PSK.
     */
    WPS_PBC_ACTIVE,
    /**
     * Internal flag, not part of
     *   the D-Bus API.
     */
    ONLY_SYSTEM,
    /**
     * Internal flag, not part of
     *   the D-Bus API.
     */
    NO_ERRORS,
}
/**
 * #NMSetting8021xAuthFlags values indicate which authentication settings
 * should be used.
 * 
 * Before 1.22, this was wrongly marked as a enum and not as a flags
 * type.
 */
enum Setting8021xAuthFlags {
    /**
     * No flags
     */
    NONE,
    /**
     * Disable TLSv1.0
     */
    TLS_1_0_DISABLE,
    /**
     * Disable TLSv1.1
     */
    TLS_1_1_DISABLE,
    /**
     * Disable TLSv1.2
     */
    TLS_1_2_DISABLE,
    /**
     * All supported flags
     */
    ALL,
}
/**
 * DCB feature flags.
 */
enum SettingDcbFlags {
    /**
     * no flag
     */
    NONE,
    /**
     * the feature is enabled
     */
    ENABLE,
    /**
     * the feature is advertised
     */
    ADVERTISE,
    /**
     * the feature is willing to change based on
     * peer configuration advertisements
     */
    WILLING,
}
/**
 * These flags indicate specific behavior related to handling of a secret.  Each
 * secret has a corresponding set of these flags which indicate how the secret
 * is to be stored and/or requested when it is needed.
 */
enum SettingSecretFlags {
    /**
     * the system is responsible for providing and
     * storing this secret (default)
     */
    NONE,
    /**
     * a user secret agent is responsible
     * for providing and storing this secret; when it is required agents will be
     * asked to retrieve it
     */
    AGENT_OWNED,
    /**
     * this secret should not be saved, but
     * should be requested from the user each time it is needed
     */
    NOT_SAVED,
    /**
     * in situations where it cannot be
     * automatically determined that the secret is required (some VPNs and PPP
     * providers don't require all secrets) this flag indicates that the specific
     * secret is not required
     */
    NOT_REQUIRED,
}
/**
 * Options for #NMSettingWired:wake-on-lan. Note that not all options
 * are supported by all devices.
 */
enum SettingWiredWakeOnLan {
    /**
     * Wake on PHY activity
     */
    PHY,
    /**
     * Wake on unicast messages
     */
    UNICAST,
    /**
     * Wake on multicast messages
     */
    MULTICAST,
    /**
     * Wake on broadcast messages
     */
    BROADCAST,
    /**
     * Wake on ARP
     */
    ARP,
    /**
     * Wake on magic packet
     */
    MAGIC,
    /**
     * Use the default value
     */
    DEFAULT,
    /**
     * Don't change configured settings
     */
    IGNORE,
}
/**
 * Configure the use of WPS by a connection while it activates.
 * 
 * Note: prior to 1.16, this was a GEnum type instead of a GFlags type
 * although, with the same numeric values.
 */
enum SettingWirelessSecurityWpsMethod {
    /**
     * Attempt whichever method AP supports
     */
    DEFAULT,
    /**
     * WPS can not be used.
     */
    DISABLED,
    /**
     * Use WPS, any method
     */
    AUTO,
    /**
     * use WPS push-button method
     */
    PBC,
    /**
     * use PIN method
     */
    PIN,
}
/**
 * Options for #NMSettingWireless:wake-on-wlan. Note that not all options
 * are supported by all devices.
 */
enum SettingWirelessWakeOnWLan {
    /**
     * Wake on any activity
     */
    ANY,
    /**
     * Wake on disconnect
     */
    DISCONNECT,
    /**
     * Wake on magic packet
     */
    MAGIC,
    /**
     * Wake on GTK rekey failure
     */
    GTK_REKEY_FAILURE,
    /**
     * Wake on EAP identity request
     */
    EAP_IDENTITY_REQUEST,
    /**
     * Wake on 4way handshake
     */
    TODO_4WAY_HANDSHAKE,
    /**
     * Wake on rfkill release
     */
    RFKILL_RELEASE,
    TCP,
    /**
     * Wake on all events. This does not
     *   include the exclusive flags `NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT` or
     *   `NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE`.
     */
    ALL,
    /**
     * Use the default value
     */
    DEFAULT,
    /**
     * Don't change configured settings
     */
    IGNORE,
}
/**
 * Numeric flags for the "flags" argument of AddConnection2() D-Bus API.
 */
enum SettingsAddConnection2Flags {
    /**
     * an alias for numeric zero, no flags set.
     */
    NONE,
    /**
     * to persist the connection to disk.
     */
    TO_DISK,
    /**
     * to make the connection in-memory only.
     */
    IN_MEMORY,
    /**
     * usually, when the connection
     *   has autoconnect enabled and gets added, it becomes eligible to autoconnect
     *   right away. Setting this flag, disables autoconnect until the connection
     *   is manually activated.
     */
    BLOCK_AUTOCONNECT,
}
/**
 * Flags describing the current activation state.
 */
enum SettingsConnectionFlags {
    /**
     * an alias for numeric zero, no flags set.
     */
    NONE,
    /**
     * the connection is not saved to disk.
     *   That either means, that the connection is in-memory only and currently
     *   is not backed by a file. Or, that the connection is backed by a file,
     *   but has modifications in-memory that were not persisted to disk.
     */
    UNSAVED,
    /**
     * A connection is "nm-generated" if
     *  it was generated by NetworkManger. If the connection gets modified or saved
     *  by the user, the flag gets cleared. A nm-generated is also unsaved
     *  and has no backing file as it is in-memory only.
     */
    NM_GENERATED,
    /**
     * The connection will be deleted
     *  when it disconnects. That is for in-memory connections (unsaved), which are
     *  currently active but deleted on disconnect. Volatile connections are
     *  always unsaved, but they are also no backing file on disk and are entirely
     *  in-memory only.
     */
    VOLATILE,
    /**
     * the profile was generated to represent
     *  an external configuration of a networking device. Since: 1.26.
     */
    EXTERNAL,
}
enum SettingsUpdate2Flags {
    /**
     * an alias for numeric zero, no flags set.
     */
    NONE,
    /**
     * to persist the connection to disk.
     */
    TO_DISK,
    /**
     * makes the profile in-memory.
     *   Note that such profiles are stored in keyfile format under /run.
     *   If the file is already in-memory, the file in /run is updated in-place.
     *   Otherwise, the previous storage for the profile is left unchanged
     *   on disk, and the in-memory copy shadows it.
     *   Note that the original filename of the previous persistent storage (if any)
     *   is remembered. That means, when later persisting the profile again to disk,
     *   the file on disk will be overwritten again.
     *   Likewise, when finally deleting the profile, both the storage from /run
     *   and persistent storage are deleted (or if the persistent storage does not
     *   allow deletion, and nmmeta file is written to mark the UUID as deleted).
     */
    IN_MEMORY,
    /**
     * this is almost the same
     *   as %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY, with one difference: when later deleting
     *   the profile, the original profile will not be deleted. Instead a nmmeta
     *   file is written to /run to indicate that the profile is gone.
     *   Note that if such a nmmeta tombstone file exists and hides a file in persistent
     *   storage, then when re-adding the profile with the same UUID, then the original
     *   storage is taken over again.
     */
    IN_MEMORY_DETACHED,
    /**
     * this is like %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY,
     *   but if the connection has a corresponding file on persistent storage, the file
     *   will be deleted right away. If the profile is later again persisted to disk,
     *   a new, unused filename will be chosen.
     */
    IN_MEMORY_ONLY,
    /**
     * This can be specified with either
     *   %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY, %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED
     *   or %NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY.
     *   After making the connection in-memory only, the connection is marked
     *   as volatile. That means, if the connection is currently not active
     *   it will be deleted right away. Otherwise, it is marked to for deletion
     *   once the connection deactivates. A volatile connection cannot autoactivate
     *   again (because it's about to be deleted), but a manual activation will
     *   clear the volatile flag.
     */
    VOLATILE,
    /**
     * usually, when the connection
     *   has autoconnect enabled and is modified, it becomes eligible to autoconnect
     *   right away. Setting this flag, disables autoconnect until the connection
     *   is manually activated.
     */
    BLOCK_AUTOCONNECT,
    /**
     * when a profile gets modified that is
     *   currently active, then these changes don't take effect for the active
     *   device unless the profile gets reactivated or the configuration reapplied.
     *   There are two exceptions: by default "connection.zone" and "connection.metered"
     *   properties take effect immediately. Specify this flag to prevent these
     *   properties to take effect, so that the change is restricted to modify
     *   the profile. Since: 1.20.
     */
    NO_REAPPLY,
}
enum TeamLinkWatcherArpPingFlags {
    /**
     * the arp_ping link watcher
     *    option 'validate_active' is enabled (set to true).
     */
    VALIDATE_ACTIVE,
    /**
     * the arp_ping link watcher
     *    option 'validate_inactive' is enabled (set to true).
     */
    VALIDATE_INACTIVE,
    /**
     * the arp_ping link watcher option
     *    'send_always' is enabled (set to true).
     */
    SEND_ALWAYS,
}
/**
 * #NMVlanFlags values control the behavior of the VLAN interface.
 */
enum VlanFlags {
    /**
     * indicates that this interface should reorder
     *  outgoing packet headers to look more like a non-VLAN Ethernet interface
     */
    REORDER_HEADERS,
    /**
     * indicates that this interface should use GVRP to register
     *  itself with its switch
     */
    GVRP,
    /**
     * indicates that this interface's operating
     *  state is tied to the underlying network interface but other details
     *  (like routing) are not.
     */
    LOOSE_BINDING,
    /**
     * indicates that this interface should use MVRP to register
     *  itself with its switch
     */
    MVRP,
}
/**
 * Flags that indicate certain capabilities of the plugin to editor programs.
 */
enum VpnEditorPluginCapability {
    /**
     * unknown or no capability
     */
    NONE,
    /**
     * the plugin can import new connections
     */
    IMPORT,
    /**
     * the plugin can export connections
     */
    EXPORT,
    /**
     * the plugin supports IPv6 addressing
     */
    IPV6,
}
const ACCESS_POINT_BSSID: string
const ACCESS_POINT_FLAGS: string
const ACCESS_POINT_FREQUENCY: string
const ACCESS_POINT_HW_ADDRESS: string
const ACCESS_POINT_LAST_SEEN: string
const ACCESS_POINT_MAX_BITRATE: string
const ACCESS_POINT_MODE: string
const ACCESS_POINT_RSN_FLAGS: string
const ACCESS_POINT_SSID: string
const ACCESS_POINT_STRENGTH: string
const ACCESS_POINT_WPA_FLAGS: string
const ACTIVE_CONNECTION_CONNECTION: string
const ACTIVE_CONNECTION_DEFAULT: string
const ACTIVE_CONNECTION_DEFAULT6: string
const ACTIVE_CONNECTION_DEVICES: string
const ACTIVE_CONNECTION_DHCP4_CONFIG: string
const ACTIVE_CONNECTION_DHCP6_CONFIG: string
const ACTIVE_CONNECTION_ID: string
const ACTIVE_CONNECTION_IP4_CONFIG: string
const ACTIVE_CONNECTION_IP6_CONFIG: string
const ACTIVE_CONNECTION_MASTER: string
const ACTIVE_CONNECTION_SPECIFIC_OBJECT_PATH: string
const ACTIVE_CONNECTION_STATE: string
const ACTIVE_CONNECTION_STATE_FLAGS: string
const ACTIVE_CONNECTION_TYPE: string
const ACTIVE_CONNECTION_UUID: string
const ACTIVE_CONNECTION_VPN: string
const BRIDGE_VLAN_VID_MAX: number
const BRIDGE_VLAN_VID_MIN: number
const CHECKPOINT_CREATED: string
const CHECKPOINT_DEVICES: string
const CHECKPOINT_ROLLBACK_TIMEOUT: string
const CLIENT_ACTIVATING_CONNECTION: string
const CLIENT_ACTIVE_CONNECTIONS: string
const CLIENT_ACTIVE_CONNECTION_ADDED: string
const CLIENT_ACTIVE_CONNECTION_REMOVED: string
const CLIENT_ALL_DEVICES: string
const CLIENT_ANY_DEVICE_ADDED: string
const CLIENT_ANY_DEVICE_REMOVED: string
const CLIENT_CAN_MODIFY: string
const CLIENT_CAPABILITIES: string
const CLIENT_CHECKPOINTS: string
const CLIENT_CONNECTIONS: string
const CLIENT_CONNECTION_ADDED: string
const CLIENT_CONNECTION_REMOVED: string
const CLIENT_CONNECTIVITY: string
const CLIENT_CONNECTIVITY_CHECK_AVAILABLE: string
const CLIENT_CONNECTIVITY_CHECK_ENABLED: string
const CLIENT_CONNECTIVITY_CHECK_URI: string
const CLIENT_DBUS_CONNECTION: string
const CLIENT_DBUS_NAME_OWNER: string
const CLIENT_DEVICES: string
const CLIENT_DEVICE_ADDED: string
const CLIENT_DEVICE_REMOVED: string
const CLIENT_DNS_CONFIGURATION: string
const CLIENT_DNS_MODE: string
const CLIENT_DNS_RC_MANAGER: string
const CLIENT_HOSTNAME: string
const CLIENT_INSTANCE_FLAGS: string
const CLIENT_METERED: string
const CLIENT_NETWORKING_ENABLED: string
const CLIENT_NM_RUNNING: string
const CLIENT_PERMISSIONS_STATE: string
const CLIENT_PERMISSION_CHANGED: string
const CLIENT_PRIMARY_CONNECTION: string
const CLIENT_STARTUP: string
const CLIENT_STATE: string
const CLIENT_VERSION: string
const CLIENT_WIMAX_ENABLED: string
const CLIENT_WIMAX_HARDWARE_ENABLED: string
const CLIENT_WIRELESS_ENABLED: string
const CLIENT_WIRELESS_HARDWARE_ENABLED: string
const CLIENT_WWAN_ENABLED: string
const CLIENT_WWAN_HARDWARE_ENABLED: string
const CONNECTION_CHANGED: string
const CONNECTION_NORMALIZE_PARAM_IP4_CONFIG_METHOD: string
const CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD: string
const CONNECTION_SECRETS_CLEARED: string
const CONNECTION_SECRETS_UPDATED: string
const DBUS_INTERFACE: string
const DBUS_INTERFACE_DNS_MANAGER: string
const DBUS_INTERFACE_SETTINGS: string
const DBUS_INTERFACE_SETTINGS_CONNECTION: string
const DBUS_INTERFACE_SETTINGS_CONNECTION_SECRETS: string
const DBUS_INTERFACE_VPN: string
const DBUS_INTERFACE_VPN_CONNECTION: string
const DBUS_INVALID_VPN_CONNECTION: string
const DBUS_NO_ACTIVE_VPN_CONNECTION: string
const DBUS_NO_VPN_CONNECTIONS: string
const DBUS_PATH: string
const DBUS_PATH_AGENT_MANAGER: string
const DBUS_PATH_DNS_MANAGER: string
const DBUS_PATH_SECRET_AGENT: string
const DBUS_PATH_SETTINGS: string
const DBUS_PATH_SETTINGS_CONNECTION: string
const DBUS_PATH_VPN: string
const DBUS_PATH_VPN_CONNECTION: string
const DBUS_SERVICE: string
const DBUS_VPN_ALREADY_STARTED: string
const DBUS_VPN_ALREADY_STOPPED: string
const DBUS_VPN_BAD_ARGUMENTS: string
const DBUS_VPN_ERROR_PREFIX: string
const DBUS_VPN_INTERACTIVE_NOT_SUPPORTED: string
const DBUS_VPN_SIGNAL_CONNECT_FAILED: string
const DBUS_VPN_SIGNAL_IP4_CONFIG: string
const DBUS_VPN_SIGNAL_IP_CONFIG_BAD: string
const DBUS_VPN_SIGNAL_LAUNCH_FAILED: string
const DBUS_VPN_SIGNAL_LOGIN_BANNER: string
const DBUS_VPN_SIGNAL_LOGIN_FAILED: string
const DBUS_VPN_SIGNAL_STATE_CHANGE: string
const DBUS_VPN_SIGNAL_VPN_CONFIG_BAD: string
const DBUS_VPN_STARTING_IN_PROGRESS: string
const DBUS_VPN_STOPPING_IN_PROGRESS: string
const DBUS_VPN_WRONG_STATE: string
const DEVICE_6LOWPAN_HW_ADDRESS: string
const DEVICE_6LOWPAN_PARENT: string
const DEVICE_ACTIVE_CONNECTION: string
const DEVICE_ADSL_CARRIER: string
const DEVICE_AUTOCONNECT: string
const DEVICE_AVAILABLE_CONNECTIONS: string
const DEVICE_BOND_CARRIER: string
const DEVICE_BOND_HW_ADDRESS: string
const DEVICE_BOND_SLAVES: string
const DEVICE_BRIDGE_CARRIER: string
const DEVICE_BRIDGE_HW_ADDRESS: string
const DEVICE_BRIDGE_SLAVES: string
const DEVICE_BT_CAPABILITIES: string
const DEVICE_BT_HW_ADDRESS: string
const DEVICE_BT_NAME: string
const DEVICE_CAPABILITIES: string
const DEVICE_DEVICE_TYPE: string
const DEVICE_DHCP4_CONFIG: string
const DEVICE_DHCP6_CONFIG: string
const DEVICE_DRIVER: string
const DEVICE_DRIVER_VERSION: string
const DEVICE_DUMMY_HW_ADDRESS: string
const DEVICE_ETHERNET_CARRIER: string
const DEVICE_ETHERNET_HW_ADDRESS: string
const DEVICE_ETHERNET_PERMANENT_HW_ADDRESS: string
const DEVICE_ETHERNET_S390_SUBCHANNELS: string
const DEVICE_ETHERNET_SPEED: string
const DEVICE_FIRMWARE_MISSING: string
const DEVICE_FIRMWARE_VERSION: string
const DEVICE_GENERIC_HW_ADDRESS: string
const DEVICE_GENERIC_TYPE_DESCRIPTION: string
const DEVICE_HW_ADDRESS: string
const DEVICE_INFINIBAND_CARRIER: string
const DEVICE_INFINIBAND_HW_ADDRESS: string
const DEVICE_INTERFACE: string
const DEVICE_INTERFACE_FLAGS: string
const DEVICE_IP4_CONFIG: string
const DEVICE_IP4_CONNECTIVITY: string
const DEVICE_IP6_CONFIG: string
const DEVICE_IP6_CONNECTIVITY: string
const DEVICE_IP_INTERFACE: string
const DEVICE_IP_TUNNEL_ENCAPSULATION_LIMIT: string
const DEVICE_IP_TUNNEL_FLAGS: string
const DEVICE_IP_TUNNEL_FLOW_LABEL: string
const DEVICE_IP_TUNNEL_INPUT_KEY: string
const DEVICE_IP_TUNNEL_LOCAL: string
const DEVICE_IP_TUNNEL_MODE: string
const DEVICE_IP_TUNNEL_OUTPUT_KEY: string
const DEVICE_IP_TUNNEL_PARENT: string
const DEVICE_IP_TUNNEL_PATH_MTU_DISCOVERY: string
const DEVICE_IP_TUNNEL_REMOTE: string
const DEVICE_IP_TUNNEL_TOS: string
const DEVICE_IP_TUNNEL_TTL: string
const DEVICE_LLDP_NEIGHBORS: string
const DEVICE_MACSEC_CIPHER_SUITE: string
const DEVICE_MACSEC_ENCODING_SA: string
const DEVICE_MACSEC_ENCRYPT: string
const DEVICE_MACSEC_ES: string
const DEVICE_MACSEC_HW_ADDRESS: string
const DEVICE_MACSEC_ICV_LENGTH: string
const DEVICE_MACSEC_INCLUDE_SCI: string
const DEVICE_MACSEC_PARENT: string
const DEVICE_MACSEC_PROTECT: string
const DEVICE_MACSEC_REPLAY_PROTECT: string
const DEVICE_MACSEC_SCB: string
const DEVICE_MACSEC_SCI: string
const DEVICE_MACSEC_VALIDATION: string
const DEVICE_MACSEC_WINDOW: string
const DEVICE_MACVLAN_HW_ADDRESS: string
const DEVICE_MACVLAN_MODE: string
const DEVICE_MACVLAN_NO_PROMISC: string
const DEVICE_MACVLAN_PARENT: string
const DEVICE_MACVLAN_TAP: string
const DEVICE_MANAGED: string
const DEVICE_METERED: string
const DEVICE_MODEM_APN: string
const DEVICE_MODEM_CURRENT_CAPABILITIES: string
const DEVICE_MODEM_DEVICE_ID: string
const DEVICE_MODEM_MODEM_CAPABILITIES: string
const DEVICE_MODEM_OPERATOR_CODE: string
const DEVICE_MTU: string
const DEVICE_NM_PLUGIN_MISSING: string
const DEVICE_OLPC_MESH_ACTIVE_CHANNEL: string
const DEVICE_OLPC_MESH_COMPANION: string
const DEVICE_OLPC_MESH_HW_ADDRESS: string
const DEVICE_OVS_BRIDGE_SLAVES: string
const DEVICE_OVS_PORT_SLAVES: string
const DEVICE_PATH: string
const DEVICE_PHYSICAL_PORT_ID: string
const DEVICE_PORTS: string
const DEVICE_PRODUCT: string
const DEVICE_REAL: string
const DEVICE_STATE: string
const DEVICE_STATE_REASON: string
const DEVICE_TEAM_CARRIER: string
const DEVICE_TEAM_CONFIG: string
const DEVICE_TEAM_HW_ADDRESS: string
const DEVICE_TEAM_SLAVES: string
const DEVICE_TUN_GROUP: string
const DEVICE_TUN_HW_ADDRESS: string
const DEVICE_TUN_MODE: string
const DEVICE_TUN_MULTI_QUEUE: string
const DEVICE_TUN_NO_PI: string
const DEVICE_TUN_OWNER: string
const DEVICE_TUN_VNET_HDR: string
const DEVICE_UDI: string
const DEVICE_VENDOR: string
const DEVICE_VETH_PEER: string
const DEVICE_VLAN_CARRIER: string
const DEVICE_VLAN_HW_ADDRESS: string
const DEVICE_VLAN_PARENT: string
const DEVICE_VLAN_VLAN_ID: string
const DEVICE_VRF_TABLE: string
const DEVICE_VXLAN_AGEING: string
const DEVICE_VXLAN_CARRIER: string
const DEVICE_VXLAN_DST_PORT: string
const DEVICE_VXLAN_GROUP: string
const DEVICE_VXLAN_HW_ADDRESS: string
const DEVICE_VXLAN_ID: string
const DEVICE_VXLAN_L2MISS: string
const DEVICE_VXLAN_L3MISS: string
const DEVICE_VXLAN_LEARNING: string
const DEVICE_VXLAN_LIMIT: string
const DEVICE_VXLAN_LOCAL: string
const DEVICE_VXLAN_PARENT: string
const DEVICE_VXLAN_PROXY: string
const DEVICE_VXLAN_RSC: string
const DEVICE_VXLAN_SRC_PORT_MAX: string
const DEVICE_VXLAN_SRC_PORT_MIN: string
const DEVICE_VXLAN_TOS: string
const DEVICE_VXLAN_TTL: string
const DEVICE_WIFI_ACCESS_POINTS: string
const DEVICE_WIFI_ACTIVE_ACCESS_POINT: string
const DEVICE_WIFI_BITRATE: string
const DEVICE_WIFI_CAPABILITIES: string
const DEVICE_WIFI_HW_ADDRESS: string
const DEVICE_WIFI_LAST_SCAN: string
const DEVICE_WIFI_MODE: string
const DEVICE_WIFI_P2P_HW_ADDRESS: string
const DEVICE_WIFI_P2P_PEERS: string
const DEVICE_WIFI_P2P_WFDIES: string
const DEVICE_WIFI_PERMANENT_HW_ADDRESS: string
const DEVICE_WIMAX_ACTIVE_NSP: string
const DEVICE_WIMAX_BSID: string
const DEVICE_WIMAX_CENTER_FREQUENCY: string
const DEVICE_WIMAX_CINR: string
const DEVICE_WIMAX_HW_ADDRESS: string
const DEVICE_WIMAX_NSPS: string
const DEVICE_WIMAX_RSSI: string
const DEVICE_WIMAX_TX_POWER: string
const DEVICE_WIREGUARD_FWMARK: string
const DEVICE_WIREGUARD_LISTEN_PORT: string
const DEVICE_WIREGUARD_PUBLIC_KEY: string
const DEVICE_WPAN_HW_ADDRESS: string
const DHCP_CONFIG_FAMILY: string
const DHCP_CONFIG_OPTIONS: string
const ETHTOOL_OPTNAME_COALESCE_ADAPTIVE_RX: string
const ETHTOOL_OPTNAME_COALESCE_ADAPTIVE_TX: string
const ETHTOOL_OPTNAME_COALESCE_PKT_RATE_HIGH: string
const ETHTOOL_OPTNAME_COALESCE_PKT_RATE_LOW: string
const ETHTOOL_OPTNAME_COALESCE_RX_FRAMES: string
const ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_HIGH: string
const ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_IRQ: string
const ETHTOOL_OPTNAME_COALESCE_RX_FRAMES_LOW: string
const ETHTOOL_OPTNAME_COALESCE_RX_USECS: string
const ETHTOOL_OPTNAME_COALESCE_RX_USECS_HIGH: string
const ETHTOOL_OPTNAME_COALESCE_RX_USECS_IRQ: string
const ETHTOOL_OPTNAME_COALESCE_RX_USECS_LOW: string
const ETHTOOL_OPTNAME_COALESCE_SAMPLE_INTERVAL: string
const ETHTOOL_OPTNAME_COALESCE_STATS_BLOCK_USECS: string
const ETHTOOL_OPTNAME_COALESCE_TX_FRAMES: string
const ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_HIGH: string
const ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_IRQ: string
const ETHTOOL_OPTNAME_COALESCE_TX_FRAMES_LOW: string
const ETHTOOL_OPTNAME_COALESCE_TX_USECS: string
const ETHTOOL_OPTNAME_COALESCE_TX_USECS_HIGH: string
const ETHTOOL_OPTNAME_COALESCE_TX_USECS_IRQ: string
const ETHTOOL_OPTNAME_COALESCE_TX_USECS_LOW: string
const ETHTOOL_OPTNAME_FEATURE_ESP_HW_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_ESP_TX_CSUM_HW_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_FCOE_MTU: string
const ETHTOOL_OPTNAME_FEATURE_GRO: string
const ETHTOOL_OPTNAME_FEATURE_GSO: string
const ETHTOOL_OPTNAME_FEATURE_HIGHDMA: string
const ETHTOOL_OPTNAME_FEATURE_HW_TC_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_L2_FWD_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_LOOPBACK: string
const ETHTOOL_OPTNAME_FEATURE_LRO: string
const ETHTOOL_OPTNAME_FEATURE_MACSEC_HW_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_NTUPLE: string
const ETHTOOL_OPTNAME_FEATURE_RX: string
const ETHTOOL_OPTNAME_FEATURE_RXHASH: string
const ETHTOOL_OPTNAME_FEATURE_RXVLAN: string
const ETHTOOL_OPTNAME_FEATURE_RX_ALL: string
const ETHTOOL_OPTNAME_FEATURE_RX_FCS: string
const ETHTOOL_OPTNAME_FEATURE_RX_GRO_HW: string
const ETHTOOL_OPTNAME_FEATURE_RX_GRO_LIST: string
const ETHTOOL_OPTNAME_FEATURE_RX_UDP_GRO_FORWARDING: string
const ETHTOOL_OPTNAME_FEATURE_RX_UDP_TUNNEL_PORT_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_RX_VLAN_FILTER: string
const ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_FILTER: string
const ETHTOOL_OPTNAME_FEATURE_RX_VLAN_STAG_HW_PARSE: string
const ETHTOOL_OPTNAME_FEATURE_SG: string
const ETHTOOL_OPTNAME_FEATURE_TLS_HW_RECORD: string
const ETHTOOL_OPTNAME_FEATURE_TLS_HW_RX_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_TLS_HW_TX_OFFLOAD: string
const ETHTOOL_OPTNAME_FEATURE_TSO: string
const ETHTOOL_OPTNAME_FEATURE_TX: string
const ETHTOOL_OPTNAME_FEATURE_TXVLAN: string
const ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_FCOE_CRC: string
const ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV4: string
const ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IPV6: string
const ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_IP_GENERIC: string
const ETHTOOL_OPTNAME_FEATURE_TX_CHECKSUM_SCTP: string
const ETHTOOL_OPTNAME_FEATURE_TX_ESP_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_FCOE_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_GRE_CSUM_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_GRE_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_GSO_LIST: string
const ETHTOOL_OPTNAME_FEATURE_TX_GSO_PARTIAL: string
const ETHTOOL_OPTNAME_FEATURE_TX_GSO_ROBUST: string
const ETHTOOL_OPTNAME_FEATURE_TX_IPXIP4_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_IPXIP6_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_NOCACHE_COPY: string
const ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER: string
const ETHTOOL_OPTNAME_FEATURE_TX_SCATTER_GATHER_FRAGLIST: string
const ETHTOOL_OPTNAME_FEATURE_TX_SCTP_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_TCP6_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_TCP_ECN_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_TCP_MANGLEID_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_TCP_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_TUNNEL_REMCSUM_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_UDP_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_CSUM_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_UDP_TNL_SEGMENTATION: string
const ETHTOOL_OPTNAME_FEATURE_TX_VLAN_STAG_HW_INSERT: string
const ETHTOOL_OPTNAME_PAUSE_AUTONEG: string
const ETHTOOL_OPTNAME_PAUSE_RX: string
const ETHTOOL_OPTNAME_PAUSE_TX: string
const ETHTOOL_OPTNAME_RING_RX: string
const ETHTOOL_OPTNAME_RING_RX_JUMBO: string
const ETHTOOL_OPTNAME_RING_RX_MINI: string
const ETHTOOL_OPTNAME_RING_TX: string
const IP_ADDRESS_ATTRIBUTE_LABEL: string
const IP_CONFIG_ADDRESSES: string
const IP_CONFIG_DOMAINS: string
const IP_CONFIG_FAMILY: string
const IP_CONFIG_GATEWAY: string
const IP_CONFIG_NAMESERVERS: string
const IP_CONFIG_ROUTES: string
const IP_CONFIG_SEARCHES: string
const IP_CONFIG_WINS_SERVERS: string
const IP_ROUTE_ATTRIBUTE_CWND: string
const IP_ROUTE_ATTRIBUTE_FROM: string
const IP_ROUTE_ATTRIBUTE_INITCWND: string
const IP_ROUTE_ATTRIBUTE_INITRWND: string
const IP_ROUTE_ATTRIBUTE_LOCK_CWND: string
const IP_ROUTE_ATTRIBUTE_LOCK_INITCWND: string
const IP_ROUTE_ATTRIBUTE_LOCK_INITRWND: string
const IP_ROUTE_ATTRIBUTE_LOCK_MTU: string
const IP_ROUTE_ATTRIBUTE_LOCK_WINDOW: string
const IP_ROUTE_ATTRIBUTE_MTU: string
const IP_ROUTE_ATTRIBUTE_ONLINK: string
const IP_ROUTE_ATTRIBUTE_SCOPE: string
const IP_ROUTE_ATTRIBUTE_SRC: string
const IP_ROUTE_ATTRIBUTE_TABLE: string
const IP_ROUTE_ATTRIBUTE_TOS: string
const IP_ROUTE_ATTRIBUTE_TYPE: string
const IP_ROUTE_ATTRIBUTE_WINDOW: string
const LLDP_ATTR_CHASSIS_ID: string
const LLDP_ATTR_CHASSIS_ID_TYPE: string
const LLDP_ATTR_DESTINATION: string
const LLDP_ATTR_IEEE_802_1_PPVID: string
const LLDP_ATTR_IEEE_802_1_PPVIDS: string
const LLDP_ATTR_IEEE_802_1_PPVID_FLAGS: string
const LLDP_ATTR_IEEE_802_1_PVID: string
const LLDP_ATTR_IEEE_802_1_VID: string
const LLDP_ATTR_IEEE_802_1_VLANS: string
const LLDP_ATTR_IEEE_802_1_VLAN_NAME: string
const LLDP_ATTR_IEEE_802_3_MAC_PHY_CONF: string
const LLDP_ATTR_IEEE_802_3_MAX_FRAME_SIZE: string
const LLDP_ATTR_IEEE_802_3_POWER_VIA_MDI: string
const LLDP_ATTR_MANAGEMENT_ADDRESSES: string
const LLDP_ATTR_MUD_URL: string
const LLDP_ATTR_PORT_DESCRIPTION: string
const LLDP_ATTR_PORT_ID: string
const LLDP_ATTR_PORT_ID_TYPE: string
const LLDP_ATTR_RAW: string
const LLDP_ATTR_SYSTEM_CAPABILITIES: string
const LLDP_ATTR_SYSTEM_DESCRIPTION: string
const LLDP_ATTR_SYSTEM_NAME: string
const LLDP_DEST_NEAREST_BRIDGE: string
const LLDP_DEST_NEAREST_CUSTOMER_BRIDGE: string
const LLDP_DEST_NEAREST_NON_TPMR_BRIDGE: string
/**
 * Evaluates to the major version number of NetworkManager which this source
 * is compiled against.
 */
const MAJOR_VERSION: number
/**
 * Evaluates to the micro version number of NetworkManager which this source
 * compiled against.
 */
const MICRO_VERSION: number
/**
 * Evaluates to the minor version number of NetworkManager which this source
 * is compiled against.
 */
const MINOR_VERSION: number
const OBJECT_CLIENT: string
const OBJECT_PATH: string
const REMOTE_CONNECTION_DBUS_CONNECTION: string
const REMOTE_CONNECTION_FILENAME: string
const REMOTE_CONNECTION_FLAGS: string
const REMOTE_CONNECTION_PATH: string
const REMOTE_CONNECTION_UNSAVED: string
const REMOTE_CONNECTION_VISIBLE: string
const SECRET_AGENT_OLD_AUTO_REGISTER: string
const SECRET_AGENT_OLD_CAPABILITIES: string
const SECRET_AGENT_OLD_DBUS_CONNECTION: string
const SECRET_AGENT_OLD_IDENTIFIER: string
const SECRET_AGENT_OLD_REGISTERED: string
const SETTING_6LOWPAN_PARENT: string
const SETTING_6LOWPAN_SETTING_NAME: string
const SETTING_802_1X_ALTSUBJECT_MATCHES: string
const SETTING_802_1X_ANONYMOUS_IDENTITY: string
const SETTING_802_1X_AUTH_TIMEOUT: string
const SETTING_802_1X_CA_CERT: string
const SETTING_802_1X_CA_CERT_PASSWORD: string
const SETTING_802_1X_CA_CERT_PASSWORD_FLAGS: string
const SETTING_802_1X_CA_PATH: string
const SETTING_802_1X_CERT_SCHEME_PREFIX_PATH: string
const SETTING_802_1X_CERT_SCHEME_PREFIX_PKCS11: string
const SETTING_802_1X_CLIENT_CERT: string
const SETTING_802_1X_CLIENT_CERT_PASSWORD: string
const SETTING_802_1X_CLIENT_CERT_PASSWORD_FLAGS: string
const SETTING_802_1X_DOMAIN_MATCH: string
const SETTING_802_1X_DOMAIN_SUFFIX_MATCH: string
const SETTING_802_1X_EAP: string
const SETTING_802_1X_IDENTITY: string
const SETTING_802_1X_OPTIONAL: string
const SETTING_802_1X_PAC_FILE: string
const SETTING_802_1X_PASSWORD: string
const SETTING_802_1X_PASSWORD_FLAGS: string
const SETTING_802_1X_PASSWORD_RAW: string
const SETTING_802_1X_PASSWORD_RAW_FLAGS: string
const SETTING_802_1X_PHASE1_AUTH_FLAGS: string
const SETTING_802_1X_PHASE1_FAST_PROVISIONING: string
const SETTING_802_1X_PHASE1_PEAPLABEL: string
const SETTING_802_1X_PHASE1_PEAPVER: string
const SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES: string
const SETTING_802_1X_PHASE2_AUTH: string
const SETTING_802_1X_PHASE2_AUTHEAP: string
const SETTING_802_1X_PHASE2_CA_CERT: string
const SETTING_802_1X_PHASE2_CA_CERT_PASSWORD: string
const SETTING_802_1X_PHASE2_CA_CERT_PASSWORD_FLAGS: string
const SETTING_802_1X_PHASE2_CA_PATH: string
const SETTING_802_1X_PHASE2_CLIENT_CERT: string
const SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD: string
const SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD_FLAGS: string
const SETTING_802_1X_PHASE2_DOMAIN_MATCH: string
const SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH: string
const SETTING_802_1X_PHASE2_PRIVATE_KEY: string
const SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD: string
const SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS: string
const SETTING_802_1X_PHASE2_SUBJECT_MATCH: string
const SETTING_802_1X_PIN: string
const SETTING_802_1X_PIN_FLAGS: string
const SETTING_802_1X_PRIVATE_KEY: string
const SETTING_802_1X_PRIVATE_KEY_PASSWORD: string
const SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS: string
const SETTING_802_1X_SETTING_NAME: string
const SETTING_802_1X_SUBJECT_MATCH: string
const SETTING_802_1X_SYSTEM_CA_CERTS: string
const SETTING_ADSL_ENCAPSULATION: string
const SETTING_ADSL_ENCAPSULATION_LLC: string
const SETTING_ADSL_ENCAPSULATION_VCMUX: string
const SETTING_ADSL_PASSWORD: string
const SETTING_ADSL_PASSWORD_FLAGS: string
const SETTING_ADSL_PROTOCOL: string
const SETTING_ADSL_PROTOCOL_IPOATM: string
const SETTING_ADSL_PROTOCOL_PPPOA: string
const SETTING_ADSL_PROTOCOL_PPPOE: string
const SETTING_ADSL_SETTING_NAME: string
const SETTING_ADSL_USERNAME: string
const SETTING_ADSL_VCI: string
const SETTING_ADSL_VPI: string
const SETTING_BLUETOOTH_BDADDR: string
const SETTING_BLUETOOTH_SETTING_NAME: string
const SETTING_BLUETOOTH_TYPE: string
/**
 * Connection type describing a connection to devices that support the Bluetooth
 * DUN profile.
 */
const SETTING_BLUETOOTH_TYPE_DUN: string
/**
 * Connection type describing a Bluetooth NAP (Network Access Point),
 * which accepts PANU clients.
 */
const SETTING_BLUETOOTH_TYPE_NAP: string
/**
 * Connection type describing PANU connection to a Bluetooth NAP (Network
 * Access Point).
 */
const SETTING_BLUETOOTH_TYPE_PANU: string
const SETTING_BOND_OPTIONS: string
const SETTING_BOND_OPTION_ACTIVE_SLAVE: string
const SETTING_BOND_OPTION_AD_ACTOR_SYSTEM: string
const SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO: string
const SETTING_BOND_OPTION_AD_SELECT: string
const SETTING_BOND_OPTION_AD_USER_PORT_KEY: string
const SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE: string
const SETTING_BOND_OPTION_ARP_ALL_TARGETS: string
const SETTING_BOND_OPTION_ARP_INTERVAL: string
const SETTING_BOND_OPTION_ARP_IP_TARGET: string
const SETTING_BOND_OPTION_ARP_VALIDATE: string
const SETTING_BOND_OPTION_DOWNDELAY: string
const SETTING_BOND_OPTION_FAIL_OVER_MAC: string
const SETTING_BOND_OPTION_LACP_RATE: string
const SETTING_BOND_OPTION_LP_INTERVAL: string
const SETTING_BOND_OPTION_MIIMON: string
const SETTING_BOND_OPTION_MIN_LINKS: string
const SETTING_BOND_OPTION_MODE: string
const SETTING_BOND_OPTION_NUM_GRAT_ARP: string
const SETTING_BOND_OPTION_NUM_UNSOL_NA: string
const SETTING_BOND_OPTION_PACKETS_PER_SLAVE: string
const SETTING_BOND_OPTION_PEER_NOTIF_DELAY: string
const SETTING_BOND_OPTION_PRIMARY: string
const SETTING_BOND_OPTION_PRIMARY_RESELECT: string
const SETTING_BOND_OPTION_RESEND_IGMP: string
const SETTING_BOND_OPTION_TLB_DYNAMIC_LB: string
const SETTING_BOND_OPTION_UPDELAY: string
const SETTING_BOND_OPTION_USE_CARRIER: string
const SETTING_BOND_OPTION_XMIT_HASH_POLICY: string
const SETTING_BOND_PORT_QUEUE_ID: string
const SETTING_BOND_PORT_SETTING_NAME: string
const SETTING_BOND_SETTING_NAME: string
const SETTING_BRIDGE_AGEING_TIME: string
const SETTING_BRIDGE_FORWARD_DELAY: string
const SETTING_BRIDGE_GROUP_ADDRESS: string
const SETTING_BRIDGE_GROUP_FORWARD_MASK: string
const SETTING_BRIDGE_HELLO_TIME: string
const SETTING_BRIDGE_MAC_ADDRESS: string
const SETTING_BRIDGE_MAX_AGE: string
const SETTING_BRIDGE_MULTICAST_HASH_MAX: string
const SETTING_BRIDGE_MULTICAST_LAST_MEMBER_COUNT: string
const SETTING_BRIDGE_MULTICAST_LAST_MEMBER_INTERVAL: string
const SETTING_BRIDGE_MULTICAST_MEMBERSHIP_INTERVAL: string
const SETTING_BRIDGE_MULTICAST_QUERIER: string
const SETTING_BRIDGE_MULTICAST_QUERIER_INTERVAL: string
const SETTING_BRIDGE_MULTICAST_QUERY_INTERVAL: string
const SETTING_BRIDGE_MULTICAST_QUERY_RESPONSE_INTERVAL: string
const SETTING_BRIDGE_MULTICAST_QUERY_USE_IFADDR: string
const SETTING_BRIDGE_MULTICAST_ROUTER: string
const SETTING_BRIDGE_MULTICAST_SNOOPING: string
const SETTING_BRIDGE_MULTICAST_STARTUP_QUERY_COUNT: string
const SETTING_BRIDGE_MULTICAST_STARTUP_QUERY_INTERVAL: string
const SETTING_BRIDGE_PORT_HAIRPIN_MODE: string
const SETTING_BRIDGE_PORT_PATH_COST: string
const SETTING_BRIDGE_PORT_PRIORITY: string
const SETTING_BRIDGE_PORT_SETTING_NAME: string
const SETTING_BRIDGE_PORT_VLANS: string
const SETTING_BRIDGE_PRIORITY: string
const SETTING_BRIDGE_SETTING_NAME: string
const SETTING_BRIDGE_STP: string
const SETTING_BRIDGE_VLANS: string
const SETTING_BRIDGE_VLAN_DEFAULT_PVID: string
const SETTING_BRIDGE_VLAN_FILTERING: string
const SETTING_BRIDGE_VLAN_PROTOCOL: string
const SETTING_BRIDGE_VLAN_STATS_ENABLED: string
const SETTING_CDMA_MTU: string
const SETTING_CDMA_NUMBER: string
const SETTING_CDMA_PASSWORD: string
const SETTING_CDMA_PASSWORD_FLAGS: string
const SETTING_CDMA_SETTING_NAME: string
const SETTING_CDMA_USERNAME: string
const SETTING_CONNECTION_AUTH_RETRIES: string
const SETTING_CONNECTION_AUTOCONNECT: string
const SETTING_CONNECTION_AUTOCONNECT_PRIORITY: string
const SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT: number
const SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX: number
const SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN: number
const SETTING_CONNECTION_AUTOCONNECT_RETRIES: string
const SETTING_CONNECTION_AUTOCONNECT_SLAVES: string
const SETTING_CONNECTION_DNS_OVER_TLS: string
const SETTING_CONNECTION_GATEWAY_PING_TIMEOUT: string
const SETTING_CONNECTION_ID: string
const SETTING_CONNECTION_INTERFACE_NAME: string
const SETTING_CONNECTION_LLDP: string
const SETTING_CONNECTION_LLMNR: string
const SETTING_CONNECTION_MASTER: string
const SETTING_CONNECTION_MDNS: string
const SETTING_CONNECTION_METERED: string
const SETTING_CONNECTION_MUD_URL: string
const SETTING_CONNECTION_MULTI_CONNECT: string
const SETTING_CONNECTION_PERMISSIONS: string
const SETTING_CONNECTION_READ_ONLY: string
const SETTING_CONNECTION_SECONDARIES: string
const SETTING_CONNECTION_SETTING_NAME: string
const SETTING_CONNECTION_SLAVE_TYPE: string
const SETTING_CONNECTION_STABLE_ID: string
const SETTING_CONNECTION_TIMESTAMP: string
const SETTING_CONNECTION_TYPE: string
const SETTING_CONNECTION_UUID: string
const SETTING_CONNECTION_WAIT_DEVICE_TIMEOUT: string
const SETTING_CONNECTION_ZONE: string
const SETTING_DCB_APP_FCOE_FLAGS: string
const SETTING_DCB_APP_FCOE_MODE: string
const SETTING_DCB_APP_FCOE_PRIORITY: string
const SETTING_DCB_APP_FIP_FLAGS: string
const SETTING_DCB_APP_FIP_PRIORITY: string
const SETTING_DCB_APP_ISCSI_FLAGS: string
const SETTING_DCB_APP_ISCSI_PRIORITY: string
/**
 * Indicates that the FCoE controller should use "fabric" mode (default)
 */
const SETTING_DCB_FCOE_MODE_FABRIC: string
/**
 * Indicates that the FCoE controller should use "VN2VN" mode.
 */
const SETTING_DCB_FCOE_MODE_VN2VN: string
const SETTING_DCB_PRIORITY_BANDWIDTH: string
const SETTING_DCB_PRIORITY_FLOW_CONTROL: string
const SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS: string
const SETTING_DCB_PRIORITY_GROUP_BANDWIDTH: string
const SETTING_DCB_PRIORITY_GROUP_FLAGS: string
const SETTING_DCB_PRIORITY_GROUP_ID: string
const SETTING_DCB_PRIORITY_STRICT_BANDWIDTH: string
const SETTING_DCB_PRIORITY_TRAFFIC_CLASS: string
const SETTING_DCB_SETTING_NAME: string
const SETTING_DNS_OPTION_ATTEMPTS: string
const SETTING_DNS_OPTION_DEBUG: string
const SETTING_DNS_OPTION_EDNS0: string
const SETTING_DNS_OPTION_INET6: string
const SETTING_DNS_OPTION_IP6_BYTESTRING: string
const SETTING_DNS_OPTION_IP6_DOTINT: string
const SETTING_DNS_OPTION_NDOTS: string
const SETTING_DNS_OPTION_NO_CHECK_NAMES: string
const SETTING_DNS_OPTION_NO_IP6_DOTINT: string
const SETTING_DNS_OPTION_NO_RELOAD: string
const SETTING_DNS_OPTION_NO_TLD_QUERY: string
const SETTING_DNS_OPTION_ROTATE: string
const SETTING_DNS_OPTION_SINGLE_REQUEST: string
const SETTING_DNS_OPTION_SINGLE_REQUEST_REOPEN: string
const SETTING_DNS_OPTION_TIMEOUT: string
const SETTING_DNS_OPTION_TRUST_AD: string
const SETTING_DNS_OPTION_USE_VC: string
const SETTING_DUMMY_SETTING_NAME: string
const SETTING_ETHTOOL_SETTING_NAME: string
const SETTING_GENERIC_SETTING_NAME: string
const SETTING_GSM_APN: string
const SETTING_GSM_AUTO_CONFIG: string
const SETTING_GSM_DEVICE_ID: string
const SETTING_GSM_HOME_ONLY: string
const SETTING_GSM_MTU: string
const SETTING_GSM_NETWORK_ID: string
const SETTING_GSM_NUMBER: string
const SETTING_GSM_PASSWORD: string
const SETTING_GSM_PASSWORD_FLAGS: string
const SETTING_GSM_PIN: string
const SETTING_GSM_PIN_FLAGS: string
const SETTING_GSM_SETTING_NAME: string
const SETTING_GSM_SIM_ID: string
const SETTING_GSM_SIM_OPERATOR_ID: string
const SETTING_GSM_USERNAME: string
const SETTING_HOSTNAME_FROM_DHCP: string
const SETTING_HOSTNAME_FROM_DNS_LOOKUP: string
const SETTING_HOSTNAME_ONLY_FROM_DEFAULT: string
const SETTING_HOSTNAME_PRIORITY: string
const SETTING_HOSTNAME_SETTING_NAME: string
const SETTING_INFINIBAND_MAC_ADDRESS: string
const SETTING_INFINIBAND_MTU: string
const SETTING_INFINIBAND_PARENT: string
const SETTING_INFINIBAND_P_KEY: string
const SETTING_INFINIBAND_SETTING_NAME: string
const SETTING_INFINIBAND_TRANSPORT_MODE: string
const SETTING_IP4_CONFIG_DHCP_CLIENT_ID: string
const SETTING_IP4_CONFIG_DHCP_FQDN: string
const SETTING_IP4_CONFIG_DHCP_VENDOR_CLASS_IDENTIFIER: string
/**
 * IPv4 configuration should be automatically determined via a method appropriate
 * for the hardware interface, ie DHCP or PPP or some other device-specific
 * manner.
 */
const SETTING_IP4_CONFIG_METHOD_AUTO: string
/**
 * This connection does not use or require IPv4 address and it should be disabled.
 */
const SETTING_IP4_CONFIG_METHOD_DISABLED: string
/**
 * IPv4 configuration should be automatically configured for link-local-only
 * operation.
 */
const SETTING_IP4_CONFIG_METHOD_LINK_LOCAL: string
/**
 * All necessary IPv4 configuration (addresses, prefix, DNS, etc) is specified
 * in the setting's properties.
 */
const SETTING_IP4_CONFIG_METHOD_MANUAL: string
/**
 * This connection specifies configuration that allows other computers to
 * connect through it to the default network (usually the Internet).  The
 * connection's interface will be assigned a private address, and a DHCP server,
 * caching DNS server, and Network Address Translation (NAT) functionality will
 * be started on this connection's interface to allow other devices to connect
 * through that interface to the default network.
 */
const SETTING_IP4_CONFIG_METHOD_SHARED: string
const SETTING_IP4_CONFIG_SETTING_NAME: string
const SETTING_IP6_CONFIG_ADDR_GEN_MODE: string
const SETTING_IP6_CONFIG_DHCP_DUID: string
const SETTING_IP6_CONFIG_IP6_PRIVACY: string
/**
 * IPv6 configuration should be automatically determined via a method appropriate
 * for the hardware interface, ie router advertisements, DHCP, or PPP or some
 * other device-specific manner.
 */
const SETTING_IP6_CONFIG_METHOD_AUTO: string
/**
 * IPv6 configuration should be automatically determined via DHCPv6 only and
 * router advertisements should be ignored.
 */
const SETTING_IP6_CONFIG_METHOD_DHCP: string
/**
 * IPv6 is disabled for the connection.
 */
const SETTING_IP6_CONFIG_METHOD_DISABLED: string
/**
 * IPv6 is not required or is handled by some other mechanism, and NetworkManager
 * should not configure IPv6 for this connection.
 */
const SETTING_IP6_CONFIG_METHOD_IGNORE: string
/**
 * IPv6 configuration should be automatically configured for link-local-only
 * operation.
 */
const SETTING_IP6_CONFIG_METHOD_LINK_LOCAL: string
/**
 * All necessary IPv6 configuration (addresses, prefix, DNS, etc) is specified
 * in the setting's properties.
 */
const SETTING_IP6_CONFIG_METHOD_MANUAL: string
/**
 * This connection specifies configuration that allows other computers to
 * connect through it to the default network (usually the Internet).  The
 * connection's interface will be assigned a private address, and router
 * advertisements, a caching DNS server, and Network Address Translation (NAT)
 * functionality will be started on this connection's interface to allow other
 * devices to connect through that interface to the default network. (not yet
 * supported for IPv6)
 */
const SETTING_IP6_CONFIG_METHOD_SHARED: string
const SETTING_IP6_CONFIG_RA_TIMEOUT: string
const SETTING_IP6_CONFIG_SETTING_NAME: string
const SETTING_IP6_CONFIG_TOKEN: string
const SETTING_IP_CONFIG_ADDRESSES: string
const SETTING_IP_CONFIG_DAD_TIMEOUT: string
const SETTING_IP_CONFIG_DAD_TIMEOUT_MAX: number
const SETTING_IP_CONFIG_DHCP_HOSTNAME: string
const SETTING_IP_CONFIG_DHCP_HOSTNAME_FLAGS: string
const SETTING_IP_CONFIG_DHCP_IAID: string
const SETTING_IP_CONFIG_DHCP_REJECT_SERVERS: string
const SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME: string
const SETTING_IP_CONFIG_DHCP_TIMEOUT: string
const SETTING_IP_CONFIG_DNS: string
const SETTING_IP_CONFIG_DNS_OPTIONS: string
const SETTING_IP_CONFIG_DNS_PRIORITY: string
const SETTING_IP_CONFIG_DNS_SEARCH: string
const SETTING_IP_CONFIG_GATEWAY: string
const SETTING_IP_CONFIG_IGNORE_AUTO_DNS: string
const SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES: string
const SETTING_IP_CONFIG_MAY_FAIL: string
const SETTING_IP_CONFIG_METHOD: string
const SETTING_IP_CONFIG_NEVER_DEFAULT: string
const SETTING_IP_CONFIG_REQUIRED_TIMEOUT: string
const SETTING_IP_CONFIG_ROUTES: string
const SETTING_IP_CONFIG_ROUTE_METRIC: string
const SETTING_IP_CONFIG_ROUTE_TABLE: string
const SETTING_IP_CONFIG_ROUTING_RULES: string
const SETTING_IP_TUNNEL_ENCAPSULATION_LIMIT: string
const SETTING_IP_TUNNEL_FLAGS: string
const SETTING_IP_TUNNEL_FLOW_LABEL: string
const SETTING_IP_TUNNEL_INPUT_KEY: string
const SETTING_IP_TUNNEL_LOCAL: string
const SETTING_IP_TUNNEL_MODE: string
const SETTING_IP_TUNNEL_MTU: string
const SETTING_IP_TUNNEL_OUTPUT_KEY: string
const SETTING_IP_TUNNEL_PARENT: string
const SETTING_IP_TUNNEL_PATH_MTU_DISCOVERY: string
const SETTING_IP_TUNNEL_REMOTE: string
const SETTING_IP_TUNNEL_SETTING_NAME: string
const SETTING_IP_TUNNEL_TOS: string
const SETTING_IP_TUNNEL_TTL: string
const SETTING_MACSEC_ENCRYPT: string
const SETTING_MACSEC_MKA_CAK: string
const SETTING_MACSEC_MKA_CAK_FLAGS: string
const SETTING_MACSEC_MKA_CAK_LENGTH: number
const SETTING_MACSEC_MKA_CKN: string
const SETTING_MACSEC_MKA_CKN_LENGTH: number
const SETTING_MACSEC_MODE: string
const SETTING_MACSEC_PARENT: string
const SETTING_MACSEC_PORT: string
const SETTING_MACSEC_SEND_SCI: string
const SETTING_MACSEC_SETTING_NAME: string
const SETTING_MACSEC_VALIDATION: string
const SETTING_MACVLAN_MODE: string
const SETTING_MACVLAN_PARENT: string
const SETTING_MACVLAN_PROMISCUOUS: string
const SETTING_MACVLAN_SETTING_NAME: string
const SETTING_MACVLAN_TAP: string
const SETTING_MATCH_DRIVER: string
const SETTING_MATCH_INTERFACE_NAME: string
const SETTING_MATCH_KERNEL_COMMAND_LINE: string
const SETTING_MATCH_PATH: string
const SETTING_MATCH_SETTING_NAME: string
const SETTING_NAME: string
const SETTING_OLPC_MESH_CHANNEL: string
const SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS: string
const SETTING_OLPC_MESH_SETTING_NAME: string
const SETTING_OLPC_MESH_SSID: string
const SETTING_OVS_BRIDGE_DATAPATH_TYPE: string
const SETTING_OVS_BRIDGE_FAIL_MODE: string
const SETTING_OVS_BRIDGE_MCAST_SNOOPING_ENABLE: string
const SETTING_OVS_BRIDGE_RSTP_ENABLE: string
const SETTING_OVS_BRIDGE_SETTING_NAME: string
const SETTING_OVS_BRIDGE_STP_ENABLE: string
const SETTING_OVS_DPDK_DEVARGS: string
const SETTING_OVS_DPDK_N_RXQ: string
const SETTING_OVS_DPDK_SETTING_NAME: string
const SETTING_OVS_EXTERNAL_IDS_DATA: string
const SETTING_OVS_EXTERNAL_IDS_SETTING_NAME: string
const SETTING_OVS_INTERFACE_SETTING_NAME: string
const SETTING_OVS_INTERFACE_TYPE: string
const SETTING_OVS_PATCH_PEER: string
const SETTING_OVS_PATCH_SETTING_NAME: string
const SETTING_OVS_PORT_BOND_DOWNDELAY: string
const SETTING_OVS_PORT_BOND_MODE: string
const SETTING_OVS_PORT_BOND_UPDELAY: string
const SETTING_OVS_PORT_LACP: string
const SETTING_OVS_PORT_SETTING_NAME: string
const SETTING_OVS_PORT_TAG: string
const SETTING_OVS_PORT_VLAN_MODE: string
const SETTING_PARAM_FUZZY_IGNORE: number
const SETTING_PARAM_REQUIRED: number
const SETTING_PARAM_SECRET: number
const SETTING_PPPOE_PARENT: string
const SETTING_PPPOE_PASSWORD: string
const SETTING_PPPOE_PASSWORD_FLAGS: string
const SETTING_PPPOE_SERVICE: string
const SETTING_PPPOE_SETTING_NAME: string
const SETTING_PPPOE_USERNAME: string
const SETTING_PPP_BAUD: string
const SETTING_PPP_CRTSCTS: string
const SETTING_PPP_LCP_ECHO_FAILURE: string
const SETTING_PPP_LCP_ECHO_INTERVAL: string
const SETTING_PPP_MPPE_STATEFUL: string
const SETTING_PPP_MRU: string
const SETTING_PPP_MTU: string
const SETTING_PPP_NOAUTH: string
const SETTING_PPP_NOBSDCOMP: string
const SETTING_PPP_NODEFLATE: string
const SETTING_PPP_NO_VJ_COMP: string
const SETTING_PPP_REFUSE_CHAP: string
const SETTING_PPP_REFUSE_EAP: string
const SETTING_PPP_REFUSE_MSCHAP: string
const SETTING_PPP_REFUSE_MSCHAPV2: string
const SETTING_PPP_REFUSE_PAP: string
const SETTING_PPP_REQUIRE_MPPE: string
const SETTING_PPP_REQUIRE_MPPE_128: string
const SETTING_PPP_SETTING_NAME: string
const SETTING_PROXY_BROWSER_ONLY: string
const SETTING_PROXY_METHOD: string
const SETTING_PROXY_PAC_SCRIPT: string
const SETTING_PROXY_PAC_URL: string
const SETTING_PROXY_SETTING_NAME: string
const SETTING_SERIAL_BAUD: string
const SETTING_SERIAL_BITS: string
const SETTING_SERIAL_PARITY: string
const SETTING_SERIAL_SEND_DELAY: string
const SETTING_SERIAL_SETTING_NAME: string
const SETTING_SERIAL_STOPBITS: string
const SETTING_SRIOV_AUTOPROBE_DRIVERS: string
const SETTING_SRIOV_SETTING_NAME: string
const SETTING_SRIOV_TOTAL_VFS: string
const SETTING_SRIOV_VFS: string
const SETTING_TC_CONFIG_QDISCS: string
const SETTING_TC_CONFIG_SETTING_NAME: string
const SETTING_TC_CONFIG_TFILTERS: string
const SETTING_TEAM_CONFIG: string
const SETTING_TEAM_LINK_WATCHERS: string
const SETTING_TEAM_MCAST_REJOIN_COUNT: string
const SETTING_TEAM_MCAST_REJOIN_INTERVAL: string
const SETTING_TEAM_NOTIFY_MCAST_COUNT_ACTIVEBACKUP_DEFAULT: number
const SETTING_TEAM_NOTIFY_PEERS_COUNT: string
const SETTING_TEAM_NOTIFY_PEERS_COUNT_ACTIVEBACKUP_DEFAULT: number
const SETTING_TEAM_NOTIFY_PEERS_INTERVAL: string
const SETTING_TEAM_PORT_CONFIG: string
const SETTING_TEAM_PORT_LACP_KEY: string
const SETTING_TEAM_PORT_LACP_PRIO: string
const SETTING_TEAM_PORT_LACP_PRIO_DEFAULT: number
const SETTING_TEAM_PORT_LINK_WATCHERS: string
const SETTING_TEAM_PORT_PRIO: string
const SETTING_TEAM_PORT_QUEUE_ID: string
const SETTING_TEAM_PORT_QUEUE_ID_DEFAULT: number
const SETTING_TEAM_PORT_SETTING_NAME: string
const SETTING_TEAM_PORT_STICKY: string
const SETTING_TEAM_RUNNER: string
const SETTING_TEAM_RUNNER_ACTIVE: string
const SETTING_TEAM_RUNNER_ACTIVEBACKUP: string
const SETTING_TEAM_RUNNER_AGG_SELECT_POLICY: string
const SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_BANDWIDTH: string
const SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_COUNT: string
const SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO: string
const SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_LACP_PRIO_STABLE: string
const SETTING_TEAM_RUNNER_AGG_SELECT_POLICY_PORT_CONFIG: string
const SETTING_TEAM_RUNNER_BROADCAST: string
const SETTING_TEAM_RUNNER_FAST_RATE: string
const SETTING_TEAM_RUNNER_HWADDR_POLICY: string
const SETTING_TEAM_RUNNER_HWADDR_POLICY_BY_ACTIVE: string
const SETTING_TEAM_RUNNER_HWADDR_POLICY_ONLY_ACTIVE: string
const SETTING_TEAM_RUNNER_HWADDR_POLICY_SAME_ALL: string
const SETTING_TEAM_RUNNER_LACP: string
const SETTING_TEAM_RUNNER_LOADBALANCE: string
const SETTING_TEAM_RUNNER_MIN_PORTS: string
const SETTING_TEAM_RUNNER_RANDOM: string
const SETTING_TEAM_RUNNER_ROUNDROBIN: string
const SETTING_TEAM_RUNNER_SYS_PRIO: string
const SETTING_TEAM_RUNNER_SYS_PRIO_DEFAULT: number
const SETTING_TEAM_RUNNER_TX_BALANCER: string
const SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL: string
const SETTING_TEAM_RUNNER_TX_BALANCER_INTERVAL_DEFAULT: number
const SETTING_TEAM_RUNNER_TX_HASH: string
const SETTING_TEAM_SETTING_NAME: string
const SETTING_TUN_GROUP: string
const SETTING_TUN_MODE: string
const SETTING_TUN_MULTI_QUEUE: string
const SETTING_TUN_OWNER: string
const SETTING_TUN_PI: string
const SETTING_TUN_SETTING_NAME: string
const SETTING_TUN_VNET_HDR: string
const SETTING_USER_DATA: string
const SETTING_USER_SETTING_NAME: string
const SETTING_VETH_PEER: string
const SETTING_VETH_SETTING_NAME: string
const SETTING_VLAN_EGRESS_PRIORITY_MAP: string
const SETTING_VLAN_FLAGS: string
const SETTING_VLAN_ID: string
const SETTING_VLAN_INGRESS_PRIORITY_MAP: string
const SETTING_VLAN_PARENT: string
const SETTING_VLAN_SETTING_NAME: string
const SETTING_VPN_DATA: string
const SETTING_VPN_PERSISTENT: string
const SETTING_VPN_SECRETS: string
const SETTING_VPN_SERVICE_TYPE: string
const SETTING_VPN_SETTING_NAME: string
const SETTING_VPN_TIMEOUT: string
const SETTING_VPN_USER_NAME: string
const SETTING_VRF_SETTING_NAME: string
const SETTING_VRF_TABLE: string
const SETTING_VXLAN_AGEING: string
const SETTING_VXLAN_DESTINATION_PORT: string
const SETTING_VXLAN_ID: string
const SETTING_VXLAN_L2_MISS: string
const SETTING_VXLAN_L3_MISS: string
const SETTING_VXLAN_LEARNING: string
const SETTING_VXLAN_LIMIT: string
const SETTING_VXLAN_LOCAL: string
const SETTING_VXLAN_PARENT: string
const SETTING_VXLAN_PROXY: string
const SETTING_VXLAN_REMOTE: string
const SETTING_VXLAN_RSC: string
const SETTING_VXLAN_SETTING_NAME: string
const SETTING_VXLAN_SOURCE_PORT_MAX: string
const SETTING_VXLAN_SOURCE_PORT_MIN: string
const SETTING_VXLAN_TOS: string
const SETTING_VXLAN_TTL: string
/**
 * The mac address of the peer to connect to.
 */
const SETTING_WIFI_P2P_PEER: string
const SETTING_WIFI_P2P_SETTING_NAME: string
const SETTING_WIFI_P2P_WFD_IES: string
const SETTING_WIFI_P2P_WPS_METHOD: string
const SETTING_WIMAX_MAC_ADDRESS: string
const SETTING_WIMAX_NETWORK_NAME: string
const SETTING_WIMAX_SETTING_NAME: string
const SETTING_WIRED_ACCEPT_ALL_MAC_ADDRESSES: string
const SETTING_WIRED_AUTO_NEGOTIATE: string
const SETTING_WIRED_CLONED_MAC_ADDRESS: string
const SETTING_WIRED_DUPLEX: string
const SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK: string
const SETTING_WIRED_MAC_ADDRESS: string
const SETTING_WIRED_MAC_ADDRESS_BLACKLIST: string
const SETTING_WIRED_MTU: string
const SETTING_WIRED_PORT: string
const SETTING_WIRED_S390_NETTYPE: string
const SETTING_WIRED_S390_OPTIONS: string
const SETTING_WIRED_S390_SUBCHANNELS: string
const SETTING_WIRED_SETTING_NAME: string
const SETTING_WIRED_SPEED: string
const SETTING_WIRED_WAKE_ON_LAN: string
const SETTING_WIRED_WAKE_ON_LAN_PASSWORD: string
const SETTING_WIREGUARD_FWMARK: string
const SETTING_WIREGUARD_IP4_AUTO_DEFAULT_ROUTE: string
const SETTING_WIREGUARD_IP6_AUTO_DEFAULT_ROUTE: string
const SETTING_WIREGUARD_LISTEN_PORT: string
const SETTING_WIREGUARD_MTU: string
const SETTING_WIREGUARD_PEERS: string
const SETTING_WIREGUARD_PEER_ROUTES: string
const SETTING_WIREGUARD_PRIVATE_KEY: string
const SETTING_WIREGUARD_PRIVATE_KEY_FLAGS: string
const SETTING_WIREGUARD_SETTING_NAME: string
const SETTING_WIRELESS_AP_ISOLATION: string
const SETTING_WIRELESS_BAND: string
const SETTING_WIRELESS_BSSID: string
const SETTING_WIRELESS_CHANNEL: string
const SETTING_WIRELESS_CLONED_MAC_ADDRESS: string
const SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK: string
const SETTING_WIRELESS_HIDDEN: string
const SETTING_WIRELESS_MAC_ADDRESS: string
const SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST: string
const SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION: string
const SETTING_WIRELESS_MODE: string
/**
 * Indicates Ad-Hoc mode where no access point is expected to be present.
 */
const SETTING_WIRELESS_MODE_ADHOC: string
/**
 * Indicates AP/master mode where the wireless device is started as an access
 * point/hotspot.
 */
const SETTING_WIRELESS_MODE_AP: string
/**
 * Indicates infrastructure mode where an access point is expected to be present
 * for this connection.
 */
const SETTING_WIRELESS_MODE_INFRA: string
/**
 * Indicates that the connection should create a mesh point.
 */
const SETTING_WIRELESS_MODE_MESH: string
const SETTING_WIRELESS_MTU: string
const SETTING_WIRELESS_POWERSAVE: string
const SETTING_WIRELESS_RATE: string
const SETTING_WIRELESS_SECURITY_AUTH_ALG: string
const SETTING_WIRELESS_SECURITY_FILS: string
const SETTING_WIRELESS_SECURITY_GROUP: string
const SETTING_WIRELESS_SECURITY_KEY_MGMT: string
const SETTING_WIRELESS_SECURITY_LEAP_PASSWORD: string
const SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS: string
const SETTING_WIRELESS_SECURITY_LEAP_USERNAME: string
const SETTING_WIRELESS_SECURITY_PAIRWISE: string
const SETTING_WIRELESS_SECURITY_PMF: string
const SETTING_WIRELESS_SECURITY_PROTO: string
const SETTING_WIRELESS_SECURITY_PSK: string
const SETTING_WIRELESS_SECURITY_PSK_FLAGS: string
const SETTING_WIRELESS_SECURITY_SETTING_NAME: string
const SETTING_WIRELESS_SECURITY_WEP_KEY0: string
const SETTING_WIRELESS_SECURITY_WEP_KEY1: string
const SETTING_WIRELESS_SECURITY_WEP_KEY2: string
const SETTING_WIRELESS_SECURITY_WEP_KEY3: string
const SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS: string
const SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE: string
const SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX: string
const SETTING_WIRELESS_SECURITY_WPS_METHOD: string
const SETTING_WIRELESS_SEEN_BSSIDS: string
const SETTING_WIRELESS_SETTING_NAME: string
const SETTING_WIRELESS_SSID: string
const SETTING_WIRELESS_TX_POWER: string
const SETTING_WIRELESS_WAKE_ON_WLAN: string
const SETTING_WPAN_CHANNEL: string
const SETTING_WPAN_CHANNEL_DEFAULT: number
const SETTING_WPAN_MAC_ADDRESS: string
const SETTING_WPAN_PAGE: string
const SETTING_WPAN_PAGE_DEFAULT: number
const SETTING_WPAN_PAN_ID: string
const SETTING_WPAN_SETTING_NAME: string
const SETTING_WPAN_SHORT_ADDRESS: string
const SRIOV_VF_ATTRIBUTE_MAC: string
const SRIOV_VF_ATTRIBUTE_MAX_TX_RATE: string
const SRIOV_VF_ATTRIBUTE_MIN_TX_RATE: string
const SRIOV_VF_ATTRIBUTE_SPOOF_CHECK: string
const SRIOV_VF_ATTRIBUTE_TRUST: string
const TEAM_LINK_WATCHER_ARP_PING: string
const TEAM_LINK_WATCHER_ETHTOOL: string
const TEAM_LINK_WATCHER_NSNA_PING: string
/**
 * The maximum length of hardware addresses handled by NetworkManager itself,
 * nm_utils_hwaddr_len(), and nm_utils_hwaddr_aton().
 */
const UTILS_HWADDR_LEN_MAX: number
const VLAN_FLAGS_ALL: number
const VPN_CONNECTION_BANNER: string
const VPN_CONNECTION_VPN_STATE: string
const VPN_DBUS_PLUGIN_INTERFACE: string
const VPN_DBUS_PLUGIN_PATH: string
const VPN_EDITOR_PLUGIN_DESCRIPTION: string
const VPN_EDITOR_PLUGIN_NAME: string
const VPN_EDITOR_PLUGIN_SERVICE: string
const VPN_PLUGIN_CAN_PERSIST: string
const VPN_PLUGIN_CONFIG_BANNER: string
const VPN_PLUGIN_CONFIG_EXT_GATEWAY: string
const VPN_PLUGIN_CONFIG_HAS_IP4: string
const VPN_PLUGIN_CONFIG_HAS_IP6: string
const VPN_PLUGIN_CONFIG_MTU: string
const VPN_PLUGIN_CONFIG_PROXY_PAC: string
const VPN_PLUGIN_CONFIG_TUNDEV: string
const VPN_PLUGIN_INFO_FILENAME: string
const VPN_PLUGIN_INFO_KEYFILE: string
const VPN_PLUGIN_INFO_KF_GROUP_CONNECTION: string
const VPN_PLUGIN_INFO_KF_GROUP_GNOME: string
const VPN_PLUGIN_INFO_KF_GROUP_LIBNM: string
const VPN_PLUGIN_INFO_NAME: string
const VPN_PLUGIN_IP4_CONFIG_ADDRESS: string
const VPN_PLUGIN_IP4_CONFIG_DNS: string
const VPN_PLUGIN_IP4_CONFIG_DOMAIN: string
const VPN_PLUGIN_IP4_CONFIG_DOMAINS: string
const VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY: string
const VPN_PLUGIN_IP4_CONFIG_MSS: string
const VPN_PLUGIN_IP4_CONFIG_NBNS: string
const VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT: string
const VPN_PLUGIN_IP4_CONFIG_PREFIX: string
const VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES: string
const VPN_PLUGIN_IP4_CONFIG_PTP: string
const VPN_PLUGIN_IP4_CONFIG_ROUTES: string
const VPN_PLUGIN_IP6_CONFIG_ADDRESS: string
const VPN_PLUGIN_IP6_CONFIG_DNS: string
const VPN_PLUGIN_IP6_CONFIG_DOMAIN: string
const VPN_PLUGIN_IP6_CONFIG_DOMAINS: string
const VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY: string
const VPN_PLUGIN_IP6_CONFIG_MSS: string
const VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT: string
const VPN_PLUGIN_IP6_CONFIG_PREFIX: string
const VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES: string
const VPN_PLUGIN_IP6_CONFIG_PTP: string
const VPN_PLUGIN_IP6_CONFIG_ROUTES: string
const VPN_PLUGIN_OLD_DBUS_SERVICE_NAME: string
const VPN_PLUGIN_OLD_STATE: string
const VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME: string
const VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER: string
const VPN_SERVICE_PLUGIN_STATE: string
const WIFI_P2P_PEER_FLAGS: string
const WIFI_P2P_PEER_HW_ADDRESS: string
const WIFI_P2P_PEER_LAST_SEEN: string
const WIFI_P2P_PEER_MANUFACTURER: string
const WIFI_P2P_PEER_MODEL: string
const WIFI_P2P_PEER_MODEL_NUMBER: string
const WIFI_P2P_PEER_NAME: string
const WIFI_P2P_PEER_SERIAL: string
const WIFI_P2P_PEER_STRENGTH: string
const WIFI_P2P_PEER_WFD_IES: string
const WIMAX_NSP_NAME: string
const WIMAX_NSP_NETWORK_TYPE: string
const WIMAX_NSP_SIGNAL_QUALITY: string
const WIREGUARD_PEER_ATTR_ALLOWED_IPS: string
const WIREGUARD_PEER_ATTR_ENDPOINT: string
const WIREGUARD_PEER_ATTR_PERSISTENT_KEEPALIVE: string
const WIREGUARD_PEER_ATTR_PRESHARED_KEY: string
const WIREGUARD_PEER_ATTR_PRESHARED_KEY_FLAGS: string
const WIREGUARD_PEER_ATTR_PUBLIC_KEY: string
const WIREGUARD_PUBLIC_KEY_LEN: number
const WIREGUARD_SYMMETRIC_KEY_LEN: number
function agent_manager_error_quark(): GLib.Quark
function bridge_vlan_from_str(str: string): BridgeVlan
function client_error_quark(): GLib.Quark
function connection_error_quark(): GLib.Quark
function crypto_error_quark(): GLib.Quark
function device_error_quark(): GLib.Quark
function ethtool_optname_is_coalesce(optname?: string | null): boolean
function ethtool_optname_is_feature(optname?: string | null): boolean
function ethtool_optname_is_pause(optname?: string | null): boolean
function ethtool_optname_is_ring(optname?: string | null): boolean
function ip_route_attribute_validate(name: string, value: GLib.Variant, family: number): [ /* returnType */ boolean, /* known */ boolean ]
function ip_route_get_variant_attribute_spec(): VariantAttributeSpec
function ip_routing_rule_from_string(str: string, to_string_flags: IPRoutingRuleAsStringFlags, extra_args?: GLib.HashTable | null): IPRoutingRule
function keyfile_read(keyfile: GLib.KeyFile, base_dir: string, handler_flags: KeyfileHandlerFlags, handler?: KeyfileReadHandler | null): Connection
function keyfile_write(connection: Connection, handler_flags: KeyfileHandlerFlags, handler?: KeyfileWriteHandler | null): GLib.KeyFile
function manager_error_quark(): GLib.Quark
function secret_agent_error_quark(): GLib.Quark
function settings_error_quark(): GLib.Quark
function sriov_vf_attribute_validate(name: string, value: GLib.Variant): [ /* returnType */ boolean, /* known */ boolean ]
function utils_ap_mode_security_valid(type: UtilsSecurityType, wifi_caps: DeviceWifiCapabilities): boolean
function utils_base64secret_decode(base64_key: string, required_key_len: number, out_key?: number | null): boolean
function utils_bin2hexstr(src: Uint8Array, final_len: number): string
function utils_bond_mode_int_to_string(mode: number): string
function utils_bond_mode_string_to_int(mode: string): number
function utils_check_virtual_device_compatibility(virtual_type: GObject.Type, other_type: GObject.Type): boolean
function utils_enum_from_str(type: GObject.Type, str: string): [ /* returnType */ boolean, /* out_value */ number | null, /* err_token */ string | null ]
function utils_enum_get_values(type: GObject.Type, from: number, to: number): string[]
function utils_enum_to_str(type: GObject.Type, value: number): string
function utils_escape_ssid(ssid: Uint8Array): string
function utils_file_is_certificate(filename: string): boolean
function utils_file_is_pkcs12(filename: string): boolean
function utils_file_is_private_key(filename: string): [ /* returnType */ boolean, /* out_encrypted */ boolean ]
function utils_file_search_in_paths(progname: string, try_first: string | null, paths: string | null, file_test_flags: GLib.FileTest, predicate: UtilsFileSearchInPathsPredicate): string
function utils_format_variant_attributes(attributes: GLib.HashTable, attr_separator: number, key_value_separator: number): string
function utils_get_timestamp_msec(): number
function utils_hexstr2bin(hex: string): GLib.Bytes
function utils_hwaddr_atoba(asc: string, length: number): Uint8Array
function utils_hwaddr_aton(asc: string, buffer: Uint8Array): number
function utils_hwaddr_canonical(asc: string, length: number): string
function utils_hwaddr_len(type: number): number
function utils_hwaddr_matches(hwaddr1: object | null, hwaddr1_len: number, hwaddr2: object | null, hwaddr2_len: number): boolean
function utils_hwaddr_ntoa(addr: Uint8Array): string
function utils_hwaddr_valid(asc: string, length: number): boolean
function utils_iface_valid_name(name?: string | null): boolean
function utils_ip4_addresses_from_variant(value: GLib.Variant): [ /* returnType */ IPAddress[], /* out_gateway */ string | null ]
function utils_ip4_addresses_to_variant(addresses: IPAddress[], gateway?: string | null): GLib.Variant
function utils_ip4_dns_from_variant(value: GLib.Variant): string
function utils_ip4_dns_to_variant(dns: string): GLib.Variant
function utils_ip4_get_default_prefix(ip: number): number
function utils_ip4_netmask_to_prefix(netmask: number): number
function utils_ip4_prefix_to_netmask(prefix: number): number
function utils_ip4_routes_from_variant(value: GLib.Variant): IPRoute[]
function utils_ip4_routes_to_variant(routes: IPRoute[]): GLib.Variant
function utils_ip6_addresses_from_variant(value: GLib.Variant): [ /* returnType */ IPAddress[], /* out_gateway */ string | null ]
function utils_ip6_addresses_to_variant(addresses: IPAddress[], gateway?: string | null): GLib.Variant
function utils_ip6_dns_from_variant(value: GLib.Variant): string
function utils_ip6_dns_to_variant(dns: string): GLib.Variant
function utils_ip6_routes_from_variant(value: GLib.Variant): IPRoute[]
function utils_ip6_routes_to_variant(routes: IPRoute[]): GLib.Variant
function utils_ip_addresses_from_variant(value: GLib.Variant, family: number): IPAddress[]
function utils_ip_addresses_to_variant(addresses: IPAddress[]): GLib.Variant
function utils_ip_routes_from_variant(value: GLib.Variant, family: number): IPRoute[]
function utils_ip_routes_to_variant(routes: IPRoute[]): GLib.Variant
function utils_ipaddr_valid(family: number, ip: string): boolean
function utils_is_empty_ssid(ssid: Uint8Array): boolean
function utils_is_json_object(str: string): boolean
function utils_is_uuid(str?: string | null): boolean
function utils_is_valid_iface_name(name?: string | null): boolean
function utils_parse_variant_attributes(string: string, attr_separator: number, key_value_separator: number, ignore_unknown: boolean, spec: VariantAttributeSpec): GLib.HashTable
function utils_print(output_mode: number, msg: string): void
function utils_same_ssid(ssid1: Uint8Array, ssid2: Uint8Array, ignore_trailing_null: boolean): boolean
function utils_security_valid(type: UtilsSecurityType, wifi_caps: DeviceWifiCapabilities, have_ap: boolean, adhoc: boolean, ap_flags: TODO_80211ApFlags, ap_wpa: TODO_80211ApSecurityFlags, ap_rsn: TODO_80211ApSecurityFlags): boolean
function utils_sriov_vf_from_str(str: string): SriovVF
function utils_sriov_vf_to_str(vf: SriovVF, omit_index: boolean): string
function utils_ssid_to_utf8(ssid: Uint8Array): string
function utils_tc_action_from_str(str: string): TCAction
function utils_tc_action_to_str(action: TCAction): string
function utils_tc_qdisc_from_str(str: string): TCQdisc
function utils_tc_qdisc_to_str(qdisc: TCQdisc): string
function utils_tc_tfilter_from_str(str: string): TCTfilter
function utils_tc_tfilter_to_str(tfilter: TCTfilter): string
function utils_uuid_generate(): string
function utils_version(): number
function utils_wep_key_valid(key: string, wep_type: WepKeyType): boolean
function utils_wifi_2ghz_freqs(): number
function utils_wifi_5ghz_freqs(): number
function utils_wifi_channel_to_freq(channel: number, band: string): number
function utils_wifi_find_next_channel(channel: number, direction: number, band: string): number
function utils_wifi_freq_to_channel(freq: number): number
function utils_wifi_is_channel_valid(channel: number, band: string): boolean
function utils_wifi_strength_bars(strength: number): string
function utils_wpa_psk_valid(psk: string): boolean
function vpn_editor_plugin_load(plugin_name: string, check_service: string): VpnEditorPlugin
function vpn_editor_plugin_load_from_file(plugin_name: string, check_service: string, check_owner: number, check_file: UtilsCheckFilePredicate): VpnEditorPlugin
function vpn_plugin_error_quark(): GLib.Quark
/**
 * Hook to nm_keyfile_read().
 * 
 * The callee may abort the reading by setting an error via nm_keyfile_handler_data_fail_with_error().
 */
interface KeyfileReadHandler {
    (keyfile: GLib.KeyFile, connection: Connection, handler_type: KeyfileHandlerType, handler_data: KeyfileHandlerData): boolean
}
/**
 * This is a hook to tweak the serialization.
 * 
 * Handler for certain properties or events that are not entirely contained
 * within the keyfile or that might be serialized differently. The `type` and
 * `handler_data` arguments tell which kind of argument we have at hand.
 * 
 * Currently only the type %NM_KEYFILE_HANDLER_TYPE_WRITE_CERT is supported.
 * 
 * The callee may call nm_keyfile_handler_data_fail_with_error() to abort
 * the writing with error.
 */
interface KeyfileWriteHandler {
    (connection: Connection, keyfile: GLib.KeyFile, handler_type: KeyfileHandlerType, handler_data: KeyfileHandlerData): boolean
}
/**
 * Called as a result of a request by NM to delete secrets.  When the
 * #NMSecretAgentOld subclass has finished deleting the secrets, this function
 * should be called.
 */
interface SecretAgentOldDeleteSecretsFunc {
    (agent: SecretAgentOld, connection: Connection, error: GLib.Error): void
}
/**
 * Called as a result of a request by NM to retrieve secrets.  When the
 * #NMSecretAgentOld subclass has finished retrieving secrets and is ready to
 * return them, or to return an error, this function should be called with
 * those secrets or the error.
 * 
 * To easily create the dictionary to return the Wi-Fi PSK, you could do
 * something like this:
 * <example>
 *  <title>Creating a secrets dictionary</title>
 *  <programlisting>
 *   NMConnection *secrets;
 *   NMSettingWirelessSecurity *s_wsec;
 *   GVariant *secrets_dict;
 * 
 *   secrets = nm_simple_connection_new ();
 *   s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
 *   g_object_set (G_OBJECT (s_wsec),
 *                 NM_SETTING_WIRELESS_SECURITY_PSK, "my really cool PSK",
 *                 NULL);
 *   nm_connection_add_setting (secrets, NM_SETTING (s_wsec));
 *   secrets_dict = nm_connection_to_dbus (secrets, NM_CONNECTION_SERIALIZE_ALL);
 * 
 *   (call the NMSecretAgentOldGetSecretsFunc with secrets_dict)
 * 
 *   g_object_unref (secrets);
 *   g_variant_unref (secrets_dict);
 *  </programlisting>
 * </example>
 */
interface SecretAgentOldGetSecretsFunc {
    (agent: SecretAgentOld, connection: Connection, secrets: GLib.Variant, error: GLib.Error): void
}
/**
 * Called as a result of a request by NM to save secrets.  When the
 * #NMSecretAgentOld subclass has finished saving the secrets, this function
 * should be called.
 */
interface SecretAgentOldSaveSecretsFunc {
    (agent: SecretAgentOld, connection: Connection, error: GLib.Error): void
}
interface SettingClearSecretsWithFlagsFn {
    (setting: Setting, secret: string, flags: SettingSecretFlags): boolean
}
interface SettingValueIterFn {
    (setting: Setting, key: string, value: any, flags: GObject.ParamFlags): void
}
interface UtilsCheckFilePredicate {
    (filename: string, stat?: object | null): boolean
}
interface UtilsFileSearchInPathsPredicate {
    (filename: string): boolean
}
/**
 * This function takes a string argument and returns either %TRUE or %FALSE.
 * It is a general purpose predicate, for example used by nm_setting_option_clear_by_name().
 */
interface UtilsPredicateStr {
    (str: string): boolean
}
interface VpnIterFunc {
    (key: string, value: string): void
}
interface _ConnectionForEachSecretFunc {
    (flags: SettingSecretFlags): boolean
}
class Connection {
    /* Methods of NM-1.0.NM.Connection */
    /**
     * Adds a #NMSetting to the connection, replacing any previous #NMSetting of the
     * same name which has previously been added to the #NMConnection.  The
     * connection takes ownership of the #NMSetting object and does not increase
     * the setting object's reference count.
     */
    add_setting(setting: Setting): void
    /**
     * Clears and frees any secrets that may be stored in the connection, to avoid
     * keeping secret data in memory when not needed.
     */
    clear_secrets(): void
    /**
     * Clears and frees secrets determined by `func`.
     */
    clear_secrets_with_flags(func?: SettingClearSecretsWithFlagsFn | null): void
    /**
     * Deletes all of `connection'`s settings.
     */
    clear_settings(): void
    /**
     * Compares two #NMConnection objects for similarity, with comparison behavior
     * modified by a set of flags.  See nm_setting_compare() for a description of
     * each flag's behavior.
     */
    compare(b: Connection, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMConnection objects for similarity, with comparison behavior
     * modified by a set of flags.  See nm_setting_compare() for a description of
     * each flag's behavior.  If the connections differ, settings and keys within
     * each setting that differ are added to the returned `out_settings` hash table.
     * No values are returned, only key names.
     */
    diff(b: Connection, flags: SettingCompareFlags, out_settings: GLib.HashTable): boolean
    /**
     * Print the connection (including secrets!) to stdout. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    dump(): void
    /**
     * Iterates over the properties of each #NMSetting object in the #NMConnection,
     * calling the supplied user function for each property.
     */
    for_each_setting_value(func: SettingValueIterFn): void
    /**
     * A shortcut to return the type from the connection's #NMSettingConnection.
     */
    get_connection_type(): string
    /**
     * A shortcut to return the ID from the connection's #NMSettingConnection.
     */
    get_id(): string
    /**
     * Returns the interface name as stored in NMSettingConnection:interface_name.
     * If the connection contains no NMSettingConnection, it will return %NULL.
     * 
     * For hardware devices and software devices created outside of NetworkManager,
     * this name is used to match the device. for software devices created by
     * NetworkManager, this is the name of the created interface.
     */
    get_interface_name(): string
    /**
     * Returns the connection's D-Bus path.
     */
    get_path(): string
    /**
     * Gets the #NMSetting with the given #GType, if one has been previously added
     * to the #NMConnection.
     */
    get_setting(setting_type: GObject.Type): Setting
    /**
     * A shortcut to return any #NMSetting8021x the connection might contain.
     */
    get_setting_802_1x(): Setting8021x
    /**
     * A shortcut to return any #NMSettingAdsl the connection might contain.
     */
    get_setting_adsl(): SettingAdsl
    /**
     * A shortcut to return any #NMSettingBluetooth the connection might contain.
     */
    get_setting_bluetooth(): SettingBluetooth
    /**
     * A shortcut to return any #NMSettingBond the connection might contain.
     */
    get_setting_bond(): SettingBond
    /**
     * A shortcut to return any #NMSettingBridge the connection might contain.
     */
    get_setting_bridge(): SettingBridge
    /**
     * A shortcut to return any #NMSettingBridgePort the connection might contain.
     */
    get_setting_bridge_port(): SettingBridgePort
    /**
     * Gets the #NMSetting with the given name, if one has been previously added
     * the #NMConnection.
     */
    get_setting_by_name(name: string): Setting
    /**
     * A shortcut to return any #NMSettingCdma the connection might contain.
     */
    get_setting_cdma(): SettingCdma
    /**
     * A shortcut to return any #NMSettingConnection the connection might contain.
     */
    get_setting_connection(): SettingConnection
    /**
     * A shortcut to return any #NMSettingDcb the connection might contain.
     */
    get_setting_dcb(): SettingDcb
    /**
     * A shortcut to return any #NMSettingDummy the connection might contain.
     */
    get_setting_dummy(): SettingDummy
    /**
     * A shortcut to return any #NMSettingGeneric the connection might contain.
     */
    get_setting_generic(): SettingGeneric
    /**
     * A shortcut to return any #NMSettingGsm the connection might contain.
     */
    get_setting_gsm(): SettingGsm
    /**
     * A shortcut to return any #NMSettingInfiniband the connection might contain.
     */
    get_setting_infiniband(): SettingInfiniband
    /**
     * A shortcut to return any #NMSettingIP4Config the connection might contain.
     * 
     * Note that it returns the value as type #NMSettingIPConfig, since the vast
     * majority of IPv4-setting-related methods are on that type, not
     * #NMSettingIP4Config.
     */
    get_setting_ip4_config(): SettingIP4Config
    /**
     * A shortcut to return any #NMSettingIP6Config the connection might contain.
     * 
     * Note that it returns the value as type #NMSettingIPConfig, since the vast
     * majority of IPv6-setting-related methods are on that type, not
     * #NMSettingIP6Config.
     */
    get_setting_ip6_config(): SettingIP6Config
    /**
     * A shortcut to return any #NMSettingIPTunnel the connection might contain.
     */
    get_setting_ip_tunnel(): SettingIPTunnel
    /**
     * A shortcut to return any #NMSettingMacsec the connection might contain.
     */
    get_setting_macsec(): SettingMacsec
    /**
     * A shortcut to return any #NMSettingMacvlan the connection might contain.
     */
    get_setting_macvlan(): SettingMacvlan
    /**
     * A shortcut to return any #NMSettingOlpcMesh the connection might contain.
     */
    get_setting_olpc_mesh(): SettingOlpcMesh
    /**
     * A shortcut to return any #NMSettingOvsBridge the connection might contain.
     */
    get_setting_ovs_bridge(): SettingOvsBridge
    /**
     * A shortcut to return any #NMSettingOvsInterface the connection might contain.
     */
    get_setting_ovs_interface(): SettingOvsInterface
    /**
     * A shortcut to return any #NMSettingOvsPatch the connection might contain.
     */
    get_setting_ovs_patch(): SettingOvsPatch
    /**
     * A shortcut to return any #NMSettingOvsPort the connection might contain.
     */
    get_setting_ovs_port(): SettingOvsPort
    /**
     * A shortcut to return any #NMSettingPpp the connection might contain.
     */
    get_setting_ppp(): SettingPpp
    /**
     * A shortcut to return any #NMSettingPppoe the connection might contain.
     */
    get_setting_pppoe(): SettingPppoe
    /**
     * A shortcut to return any #NMSettingProxy the connection might contain.
     */
    get_setting_proxy(): SettingProxy
    /**
     * A shortcut to return any #NMSettingSerial the connection might contain.
     */
    get_setting_serial(): SettingSerial
    /**
     * A shortcut to return any #NMSettingTCConfig the connection might contain.
     */
    get_setting_tc_config(): SettingTCConfig
    /**
     * A shortcut to return any #NMSettingTeam the connection might contain.
     */
    get_setting_team(): SettingTeam
    /**
     * A shortcut to return any #NMSettingTeamPort the connection might contain.
     */
    get_setting_team_port(): SettingTeamPort
    /**
     * A shortcut to return any #NMSettingTun the connection might contain.
     */
    get_setting_tun(): SettingTun
    /**
     * A shortcut to return any #NMSettingVlan the connection might contain.
     */
    get_setting_vlan(): SettingVlan
    /**
     * A shortcut to return any #NMSettingVpn the connection might contain.
     */
    get_setting_vpn(): SettingVpn
    /**
     * A shortcut to return any #NMSettingVxlan the connection might contain.
     */
    get_setting_vxlan(): SettingVxlan
    /**
     * A shortcut to return any #NMSettingWimax the connection might contain.
     */
    get_setting_wimax(): SettingWimax
    /**
     * A shortcut to return any #NMSettingWired the connection might contain.
     */
    get_setting_wired(): SettingWired
    /**
     * A shortcut to return any #NMSettingWireless the connection might contain.
     */
    get_setting_wireless(): SettingWireless
    /**
     * A shortcut to return any #NMSettingWirelessSecurity the connection might contain.
     */
    get_setting_wireless_security(): SettingWirelessSecurity
    /**
     * Retrieves the settings in `connection`.
     * 
     * The returned array is %NULL-terminated.
     */
    get_settings(): Setting[]
    /**
     * A shortcut to return the UUID from the connection's #NMSettingConnection.
     */
    get_uuid(): string
    /**
     * Returns the name that nm_device_disambiguate_names() would
     * return for the virtual device that would be created for `connection`.
     * Eg, "VLAN (eth1.1)".
     */
    get_virtual_device_description(): string
    /**
     * A convenience function to check if the given `connection` is a particular
     * type (ie wired, Wi-Fi, ppp, etc). Checks the #NMSettingConnection:type
     * property of the connection and matches that against `type`.
     */
    is_type(type: string): boolean
    /**
     * Checks if `connection` refers to a virtual device (and thus can potentially be
     * activated even if the device it refers to doesn't exist).
     */
    is_virtual(): boolean
    /**
     * Returns the name of the first setting object in the connection which would
     * need secrets to make a successful connection.  The returned hints are only
     * intended as a guide to what secrets may be required, because in some
     * circumstances, there is no way to conclusively determine exactly which
     * secrets are needed.
     */
    need_secrets(): [ /* returnType */ string, /* hints */ string[] | null ]
    /**
     * Does some basic normalization and fixup of well known inconsistencies
     * and deprecated fields. If the connection was modified in any way,
     * the output parameter `modified` is set %TRUE.
     * 
     * Finally the connection will be verified and %TRUE returns if the connection
     * is valid. As this function only performs some specific normalization steps
     * it cannot repair all connections. If the connection has errors that
     * cannot be normalized, the connection will not be modified.
     */
    normalize(parameters?: GLib.HashTable | null): [ /* returnType */ boolean, /* modified */ boolean | null ]
    /**
     * Removes the #NMSetting with the given #GType from the #NMConnection.  This
     * operation dereferences the #NMSetting object.
     */
    remove_setting(setting_type: GObject.Type): void
    /**
     * Replaces `connection'`s settings with `new_settings` (which must be
     * syntactically valid, and describe a known type of connection, but does not
     * need to result in a connection that passes nm_connection_verify()).
     */
    replace_settings(new_settings: GLib.Variant): boolean
    /**
     * Deep-copies the settings of `new_connection` and replaces the settings of `connection`
     * with the copied settings.
     */
    replace_settings_from_connection(new_connection: Connection): void
    /**
     * Sets the D-Bus path of the connection.  This property is not serialized, and
     * is only for the reference of the caller.  Sets the #NMConnection:path
     * property.
     */
    set_path(path: string): void
    /**
     * Converts the #NMConnection into a #GVariant of type
     * %NM_VARIANT_TYPE_CONNECTION describing the connection, suitable for
     * marshalling over D-Bus or otherwise serializing.
     */
    to_dbus(flags: ConnectionSerializationFlags): GLib.Variant
    /**
     * Update the specified setting's secrets, given a dictionary of secrets
     * intended for that setting (deserialized from D-Bus for example).  Will also
     * extract the given setting's secrets hash if given a connection dictionary.
     * If `setting_name` is %NULL, expects a fully serialized #NMConnection as
     * returned by nm_connection_to_dbus() and will update all secrets from all
     * settings contained in `secrets`.
     */
    update_secrets(setting_name: string, secrets: GLib.Variant): boolean
    /**
     * Validates the connection and all its settings.  Each setting's properties
     * have allowed values, and some values are dependent on other values.  For
     * example, if a Wi-Fi connection is security enabled, the #NMSettingWireless
     * setting object's 'security' property must contain the setting name of the
     * #NMSettingWirelessSecurity object, which must also be present in the
     * connection for the connection to be valid.  As another example, the
     * #NMSettingWired object's 'mac-address' property must be a validly formatted
     * MAC address.  The returned #GError contains information about which
     * setting and which property failed validation, and how it failed validation.
     */
    verify(): boolean
    /**
     * Verifies the secrets in the connection.
     */
    verify_secrets(): boolean
    /* Virtual methods of NM-1.0.NM.Connection */
    vfunc_changed(): void
    vfunc_secrets_cleared(): void
    vfunc_secrets_updated(setting: string): void
    /* Signals of NM-1.0.NM.Connection */
    /**
     * The ::changed signal is emitted when any property (including secrets)
     * of any setting of the connection is modified, or when settings are
     * added or removed.
     */
    connect(sigName: "changed", callback: (($obj: Connection) => void)): number
    connect_after(sigName: "changed", callback: (($obj: Connection) => void)): number
    emit(sigName: "changed"): void
    /**
     * The ::secrets-cleared signal is emitted when the secrets of a connection
     * are cleared.
     */
    connect(sigName: "secrets-cleared", callback: (($obj: Connection) => void)): number
    connect_after(sigName: "secrets-cleared", callback: (($obj: Connection) => void)): number
    emit(sigName: "secrets-cleared"): void
    /**
     * The ::secrets-updated signal is emitted when the secrets of a setting
     * have been changed.
     */
    connect(sigName: "secrets-updated", callback: (($obj: Connection, setting_name: string) => void)): number
    connect_after(sigName: "secrets-updated", callback: (($obj: Connection, setting_name: string) => void)): number
    emit(sigName: "secrets-updated", setting_name: string): void
    static name: string
}
class VpnEditor {
    /* Methods of NM-1.0.NM.VpnEditor */
    get_widget(): GObject.Object
    update_connection(connection: Connection): boolean
    /* Virtual methods of NM-1.0.NM.VpnEditor */
    vfunc_changed(): void
    vfunc_get_widget(): GObject.Object
    vfunc_update_connection(connection: Connection): boolean
    /* Signals of NM-1.0.NM.VpnEditor */
    connect(sigName: "changed", callback: (($obj: VpnEditor) => void)): number
    connect_after(sigName: "changed", callback: (($obj: VpnEditor) => void)): number
    emit(sigName: "changed"): void
    static name: string
}
class VpnEditorPlugin {
    /* Properties of NM-1.0.NM.VpnEditorPlugin */
    /**
     * Longer description of the VPN plugin.
     */
    readonly description: string
    /**
     * Short display name of the VPN plugin.
     */
    readonly name: string
    /**
     * D-Bus service name of the plugin's VPN service.
     */
    readonly service: string
    /* Methods of NM-1.0.NM.VpnEditorPlugin */
    export(path: string, connection: Connection): boolean
    get_capabilities(): VpnEditorPluginCapability
    get_editor(connection: Connection): VpnEditor
    get_plugin_info(): VpnPluginInfo
    get_suggested_filename(connection: Connection): string
    /**
     * Returns an opaque VT function table for the plugin to extend
     * functionality. The actual meaning of NMVpnEditorPluginVT is not
     * defined in public API of libnm, instead it must be agreed by
     * both the plugin and the caller. See the header-only file
     * 'nm-vpn-editor-plugin-call.h' which defines the meaning.
     */
    get_vt(vt_size: number): [ /* returnType */ number, /* vt */ VpnEditorPluginVT ]
    import(path: string): Connection
    /**
     * Set or clear the plugin-info instance.
     * This takes a weak reference on `plugin_info,` to avoid circular
     * reference as the plugin-info might also reference the editor-plugin.
     */
    set_plugin_info(plugin_info?: VpnPluginInfo | null): void
    /* Virtual methods of NM-1.0.NM.VpnEditorPlugin */
    vfunc_export_to_file(path: string, connection: Connection): boolean
    vfunc_get_capabilities(): VpnEditorPluginCapability
    vfunc_get_editor(connection: Connection): VpnEditor
    vfunc_get_suggested_filename(connection: Connection): string
    vfunc_get_vt(out_vt_size: number): VpnEditorPluginVT
    vfunc_notify_plugin_info_set(plugin_info: VpnPluginInfo): void
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Load the shared library `plugin_name` and create a new
     * #NMVpnEditorPlugin instance via the #NMVpnEditorPluginFactory
     * function.
     * 
     * This is similar to nm_vpn_editor_plugin_load_from_file(), but
     * it does no validation of the plugin name, instead passes it directly
     * to dlopen(). If you have the full path to a plugin file,
     * nm_vpn_editor_plugin_load_from_file() is preferred.
     */
    static load(plugin_name: string, check_service: string): VpnEditorPlugin
    /**
     * Load the shared library `plugin_name` and create a new
     * #NMVpnEditorPlugin instance via the #NMVpnEditorPluginFactory
     * function.
     * 
     * If `plugin_name` is not an absolute path name, it assumes the file
     * is in the plugin directory of NetworkManager. In any case, the call
     * will do certain checks on the file before passing it to dlopen.
     * A consequence for that is, that you cannot omit the ".so" suffix
     * as you could for nm_vpn_editor_plugin_load().
     */
    static load_from_file(plugin_name: string, check_service: string, check_owner: number, check_file: UtilsCheckFilePredicate): VpnEditorPlugin
}
interface AccessPoint_ConstructProps extends Object_ConstructProps {
}
class AccessPoint {
    /* Properties of NM-1.0.NM.AccessPoint */
    /**
     * The BSSID of the access point.
     */
    readonly bssid: string
    /**
     * The flags of the access point.
     */
    readonly flags: TODO_80211ApFlags
    /**
     * The frequency of the access point.
     */
    readonly frequency: number
    /**
     * Alias for #NMAccessPoint:bssid.
     */
    readonly hw_address: string
    /**
     * The timestamp (in CLOCK_BOOTTIME seconds) for the last time the
     * access point was found in scan results.  A value of -1 means the
     * access point has not been found in a scan.
     */
    readonly last_seen: number
    /**
     * The maximum bit rate of the access point in kbit/s.
     */
    readonly max_bitrate: number
    /**
     * The mode of the access point; either "infrastructure" (a central
     * coordinator of the wireless network allowing clients to connect) or
     * "ad-hoc" (a network with no central controller).
     */
    readonly mode: TODO_80211Mode
    /**
     * The RSN flags of the access point.
     */
    readonly rsn_flags: TODO_80211ApSecurityFlags
    /**
     * The SSID of the access point, or %NULL if it is not known.
     */
    readonly ssid: GLib.Bytes
    /**
     * The current signal strength of the access point.
     */
    readonly strength: number
    /**
     * The WPA flags of the access point.
     */
    readonly wpa_flags: TODO_80211ApSecurityFlags
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.AccessPoint */
    /**
     * Validates a given connection against a given Wi-Fi access point to ensure that
     * the connection may be activated with that AP.  The connection must match the
     * `ap'`s SSID, (if given) BSSID, and other attributes like security settings,
     * channel, band, etc.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Filters a given array of connections for a given #NMAccessPoint object and
     * returns connections which may be activated with the access point.  Any
     * returned connections will match the `ap'`s SSID and (if given) BSSID and
     * other attributes like security settings, channel, etc.
     * 
     * To obtain the list of connections that are compatible with this access point,
     * use nm_client_get_connections() and then filter the returned list for a given
     * #NMDevice using nm_device_filter_connections() and finally filter that list
     * with this function.
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the Basic Service Set ID (BSSID) of the Wi-Fi access point.
     */
    get_bssid(): string
    /**
     * Gets the flags of the access point.
     */
    get_flags(): TODO_80211ApFlags
    /**
     * Gets the frequency of the access point in MHz.
     */
    get_frequency(): number
    /**
     * Returns the timestamp (in CLOCK_BOOTTIME seconds) for the last time the
     * access point was found in scan results.  A value of -1 means the access
     * point has not been found in a scan.
     */
    get_last_seen(): number
    /**
     * Gets the maximum bit rate of the access point in kbit/s.
     */
    get_max_bitrate(): number
    /**
     * Gets the mode of the access point.
     */
    get_mode(): TODO_80211Mode
    /**
     * Gets the RSN (Robust Secure Network, ie WPA version 2) flags of the access
     * point.
     */
    get_rsn_flags(): TODO_80211ApSecurityFlags
    /**
     * Gets the SSID of the access point.
     */
    get_ssid(): GLib.Bytes
    /**
     * Gets the current signal strength of the access point as a percentage.
     */
    get_strength(): number
    /**
     * Gets the WPA (version 1) flags of the access point.
     */
    get_wpa_flags(): TODO_80211ApSecurityFlags
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::bssid", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bssid", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::flags", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::frequency", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::frequency", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::last-seen", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-seen", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-bitrate", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-bitrate", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::rsn-flags", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rsn-flags", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ssid", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ssid", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::strength", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::strength", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wpa-flags", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wpa-flags", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: AccessPoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: AccessPoint_ConstructProps)
    _init (config?: AccessPoint_ConstructProps): void
    static $gtype: GObject.Type
}
interface ActiveConnection_ConstructProps extends Object_ConstructProps {
}
class ActiveConnection {
    /* Properties of NM-1.0.NM.ActiveConnection */
    /**
     * The connection that this is an active instance of.
     */
    readonly connection: RemoteConnection
    /**
     * Whether the active connection is the default IPv4 one.
     */
    readonly "default": boolean
    /**
     * Whether the active connection is the default IPv6 one.
     */
    readonly default6: boolean
    /**
     * The devices of the active connection.
     */
    readonly devices: Device[]
    /**
     * The IPv4 #NMDhcpConfig of the connection.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the connection.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The active connection's ID
     */
    readonly id: string
    /**
     * The IPv4 #NMIPConfig of the connection.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv6 #NMIPConfig of the connection.
     */
    readonly ip6_config: IPConfig
    /**
     * The master device if one exists.
     */
    readonly master: Device
    /**
     * The path to the "specific object" of the active connection; see
     * nm_active_connection_get_specific_object_path() for more details.
     */
    readonly specific_object_path: string
    /**
     * The state of the active connection.
     */
    readonly state: ActiveConnectionState
    /**
     * The state flags of the active connection.
     */
    readonly state_flags: number
    /**
     * The active connection's type
     */
    readonly type: string
    /**
     * The active connection's UUID
     */
    readonly uuid: string
    /**
     * Whether the active connection is a VPN connection.
     */
    readonly vpn: boolean
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.ActiveConnection */
    /**
     * Gets the #NMRemoteConnection associated with `connection`.
     */
    get_connection(): RemoteConnection
    /**
     * Gets the #NMConnection's type.
     */
    get_connection_type(): string
    /**
     * Whether the active connection is the default IPv4 one (that is, is used for
     * the default IPv4 route and DNS information).
     */
    get_default(): boolean
    /**
     * Whether the active connection is the default IPv6 one (that is, is used for
     * the default IPv6 route and DNS information).
     */
    get_default6(): boolean
    /**
     * Gets the #NMDevices used for the active connections.
     */
    get_devices(): Device[]
    /**
     * Gets the current IPv4 #NMDhcpConfig (if any) associated with the
     * #NMActiveConnection.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig (if any) associated with the
     * #NMActiveConnection.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the #NMConnection's ID.
     */
    get_id(): string
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMActiveConnection.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMActiveConnection.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the master #NMDevice of the connection.
     */
    get_master(): Device
    /**
     * Gets the path of the "specific object" used at activation.
     * 
     * Currently, there is no single method that will allow you to automatically turn
     * this into an appropriate #NMObject; you need to know what kind of object it
     * is based on other information. (Eg, if `connection` corresponds to a Wi-Fi
     * connection, then the specific object will be an #NMAccessPoint, and you can
     * resolve it with nm_device_wifi_get_access_point_by_path().)
     */
    get_specific_object_path(): string
    /**
     * Gets the active connection's state.
     */
    get_state(): ActiveConnectionState
    /**
     * Gets the active connection's state flags.
     */
    get_state_flags(): ActivationStateFlags
    /**
     * Gets the reason for active connection's state.
     */
    get_state_reason(): ActiveConnectionStateReason
    /**
     * Gets the #NMConnection's UUID.
     */
    get_uuid(): string
    /**
     * Whether the active connection is a VPN connection.
     */
    get_vpn(): boolean
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.ActiveConnection */
    connect(sigName: "state-changed", callback: (($obj: ActiveConnection, state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: ActiveConnection, state: number, reason: number) => void)): number
    emit(sigName: "state-changed", state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::connection", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::default", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::default", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::default6", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::default6", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::devices", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::devices", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::master", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::master", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::specific-object-path", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::specific-object-path", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-flags", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-flags", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::type", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::uuid", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uuid", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vpn", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vpn", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: ActiveConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: ActiveConnection_ConstructProps)
    _init (config?: ActiveConnection_ConstructProps): void
    static $gtype: GObject.Type
}
interface Checkpoint_ConstructProps extends Object_ConstructProps {
}
class Checkpoint {
    /* Properties of NM-1.0.NM.Checkpoint */
    /**
     * The timestamp (in CLOCK_BOOTTIME milliseconds) of checkpoint creation.
     */
    readonly created: number
    /**
     * The devices that are part of this checkpoint.
     */
    readonly devices: Device[]
    /**
     * Timeout in seconds for automatic rollback, or zero.
     */
    readonly rollback_timeout: number
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Checkpoint */
    /**
     * Gets the timestamp (in CLOCK_BOOTTIME milliseconds) of checkpoint creation.
     * 
     * Use nm_utils_get_timestamp_msec() to obtain current time value suitable for
     * comparing to this value.
     */
    get_created(): number
    /**
     * The devices that are part of this checkpoint.
     */
    get_devices(): Device[]
    /**
     * Gets the timeout in seconds for automatic rollback.
     */
    get_rollback_timeout(): number
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::created", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::created", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::devices", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::devices", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::rollback-timeout", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rollback-timeout", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: Checkpoint, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Checkpoint_ConstructProps)
    _init (config?: Checkpoint_ConstructProps): void
    static $gtype: GObject.Type
}
interface Client_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of NM-1.0.NM.Client */
    connectivity_check_enabled?: boolean
    /**
     * The #GDBusConnection to use.
     * 
     * If this is not set during object construction, the D-Bus connection will
     * automatically be chosen during async/sync initalization via g_bus_get().
     */
    dbus_connection?: Gio.DBusConnection
    /**
     * #NMClientInstanceFlags for the instance. These affect behavior of #NMClient.
     * This is a construct property and you may only set most flags only during
     * construction.
     * 
     * The flag %NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS can be toggled any time,
     * even after constructing the instance. Note that you may want to watch NMClient:permissions-state
     * property to know whether permissions are ready. Note that permissions are only fetched
     * when NMClient has a D-Bus name owner.
     */
    instance_flags?: number
    /**
     * Whether networking is enabled.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    networking_enabled?: boolean
    /**
     * Whether WiMAX functionality is enabled.
     */
    wimax_enabled?: boolean
    /**
     * Whether wireless is enabled.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    wireless_enabled?: boolean
    /**
     * Whether WWAN functionality is enabled.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    wwan_enabled?: boolean
}
class Client {
    /* Properties of NM-1.0.NM.Client */
    /**
     * The #NMActiveConnection of the activating connection that is
     * likely to become the new #NMClient:primary-connection.
     */
    readonly activating_connection: ActiveConnection
    /**
     * The active connections.
     */
    readonly active_connections: ActiveConnection[]
    /**
     * List of both real devices and device placeholders.
     */
    readonly all_devices: Device[]
    /**
     * If %TRUE, adding and modifying connections is supported.
     */
    readonly can_modify: boolean
    /**
     * The list of capabilities numbers as guint32 or %NULL if
     * there are no capabilities. The numeric value correspond
     * to %NMCapability enum.
     */
    readonly capabilities: number[]
    /**
     * The list of active checkpoints.
     */
    readonly checkpoints: Checkpoint[]
    /**
     * The list of configured connections that are available to the user. (Note
     * that this differs from the underlying D-Bus property, which may also
     * contain the object paths of connections that the user does not have
     * permission to read the details of.)
     */
    readonly connections: RemoteConnection[]
    /**
     * The network connectivity state.
     */
    readonly connectivity: ConnectivityState
    readonly connectivity_check_available: boolean
    connectivity_check_enabled: boolean
    /**
     * The used URI for connectivity checking.
     */
    readonly connectivity_check_uri: string
    /**
     * The name owner of the NetworkManager D-Bus service.
     */
    readonly dbus_name_owner: string
    /**
     * List of real network devices.  Does not include placeholder devices.
     */
    readonly devices: Device[]
    /**
     * The current DNS configuration, represented as an array
     * of #NMDnsEntry objects.
     */
    readonly dns_configuration: DnsEntry[]
    /**
     * The current DNS processing mode.
     */
    readonly dns_mode: string
    /**
     * The current resolv.conf management mode.
     */
    readonly dns_rc_manager: string
    /**
     * The machine hostname stored in persistent configuration. This can be
     * modified by calling nm_client_save_hostname().
     */
    readonly hostname: string
    /**
     * #NMClientInstanceFlags for the instance. These affect behavior of #NMClient.
     * This is a construct property and you may only set most flags only during
     * construction.
     * 
     * The flag %NM_CLIENT_INSTANCE_FLAGS_NO_AUTO_FETCH_PERMISSIONS can be toggled any time,
     * even after constructing the instance. Note that you may want to watch NMClient:permissions-state
     * property to know whether permissions are ready. Note that permissions are only fetched
     * when NMClient has a D-Bus name owner.
     */
    instance_flags: number
    /**
     * Whether the connectivity is metered.
     */
    readonly metered: number
    /**
     * Whether networking is enabled.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    networking_enabled: boolean
    /**
     * Whether the daemon is running.
     */
    readonly nm_running: boolean
    /**
     * The state of the cached permissions. The value %NM_TERNARY_DEFAULT
     * means that no permissions are yet received (or not yet requested).
     * %NM_TERNARY_TRUE means that permissions are received, cached and up
     * to date. %NM_TERNARY_FALSE means that permissions were received and are
     * cached, but in the meantime a "CheckPermissions" signal was received
     * that invalidated the cached permissions.
     * Note that NMClient will always emit a notify::permissions-state signal
     * when a "CheckPermissions" signal got received or after new permissions
     * got received (that is regardless whether the value of the permission state
     * actually changed). With this you can watch the permissions-state property
     * to know whether the permissions are ready. Note that while NMClient has
     * no D-Bus name owner, no permissions are fetched (and this property won't
     * change).
     */
    readonly permissions_state: Ternary
    /**
     * The #NMActiveConnection of the device with the default route;
     * see nm_client_get_primary_connection() for more details.
     */
    readonly primary_connection: ActiveConnection
    /**
     * Whether the daemon is still starting up.
     */
    readonly startup: boolean
    /**
     * The current daemon state.
     */
    readonly state: State
    /**
     * The NetworkManager version.
     */
    readonly version: string
    /**
     * Whether WiMAX functionality is enabled.
     */
    wimax_enabled: boolean
    /**
     * Whether the WiMAX hardware is enabled.
     */
    readonly wimax_hardware_enabled: boolean
    /**
     * Whether wireless is enabled.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    wireless_enabled: boolean
    /**
     * Whether the wireless hardware is enabled.
     */
    readonly wireless_hardware_enabled: boolean
    /**
     * Whether WWAN functionality is enabled.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    wwan_enabled: boolean
    /**
     * Whether the WWAN hardware is enabled.
     */
    readonly wwan_hardware_enabled: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Client */
    /**
     * Asynchronously starts a connection to a particular network using the
     * configuration settings from `connection` and the network device `device`.
     * Certain connection types also take a "specific object" which is the object
     * path of a connection- specific object, like an #NMAccessPoint for Wi-Fi
     * connections, or an #NMWimaxNsp for WiMAX connections, to which you wish to
     * connect.  If the specific object is not given, NetworkManager can, in some
     * cases, automatically determine which network to connect to given the settings
     * in `connection`.
     * 
     * If `connection` is not given for a device-based activation, NetworkManager
     * picks the best available connection for the device and activates it.
     * 
     * Note that the callback is invoked when NetworkManager has started activating
     * the new connection, not when it finishes. You can use the returned
     * #NMActiveConnection object (in particular, #NMActiveConnection:state) to
     * track the activation to its completion.
     */
    activate_connection_async(connection?: Connection | null, device?: Device | null, specific_object?: string | null, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_activate_connection_async().
     */
    activate_connection_finish(result: Gio.AsyncResult): ActiveConnection
    /**
     * Adds a new connection using the given details (if any) as a template,
     * automatically filling in missing settings with the capabilities of the given
     * device and specific object.  The new connection is then asynchronously
     * activated as with nm_client_activate_connection_async(). Cannot be used for
     * VPN connections at this time.
     * 
     * Note that the callback is invoked when NetworkManager has started activating
     * the new connection, not when it finishes. You can used the returned
     * #NMActiveConnection object (in particular, #NMActiveConnection:state) to
     * track the activation to its completion.
     * 
     * This is identical to nm_client_add_and_activate_connection_async() but takes
     * a further `options` parameter. Currently, the following options are supported
     * by the daemon:
     *  * "persist": A string describing how the connection should be stored.
     *               The default is "disk", but it can be modified to "memory" (until
     *               the daemon quits) or "volatile" (will be deleted on disconnect).
     *  * "bind-activation": Bind the connection lifetime to something. The default is "none",
     *            meaning an explicit disconnect is needed. The value "dbus-client"
     *            means the connection will automatically be deactivated when the calling
     *            D-Bus client disappears from the system bus.
     */
    add_and_activate_connection2(partial: Connection | null, device: Device, specific_object: string | null, options: GLib.Variant, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_add_and_activate_connection2().
     * 
     * You can call nm_active_connection_get_connection() on the returned
     * #NMActiveConnection to find the path of the created #NMConnection.
     */
    add_and_activate_connection2_finish(result: Gio.AsyncResult): [ /* returnType */ ActiveConnection, /* out_result */ GLib.Variant | null ]
    /**
     * Adds a new connection using the given details (if any) as a template,
     * automatically filling in missing settings with the capabilities of the given
     * device and specific object.  The new connection is then asynchronously
     * activated as with nm_client_activate_connection_async(). Cannot be used for
     * VPN connections at this time.
     * 
     * Note that the callback is invoked when NetworkManager has started activating
     * the new connection, not when it finishes. You can used the returned
     * #NMActiveConnection object (in particular, #NMActiveConnection:state) to
     * track the activation to its completion.
     */
    add_and_activate_connection_async(partial: Connection | null, device: Device, specific_object?: string | null, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_add_and_activate_connection_async().
     * 
     * You can call nm_active_connection_get_connection() on the returned
     * #NMActiveConnection to find the path of the created #NMConnection.
     */
    add_and_activate_connection_finish(result: Gio.AsyncResult): ActiveConnection
    /**
     * Call AddConnection2() D-Bus API asynchronously.
     */
    add_connection2(settings: GLib.Variant, flags: SettingsAddConnection2Flags, args: GLib.Variant | null, ignore_out_result: boolean, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    add_connection2_finish(result: Gio.AsyncResult): [ /* returnType */ RemoteConnection, /* out_result */ GLib.Variant | null ]
    /**
     * Requests that the remote settings service add the given settings to a new
     * connection.  If `save_to_disk` is %TRUE, the connection is immediately written
     * to disk; otherwise it is initially only stored in memory, but may be saved
     * later by calling the connection's nm_remote_connection_commit_changes()
     * method.
     * 
     * `connection` is untouched by this function and only serves as a template of
     * the settings to add.  The #NMRemoteConnection object that represents what
     * NetworkManager actually added is returned to `callback` when the addition
     * operation is complete.
     * 
     * Note that the #NMRemoteConnection returned in `callback` may not contain
     * identical settings to `connection` as NetworkManager may perform automatic
     * completion and/or normalization of connection properties.
     */
    add_connection_async(connection: Connection, save_to_disk: boolean, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_add_connection_async().
     */
    add_connection_finish(result: Gio.AsyncResult): RemoteConnection
    /**
     * Updates the network connectivity state and returns the (new)
     * current state. Contrast nm_client_get_connectivity(), which returns
     * the most recent known state without re-checking.
     * 
     * This is a blocking call; use nm_client_check_connectivity_async()
     * if you do not want to block.
     */
    check_connectivity(cancellable?: Gio.Cancellable | null): ConnectivityState
    /**
     * Asynchronously updates the network connectivity state and invokes
     * `callback` when complete. Contrast nm_client_get_connectivity(),
     * which (immediately) returns the most recent known state without
     * re-checking, and nm_client_check_connectivity(), which blocks.
     */
    check_connectivity_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Retrieves the result of an nm_client_check_connectivity_async()
     * call.
     */
    check_connectivity_finish(result: Gio.AsyncResult): ConnectivityState
    /**
     * Resets the timeout for the checkpoint with path `checkpoint_path`
     * to `timeout_add`.
     */
    checkpoint_adjust_rollback_timeout(checkpoint_path: string, add_timeout: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_checkpoint_adjust_rollback_timeout().
     */
    checkpoint_adjust_rollback_timeout_finish(result: Gio.AsyncResult): boolean
    /**
     * Creates a checkpoint of the current networking configuration
     * for given interfaces. An empty `devices` argument means all
     * devices. If `rollback_timeout` is not zero, a rollback is
     * automatically performed after the given timeout.
     */
    checkpoint_create(devices: Device[], rollback_timeout: number, flags: CheckpointCreateFlags, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_checkpoint_create().
     */
    checkpoint_create_finish(result: Gio.AsyncResult): Checkpoint
    /**
     * Destroys an existing checkpoint without performing a rollback.
     */
    checkpoint_destroy(checkpoint_path: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_checkpoint_destroy().
     */
    checkpoint_destroy_finish(result: Gio.AsyncResult): boolean
    /**
     * Performs the rollback of a checkpoint before the timeout is reached.
     */
    checkpoint_rollback(checkpoint_path: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_checkpoint_rollback().
     */
    checkpoint_rollback_finish(result: Gio.AsyncResult): GLib.HashTable
    /**
     * Determine whether connectivity checking is available.  This
     * requires that the URI of a connectivity service has been set in the
     * configuration file.
     */
    connectivity_check_get_available(): boolean
    /**
     * Determine whether connectivity checking is enabled.
     */
    connectivity_check_get_enabled(): boolean
    /**
     * Get the URI that will be queried to determine if there is internet
     * connectivity.
     */
    connectivity_check_get_uri(): string
    /**
     * Enable or disable connectivity checking.  Note that if a
     * connectivity checking URI has not been configured, this will not
     * have any effect.
     */
    connectivity_check_set_enabled(enabled: boolean): void
    /**
     * Call g_dbus_connection_call() on the current name owner with the specified
     * arguments. Most importantly, this invokes g_dbus_connection_call() with the
     * client's #GMainContext, so that the response is always in order with other
     * events D-Bus events. Of course, the call uses #GTask and will invoke the
     * callback on the current g_main_context_get_thread_default().
     * 
     * This API is merely a convenient wrapper for g_dbus_connection_call(). You can
     * also use g_dbus_connection_call() directly, with the same effect.
     */
    dbus_call(object_path: string, interface_name: string, method_name: string, parameters: GLib.Variant | null, reply_type: GLib.VariantType | null, timeout_msec: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_dbus_call().
     */
    dbus_call_finish(result: Gio.AsyncResult): GLib.Variant
    /**
     * Like nm_client_dbus_call() but calls "Set" on the standard "org.freedesktop.DBus.Properties"
     * D-Bus interface.
     */
    dbus_set_property(object_path: string, interface_name: string, property_name: string, value: GLib.Variant, timeout_msec: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_dbus_set_property().
     */
    dbus_set_property_finish(result: Gio.AsyncResult): boolean
    /**
     * Deactivates an active #NMActiveConnection.
     */
    deactivate_connection(active: ActiveConnection, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously deactivates an active #NMActiveConnection.
     */
    deactivate_connection_async(active: ActiveConnection, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_client_deactivate_connection_async().
     */
    deactivate_connection_finish(result: Gio.AsyncResult): boolean
    /**
     * Gets the #NMActiveConnection corresponding to a
     * currently-activating connection that is expected to become the new
     * #NMClient:primary-connection upon successful activation.
     */
    get_activating_connection(): ActiveConnection
    /**
     * Gets the active connections.
     */
    get_active_connections(): ActiveConnection[]
    /**
     * Gets both real devices and device placeholders (eg, software devices which
     * do not currently exist, but could be created automatically by NetworkManager
     * if one of their NMDevice::ActivatableConnections was activated).  Use
     * nm_device_is_real() to determine whether each device is a real device or
     * a placeholder.
     * 
     * Use nm_device_get_type() or the NM_IS_DEVICE_XXXX() functions to determine
     * what kind of device each member of the returned array is, and then you may
     * use device-specific methods such as nm_device_ethernet_get_hw_address().
     */
    get_all_devices(): Device[]
    get_capabilities(): number[]
    /**
     * Gets all the active checkpoints.
     */
    get_checkpoints(): Checkpoint[]
    /**
     * Returns the first matching %NMRemoteConnection matching a given `id`.
     */
    get_connection_by_id(id: string): RemoteConnection
    /**
     * Returns the %NMRemoteConnection representing the connection at `path`.
     */
    get_connection_by_path(path: string): RemoteConnection
    /**
     * Returns the %NMRemoteConnection identified by `uuid`.
     */
    get_connection_by_uuid(uuid: string): RemoteConnection
    get_connections(): RemoteConnection[]
    /**
     * Gets the current network connectivity state. Contrast
     * nm_client_check_connectivity() and
     * nm_client_check_connectivity_async(), which re-check the
     * connectivity state first before returning any information.
     */
    get_connectivity(): ConnectivityState
    get_context_busy_watcher(): GObject.Object
    /**
     * Gets the %GDBusConnection of the instance. This can be either passed when
     * constructing the instance (as "dbus-connection" property), or it will be
     * automatically initialized during async/sync init.
     */
    get_dbus_connection(): Gio.DBusConnection
    get_dbus_name_owner(): string
    /**
     * Gets a #NMDevice from a #NMClient.
     */
    get_device_by_iface(iface: string): Device
    /**
     * Gets a #NMDevice from a #NMClient.
     */
    get_device_by_path(object_path: string): Device
    /**
     * Gets all the known network devices.  Use nm_device_get_type() or the
     * <literal>NM_IS_DEVICE_XXXX</literal> functions to determine what kind of
     * device member of the returned array is, and then you may use device-specific
     * methods such as nm_device_ethernet_get_hw_address().
     */
    get_devices(): Device[]
    /**
     * Gets the current DNS configuration
     */
    get_dns_configuration(): DnsEntry[]
    /**
     * Gets the current DNS processing mode.
     */
    get_dns_mode(): string
    /**
     * Gets the current DNS resolv.conf manager.
     */
    get_dns_rc_manager(): string
    get_instance_flags(): ClientInstanceFlags
    /**
     * Gets NetworkManager current logging level and domains.
     */
    get_logging(level?: string | null, domains?: string | null): boolean
    /**
     * The #NMClient instance is permanently associated with the current
     * thread default #GMainContext, referenced the time when the instance
     * was created. To receive events, the user must iterate this context
     * and can use it to synchronize access to the client.
     * 
     * Note that even after #NMClient instance got destroyed, there might
     * still be pending sources registered in the context. That means, to fully
     * clean up, the user must continue iterating the context as long as
     * the nm_client_get_context_busy_watcher() object is alive.
     */
    get_main_context(): GLib.MainContext
    get_metered(): Metered
    /**
     * Determines whether the daemon is running.
     */
    get_nm_running(): boolean
    get_object_by_path(dbus_path: string): Object
    /**
     * Requests the result of a specific permission, which indicates whether the
     * client can or cannot perform the action the permission represents
     */
    get_permission_result(permission: ClientPermission): ClientPermissionResult
    get_permissions_state(): Ternary
    /**
     * Gets the #NMActiveConnection corresponding to the primary active
     * network device.
     * 
     * In particular, when there is no VPN active, or the VPN does not
     * have the default route, this returns the active connection that has
     * the default route. If there is a VPN active with the default route,
     * then this function returns the active connection that contains the
     * route to the VPN endpoint.
     * 
     * If there is no default route, or the default route is over a
     * non-NetworkManager-recognized device, this will return %NULL.
     */
    get_primary_connection(): ActiveConnection
    /**
     * Tests whether the daemon is still in the process of activating
     * connections at startup.
     */
    get_startup(): boolean
    /**
     * Gets the current daemon state.
     */
    get_state(): State
    /**
     * Gets NetworkManager version.
     */
    get_version(): string
    /**
     * Requests that the remote settings service load or reload the given files,
     * adding or updating the connections described within.
     * 
     * The changes to the indicated files will not yet be reflected in
     * `client'`s connections array when the function returns.
     * 
     * If all of the indicated files were successfully loaded, the
     * function will return %TRUE, and `failures` will be set to %NULL. If
     * NetworkManager tried to load the files, but some (or all) failed,
     * then `failures` will be set to a %NULL-terminated array of the
     * filenames that failed to load.
     */
    load_connections(filenames: string[], cancellable?: Gio.Cancellable | null): [ /* returnType */ boolean, /* failures */ string ]
    /**
     * Requests that the remote settings service asynchronously load or reload the
     * given files, adding or updating the connections described within.
     * 
     * See nm_client_load_connections() for more details.
     */
    load_connections_async(filenames: string[], cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of an nm_client_load_connections_async() call.
     * 
     * See nm_client_load_connections() for more details.
     */
    load_connections_finish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* failures */ string[] ]
    /**
     * Whether networking is enabled or disabled.
     */
    networking_get_enabled(): boolean
    /**
     * Enables or disables networking.  When networking is disabled, all controlled
     * interfaces are disconnected and deactivated.  When networking is enabled,
     * all controlled interfaces are available for activation.
     */
    networking_set_enabled(enabled: boolean): boolean
    /**
     * Reload NetworkManager's configuration and perform certain updates, like
     * flushing caches or rewriting external state to disk. This is similar to
     * sending SIGHUP to NetworkManager but it allows for more fine-grained control
     * over what to reload (see `flags)`. It also allows non-root access via
     * PolicyKit and contrary to signals it is synchronous.
     */
    reload(flags: ManagerReloadFlags, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Requests that the remote settings service reload all connection
     * files from disk, adding, updating, and removing connections until
     * the in-memory state matches the on-disk state.
     */
    reload_connections(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Requests that the remote settings service begin reloading all connection
     * files from disk, adding, updating, and removing connections until the
     * in-memory state matches the on-disk state.
     */
    reload_connections_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of an nm_client_reload_connections_async() call.
     */
    reload_connections_finish(result: Gio.AsyncResult): boolean
    /**
     * Gets the result of a call to nm_client_reload().
     */
    reload_finish(result: Gio.AsyncResult): boolean
    /**
     * Requests that the machine's persistent hostname be set to the specified value
     * or cleared.
     */
    save_hostname(hostname?: string | null, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Requests that the machine's persistent hostname be set to the specified value
     * or cleared.
     */
    save_hostname_async(hostname?: string | null, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of an nm_client_save_hostname_async() call.
     */
    save_hostname_finish(result: Gio.AsyncResult): boolean
    /**
     * Sets NetworkManager logging level and/or domains.
     */
    set_logging(level?: string | null, domains?: string | null): boolean
    /**
     * Determines whether WiMAX is enabled.
     */
    wimax_get_enabled(): boolean
    /**
     * Determines whether the WiMAX hardware is enabled.
     */
    wimax_hardware_get_enabled(): boolean
    /**
     * Enables or disables WiMAX devices.
     */
    wimax_set_enabled(enabled: boolean): void
    /**
     * Determines whether the wireless is enabled.
     */
    wireless_get_enabled(): boolean
    /**
     * Determines whether the wireless hardware is enabled.
     */
    wireless_hardware_get_enabled(): boolean
    /**
     * Enables or disables wireless devices.
     */
    wireless_set_enabled(enabled: boolean): void
    /**
     * Determines whether WWAN is enabled.
     */
    wwan_get_enabled(): boolean
    /**
     * Determines whether the WWAN hardware is enabled.
     */
    wwan_hardware_get_enabled(): boolean
    /**
     * Enables or disables WWAN devices.
     */
    wwan_set_enabled(enabled: boolean): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of NM-1.0.NM.Client */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Client */
    /**
     * Notifies that a #NMActiveConnection has been added.
     */
    connect(sigName: "active-connection-added", callback: (($obj: Client, active_connection: ActiveConnection) => void)): number
    connect_after(sigName: "active-connection-added", callback: (($obj: Client, active_connection: ActiveConnection) => void)): number
    emit(sigName: "active-connection-added", active_connection: ActiveConnection): void
    /**
     * Notifies that a #NMActiveConnection has been removed.
     */
    connect(sigName: "active-connection-removed", callback: (($obj: Client, active_connection: ActiveConnection) => void)): number
    connect_after(sigName: "active-connection-removed", callback: (($obj: Client, active_connection: ActiveConnection) => void)): number
    emit(sigName: "active-connection-removed", active_connection: ActiveConnection): void
    /**
     * Notifies that a #NMDevice is added.  This signal is emitted for both
     * regular devices and placeholder devices.
     */
    connect(sigName: "any-device-added", callback: (($obj: Client, device: Device) => void)): number
    connect_after(sigName: "any-device-added", callback: (($obj: Client, device: Device) => void)): number
    emit(sigName: "any-device-added", device: Device): void
    /**
     * Notifies that a #NMDevice is removed.  This signal is emitted for both
     * regular devices and placeholder devices.
     */
    connect(sigName: "any-device-removed", callback: (($obj: Client, device: Device) => void)): number
    connect_after(sigName: "any-device-removed", callback: (($obj: Client, device: Device) => void)): number
    emit(sigName: "any-device-removed", device: Device): void
    /**
     * Notifies that a #NMConnection has been added.
     */
    connect(sigName: "connection-added", callback: (($obj: Client, connection: RemoteConnection) => void)): number
    connect_after(sigName: "connection-added", callback: (($obj: Client, connection: RemoteConnection) => void)): number
    emit(sigName: "connection-added", connection: RemoteConnection): void
    /**
     * Notifies that a #NMConnection has been removed.
     */
    connect(sigName: "connection-removed", callback: (($obj: Client, connection: RemoteConnection) => void)): number
    connect_after(sigName: "connection-removed", callback: (($obj: Client, connection: RemoteConnection) => void)): number
    emit(sigName: "connection-removed", connection: RemoteConnection): void
    /**
     * Notifies that a #NMDevice is added.  This signal is not emitted for
     * placeholder devices.
     */
    connect(sigName: "device-added", callback: (($obj: Client, device: Device) => void)): number
    connect_after(sigName: "device-added", callback: (($obj: Client, device: Device) => void)): number
    emit(sigName: "device-added", device: Device): void
    /**
     * Notifies that a #NMDevice is removed.  This signal is not emitted for
     * placeholder devices.
     */
    connect(sigName: "device-removed", callback: (($obj: Client, device: Device) => void)): number
    connect_after(sigName: "device-removed", callback: (($obj: Client, device: Device) => void)): number
    emit(sigName: "device-removed", device: Device): void
    /**
     * Notifies that a permission has changed
     */
    connect(sigName: "permission-changed", callback: (($obj: Client, permission: number, result: number) => void)): number
    connect_after(sigName: "permission-changed", callback: (($obj: Client, permission: number, result: number) => void)): number
    emit(sigName: "permission-changed", permission: number, result: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::activating-connection", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::activating-connection", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connections", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connections", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::all-devices", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::all-devices", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::can-modify", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-modify", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::checkpoints", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::checkpoints", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::connections", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connections", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::connectivity", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connectivity", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::connectivity-check-available", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connectivity-check-available", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::connectivity-check-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connectivity-check-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::connectivity-check-uri", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connectivity-check-uri", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dbus-name-owner", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dbus-name-owner", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::devices", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::devices", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-configuration", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-configuration", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-mode", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-mode", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-rc-manager", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-rc-manager", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hostname", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hostname", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::instance-flags", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::instance-flags", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::networking-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::networking-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-running", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-running", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::permissions-state", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::permissions-state", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::primary-connection", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::primary-connection", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::startup", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::startup", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::version", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::version", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wimax-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wimax-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wimax-hardware-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wimax-hardware-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wireless-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wireless-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wireless-hardware-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wireless-hardware-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wwan-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wwan-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wwan-hardware-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wwan-hardware-enabled", callback: (($obj: Client, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Client_ConstructProps)
    _init (config?: Client_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(cancellable?: Gio.Cancellable | null): Client
    static new_finish(result: Gio.AsyncResult): Client
    /**
     * Creates a new #NMClient asynchronously.
     * `callback` will be called when it is done. Use
     * nm_client_new_finish() to get the result.
     * 
     * This does nothing beside calling g_async_initable_new_async(). You are free to
     * call g_async_initable_new_async() or g_object_new()/g_async_initable_init_async()
     * directly for more control, to set GObject properties or get access to the NMClient
     * instance while it is still initializing.
     * 
     * Creating an #NMClient instance can only fail for two reasons. First, if you didn't
     * provide a %NM_CLIENT_DBUS_CONNECTION and the call to g_bus_get()
     * fails. You can avoid that by using g_async_initable_new_async() directly and
     * set a D-Bus connection.
     * Second, if you cancelled the creation. If you do that, then note
     * that after the failure there might still be idle actions pending
     * which keep nm_client_get_main_context() alive. That means,
     * in that case you must continue iterating the context to avoid
     * leaks. See nm_client_get_context_busy_watcher().
     * 
     * Creating an #NMClient instance when NetworkManager is not running
     * does not cause a failure.
     */
    static new_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface Device_ConstructProps extends Object_ConstructProps {
    /* Constructor properties of NM-1.0.NM.Device */
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect?: boolean
}
class Device {
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: Device, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: Device, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::active-connection", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: Device, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Device_ConstructProps)
    _init (config?: Device_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Generates a list of short-ish unique presentation names for the
     * devices in `devices`.
     */
    static disambiguate_names(devices: Device[]): string[]
    static $gtype: GObject.Type
}
interface Device6Lowpan_ConstructProps extends Device_ConstructProps {
}
class Device6Lowpan {
    /* Properties of NM-1.0.NM.Device6Lowpan */
    /**
     * The devices's parent device.
     */
    readonly parent: Device
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Device6Lowpan */
    get_parent(): Device
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: Device6Lowpan, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: Device6Lowpan, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parent", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: Device6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Device6Lowpan_ConstructProps)
    _init (config?: Device6Lowpan_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceAdsl_ConstructProps extends Device_ConstructProps {
}
class DeviceAdsl {
    /* Properties of NM-1.0.NM.DeviceAdsl */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceAdsl */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceAdsl, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceAdsl, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::carrier", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceAdsl_ConstructProps)
    _init (config?: DeviceAdsl_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceBond_ConstructProps extends Device_ConstructProps {
}
class DeviceBond {
    /* Properties of NM-1.0.NM.DeviceBond */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /**
     * The devices enslaved to the bond device.
     */
    readonly slaves: Device[]
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceBond */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    /**
     * Gets the devices currently enslaved to `device`.
     */
    get_slaves(): Device[]
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceBond, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceBond, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::carrier", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::slaves", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::slaves", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceBond_ConstructProps)
    _init (config?: DeviceBond_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceBridge_ConstructProps extends Device_ConstructProps {
}
class DeviceBridge {
    /* Properties of NM-1.0.NM.DeviceBridge */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /**
     * The devices enslaved to the bridge device.
     */
    readonly slaves: Device[]
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceBridge */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    /**
     * Gets the devices currently enslaved to `device`.
     */
    get_slaves(): Device[]
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceBridge, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceBridge, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::carrier", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::slaves", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::slaves", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceBridge_ConstructProps)
    _init (config?: DeviceBridge_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceBt_ConstructProps extends Device_ConstructProps {
}
class DeviceBt {
    /* Properties of NM-1.0.NM.DeviceBt */
    /**
     * The device's bluetooth capabilities, a combination of #NMBluetoothCapabilities.
     */
    readonly bt_capabilities: BluetoothCapabilities
    /**
     * The name of the bluetooth device.
     */
    readonly name: string
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceBt */
    /**
     * Returns the Bluetooth device's usable capabilities.
     */
    get_capabilities(): BluetoothCapabilities
    /**
     * Gets the name of the #NMDeviceBt.
     */
    get_name(): string
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceBt, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceBt, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::bt-capabilities", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bt-capabilities", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceBt, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceBt_ConstructProps)
    _init (config?: DeviceBt_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceDummy_ConstructProps extends Device_ConstructProps {
}
class DeviceDummy {
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceDummy, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceDummy, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceDummy_ConstructProps)
    _init (config?: DeviceDummy_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceEthernet_ConstructProps extends Device_ConstructProps {
}
class DeviceEthernet {
    /* Properties of NM-1.0.NM.DeviceEthernet */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /**
     * The permanent hardware (MAC) address of the device.
     */
    readonly perm_hw_address: string
    /**
     * Identifies subchannels of this network device used for
     * communication with z/VM or s390 host.
     */
    readonly s390_subchannels: string[]
    /**
     * The speed of the device.
     */
    readonly speed: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceEthernet */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    /**
     * Gets the permanent hardware (MAC) address of the #NMDeviceEthernet
     */
    get_permanent_hw_address(): string
    /**
     * Return the list of s390 subchannels if the device supports them.
     */
    get_s390_subchannels(): string[]
    /**
     * Gets the speed of the #NMDeviceEthernet in Mbit/s.
     */
    get_speed(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceEthernet, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceEthernet, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::carrier", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::perm-hw-address", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::perm-hw-address", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::s390-subchannels", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::s390-subchannels", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::speed", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::speed", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceEthernet, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceEthernet_ConstructProps)
    _init (config?: DeviceEthernet_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceGeneric_ConstructProps extends Device_ConstructProps {
}
class DeviceGeneric {
    /* Properties of NM-1.0.NM.DeviceGeneric */
    /**
     * A description of the specific type of device this is, or %NULL
     * if not known.
     */
    readonly type_description: string
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceGeneric, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceGeneric, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::type-description", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type-description", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceGeneric_ConstructProps)
    _init (config?: DeviceGeneric_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceIPTunnel_ConstructProps extends Device_ConstructProps {
}
class DeviceIPTunnel {
    /* Properties of NM-1.0.NM.DeviceIPTunnel */
    /**
     * How many additional levels of encapsulation are permitted to
     * be prepended to packets. This property applies only to IPv6
     * tunnels.
     */
    readonly encapsulation_limit: number
    /**
     * Tunnel flags.
     */
    readonly flags: number
    /**
     * The flow label to assign to tunnel packets. This property
     * applies only to IPv6 tunnels.
     */
    readonly flow_label: number
    /**
     * The key used for tunneled input packets, if applicable.
     */
    readonly input_key: string
    /**
     * The local endpoint of the tunnel.
     */
    readonly local: string
    /**
     * The tunneling mode of the device.
     */
    readonly mode: number
    /**
     * The key used for tunneled output packets, if applicable.
     */
    readonly output_key: string
    /**
     * The devices's parent device.
     */
    readonly parent: Device
    /**
     * Whether path MTU discovery is enabled on this tunnel.
     */
    readonly path_mtu_discovery: boolean
    /**
     * The remote endpoint of the tunnel.
     */
    readonly remote: string
    /**
     * The type of service (IPv4) or traffic class (IPv6) assigned to
     * tunneled packets.
     */
    readonly tos: number
    /**
     * The TTL assigned to tunneled packets. 0 is a special value
     *  meaning that packets inherit the TTL value
     */
    readonly ttl: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceIPTunnel */
    get_encapsulation_limit(): number
    get_flags(): IPTunnelFlags
    get_flow_label(): number
    get_input_key(): string
    get_local(): string
    get_mode(): IPTunnelMode
    get_output_key(): string
    get_parent(): Device
    get_path_mtu_discovery(): boolean
    get_remote(): string
    get_tos(): number
    get_ttl(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceIPTunnel, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceIPTunnel, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::encapsulation-limit", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::encapsulation-limit", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::flags", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::flow-label", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flow-label", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::input-key", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::input-key", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::local", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::output-key", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::output-key", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path-mtu-discovery", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path-mtu-discovery", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::remote", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remote", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tos", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tos", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ttl", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ttl", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceIPTunnel_ConstructProps)
    _init (config?: DeviceIPTunnel_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceInfiniband_ConstructProps extends Device_ConstructProps {
}
class DeviceInfiniband {
    /* Properties of NM-1.0.NM.DeviceInfiniband */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceInfiniband */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceInfiniband, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceInfiniband, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::carrier", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceInfiniband_ConstructProps)
    _init (config?: DeviceInfiniband_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceMacsec_ConstructProps extends Device_ConstructProps {
}
class DeviceMacsec {
    /* Properties of NM-1.0.NM.DeviceMacsec */
    /**
     * The set of cryptographic algorithms in use.
     */
    readonly cipher_suite: number
    /**
     * The value of the Association Number (0..3) for the Security
     * Association in use.
     */
    readonly encoding_sa: number
    /**
     * Whether encryption of transmitted frames is enabled.
     */
    readonly encrypt: boolean
    /**
     * Whether the ES (End station) bit is enabled in SecTAG for
     * transmitted frames.
     */
    readonly es: boolean
    /**
     * The length of ICV (Integrity Check Value).
     */
    readonly icv_length: number
    /**
     * Whether the SCI is always included in SecTAG for transmitted
     * frames.
     */
    readonly include_sci: boolean
    /**
     * The devices's parent device.
     */
    readonly parent: Device
    /**
     * Whether protection of transmitted frames is enabled.
     */
    readonly protect: boolean
    /**
     * Whether replay protection is enabled.
     */
    readonly replay_protect: boolean
    /**
     * Whether the SCB (Single Copy Broadcast) bit is enabled in
     * SecTAG for transmitted frames.
     */
    readonly scb: boolean
    /**
     * The Secure Channel Identifier in use.
     */
    readonly sci: number
    /**
     * The validation mode for incoming packets (strict, check,
     * disabled).
     */
    readonly validation: string
    /**
     * The size of the replay window.
     */
    readonly window: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceMacsec */
    /**
     * Gets the set of cryptographic algorithms in use
     */
    get_cipher_suite(): number
    /**
     * Gets the value of the Association Number (0..3) for the Security
     * Association in use.
     */
    get_encoding_sa(): number
    /**
     * Gets whether encryption of transmitted frames is enabled
     */
    get_encrypt(): boolean
    /**
     * Gets whether the ES (End station) bit is enabled in SecTAG for
     * transmitted frames
     */
    get_es(): boolean
    /**
     * Gets the length of ICV (Integrity Check Value)
     */
    get_icv_length(): number
    /**
     * Gets whether the SCI is always included in SecTAG for transmitted
     * frames
     */
    get_include_sci(): boolean
    get_parent(): Device
    /**
     * Gets whether protection of transmitted frames is enabled
     */
    get_protect(): boolean
    /**
     * Gets whether replay protection is enabled
     */
    get_replay_protect(): boolean
    /**
     * Gets whether the SCB (Single Copy Broadcast) bit is enabled in
     * SecTAG for transmitted frames
     */
    get_scb(): boolean
    /**
     * Gets the Secure Channel Identifier in use
     */
    get_sci(): number
    /**
     * Gets the validation mode for incoming packets (strict, check,
     * disabled)
     */
    get_validation(): string
    /**
     * Gets the size of the replay window
     */
    get_window(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceMacsec, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceMacsec, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::cipher-suite", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cipher-suite", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::encoding-sa", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::encoding-sa", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::encrypt", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::encrypt", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::es", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::es", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::icv-length", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icv-length", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::include-sci", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::include-sci", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::protect", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protect", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::replay-protect", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::replay-protect", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::scb", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::scb", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::sci", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sci", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::validation", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::validation", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::window", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::window", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceMacsec_ConstructProps)
    _init (config?: DeviceMacsec_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceMacvlan_ConstructProps extends Device_ConstructProps {
}
class DeviceMacvlan {
    /* Properties of NM-1.0.NM.DeviceMacvlan */
    /**
     * The MACVLAN mode.
     */
    readonly mode: string
    /**
     * Whether the device has the no-promiscuos flag.
     */
    readonly no_promisc: boolean
    /**
     * The devices's parent device.
     */
    readonly parent: Device
    /**
     * Whether the device is a MACVTAP.
     */
    readonly tap: boolean
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceMacvlan */
    /**
     * Gets the MACVLAN mode of the device.
     */
    get_mode(): string
    /**
     * Gets the no-promiscuous flag of the device.
     */
    get_no_promisc(): boolean
    get_parent(): Device
    /**
     * Gets the device type (MACVLAN or MACVTAP).
     */
    get_tap(): boolean
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceMacvlan, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceMacvlan, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::mode", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::no-promisc", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::no-promisc", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tap", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tap", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceMacvlan_ConstructProps)
    _init (config?: DeviceMacvlan_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceModem_ConstructProps extends Device_ConstructProps {
}
class DeviceModem {
    /* Properties of NM-1.0.NM.DeviceModem */
    readonly apn: string
    /**
     * The generic family of access technologies the modem currently supports
     * without a firmware reload or reinitialization.
     */
    readonly current_capabilities: DeviceModemCapabilities
    readonly device_id: string
    /**
     * The generic family of access technologies the modem supports.  Not all
     * capabilities are available at the same time however; some modems require
     * a firmware reload or other reinitialization to switch between eg
     * CDMA/EVDO and GSM/UMTS.
     */
    readonly modem_capabilities: DeviceModemCapabilities
    readonly operator_code: string
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceModem */
    /**
     * The access point name the modem is connected to.
     */
    get_apn(): string
    /**
     * Returns a bitfield of the generic access technology families the modem
     * supports without a firmware reload or reinitialization.  This value
     * represents the network types the modem can immediately connect to.
     */
    get_current_capabilities(): DeviceModemCapabilities
    /**
     * An identifier used by the modem backend (ModemManager) that aims to
     * uniquely identify the a device. Can be used to match a connection to a
     * particular device.
     */
    get_device_id(): string
    /**
     * Returns a bitfield of the generic access technology families the modem
     * supports.  Not all capabilities are available concurrently however; some
     * may require a firmware reload or reinitialization.
     */
    get_modem_capabilities(): DeviceModemCapabilities
    /**
     * The MCC and MNC (concatenated) of the network the modem is connected to.
     */
    get_operator_code(): string
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceModem, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceModem, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::apn", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::apn", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::current-capabilities", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-capabilities", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-id", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-id", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::modem-capabilities", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::modem-capabilities", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::operator-code", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::operator-code", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceModem, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceModem_ConstructProps)
    _init (config?: DeviceModem_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceOlpcMesh_ConstructProps extends Device_ConstructProps {
}
class DeviceOlpcMesh {
    /* Properties of NM-1.0.NM.DeviceOlpcMesh */
    /**
     * The device's active channel.
     */
    readonly active_channel: number
    /**
     * The companion device.
     */
    readonly companion: DeviceWifi
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceOlpcMesh */
    /**
     * Returns the active channel of the #NMDeviceOlpcMesh device.
     */
    get_active_channel(): number
    /**
     * Gets the companion device of the #NMDeviceOlpcMesh.
     */
    get_companion(): DeviceWifi
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceOlpcMesh, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceOlpcMesh, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::active-channel", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-channel", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::companion", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::companion", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceOlpcMesh_ConstructProps)
    _init (config?: DeviceOlpcMesh_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceOvsBridge_ConstructProps extends Device_ConstructProps {
}
class DeviceOvsBridge {
    /* Properties of NM-1.0.NM.DeviceOvsBridge */
    /**
     * Gets the ports currently enslaved to the device.
     */
    readonly slaves: Device[]
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceOvsBridge */
    /**
     * Gets the ports currently enslaved to `device`.
     */
    get_slaves(): Device[]
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceOvsBridge, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceOvsBridge, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::slaves", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::slaves", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceOvsBridge_ConstructProps)
    _init (config?: DeviceOvsBridge_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceOvsInterface_ConstructProps extends Device_ConstructProps {
}
class DeviceOvsInterface {
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceOvsInterface, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceOvsInterface, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceOvsInterface_ConstructProps)
    _init (config?: DeviceOvsInterface_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceOvsPort_ConstructProps extends Device_ConstructProps {
}
class DeviceOvsPort {
    /* Properties of NM-1.0.NM.DeviceOvsPort */
    /**
     * Gets the interfaces currently enslaved to the device.
     */
    readonly slaves: Device[]
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceOvsPort */
    /**
     * Gets the interfaces currently enslaved to `device`.
     */
    get_slaves(): Device[]
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceOvsPort, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceOvsPort, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::slaves", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::slaves", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceOvsPort_ConstructProps)
    _init (config?: DeviceOvsPort_ConstructProps): void
    static $gtype: GObject.Type
}
interface DevicePpp_ConstructProps extends Device_ConstructProps {
}
class DevicePpp {
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DevicePpp, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DevicePpp, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::active-connection", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DevicePpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DevicePpp_ConstructProps)
    _init (config?: DevicePpp_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceTeam_ConstructProps extends Device_ConstructProps {
}
class DeviceTeam {
    /* Properties of NM-1.0.NM.DeviceTeam */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /**
     * The current JSON configuration of the device.
     */
    readonly config: string
    /**
     * The devices enslaved to the team device.
     */
    readonly slaves: Device[]
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceTeam */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    /**
     * Gets the current JSON configuration of the #NMDeviceTeam
     */
    get_config(): string
    /**
     * Gets the devices currently enslaved to `device`.
     */
    get_slaves(): Device[]
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceTeam, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceTeam, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::carrier", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::slaves", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::slaves", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceTeam_ConstructProps)
    _init (config?: DeviceTeam_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceTun_ConstructProps extends Device_ConstructProps {
}
class DeviceTun {
    /* Properties of NM-1.0.NM.DeviceTun */
    /**
     * The gid of the tunnel group, or -1 if it has no owner.
     */
    readonly group: number
    /**
     * The tunnel mode, either "tun" or "tap".
     */
    readonly mode: string
    /**
     * The tunnel's "TUN_TAP_MQ" flag; true if callers can connect to
     * the tap device multiple times, for multiple send/receive
     * queues.
     */
    readonly multi_queue: boolean
    /**
     * The tunnel's "TUN_NO_PI" flag; true if no protocol info is
     * prepended to the tunnel packets.
     */
    readonly no_pi: boolean
    /**
     * The uid of the tunnel owner, or -1 if it has no owner.
     */
    readonly owner: number
    /**
     * The tunnel's "TUN_VNET_HDR" flag; true if the tunnel packets
     * include a virtio network header.
     */
    readonly vnet_hdr: boolean
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceTun */
    /**
     * Gets the tunnel group.
     */
    get_group(): number
    /**
     * Returns the TUN/TAP mode for the device.
     */
    get_mode(): string
    /**
     * Returns whether the #NMDeviceTun has the IFF_MULTI_QUEUE flag.
     */
    get_multi_queue(): boolean
    get_no_pi(): boolean
    /**
     * Gets the tunnel owner.
     */
    get_owner(): number
    /**
     * Returns whether the #NMDeviceTun has the IFF_VNET_HDR flag.
     */
    get_vnet_hdr(): boolean
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceTun, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceTun, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::group", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multi-queue", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multi-queue", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::no-pi", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::no-pi", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::owner", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::owner", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vnet-hdr", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vnet-hdr", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceTun_ConstructProps)
    _init (config?: DeviceTun_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceVeth_ConstructProps extends DeviceEthernet_ConstructProps {
}
class DeviceVeth {
    /* Properties of NM-1.0.NM.DeviceVeth */
    /**
     * The device's peer device.
     */
    readonly peer: Device
    /* Properties of NM-1.0.NM.DeviceEthernet */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /**
     * The permanent hardware (MAC) address of the device.
     */
    readonly perm_hw_address: string
    /**
     * Identifies subchannels of this network device used for
     * communication with z/VM or s390 host.
     */
    readonly s390_subchannels: string[]
    /**
     * The speed of the device.
     */
    readonly speed: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceVeth */
    get_peer(): Device
    /* Methods of NM-1.0.NM.DeviceEthernet */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    /**
     * Gets the permanent hardware (MAC) address of the #NMDeviceEthernet
     */
    get_permanent_hw_address(): string
    /**
     * Return the list of s390 subchannels if the device supports them.
     */
    get_s390_subchannels(): string[]
    /**
     * Gets the speed of the #NMDeviceEthernet in Mbit/s.
     */
    get_speed(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceVeth, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceVeth, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::peer", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::carrier", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::perm-hw-address", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::perm-hw-address", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::s390-subchannels", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::s390-subchannels", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::speed", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::speed", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceVeth_ConstructProps)
    _init (config?: DeviceVeth_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceVlan_ConstructProps extends Device_ConstructProps {
}
class DeviceVlan {
    /* Properties of NM-1.0.NM.DeviceVlan */
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /**
     * The devices's parent device.
     */
    readonly parent: Device
    /**
     * The device's VLAN ID.
     */
    readonly vlan_id: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceVlan */
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    get_parent(): Device
    get_vlan_id(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceVlan, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceVlan, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::carrier", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlan-id", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlan-id", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceVlan_ConstructProps)
    _init (config?: DeviceVlan_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceVrf_ConstructProps extends Device_ConstructProps {
}
class DeviceVrf {
    /* Properties of NM-1.0.NM.DeviceVrf */
    /**
     * The device's VRF table.
     */
    readonly table: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceVrf */
    get_table(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceVrf, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceVrf, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::table", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::table", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceVrf_ConstructProps)
    _init (config?: DeviceVrf_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceVxlan_ConstructProps extends Device_ConstructProps {
}
class DeviceVxlan {
    /* Properties of NM-1.0.NM.DeviceVxlan */
    /**
     * The lifetime in seconds of FDB entries learnt by the kernel.
     */
    readonly ageing: number
    /**
     * Whether the device has carrier.
     */
    readonly carrier: boolean
    /**
     * The UDP destination port used to communicate with the remote VXLAN tunnel
     * endpoint.
     */
    readonly dst_port: number
    /**
     * The unicast destination IP address used in outgoing packets when the
     * destination link layer address is not known in the VXLAN device
     * forwarding database or the multicast IP address joined.
     */
    readonly group: string
    /**
     * The device's VXLAN ID.
     */
    readonly id: number
    /**
     * Whether netlink LL ADDR miss notifications are generated.
     */
    readonly l2miss: boolean
    /**
     * Whether netlink IP ADDR miss notifications are generated.
     */
    readonly l3miss: boolean
    /**
     * Whether unknown source link layer addresses and IP addresses are entered
     * into the VXLAN device forwarding database.
     */
    readonly learning: boolean
    /**
     * The maximum number of entries that can be added to the forwarding table.
     */
    readonly limit: number
    /**
     * The source IP address to use in outgoing packets.
     */
    readonly local: string
    /**
     * The devices's parent device.
     */
    readonly parent: Device
    /**
     * Whether ARP proxy is turned on.
     */
    readonly proxy: boolean
    /**
     * Whether route short circuit is turned on.
     */
    readonly rsc: boolean
    /**
     * The maximum UDP source port used to communicate with the remote VXLAN
     * tunnel endpoint.
     */
    readonly src_port_max: number
    /**
     * The minimum UDP source port used to communicate with the remote VXLAN
     * tunnel endpoint.
     */
    readonly src_port_min: number
    /**
     * The TOS value to use in outgoing packets.
     */
    readonly tos: number
    /**
     * The time-to-live value to use in outgoing packets.
     */
    readonly ttl: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceVxlan */
    get_ageing(): number
    /**
     * Whether the device has carrier.
     */
    get_carrier(): boolean
    get_dst_port(): number
    get_group(): string
    get_id(): number
    get_l2miss(): boolean
    get_l3miss(): boolean
    get_learning(): boolean
    get_limit(): number
    get_local(): string
    get_parent(): Device
    get_proxy(): boolean
    get_rsc(): boolean
    get_src_port_max(): number
    get_src_port_min(): number
    get_tos(): number
    get_ttl(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceVxlan, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceVxlan, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::ageing", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ageing", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::carrier", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::carrier", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dst-port", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dst-port", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::group", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::l2miss", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::l2miss", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::l3miss", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::l3miss", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::learning", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::learning", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::limit", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::limit", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::local", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::rsc", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rsc", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::src-port-max", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::src-port-max", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::src-port-min", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::src-port-min", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tos", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tos", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ttl", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ttl", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceVxlan_ConstructProps)
    _init (config?: DeviceVxlan_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceWifi_ConstructProps extends Device_ConstructProps {
}
class DeviceWifi {
    /* Properties of NM-1.0.NM.DeviceWifi */
    /**
     * List of all Wi-Fi access points the device can see.
     */
    readonly access_points: AccessPoint[]
    /**
     * The active #NMAccessPoint of the device.
     */
    readonly active_access_point: AccessPoint
    /**
     * The bit rate of the device in kbit/s.
     */
    readonly bitrate: number
    /**
     * The timestamp (in CLOCK_BOOTTIME seconds) for the last finished
     * network scan. A value of -1 means the device never scanned for
     * access points.
     */
    readonly last_scan: number
    /**
     * The mode of the device.
     */
    readonly mode: TODO_80211Mode
    /**
     * The hardware (MAC) address of the device.
     */
    readonly perm_hw_address: string
    /**
     * The wireless capabilities of the device.
     */
    readonly wireless_capabilities: DeviceWifiCapabilities
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceWifi */
    /**
     * Gets a #NMAccessPoint by path.
     */
    get_access_point_by_path(path: string): AccessPoint
    /**
     * Gets all the scanned access points of the #NMDeviceWifi.
     */
    get_access_points(): AccessPoint[]
    /**
     * Gets the active #NMAccessPoint.
     */
    get_active_access_point(): AccessPoint
    /**
     * Gets the bit rate of the #NMDeviceWifi in kbit/s.
     */
    get_bitrate(): number
    /**
     * Gets the Wi-Fi capabilities of the #NMDeviceWifi.
     */
    get_capabilities(): DeviceWifiCapabilities
    /**
     * Returns the timestamp (in CLOCK_BOOTTIME milliseconds) for the last finished
     * network scan. A value of -1 means the device never scanned for access points.
     * 
     * Use nm_utils_get_timestamp_msec() to obtain current time value suitable for
     * comparing to this value.
     */
    get_last_scan(): number
    /**
     * Gets the #NMDeviceWifi mode.
     */
    get_mode(): TODO_80211Mode
    /**
     * Gets the permanent hardware (MAC) address of the #NMDeviceWifi
     */
    get_permanent_hw_address(): string
    /**
     * Request NM to scan for access points on `device`. Note that the function
     * returns immediately after requesting the scan, and it may take some time
     * after that for the scan to complete.
     */
    request_scan(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Request NM to scan for access points on `device`. Note that `callback` will be
     * called immediately after requesting the scan, and it may take some time after
     * that for the scan to complete.
     */
    request_scan_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_wifi_request_scan_async() and
     * nm_device_wifi_request_scan_options_async().
     */
    request_scan_finish(result: Gio.AsyncResult): boolean
    /**
     * Request NM to scan for access points on `device`. Note that the function
     * returns immediately after requesting the scan, and it may take some time
     * after that for the scan to complete.
     * This is the same as `nm_device_wifi_request_scan` except it accepts `options`
     * for the scanning. The argument is the dictionary passed to RequestScan()
     * D-Bus call. Valid options inside the dictionary are:
     * 'ssids' => array of SSIDs (saay)
     */
    request_scan_options(options: GLib.Variant, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Request NM to scan for access points on `device`. Note that `callback` will be
     * called immediately after requesting the scan, and it may take some time after
     * that for the scan to complete.
     * This is the same as `nm_device_wifi_request_scan_async` except it accepts `options`
     * for the scanning. The argument is the dictionary passed to RequestScan()
     * D-Bus call. Valid options inside the dictionary are:
     * 'ssids' => array of SSIDs (saay)
     * 
     * To complete the request call nm_device_wifi_request_scan_finish().
     */
    request_scan_options_async(options: GLib.Variant, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.DeviceWifi */
    /**
     * Notifies that a #NMAccessPoint is added to the Wi-Fi device.
     */
    connect(sigName: "access-point-added", callback: (($obj: DeviceWifi, ap: GObject.Object) => void)): number
    connect_after(sigName: "access-point-added", callback: (($obj: DeviceWifi, ap: GObject.Object) => void)): number
    emit(sigName: "access-point-added", ap: GObject.Object): void
    /**
     * Notifies that a #NMAccessPoint is removed from the Wi-Fi device.
     */
    connect(sigName: "access-point-removed", callback: (($obj: DeviceWifi, ap: GObject.Object) => void)): number
    connect_after(sigName: "access-point-removed", callback: (($obj: DeviceWifi, ap: GObject.Object) => void)): number
    emit(sigName: "access-point-removed", ap: GObject.Object): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceWifi, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceWifi, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::access-points", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::access-points", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-access-point", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-access-point", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::bitrate", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bitrate", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::last-scan", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-scan", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::perm-hw-address", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::perm-hw-address", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wireless-capabilities", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wireless-capabilities", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceWifi, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceWifi_ConstructProps)
    _init (config?: DeviceWifi_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceWifiP2P_ConstructProps extends Device_ConstructProps {
}
class DeviceWifiP2P {
    /* Properties of NM-1.0.NM.DeviceWifiP2P */
    /**
     * List of all Wi-Fi P2P peers the device can see.
     */
    readonly peers: WifiP2PPeer[]
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceWifiP2P */
    /**
     * Gets a #NMWifiP2PPeer by path.
     */
    get_peer_by_path(path: string): WifiP2PPeer
    /**
     * Gets all the found peers of the #NMDeviceWifiP2P.
     */
    get_peers(): WifiP2PPeer[]
    /**
     * Request NM to search for Wi-Fi P2P peers on `device`. Note that the call
     * returns immediately after requesting the find, and it may take some time
     * after that for peers to be found.
     * 
     * The find operation will run for 30s by default. You can stop it earlier
     * using nm_device_p2p_wifi_stop_find().
     */
    start_find(options?: GLib.Variant | null, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finish an operation started by nm_device_wifi_p2p_start_find().
     */
    start_find_finish(result: Gio.AsyncResult): boolean
    /**
     * Request NM to stop any ongoing find operation for Wi-Fi P2P peers on `device`.
     */
    stop_find(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finish an operation started by nm_device_wifi_p2p_stop_find().
     */
    stop_find_finish(result: Gio.AsyncResult): boolean
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.DeviceWifiP2P */
    /**
     * Notifies that a #NMWifiP2PPeer is added to the Wi-Fi P2P device.
     */
    connect(sigName: "peer-added", callback: (($obj: DeviceWifiP2P, peer: GObject.Object) => void)): number
    connect_after(sigName: "peer-added", callback: (($obj: DeviceWifiP2P, peer: GObject.Object) => void)): number
    emit(sigName: "peer-added", peer: GObject.Object): void
    /**
     * Notifies that a #NMWifiP2PPeer is removed from the Wi-Fi P2P device.
     */
    connect(sigName: "peer-removed", callback: (($obj: DeviceWifiP2P, peer: GObject.Object) => void)): number
    connect_after(sigName: "peer-removed", callback: (($obj: DeviceWifiP2P, peer: GObject.Object) => void)): number
    emit(sigName: "peer-removed", peer: GObject.Object): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceWifiP2P, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceWifiP2P, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::peers", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peers", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceWifiP2P_ConstructProps)
    _init (config?: DeviceWifiP2P_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceWimax_ConstructProps extends Device_ConstructProps {
}
class DeviceWimax {
    /* Properties of NM-1.0.NM.DeviceWimax */
    /**
     * The active #NMWimaxNsp of the device.
     */
    readonly active_nsp: WimaxNsp
    /**
     * The ID of the serving base station as received from the network.  Has
     * no meaning when the device is not connected.
     */
    readonly bsid: string
    /**
     * The center frequency (in KHz) of the radio channel the device is using to
     * communicate with the network when connected.  Has no meaning when the
     * device is not connected.
     */
    readonly center_frequency: number
    /**
     * CINR (Carrier to Interference + Noise Ratio) of the current radio link
     * in dB.  CINR is a more accurate measure of radio link quality.  Has no
     * meaning when the device is not connected.
     */
    readonly cinr: number
    /**
     * The hardware (MAC) address of the device.
     */
    readonly hw_address: string
    /**
     * List of all WiMAX Network Service Providers the device can see.
     */
    readonly nsps: WimaxNsp[]
    /**
     * RSSI of the current radio link in dBm.  This value indicates how strong
     * the raw received RF signal from the base station is, but does not
     * indicate the overall quality of the radio link.  Has no meaning when the
     * device is not connected.
     */
    readonly rssi: number
    /**
     * Average power of the last burst transmitted by the device, in units of
     * 0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
     * -5.5 dBm.  Has no meaning when the device is not connected.
     */
    readonly tx_power: number
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceWimax */
    /**
     * Gets the active #NMWimaxNsp.
     */
    get_active_nsp(): WimaxNsp
    /**
     * Gets the ID of the serving Base Station when the device is connected.
     */
    get_bsid(): string
    /**
     * Gets the center frequency (in KHz) of the radio channel the device is using
     * to communicate with the network when connected.  Has no meaning when the
     * device is not connected.
     */
    get_center_frequency(): number
    /**
     * Gets the CINR (Carrier to Interference + Noise Ratio) of the current radio
     * link in dB.  CINR is a more accurate measure of radio link quality.  Has no
     * meaning when the device is not connected.
     */
    get_cinr(): number
    /**
     * Gets the hardware (MAC) address of the #NMDeviceWimax
     */
    get_hw_address(): string
    /**
     * Gets a #NMWimaxNsp by path.
     */
    get_nsp_by_path(path: string): WimaxNsp
    /**
     * Gets all the scanned NSPs of the #NMDeviceWimax.
     */
    get_nsps(): WimaxNsp[]
    /**
     * Gets the RSSI of the current radio link in dBm.  This value indicates how
     * strong the raw received RF signal from the base station is, but does not
     * indicate the overall quality of the radio link.  Has no meaning when the
     * device is not connected.
     */
    get_rssi(): number
    /**
     * Average power of the last burst transmitted by the device, in units of
     * 0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
     * -5.5 dBm.  Has no meaning when the device is not connected.
     */
    get_tx_power(): number
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.DeviceWimax */
    /**
     * Notifies that a #NMWimaxNsp is added to the wimax device.
     */
    connect(sigName: "nsp-added", callback: (($obj: DeviceWimax, nsp: GObject.Object) => void)): number
    connect_after(sigName: "nsp-added", callback: (($obj: DeviceWimax, nsp: GObject.Object) => void)): number
    emit(sigName: "nsp-added", nsp: GObject.Object): void
    /**
     * Notifies that a #NMWimaxNsp is removed from the wimax device.
     */
    connect(sigName: "nsp-removed", callback: (($obj: DeviceWimax, nsp: GObject.Object) => void)): number
    connect_after(sigName: "nsp-removed", callback: (($obj: DeviceWimax, nsp: GObject.Object) => void)): number
    emit(sigName: "nsp-removed", nsp: GObject.Object): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceWimax, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceWimax, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::active-nsp", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-nsp", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::bsid", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bsid", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::center-frequency", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::center-frequency", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::cinr", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cinr", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nsps", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nsps", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::rssi", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rssi", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tx-power", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tx-power", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceWimax_ConstructProps)
    _init (config?: DeviceWimax_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceWireGuard_ConstructProps extends Device_ConstructProps {
}
class DeviceWireGuard {
    /* Properties of NM-1.0.NM.DeviceWireGuard */
    /**
     * Optional firewall mark - see ip-rule(8).
     * Used when setting routing policy for outgoing encrypted packets.
     * Set to 0 to disable the mark (default).
     */
    readonly fwmark: number
    /**
     * Local UDP listen port.
     * Set to 0 to allow a random port to be chosen (default).
     */
    readonly listen_port: number
    /**
     * 32-byte public key, derived from the current private key.
     */
    readonly public_key: GLib.Bytes
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DeviceWireGuard */
    /**
     * Gets the fwmark (firewall mark) for this interface.
     * It can be used to set routing policy for outgoing encrypted packets.
     * See: ip-rule(8)
     */
    get_fwmark(): number
    /**
     * Gets the local UDP port this interface listens on
     */
    get_listen_port(): number
    /**
     * Gets the public key for this interface
     */
    get_public_key(): GLib.Bytes
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceWireGuard, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceWireGuard, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::fwmark", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fwmark", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::listen-port", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listen-port", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::public-key", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::public-key", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceWireGuard_ConstructProps)
    _init (config?: DeviceWireGuard_ConstructProps): void
    static $gtype: GObject.Type
}
interface DeviceWpan_ConstructProps extends Device_ConstructProps {
}
class DeviceWpan {
    /* Properties of NM-1.0.NM.Device */
    /**
     * The #NMActiveConnection object that "owns" this device during activation.
     */
    readonly active_connection: ActiveConnection
    /**
     * Whether the device can auto-activate a connection.
     * 
     * The property setter is a synchronous D-Bus call. This is deprecated since 1.22.
     */
    autoconnect: boolean
    /**
     * The available connections of the device
     */
    readonly available_connections: RemoteConnection[]
    /**
     * The capabilities of the device.
     */
    readonly capabilities: DeviceCapabilities
    /**
     * The numeric type of the device.
     */
    readonly device_type: DeviceType
    /**
     * The IPv4 #NMDhcpConfig of the device.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the device.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The driver of the device.
     */
    readonly driver: string
    /**
     * The version of the device driver.
     */
    readonly driver_version: string
    /**
     * When %TRUE indicates the device is likely missing firmware required
     * for its operation.
     */
    readonly firmware_missing: boolean
    /**
     * The firmware version of the device.
     */
    readonly firmware_version: string
    /**
     * The hardware address of the device.
     */
    readonly hw_address: string
    /**
     * The interface of the device.
     */
    readonly interface: string
    /**
     * The interface flags.
     */
    readonly interface_flags: number
    /**
     * The IP interface of the device which should be used for all IP-related
     * operations like addressing and routing.
     */
    readonly ip_interface: string
    /**
     * The #NMIP4Config of the device.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv4 connectivity state of the device.
     */
    readonly ip4_connectivity: ConnectivityState
    /**
     * The IPv6 #NMIPConfig of the device.
     */
    readonly ip6_config: IPConfig
    /**
     * The IPv6 connectivity state of the device.
     */
    readonly ip6_connectivity: ConnectivityState
    /**
     * The LLDP neighbors.
     */
    readonly lldp_neighbors: object[]
    /**
     * Whether the device is managed by NetworkManager.
     */
    readonly managed: boolean
    /**
     * Whether the device is metered.
     */
    readonly metered: number
    /**
     * The MTU of the device.
     */
    readonly mtu: number
    /**
     * When %TRUE indicates that the NetworkManager plugin for the device
     * is not installed.
     */
    readonly nm_plugin_missing: boolean
    /**
     * The device path as exposed by the udev property ID_PATH.
     * 
     * The string is backslash escaped (C escaping) for invalid
     * characters. The escaping can be reverted with g_strcompress(),
     * however the result may not be valid UTF-8.
     */
    readonly path: string
    /**
     * The physical port ID of the device. (See
     * nm_device_get_physical_port_id().)
     */
    readonly physical_port_id: string
    /**
     * The port devices of the controller device. For devices that cannot be
     * controllers this is likely to be always empty.
     */
    readonly ports: object[]
    /**
     * The product string of the device.
     */
    readonly product: string
    /**
     * Whether the device is real or is a placeholder device that could
     * be created automatically by NetworkManager if one of its
     * #NMDevice:available-connections was activated.
     */
    readonly real: boolean
    /**
     * The state of the device.
     */
    readonly state: DeviceState
    /**
     * The reason for the device state.
     */
    readonly state_reason: number
    /**
     * An operating-system specific device hardware identifier; this is not
     * unique to a specific hardware device across reboots or hotplugs.  It
     * is an opaque string which for some device types (Bluetooth, Modem)
     * contains an identifier provided by the underlying hardware service daemon
     * such as Bluez or ModemManager, and clients can use this property to
     * request more information about the device from those services.
     */
    readonly udi: string
    /**
     * The vendor string of the device.
     */
    readonly vendor: string
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Device */
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     * 
     * This function does the same as nm_device_connection_valid(), i.e. checking
     * compatibility of the given device and connection. But, in addition, it sets
     * GError when FALSE is returned.
     */
    connection_compatible(connection: Connection): boolean
    /**
     * Validates a given connection for a given #NMDevice object and returns
     * whether the connection may be activated with the device. For example if
     * `device` is a Wi-Fi device that supports only WEP encryption, the connection
     * will only be valid if it is a Wi-Fi connection which describes a WEP or open
     * network, and will not be valid if it describes a WPA network, or if it is
     * an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
     * device.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Deletes the software device. Hardware devices can't be deleted.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins deleting the software device. Hardware devices can't
     * be deleted.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    /**
     * Disconnects the device if currently connected, and prevents the device from
     * automatically connecting to networks until the next manual network connection
     * request.
     */
    disconnect(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins disconnecting the device if currently connected, and
     * prevents the device from automatically connecting to networks until the next
     * manual network connection request.
     */
    disconnect_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_disconnect_async().
     */
    disconnect_finish(result: Gio.AsyncResult): boolean
    /**
     * Filters a given array of connections for a given #NMDevice object and returns
     * connections which may be activated with the device. For example if `device`
     * is a Wi-Fi device that supports only WEP encryption, the returned array will
     * contain any Wi-Fi connections in `connections` that allow connection to
     * unencrypted or WEP-enabled SSIDs.  The returned array will not contain
     * Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
     * incompatible with the device. To get the full list of connections see
     * nm_client_get_connections().
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the #NMActiveConnection object which owns this device during activation.
     */
    get_active_connection(): ActiveConnection
    /**
     * Fetch the currently applied connection on the device.
     */
    get_applied_connection(flags: number, cancellable?: Gio.Cancellable | null): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Asynchronously begins and gets the currently applied connection.
     */
    get_applied_connection_async(flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_get_applied_connection_async().
     */
    get_applied_connection_finish(result: Gio.AsyncResult): [ /* returnType */ Connection, /* version_id */ number | null ]
    /**
     * Whether the #NMDevice can be autoconnected.
     */
    get_autoconnect(): boolean
    /**
     * Gets the #NMRemoteConnections currently known to the daemon that could
     * be activated on `device`.
     */
    get_available_connections(): RemoteConnection[]
    /**
     * Gets the device' capabilities.
     */
    get_capabilities(): DeviceCapabilities
    /**
     * The connectivity state of the device for given address family.
     * Supported address families are %AF_INET for IPv4, %AF_INET6
     * for IPv6 or %AF_UNSPEC for any.
     */
    get_connectivity(addr_family: number): ConnectivityState
    /**
     * Gets a description of `device,` based on its vendor and product names.
     */
    get_description(): string
    /**
     * Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.
     */
    get_device_type(): DeviceType
    /**
     * Gets the current IPv4 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp4_config(), which also
     * works with VPN connections.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_dhcp6_config(), which also
     * works with VPN connections.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the driver of the #NMDevice.
     */
    get_driver(): string
    /**
     * Gets the driver version of the #NMDevice.
     */
    get_driver_version(): string
    /**
     * Indicates that firmware required for the device's operation is likely
     * to be missing.
     */
    get_firmware_missing(): boolean
    /**
     * Gets the firmware version of the #NMDevice.
     */
    get_firmware_version(): string
    /**
     * Gets the current a hardware address (MAC) for the `device`.
     */
    get_hw_address(): string
    /**
     * Gets the interface name of the #NMDevice.
     */
    get_iface(): string
    /**
     * Gets the interface flags of the device.
     */
    get_interface_flags(): DeviceInterfaceFlags
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip4_config(), which also
     * works with VPN connections.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMDevice.
     * 
     * You can alternatively use nm_active_connection_get_ip6_config(), which also
     * works with VPN connections.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the IP interface name of the #NMDevice over which IP traffic flows
     * when the device is in the ACTIVATED state.
     */
    get_ip_iface(): string
    /**
     * Gets the list of neighbors discovered through LLDP.
     */
    get_lldp_neighbors(): LldpNeighbor[]
    /**
     * Whether the #NMDevice is managed by NetworkManager.
     */
    get_managed(): boolean
    /**
     * Gets the metered setting of a #NMDevice.
     */
    get_metered(): Metered
    /**
     * Gets the  MTU of the #NMDevice.
     */
    get_mtu(): number
    /**
     * Indicates that the NetworkManager plugin for the device is not installed.
     */
    get_nm_plugin_missing(): boolean
    /**
     * Gets the path of the #NMDevice as exposed by the udev property ID_PATH.
     */
    get_path(): string
    /**
     * Gets the physical port ID of the #NMDevice. If non-%NULL, this is
     * an opaque string that can be used to recognize when
     * seemingly-unrelated #NMDevices are actually just different virtual
     * ports on a single physical port. (Eg, NPAR / SR-IOV.)
     */
    get_physical_port_id(): string
    /**
     * Gets the devices currently set as port of `device`.
     */
    get_ports(): Device[]
    /**
     * Gets the product string of the #NMDevice.
     */
    get_product(): string
    /**
     * Gets the (primary) #NMSetting subtype associated with connections
     * that can be used on `device`.
     */
    get_setting_type(): GObject.Type
    /**
     * Gets the current #NMDevice state.
     */
    get_state(): DeviceState
    /**
     * Gets the reason for entering the current #NMDevice state.
     */
    get_state_reason(): DeviceStateReason
    /**
     * Gets a (non-localized) description of the type of device that
     * `device` is.
     */
    get_type_description(): string
    /**
     * Gets the Unique Device Identifier of the #NMDevice.
     */
    get_udi(): string
    /**
     * Gets the vendor string of the #NMDevice.
     */
    get_vendor(): string
    is_real(): boolean
    /**
     * Whether the device is a software device.
     */
    is_software(): boolean
    /**
     * Attempts to update device with changes to the currently active connection
     * made since it was last applied.
     */
    reapply(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously begins an attempt to update device with changes to the
     * currently active connection made since it was last applied.
     */
    reapply_async(connection: Connection | null, version_id: number, flags: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_device_reapply_async().
     */
    reapply_finish(result: Gio.AsyncResult): boolean
    /**
     * Enables or disables automatic activation of the #NMDevice.
     */
    set_autoconnect(autoconnect: boolean): void
    /**
     * Enables or disables management of  #NMDevice by NetworkManager.
     */
    set_managed(managed: boolean): void
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Device */
    /**
     * Notifies the state change of a #NMDevice.
     */
    connect(sigName: "state-changed", callback: (($obj: DeviceWpan, new_state: number, old_state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: DeviceWpan, new_state: number, old_state: number, reason: number) => void)): number
    emit(sigName: "state-changed", new_state: number, old_state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::active-connection", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::active-connection", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::available-connections", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::available-connections", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-type", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-type", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::driver-version", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver-version", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-missing", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-missing", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::firmware-version", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::firmware-version", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-flags", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-flags", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip-interface", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip-interface", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-connectivity", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-connectivity", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp-neighbors", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::managed", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::managed", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nm-plugin-missing", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::physical-port-id", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::physical-port-id", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ports", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ports", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::product", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::product", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::real", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::real", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-reason", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::udi", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::udi", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vendor", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vendor", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DeviceWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DeviceWpan_ConstructProps)
    _init (config?: DeviceWpan_ConstructProps): void
    static $gtype: GObject.Type
}
interface DhcpConfig_ConstructProps extends Object_ConstructProps {
}
class DhcpConfig {
    /* Properties of NM-1.0.NM.DhcpConfig */
    /**
     * The IP address family of the configuration; either
     * <literal>AF_INET</literal> or <literal>AF_INET6</literal>.
     */
    readonly family: number
    /**
     * The #GHashTable containing options of the configuration.
     */
    readonly options: GLib.HashTable
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.DhcpConfig */
    /**
     * Gets the IP address family of the configuration
     */
    get_family(): number
    /**
     * Gets one option by option name.
     */
    get_one_option(option: string): string
    /**
     * Gets all the options contained in the configuration.
     */
    get_options(): GLib.HashTable
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::family", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::options", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::options", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: DhcpConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: DhcpConfig_ConstructProps)
    _init (config?: DhcpConfig_ConstructProps): void
    static $gtype: GObject.Type
}
interface IPConfig_ConstructProps extends Object_ConstructProps {
}
class IPConfig {
    /* Properties of NM-1.0.NM.IPConfig */
    /**
     * A #GPtrArray containing the addresses (#NMIPAddress) of the configuration.
     */
    readonly addresses: object[]
    /**
     * The array containing domain strings of the configuration.
     */
    readonly domains: string[]
    /**
     * The IP address family of the configuration; either
     * <literal>AF_INET</literal> or <literal>AF_INET6</literal>.
     */
    readonly family: number
    /**
     * The IP gateway address of the configuration as string.
     */
    readonly gateway: string
    /**
     * The array containing name server IP addresses of the configuration.
     */
    readonly nameservers: string[]
    /**
     * A #GPtrArray containing the routes (#NMIPRoute) of the configuration.
     */
    readonly routes: IPRoute[]
    /**
     * The array containing DNS search strings of the configuration.
     */
    readonly searches: string[]
    /**
     * The array containing WINS server IP addresses of the configuration.
     * (This will always be empty for IPv6 configurations.)
     */
    readonly wins_servers: string[]
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.IPConfig */
    /**
     * Gets the IP addresses (containing the address, prefix, and gateway).
     */
    get_addresses(): IPAddress[]
    /**
     * Gets the domain names.
     */
    get_domains(): string[]
    /**
     * Gets the IP address family
     */
    get_family(): number
    /**
     * Gets the IP gateway address.
     */
    get_gateway(): string
    /**
     * Gets the domain name servers (DNS).
     */
    get_nameservers(): string[]
    /**
     * Gets the routes.
     */
    get_routes(): IPRoute[]
    /**
     * Gets the DNS searches.
     */
    get_searches(): string[]
    /**
     * Gets the Windows Internet Name Service servers (WINS).
     */
    get_wins_servers(): string[]
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::addresses", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addresses", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::domains", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::domains", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::family", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::family", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::gateway", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::gateway", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nameservers", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nameservers", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::routes", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::routes", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::searches", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::searches", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wins-servers", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wins-servers", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: IPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: IPConfig_ConstructProps)
    _init (config?: IPConfig_ConstructProps): void
    static $gtype: GObject.Type
}
interface Object_ConstructProps extends GObject.Object_ConstructProps {
}
class Object {
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::client", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: Object, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Object_ConstructProps)
    _init (config?: Object_ConstructProps): void
    static $gtype: GObject.Type
}
interface RemoteConnection_ConstructProps extends Object_ConstructProps {
}
class RemoteConnection {
    /* Properties of NM-1.0.NM.RemoteConnection */
    /**
     * File that stores the connection in case the connection is
     * file-backed.
     */
    readonly filename: string
    /**
     * The flags of the connection as unsigned integer. The values
     * correspond to the #NMSettingsConnectionFlags enum.
     */
    readonly flags: number
    /**
     * %TRUE if the remote connection contains changes that have not been saved
     * to disk, %FALSE if the connection is the same as its on-disk representation.
     */
    readonly unsaved: boolean
    /**
     * %TRUE if the remote connection is visible to the current user, %FALSE if
     * not.  If the connection is not visible then it is essentially useless; it
     * will not contain any settings, and operations such as
     * nm_remote_connection_save() and nm_remote_connection_delete() will always
     * fail. (#NMRemoteSettings will not normally return non-visible connections
     * to callers, but it is possible for a connection's visibility to change
     * after you already have a reference to it.)
     */
    readonly visible: boolean
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.RemoteConnection */
    /**
     * Send any local changes to the settings and properties of `connection` to
     * NetworkManager. If `save_to_disk` is %TRUE, the updated connection will be saved to
     * disk; if %FALSE, then only the in-memory representation will be changed.
     */
    commit_changes(save_to_disk: boolean, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously sends any local changes to the settings and properties of
     * `connection` to NetworkManager. If `save` is %TRUE, the updated connection will
     * be saved to disk; if %FALSE, then only the in-memory representation will be
     * changed.
     */
    commit_changes_async(save_to_disk: boolean, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_remote_connection_commit_changes_async().
     */
    commit_changes_finish(result: Gio.AsyncResult): boolean
    /**
     * Deletes the connection.
     */
    delete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously deletes the connection.
     */
    delete_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_remote_connection_delete_async().
     */
    delete_finish(result: Gio.AsyncResult): boolean
    get_filename(): string
    get_flags(): SettingsConnectionFlags
    /**
     * Request the connection's secrets. Note that this is a blocking D-Bus call,
     * not a simple property accessor.
     */
    get_secrets(setting_name: string, cancellable?: Gio.Cancellable | null): GLib.Variant
    /**
     * Asynchronously requests the connection's secrets.
     */
    get_secrets_async(setting_name: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_remote_connection_get_secrets_async().
     */
    get_secrets_finish(result: Gio.AsyncResult): GLib.Variant
    get_unsaved(): boolean
    /**
     * Checks if the connection is visible to the current user.  If the
     * connection is not visible then it is essentially useless; it will
     * not contain any settings, and operations such as
     * nm_remote_connection_save() and nm_remote_connection_delete() will
     * always fail. (#NMRemoteSettings will not normally return
     * non-visible connections to callers, but it is possible for a
     * connection's visibility to change after you already have a
     * reference to it.)
     */
    get_visible(): boolean
    /**
     * Saves the connection to disk if the connection has changes that have not yet
     * been written to disk, or if the connection has never been saved.
     */
    save(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Saves the connection to disk if the connection has changes that have not yet
     * been written to disk, or if the connection has never been saved.
     */
    save_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_remote_connection_save_async().
     */
    save_finish(result: Gio.AsyncResult): boolean
    /**
     * Asynchronously calls the Update2() D-Bus method.
     */
    update2(settings: GLib.Variant | null, flags: SettingsUpdate2Flags, args?: GLib.Variant | null, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_remote_connection_commit_changes_async().
     */
    update2_finish(result: Gio.AsyncResult): GLib.Variant
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of NM-1.0.NM.Connection */
    /**
     * Adds a #NMSetting to the connection, replacing any previous #NMSetting of the
     * same name which has previously been added to the #NMConnection.  The
     * connection takes ownership of the #NMSetting object and does not increase
     * the setting object's reference count.
     */
    add_setting(setting: Setting): void
    /**
     * Clears and frees any secrets that may be stored in the connection, to avoid
     * keeping secret data in memory when not needed.
     */
    clear_secrets(): void
    /**
     * Clears and frees secrets determined by `func`.
     */
    clear_secrets_with_flags(func?: SettingClearSecretsWithFlagsFn | null): void
    /**
     * Deletes all of `connection'`s settings.
     */
    clear_settings(): void
    /**
     * Compares two #NMConnection objects for similarity, with comparison behavior
     * modified by a set of flags.  See nm_setting_compare() for a description of
     * each flag's behavior.
     */
    compare(b: Connection, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMConnection objects for similarity, with comparison behavior
     * modified by a set of flags.  See nm_setting_compare() for a description of
     * each flag's behavior.  If the connections differ, settings and keys within
     * each setting that differ are added to the returned `out_settings` hash table.
     * No values are returned, only key names.
     */
    diff(b: Connection, flags: SettingCompareFlags, out_settings: GLib.HashTable): boolean
    /**
     * Print the connection (including secrets!) to stdout. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    dump(): void
    /**
     * Iterates over the properties of each #NMSetting object in the #NMConnection,
     * calling the supplied user function for each property.
     */
    for_each_setting_value(func: SettingValueIterFn): void
    /**
     * A shortcut to return the type from the connection's #NMSettingConnection.
     */
    get_connection_type(): string
    /**
     * A shortcut to return the ID from the connection's #NMSettingConnection.
     */
    get_id(): string
    /**
     * Returns the interface name as stored in NMSettingConnection:interface_name.
     * If the connection contains no NMSettingConnection, it will return %NULL.
     * 
     * For hardware devices and software devices created outside of NetworkManager,
     * this name is used to match the device. for software devices created by
     * NetworkManager, this is the name of the created interface.
     */
    get_interface_name(): string
    /**
     * Gets the #NMSetting with the given #GType, if one has been previously added
     * to the #NMConnection.
     */
    get_setting(setting_type: GObject.Type): Setting
    /**
     * A shortcut to return any #NMSetting8021x the connection might contain.
     */
    get_setting_802_1x(): Setting8021x
    /**
     * A shortcut to return any #NMSettingAdsl the connection might contain.
     */
    get_setting_adsl(): SettingAdsl
    /**
     * A shortcut to return any #NMSettingBluetooth the connection might contain.
     */
    get_setting_bluetooth(): SettingBluetooth
    /**
     * A shortcut to return any #NMSettingBond the connection might contain.
     */
    get_setting_bond(): SettingBond
    /**
     * A shortcut to return any #NMSettingBridge the connection might contain.
     */
    get_setting_bridge(): SettingBridge
    /**
     * A shortcut to return any #NMSettingBridgePort the connection might contain.
     */
    get_setting_bridge_port(): SettingBridgePort
    /**
     * Gets the #NMSetting with the given name, if one has been previously added
     * the #NMConnection.
     */
    get_setting_by_name(name: string): Setting
    /**
     * A shortcut to return any #NMSettingCdma the connection might contain.
     */
    get_setting_cdma(): SettingCdma
    /**
     * A shortcut to return any #NMSettingConnection the connection might contain.
     */
    get_setting_connection(): SettingConnection
    /**
     * A shortcut to return any #NMSettingDcb the connection might contain.
     */
    get_setting_dcb(): SettingDcb
    /**
     * A shortcut to return any #NMSettingDummy the connection might contain.
     */
    get_setting_dummy(): SettingDummy
    /**
     * A shortcut to return any #NMSettingGeneric the connection might contain.
     */
    get_setting_generic(): SettingGeneric
    /**
     * A shortcut to return any #NMSettingGsm the connection might contain.
     */
    get_setting_gsm(): SettingGsm
    /**
     * A shortcut to return any #NMSettingInfiniband the connection might contain.
     */
    get_setting_infiniband(): SettingInfiniband
    /**
     * A shortcut to return any #NMSettingIP4Config the connection might contain.
     * 
     * Note that it returns the value as type #NMSettingIPConfig, since the vast
     * majority of IPv4-setting-related methods are on that type, not
     * #NMSettingIP4Config.
     */
    get_setting_ip4_config(): SettingIP4Config
    /**
     * A shortcut to return any #NMSettingIP6Config the connection might contain.
     * 
     * Note that it returns the value as type #NMSettingIPConfig, since the vast
     * majority of IPv6-setting-related methods are on that type, not
     * #NMSettingIP6Config.
     */
    get_setting_ip6_config(): SettingIP6Config
    /**
     * A shortcut to return any #NMSettingIPTunnel the connection might contain.
     */
    get_setting_ip_tunnel(): SettingIPTunnel
    /**
     * A shortcut to return any #NMSettingMacsec the connection might contain.
     */
    get_setting_macsec(): SettingMacsec
    /**
     * A shortcut to return any #NMSettingMacvlan the connection might contain.
     */
    get_setting_macvlan(): SettingMacvlan
    /**
     * A shortcut to return any #NMSettingOlpcMesh the connection might contain.
     */
    get_setting_olpc_mesh(): SettingOlpcMesh
    /**
     * A shortcut to return any #NMSettingOvsBridge the connection might contain.
     */
    get_setting_ovs_bridge(): SettingOvsBridge
    /**
     * A shortcut to return any #NMSettingOvsInterface the connection might contain.
     */
    get_setting_ovs_interface(): SettingOvsInterface
    /**
     * A shortcut to return any #NMSettingOvsPatch the connection might contain.
     */
    get_setting_ovs_patch(): SettingOvsPatch
    /**
     * A shortcut to return any #NMSettingOvsPort the connection might contain.
     */
    get_setting_ovs_port(): SettingOvsPort
    /**
     * A shortcut to return any #NMSettingPpp the connection might contain.
     */
    get_setting_ppp(): SettingPpp
    /**
     * A shortcut to return any #NMSettingPppoe the connection might contain.
     */
    get_setting_pppoe(): SettingPppoe
    /**
     * A shortcut to return any #NMSettingProxy the connection might contain.
     */
    get_setting_proxy(): SettingProxy
    /**
     * A shortcut to return any #NMSettingSerial the connection might contain.
     */
    get_setting_serial(): SettingSerial
    /**
     * A shortcut to return any #NMSettingTCConfig the connection might contain.
     */
    get_setting_tc_config(): SettingTCConfig
    /**
     * A shortcut to return any #NMSettingTeam the connection might contain.
     */
    get_setting_team(): SettingTeam
    /**
     * A shortcut to return any #NMSettingTeamPort the connection might contain.
     */
    get_setting_team_port(): SettingTeamPort
    /**
     * A shortcut to return any #NMSettingTun the connection might contain.
     */
    get_setting_tun(): SettingTun
    /**
     * A shortcut to return any #NMSettingVlan the connection might contain.
     */
    get_setting_vlan(): SettingVlan
    /**
     * A shortcut to return any #NMSettingVpn the connection might contain.
     */
    get_setting_vpn(): SettingVpn
    /**
     * A shortcut to return any #NMSettingVxlan the connection might contain.
     */
    get_setting_vxlan(): SettingVxlan
    /**
     * A shortcut to return any #NMSettingWimax the connection might contain.
     */
    get_setting_wimax(): SettingWimax
    /**
     * A shortcut to return any #NMSettingWired the connection might contain.
     */
    get_setting_wired(): SettingWired
    /**
     * A shortcut to return any #NMSettingWireless the connection might contain.
     */
    get_setting_wireless(): SettingWireless
    /**
     * A shortcut to return any #NMSettingWirelessSecurity the connection might contain.
     */
    get_setting_wireless_security(): SettingWirelessSecurity
    /**
     * Retrieves the settings in `connection`.
     * 
     * The returned array is %NULL-terminated.
     */
    get_settings(): Setting[]
    /**
     * A shortcut to return the UUID from the connection's #NMSettingConnection.
     */
    get_uuid(): string
    /**
     * Returns the name that nm_device_disambiguate_names() would
     * return for the virtual device that would be created for `connection`.
     * Eg, "VLAN (eth1.1)".
     */
    get_virtual_device_description(): string
    /**
     * A convenience function to check if the given `connection` is a particular
     * type (ie wired, Wi-Fi, ppp, etc). Checks the #NMSettingConnection:type
     * property of the connection and matches that against `type`.
     */
    is_type(type: string): boolean
    /**
     * Checks if `connection` refers to a virtual device (and thus can potentially be
     * activated even if the device it refers to doesn't exist).
     */
    is_virtual(): boolean
    /**
     * Returns the name of the first setting object in the connection which would
     * need secrets to make a successful connection.  The returned hints are only
     * intended as a guide to what secrets may be required, because in some
     * circumstances, there is no way to conclusively determine exactly which
     * secrets are needed.
     */
    need_secrets(): [ /* returnType */ string, /* hints */ string[] | null ]
    /**
     * Does some basic normalization and fixup of well known inconsistencies
     * and deprecated fields. If the connection was modified in any way,
     * the output parameter `modified` is set %TRUE.
     * 
     * Finally the connection will be verified and %TRUE returns if the connection
     * is valid. As this function only performs some specific normalization steps
     * it cannot repair all connections. If the connection has errors that
     * cannot be normalized, the connection will not be modified.
     */
    normalize(parameters?: GLib.HashTable | null): [ /* returnType */ boolean, /* modified */ boolean | null ]
    /**
     * Removes the #NMSetting with the given #GType from the #NMConnection.  This
     * operation dereferences the #NMSetting object.
     */
    remove_setting(setting_type: GObject.Type): void
    /**
     * Replaces `connection'`s settings with `new_settings` (which must be
     * syntactically valid, and describe a known type of connection, but does not
     * need to result in a connection that passes nm_connection_verify()).
     */
    replace_settings(new_settings: GLib.Variant): boolean
    /**
     * Deep-copies the settings of `new_connection` and replaces the settings of `connection`
     * with the copied settings.
     */
    replace_settings_from_connection(new_connection: Connection): void
    /**
     * Sets the D-Bus path of the connection.  This property is not serialized, and
     * is only for the reference of the caller.  Sets the #NMConnection:path
     * property.
     */
    set_path(path: string): void
    /**
     * Converts the #NMConnection into a #GVariant of type
     * %NM_VARIANT_TYPE_CONNECTION describing the connection, suitable for
     * marshalling over D-Bus or otherwise serializing.
     */
    to_dbus(flags: ConnectionSerializationFlags): GLib.Variant
    /**
     * Update the specified setting's secrets, given a dictionary of secrets
     * intended for that setting (deserialized from D-Bus for example).  Will also
     * extract the given setting's secrets hash if given a connection dictionary.
     * If `setting_name` is %NULL, expects a fully serialized #NMConnection as
     * returned by nm_connection_to_dbus() and will update all secrets from all
     * settings contained in `secrets`.
     */
    update_secrets(setting_name: string, secrets: GLib.Variant): boolean
    /**
     * Validates the connection and all its settings.  Each setting's properties
     * have allowed values, and some values are dependent on other values.  For
     * example, if a Wi-Fi connection is security enabled, the #NMSettingWireless
     * setting object's 'security' property must contain the setting name of the
     * #NMSettingWirelessSecurity object, which must also be present in the
     * connection for the connection to be valid.  As another example, the
     * #NMSettingWired object's 'mac-address' property must be a validly formatted
     * MAC address.  The returned #GError contains information about which
     * setting and which property failed validation, and how it failed validation.
     */
    verify(): boolean
    /**
     * Verifies the secrets in the connection.
     */
    verify_secrets(): boolean
    /* Virtual methods of NM-1.0.NM.RemoteConnection */
    vfunc_changed(): void
    vfunc_secrets_cleared(): void
    vfunc_secrets_updated(setting: string): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Connection */
    /**
     * The ::changed signal is emitted when any property (including secrets)
     * of any setting of the connection is modified, or when settings are
     * added or removed.
     */
    connect(sigName: "changed", callback: (($obj: RemoteConnection) => void)): number
    connect_after(sigName: "changed", callback: (($obj: RemoteConnection) => void)): number
    emit(sigName: "changed"): void
    /**
     * The ::secrets-cleared signal is emitted when the secrets of a connection
     * are cleared.
     */
    connect(sigName: "secrets-cleared", callback: (($obj: RemoteConnection) => void)): number
    connect_after(sigName: "secrets-cleared", callback: (($obj: RemoteConnection) => void)): number
    emit(sigName: "secrets-cleared"): void
    /**
     * The ::secrets-updated signal is emitted when the secrets of a setting
     * have been changed.
     */
    connect(sigName: "secrets-updated", callback: (($obj: RemoteConnection, setting_name: string) => void)): number
    connect_after(sigName: "secrets-updated", callback: (($obj: RemoteConnection, setting_name: string) => void)): number
    emit(sigName: "secrets-updated", setting_name: string): void
    connect(sigName: "notify::filename", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::flags", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::unsaved", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::unsaved", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::visible", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::visible", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: RemoteConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: RemoteConnection_ConstructProps)
    _init (config?: RemoteConnection_ConstructProps): void
    static $gtype: GObject.Type
}
interface SecretAgentOld_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SecretAgentOld */
    /**
     * If %TRUE (the default), the agent will always be registered when
     * NetworkManager is running; if NetworkManager exits and restarts, the
     * agent will re-register itself automatically.
     * 
     * In particular, if this property is %TRUE at construct time, then the
     * agent will register itself with NetworkManager during
     * construction/initialization and initialization will only complete
     * after registration is completed (either successfully or unsuccessfully).
     * Since 1.24, a failure to register will no longer cause initialization
     * of #NMSecretAgentOld to fail.
     * 
     * If the property is %FALSE, the agent will not automatically register with
     * NetworkManager, and nm_secret_agent_old_enable() or
     * nm_secret_agent_old_register_async() must be called to register it.
     * 
     * Calling nm_secret_agent_old_enable() has the same effect as setting this
     * property.
     */
    auto_register?: boolean
    /**
     * A bitfield of %NMSecretAgentCapabilities.
     * 
     * Changing this property is possible at any time. In case the secret
     * agent is currently registered, this will cause a re-registration.
     */
    capabilities?: SecretAgentCapabilities
    /**
     * The #GDBusConnection used by the instance. You may either set this
     * as construct-only property, or otherwise #NMSecretAgentOld will choose
     * a connection via g_bus_get() during initialization.
     */
    dbus_connection?: Gio.DBusConnection
    /**
     * Identifies this agent; only one agent in each user session may use the
     * same identifier.  Identifier formatting follows the same rules as
     * D-Bus bus names with the exception that the ':' character is not
     * allowed.  The valid set of characters is "[A-Z][a-z][0-9]_-." and the
     * identifier is limited in length to 255 characters with a minimum
     * of 3 characters.  An example valid identifier is 'org.gnome.nm-applet'
     * (without quotes).
     */
    identifier?: string
}
class SecretAgentOld {
    /* Properties of NM-1.0.NM.SecretAgentOld */
    /**
     * If %TRUE (the default), the agent will always be registered when
     * NetworkManager is running; if NetworkManager exits and restarts, the
     * agent will re-register itself automatically.
     * 
     * In particular, if this property is %TRUE at construct time, then the
     * agent will register itself with NetworkManager during
     * construction/initialization and initialization will only complete
     * after registration is completed (either successfully or unsuccessfully).
     * Since 1.24, a failure to register will no longer cause initialization
     * of #NMSecretAgentOld to fail.
     * 
     * If the property is %FALSE, the agent will not automatically register with
     * NetworkManager, and nm_secret_agent_old_enable() or
     * nm_secret_agent_old_register_async() must be called to register it.
     * 
     * Calling nm_secret_agent_old_enable() has the same effect as setting this
     * property.
     */
    auto_register: boolean
    /**
     * A bitfield of %NMSecretAgentCapabilities.
     * 
     * Changing this property is possible at any time. In case the secret
     * agent is currently registered, this will cause a re-registration.
     */
    capabilities: SecretAgentCapabilities
    /**
     * %TRUE if the agent is registered with NetworkManager, %FALSE if not.
     */
    readonly registered: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SecretAgentOld */
    /**
     * Asynchronously asks the agent to delete all saved secrets belonging to
     * `connection`.
     */
    delete_secrets(connection: Connection, callback: SecretAgentOldDeleteSecretsFunc): void
    /**
     * Since 1.24, the instance will already register a D-Bus object on the
     * D-Bus connection during initialization. That object will stay registered
     * until `self` gets unrefed (destroyed) or this function is called. This
     * function performs the necessary cleanup to tear down the instance. Afterwards,
     * the function can not longer be used. This is optional, but necessary to
     * ensure unregistering the D-Bus object at a define point, when other users
     * might still have a reference on `self`.
     * 
     * You may call this function any time and repeatedly. However, after destroying
     * the instance, it is a bug to still use the instance for other purposes. The
     * instance becomes defunct and cannot re-register.
     */
    destroy(): void
    /**
     * This has the same effect as setting %NM_SECRET_AGENT_OLD_AUTO_REGISTER
     * property.
     * 
     * Unlike most other functions, you may already call this function before
     * initialization completes.
     */
    enable(enable: boolean): void
    /**
     * Returns a #GObject that stays alive as long as there are pending
     * requests in the #GDBusConnection. Such requests keep the #GMainContext
     * alive, and thus you may want to keep iterating the context as long
     * until a weak reference indicates that this object is gone. This is
     * useful because even when you destroy the instance right away (and all
     * the internally pending requests get cancelled), any pending g_dbus_connection_call()
     * requests will still invoke the result on the #GMainContext. Hence, this
     * allows you to know how long you must iterate the context to know
     * that all remains are cleaned up.
     */
    get_context_busy_watcher(): GObject.Object
    get_dbus_connection(): Gio.DBusConnection
    get_dbus_name_owner(): string
    get_main_context(): GLib.MainContext
    /**
     * Note that the secret agent transparently registers and re-registers
     * as the D-Bus name owner appears. Hence, this property is not really
     * useful. Also, to be graceful against races during registration, the
     * instance will already accept requests while being in the process of
     * registering.
     * If you need to avoid races and want to wait until `self` is registered,
     * call nm_secret_agent_old_register_async(). If that function completes
     * with success, you know the instance is registered.
     */
    get_registered(): boolean
    /**
     * Asynchronously retrieves secrets belonging to `connection` for the
     * setting `setting_name`.  `flags` indicate specific behavior that the secret
     * agent should use when performing the request, for example returning only
     * existing secrets without user interaction, or requesting entirely new
     * secrets from the user.
     */
    get_secrets(connection: Connection, setting_name: string, hints: string[], flags: SecretAgentGetSecretsFlags, callback: SecretAgentOldGetSecretsFunc): void
    /**
     * Registers the #NMSecretAgentOld with the NetworkManager secret manager,
     * indicating to NetworkManager that the agent is able to provide and save
     * secrets for connections on behalf of its user.
     */
    register(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously registers the #NMSecretAgentOld with the NetworkManager secret
     * manager, indicating to NetworkManager that the agent is able to provide and
     * save secrets for connections on behalf of its user.
     * 
     * Since 1.24, registration cannot fail and is idempotent. It has
     * the same effect as setting %NM_SECRET_AGENT_OLD_AUTO_REGISTER to %TRUE
     * or nm_secret_agent_old_enable().
     * 
     * Since 1.24, the asynchronous result indicates whether the instance is successfully
     * registered. In any case, this call enables the agent and it will automatically
     * try to register and handle secret requests. A failure of this function only indicates
     * that currently the instance might not be ready (but since it will automatically
     * try to recover, it might be ready in a moment afterwards). Use this function if
     * you want to check and ensure that the agent is registered.
     */
    register_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_secret_agent_old_register_async().
     */
    register_finish(result: Gio.AsyncResult): boolean
    /**
     * Asynchronously ensures that all secrets inside `connection` are stored to
     * disk.
     */
    save_secrets(connection: Connection, callback: SecretAgentOldSaveSecretsFunc): void
    /**
     * Unregisters the #NMSecretAgentOld with the NetworkManager secret manager,
     * indicating to NetworkManager that the agent will no longer provide or
     * store secrets on behalf of this user.
     */
    unregister(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously unregisters the #NMSecretAgentOld with the NetworkManager secret
     * manager, indicating to NetworkManager that the agent will no longer provide
     * or store secrets on behalf of this user.
     * 
     * Since 1.24, registration cannot fail and is idempotent. It has
     * the same effect as setting %NM_SECRET_AGENT_OLD_AUTO_REGISTER to %FALSE
     * or nm_secret_agent_old_enable().
     */
    unregister_async(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Gets the result of a call to nm_secret_agent_old_unregister_async().
     */
    unregister_finish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    init_finish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    new_finish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of NM-1.0.NM.SecretAgentOld */
    vfunc_cancel_get_secrets(connection_path: string, setting_name: string): void
    /**
     * Asynchronously asks the agent to delete all saved secrets belonging to
     * `connection`.
     */
    vfunc_delete_secrets(connection: Connection, connection_path: string, callback: SecretAgentOldDeleteSecretsFunc): void
    /**
     * Asynchronously retrieves secrets belonging to `connection` for the
     * setting `setting_name`.  `flags` indicate specific behavior that the secret
     * agent should use when performing the request, for example returning only
     * existing secrets without user interaction, or requesting entirely new
     * secrets from the user.
     */
    vfunc_get_secrets(connection: Connection, connection_path: string, setting_name: string, hints: string[], flags: SecretAgentGetSecretsFlags, callback: SecretAgentOldGetSecretsFunc): void
    /**
     * Asynchronously ensures that all secrets inside `connection` are stored to
     * disk.
     */
    vfunc_save_secrets(connection: Connection, connection_path: string, callback: SecretAgentOldSaveSecretsFunc): void
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    vfunc_init_async(io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    vfunc_init_finish(res: Gio.AsyncResult): boolean
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::auto-register", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-register", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::capabilities", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::registered", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::registered", callback: (($obj: SecretAgentOld, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SecretAgentOld_ConstructProps)
    _init (config?: SecretAgentOld_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newv_async(object_type: GObject.Type, n_parameters: number, parameters: GObject.Parameter, io_priority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface Setting_ConstructProps extends GObject.Object_ConstructProps {
}
class Setting {
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Setting, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Setting, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: Setting, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: Setting, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Setting_ConstructProps)
    _init (config?: Setting_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Returns the #GType of the setting's class for a given setting name.
     */
    static lookup_type(name: string): GObject.Type
    static $gtype: GObject.Type
}
interface Setting6Lowpan_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.Setting6Lowpan */
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this 6LowPAN interface should be created.
     */
    parent?: string
}
class Setting6Lowpan {
    /* Properties of NM-1.0.NM.Setting6Lowpan */
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this 6LowPAN interface should be created.
     */
    parent: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Setting6Lowpan */
    get_parent(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Setting6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Setting6Lowpan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parent", callback: (($obj: Setting6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: Setting6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: Setting6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: Setting6Lowpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Setting6Lowpan_ConstructProps)
    _init (config?: Setting6Lowpan_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Setting6Lowpan
    static $gtype: GObject.Type
}
interface Setting8021x_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.Setting8021x */
    /**
     * List of strings to be matched against the altSubjectName of the
     * certificate presented by the authentication server. If the list is empty,
     * no verification of the server certificate's altSubjectName is performed.
     */
    altsubject_matches?: string[]
    /**
     * Anonymous identity string for EAP authentication methods.  Used as the
     * unencrypted identity with EAP types that support different tunneled
     * identity like EAP-TTLS.
     */
    anonymous_identity?: string
    /**
     * A timeout for the authentication. Zero means the global default; if the
     * global default is not set, the authentication timeout is 25 seconds.
     */
    auth_timeout?: number
    /**
     * Contains the CA certificate if used by the EAP method specified in the
     * #NMSetting8021x:eap property.
     * 
     * Certificate data is specified using a "scheme"; three are currently
     * supported: blob, path and pkcs#11 URL. When using the blob scheme this property
     * should be set to the certificate's DER encoded data. When using the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * certificate, prefixed with the string "file://" and ending with a terminating
     * NUL byte.
     * This property can be unset even if the EAP method supports CA certificates,
     * but this allows man-in-the-middle attacks and is NOT recommended.
     * 
     * Note that enabling NMSetting8021x:system-ca-certs will override this
     * setting to use the built-in path, if the built-in path is not a directory.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_ca_cert() function instead.
     */
    ca_cert?: GLib.Bytes
    /**
     * The password used to access the CA certificate stored in
     * #NMSetting8021x:ca-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    ca_cert_password?: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:ca-cert-password property.
     */
    ca_cert_password_flags?: SettingSecretFlags
    /**
     * UTF-8 encoded path to a directory containing PEM or DER formatted
     * certificates to be added to the verification chain in addition to the
     * certificate specified in the #NMSetting8021x:ca-cert property.
     * 
     * If NMSetting8021x:system-ca-certs is enabled and the built-in CA
     * path is an existing directory, then this setting is ignored.
     */
    ca_path?: string
    /**
     * Contains the client certificate if used by the EAP method specified in
     * the #NMSetting8021x:eap property.
     * 
     * Certificate data is specified using a "scheme"; two are currently
     * supported: blob and path. When using the blob scheme (which is backwards
     * compatible with NM 0.7.x) this property should be set to the
     * certificate's DER encoded data. When using the path scheme, this property
     * should be set to the full UTF-8 encoded path of the certificate, prefixed
     * with the string "file://" and ending with a terminating NUL byte.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_client_cert() function instead.
     */
    client_cert?: GLib.Bytes
    /**
     * The password used to access the client certificate stored in
     * #NMSetting8021x:client-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    client_cert_password?: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:client-cert-password property.
     */
    client_cert_password_flags?: SettingSecretFlags
    /**
     * Constraint for server domain name. If set, this list of FQDNs is used as
     * a match requirement for dNSName element(s) of the certificate presented
     * by the authentication server.  If a matching dNSName is found, this
     * constraint is met.  If no dNSName values are present, this constraint is
     * matched against SubjectName CN using the same comparison.
     * Multiple valid FQDNs can be passed as a ";" delimited list.
     */
    domain_match?: string
    /**
     * Constraint for server domain name. If set, this FQDN is used as a suffix
     * match requirement for dNSName element(s) of the certificate presented by
     * the authentication server.  If a matching dNSName is found, this
     * constraint is met.  If no dNSName values are present, this constraint is
     * matched against SubjectName CN using same suffix match comparison.
     * Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
     * list.
     */
    domain_suffix_match?: string
    /**
     * The allowed EAP method to be used when authenticating to the network with
     * 802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
     * and "fast".  Each method requires different configuration using the
     * properties of this setting; refer to wpa_supplicant documentation for the
     * allowed combinations.
     */
    eap?: string[]
    /**
     * Identity string for EAP authentication methods.  Often the user's user or
     * login name.
     */
    identity?: string
    /**
     * Whether the 802.1X authentication is optional. If %TRUE, the activation
     * will continue even after a timeout or an authentication failure. Setting
     * the property to %TRUE is currently allowed only for Ethernet connections.
     * If set to %FALSE, the activation can continue only after a successful
     * authentication.
     */
    optional?: boolean
    /**
     * UTF-8 encoded file path containing PAC for EAP-FAST.
     */
    pac_file?: string
    /**
     * UTF-8 encoded password used for EAP authentication methods. If both the
     * #NMSetting8021x:password property and the #NMSetting8021x:password-raw
     * property are specified, #NMSetting8021x:password is preferred.
     */
    password?: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:password property.
     */
    password_flags?: SettingSecretFlags
    /**
     * Password used for EAP authentication methods, given as a byte array to
     * allow passwords in other encodings than UTF-8 to be used. If both the
     * #NMSetting8021x:password property and the #NMSetting8021x:password-raw
     * property are specified, #NMSetting8021x:password is preferred.
     */
    password_raw?: GLib.Bytes
    /**
     * Flags indicating how to handle the #NMSetting8021x:password-raw property.
     */
    password_raw_flags?: SettingSecretFlags
    /**
     * Specifies authentication flags to use in "phase 1" outer
     * authentication using #NMSetting8021xAuthFlags options.
     * The individual TLS versions can be explicitly disabled. If a certain
     * TLS disable flag is not set, it is up to the supplicant to allow
     * or forbid it. The TLS options map to tls_disable_tlsv1_x settings.
     * See the wpa_supplicant documentation for more details.
     */
    phase1_auth_flags?: number
    /**
     * Enables or disables in-line provisioning of EAP-FAST credentials when
     * FAST is specified as the EAP method in the #NMSetting8021x:eap property.
     * Recognized values are "0" (disabled), "1" (allow unauthenticated
     * provisioning), "2" (allow authenticated provisioning), and "3" (allow
     * both authenticated and unauthenticated provisioning).  See the
     * wpa_supplicant documentation for more details.
     */
    phase1_fast_provisioning?: string
    /**
     * Forces use of the new PEAP label during key derivation.  Some RADIUS
     * servers may require forcing the new PEAP label to interoperate with
     * PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
     * wpa_supplicant documentation for more details.
     */
    phase1_peaplabel?: string
    /**
     * Forces which PEAP version is used when PEAP is set as the EAP method in
     * the #NMSetting8021x:eap property.  When unset, the version reported by
     * the server will be used.  Sometimes when using older RADIUS servers, it
     * is necessary to force the client to use a particular PEAP version.  To do
     * so, this property may be set to "0" or "1" to force that specific PEAP
     * version.
     */
    phase1_peapver?: string
    /**
     * List of strings to be matched against the altSubjectName of the
     * certificate presented by the authentication server during the inner
     * "phase 2" authentication. If the list is empty, no verification of the
     * server certificate's altSubjectName is performed.
     */
    phase2_altsubject_matches?: string[]
    /**
     * Specifies the allowed "phase 2" inner authentication method when an EAP
     * method that uses an inner TLS tunnel is specified in the #NMSetting8021x:eap
     * property.  For TTLS this property selects one of the supported non-EAP
     * inner methods: "pap", "chap", "mschap", "mschapv2" while
     * #NMSetting8021x:phase2-autheap selects an EAP inner method.  For PEAP
     * this selects an inner EAP method, one of: "gtc", "otp", "md5" and "tls".
     * Each "phase 2" inner method requires specific parameters for successful
     * authentication; see the wpa_supplicant documentation for more details.
     * Both #NMSetting8021x:phase2-auth and #NMSetting8021x:phase2-autheap cannot
     * be specified.
     */
    phase2_auth?: string
    /**
     * Specifies the allowed "phase 2" inner EAP-based authentication method
     * when TTLS is specified in the #NMSetting8021x:eap property.  Recognized
     * EAP-based "phase 2" methods are "md5", "mschapv2", "otp", "gtc", and
     * "tls". Each "phase 2" inner method requires specific parameters for
     * successful authentication; see the wpa_supplicant documentation for
     * more details.
     */
    phase2_autheap?: string
    /**
     * Contains the "phase 2" CA certificate if used by the EAP method specified
     * in the #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap
     * properties.
     * 
     * Certificate data is specified using a "scheme"; three are currently
     * supported: blob, path and pkcs#11 URL. When using the blob scheme this property
     * should be set to the certificate's DER encoded data. When using the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * certificate, prefixed with the string "file://" and ending with a terminating
     * NUL byte.
     * This property can be unset even if the EAP method supports CA certificates,
     * but this allows man-in-the-middle attacks and is NOT recommended.
     * 
     * Note that enabling NMSetting8021x:system-ca-certs will override this
     * setting to use the built-in path, if the built-in path is not a directory.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_phase2_ca_cert() function instead.
     */
    phase2_ca_cert?: GLib.Bytes
    /**
     * The password used to access the "phase2" CA certificate stored in
     * #NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    phase2_ca_cert_password?: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:phase2-ca-cert-password property.
     */
    phase2_ca_cert_password_flags?: SettingSecretFlags
    /**
     * UTF-8 encoded path to a directory containing PEM or DER formatted
     * certificates to be added to the verification chain in addition to the
     * certificate specified in the #NMSetting8021x:phase2-ca-cert property.
     * 
     * If NMSetting8021x:system-ca-certs is enabled and the built-in CA
     * path is an existing directory, then this setting is ignored.
     */
    phase2_ca_path?: string
    /**
     * Contains the "phase 2" client certificate if used by the EAP method
     * specified in the #NMSetting8021x:phase2-auth or
     * #NMSetting8021x:phase2-autheap properties.
     * 
     * Certificate data is specified using a "scheme"; two are currently
     * supported: blob and path. When using the blob scheme (which is backwards
     * compatible with NM 0.7.x) this property should be set to the
     * certificate's DER encoded data. When using the path scheme, this property
     * should be set to the full UTF-8 encoded path of the certificate, prefixed
     * with the string "file://" and ending with a terminating NUL byte. This
     * property can be unset even if the EAP method supports CA certificates,
     * but this allows man-in-the-middle attacks and is NOT recommended.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_phase2_client_cert() function instead.
     */
    phase2_client_cert?: GLib.Bytes
    /**
     * The password used to access the "phase2" client certificate stored in
     * #NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    phase2_client_cert_password?: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:phase2-client-cert-password property.
     */
    phase2_client_cert_password_flags?: SettingSecretFlags
    /**
     * Constraint for server domain name. If set, this list of FQDNs is used as
     * a match requirement for dNSName element(s) of the certificate presented
     * by the authentication server during the inner "phase 2" authentication.
     * If a matching dNSName is found, this constraint is met.  If no dNSName
     * values are present, this constraint is matched against SubjectName CN
     * using the same comparison.
     * Multiple valid FQDNs can be passed as a ";" delimited list.
     */
    phase2_domain_match?: string
    /**
     * Constraint for server domain name. If set, this FQDN is used as a suffix
     * match requirement for dNSName element(s) of the certificate presented by
     * the authentication server during the inner "phase 2" authentication.  If
     * a matching dNSName is found, this constraint is met.  If no dNSName
     * values are present, this constraint is matched against SubjectName CN
     * using same suffix match comparison.
     * Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
     * list.
     */
    phase2_domain_suffix_match?: string
    /**
     * Contains the "phase 2" inner private key when the
     * #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap property is
     * set to "tls".
     * 
     * Key data is specified using a "scheme"; two are currently supported: blob
     * and path. When using the blob scheme and private keys, this property
     * should be set to the key's encrypted PEM encoded data. When using private
     * keys with the path scheme, this property should be set to the full UTF-8
     * encoded path of the key, prefixed with the string "file://" and ending
     * with a terminating NUL byte. When using PKCS#<!-- -->12 format private
     * keys and the blob scheme, this property should be set to the
     * PKCS#<!-- -->12 data and the #NMSetting8021x:phase2-private-key-password
     * property must be set to password used to decrypt the PKCS#<!-- -->12
     * certificate and key. When using PKCS#<!-- -->12 files and the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * key, prefixed with the string "file://" and ending with a terminating
     * NUL byte, and as with the blob scheme the
     * #NMSetting8021x:phase2-private-key-password property must be set to the
     * password used to decode the PKCS#<!-- -->12 private key and certificate.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_phase2_private_key() function instead.
     */
    phase2_private_key?: GLib.Bytes
    /**
     * The password used to decrypt the "phase 2" private key specified in the
     * #NMSetting8021x:phase2-private-key property when the private key either
     * uses the path scheme, or is a PKCS#<!-- -->12 format key.  Setting this
     * property directly is not generally necessary except when returning
     * secrets to NetworkManager; it is generally set automatically when setting
     * the private key by the nm_setting_802_1x_set_phase2_private_key()
     * function.
     */
    phase2_private_key_password?: string
    /**
     * Flags indicating how to handle the
     * #NMSetting8021x:phase2-private-key-password property.
     */
    phase2_private_key_password_flags?: SettingSecretFlags
    /**
     * Substring to be matched against the subject of the certificate presented
     * by the authentication server during the inner "phase 2"
     * authentication. When unset, no verification of the authentication server
     * certificate's subject is performed.  This property provides little security,
     * if any, and its use is deprecated in favor of
     * NMSetting8021x:phase2-domain-suffix-match.
     */
    phase2_subject_match?: string
    /**
     * PIN used for EAP authentication methods.
     */
    pin?: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:pin property.
     */
    pin_flags?: SettingSecretFlags
    /**
     * Contains the private key when the #NMSetting8021x:eap property is set to
     * "tls".
     * 
     * Key data is specified using a "scheme"; two are currently supported: blob
     * and path. When using the blob scheme and private keys, this property
     * should be set to the key's encrypted PEM encoded data. When using private
     * keys with the path scheme, this property should be set to the full UTF-8
     * encoded path of the key, prefixed with the string "file://" and ending
     * with a terminating NUL byte. When using PKCS#<!-- -->12 format private
     * keys and the blob scheme, this property should be set to the
     * PKCS#<!-- -->12 data and the #NMSetting8021x:private-key-password
     * property must be set to password used to decrypt the PKCS#<!-- -->12
     * certificate and key. When using PKCS#<!-- -->12 files and the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * key, prefixed with the string "file://" and ending with a terminating
     * NUL byte, and as with the blob scheme the "private-key-password" property
     * must be set to the password used to decode the PKCS#<!-- -->12 private
     * key and certificate.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_private_key() function instead.
     * 
     * WARNING: #NMSetting8021x:private-key is not a "secret" property, and thus
     * unencrypted private key data using the BLOB scheme may be readable by
     * unprivileged users.  Private keys should always be encrypted with a
     * private key password to prevent unauthorized access to unencrypted
     * private key data.
     */
    private_key?: GLib.Bytes
    /**
     * The password used to decrypt the private key specified in the
     * #NMSetting8021x:private-key property when the private key either uses the
     * path scheme, or if the private key is a PKCS#<!-- -->12 format key.  Setting this
     * property directly is not generally necessary except when returning
     * secrets to NetworkManager; it is generally set automatically when setting
     * the private key by the nm_setting_802_1x_set_private_key() function.
     */
    private_key_password?: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:private-key-password
     * property.
     */
    private_key_password_flags?: SettingSecretFlags
    /**
     * Substring to be matched against the subject of the certificate presented
     * by the authentication server. When unset, no verification of the
     * authentication server certificate's subject is performed.  This property
     * provides little security, if any, and its use is deprecated in favor of
     * NMSetting8021x:domain-suffix-match.
     */
    subject_match?: string
    /**
     * When %TRUE, overrides the #NMSetting8021x:ca-path and
     * #NMSetting8021x:phase2-ca-path properties using the system CA directory
     * specified at configure time with the --system-ca-path switch.  The
     * certificates in this directory are added to the verification chain in
     * addition to any certificates specified by the #NMSetting8021x:ca-cert and
     * #NMSetting8021x:phase2-ca-cert properties. If the path provided with
     * --system-ca-path is rather a file name (bundle of trusted CA certificates),
     * it overrides #NMSetting8021x:ca-cert and #NMSetting8021x:phase2-ca-cert
     * properties instead (sets ca_cert/ca_cert2 options for wpa_supplicant).
     */
    system_ca_certs?: boolean
}
class Setting8021x {
    /* Properties of NM-1.0.NM.Setting8021x */
    /**
     * List of strings to be matched against the altSubjectName of the
     * certificate presented by the authentication server. If the list is empty,
     * no verification of the server certificate's altSubjectName is performed.
     */
    altsubject_matches: string[]
    /**
     * Anonymous identity string for EAP authentication methods.  Used as the
     * unencrypted identity with EAP types that support different tunneled
     * identity like EAP-TTLS.
     */
    anonymous_identity: string
    /**
     * A timeout for the authentication. Zero means the global default; if the
     * global default is not set, the authentication timeout is 25 seconds.
     */
    auth_timeout: number
    /**
     * Contains the CA certificate if used by the EAP method specified in the
     * #NMSetting8021x:eap property.
     * 
     * Certificate data is specified using a "scheme"; three are currently
     * supported: blob, path and pkcs#11 URL. When using the blob scheme this property
     * should be set to the certificate's DER encoded data. When using the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * certificate, prefixed with the string "file://" and ending with a terminating
     * NUL byte.
     * This property can be unset even if the EAP method supports CA certificates,
     * but this allows man-in-the-middle attacks and is NOT recommended.
     * 
     * Note that enabling NMSetting8021x:system-ca-certs will override this
     * setting to use the built-in path, if the built-in path is not a directory.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_ca_cert() function instead.
     */
    ca_cert: GLib.Bytes
    /**
     * The password used to access the CA certificate stored in
     * #NMSetting8021x:ca-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    ca_cert_password: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:ca-cert-password property.
     */
    ca_cert_password_flags: SettingSecretFlags
    /**
     * UTF-8 encoded path to a directory containing PEM or DER formatted
     * certificates to be added to the verification chain in addition to the
     * certificate specified in the #NMSetting8021x:ca-cert property.
     * 
     * If NMSetting8021x:system-ca-certs is enabled and the built-in CA
     * path is an existing directory, then this setting is ignored.
     */
    ca_path: string
    /**
     * Contains the client certificate if used by the EAP method specified in
     * the #NMSetting8021x:eap property.
     * 
     * Certificate data is specified using a "scheme"; two are currently
     * supported: blob and path. When using the blob scheme (which is backwards
     * compatible with NM 0.7.x) this property should be set to the
     * certificate's DER encoded data. When using the path scheme, this property
     * should be set to the full UTF-8 encoded path of the certificate, prefixed
     * with the string "file://" and ending with a terminating NUL byte.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_client_cert() function instead.
     */
    client_cert: GLib.Bytes
    /**
     * The password used to access the client certificate stored in
     * #NMSetting8021x:client-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    client_cert_password: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:client-cert-password property.
     */
    client_cert_password_flags: SettingSecretFlags
    /**
     * Constraint for server domain name. If set, this list of FQDNs is used as
     * a match requirement for dNSName element(s) of the certificate presented
     * by the authentication server.  If a matching dNSName is found, this
     * constraint is met.  If no dNSName values are present, this constraint is
     * matched against SubjectName CN using the same comparison.
     * Multiple valid FQDNs can be passed as a ";" delimited list.
     */
    domain_match: string
    /**
     * Constraint for server domain name. If set, this FQDN is used as a suffix
     * match requirement for dNSName element(s) of the certificate presented by
     * the authentication server.  If a matching dNSName is found, this
     * constraint is met.  If no dNSName values are present, this constraint is
     * matched against SubjectName CN using same suffix match comparison.
     * Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
     * list.
     */
    domain_suffix_match: string
    /**
     * The allowed EAP method to be used when authenticating to the network with
     * 802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
     * and "fast".  Each method requires different configuration using the
     * properties of this setting; refer to wpa_supplicant documentation for the
     * allowed combinations.
     */
    eap: string[]
    /**
     * Identity string for EAP authentication methods.  Often the user's user or
     * login name.
     */
    identity: string
    /**
     * Whether the 802.1X authentication is optional. If %TRUE, the activation
     * will continue even after a timeout or an authentication failure. Setting
     * the property to %TRUE is currently allowed only for Ethernet connections.
     * If set to %FALSE, the activation can continue only after a successful
     * authentication.
     */
    optional: boolean
    /**
     * UTF-8 encoded file path containing PAC for EAP-FAST.
     */
    pac_file: string
    /**
     * UTF-8 encoded password used for EAP authentication methods. If both the
     * #NMSetting8021x:password property and the #NMSetting8021x:password-raw
     * property are specified, #NMSetting8021x:password is preferred.
     */
    password: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:password property.
     */
    password_flags: SettingSecretFlags
    /**
     * Password used for EAP authentication methods, given as a byte array to
     * allow passwords in other encodings than UTF-8 to be used. If both the
     * #NMSetting8021x:password property and the #NMSetting8021x:password-raw
     * property are specified, #NMSetting8021x:password is preferred.
     */
    password_raw: GLib.Bytes
    /**
     * Flags indicating how to handle the #NMSetting8021x:password-raw property.
     */
    password_raw_flags: SettingSecretFlags
    /**
     * Specifies authentication flags to use in "phase 1" outer
     * authentication using #NMSetting8021xAuthFlags options.
     * The individual TLS versions can be explicitly disabled. If a certain
     * TLS disable flag is not set, it is up to the supplicant to allow
     * or forbid it. The TLS options map to tls_disable_tlsv1_x settings.
     * See the wpa_supplicant documentation for more details.
     */
    phase1_auth_flags: number
    /**
     * Enables or disables in-line provisioning of EAP-FAST credentials when
     * FAST is specified as the EAP method in the #NMSetting8021x:eap property.
     * Recognized values are "0" (disabled), "1" (allow unauthenticated
     * provisioning), "2" (allow authenticated provisioning), and "3" (allow
     * both authenticated and unauthenticated provisioning).  See the
     * wpa_supplicant documentation for more details.
     */
    phase1_fast_provisioning: string
    /**
     * Forces use of the new PEAP label during key derivation.  Some RADIUS
     * servers may require forcing the new PEAP label to interoperate with
     * PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
     * wpa_supplicant documentation for more details.
     */
    phase1_peaplabel: string
    /**
     * Forces which PEAP version is used when PEAP is set as the EAP method in
     * the #NMSetting8021x:eap property.  When unset, the version reported by
     * the server will be used.  Sometimes when using older RADIUS servers, it
     * is necessary to force the client to use a particular PEAP version.  To do
     * so, this property may be set to "0" or "1" to force that specific PEAP
     * version.
     */
    phase1_peapver: string
    /**
     * List of strings to be matched against the altSubjectName of the
     * certificate presented by the authentication server during the inner
     * "phase 2" authentication. If the list is empty, no verification of the
     * server certificate's altSubjectName is performed.
     */
    phase2_altsubject_matches: string[]
    /**
     * Specifies the allowed "phase 2" inner authentication method when an EAP
     * method that uses an inner TLS tunnel is specified in the #NMSetting8021x:eap
     * property.  For TTLS this property selects one of the supported non-EAP
     * inner methods: "pap", "chap", "mschap", "mschapv2" while
     * #NMSetting8021x:phase2-autheap selects an EAP inner method.  For PEAP
     * this selects an inner EAP method, one of: "gtc", "otp", "md5" and "tls".
     * Each "phase 2" inner method requires specific parameters for successful
     * authentication; see the wpa_supplicant documentation for more details.
     * Both #NMSetting8021x:phase2-auth and #NMSetting8021x:phase2-autheap cannot
     * be specified.
     */
    phase2_auth: string
    /**
     * Specifies the allowed "phase 2" inner EAP-based authentication method
     * when TTLS is specified in the #NMSetting8021x:eap property.  Recognized
     * EAP-based "phase 2" methods are "md5", "mschapv2", "otp", "gtc", and
     * "tls". Each "phase 2" inner method requires specific parameters for
     * successful authentication; see the wpa_supplicant documentation for
     * more details.
     */
    phase2_autheap: string
    /**
     * Contains the "phase 2" CA certificate if used by the EAP method specified
     * in the #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap
     * properties.
     * 
     * Certificate data is specified using a "scheme"; three are currently
     * supported: blob, path and pkcs#11 URL. When using the blob scheme this property
     * should be set to the certificate's DER encoded data. When using the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * certificate, prefixed with the string "file://" and ending with a terminating
     * NUL byte.
     * This property can be unset even if the EAP method supports CA certificates,
     * but this allows man-in-the-middle attacks and is NOT recommended.
     * 
     * Note that enabling NMSetting8021x:system-ca-certs will override this
     * setting to use the built-in path, if the built-in path is not a directory.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_phase2_ca_cert() function instead.
     */
    phase2_ca_cert: GLib.Bytes
    /**
     * The password used to access the "phase2" CA certificate stored in
     * #NMSetting8021x:phase2-ca-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    phase2_ca_cert_password: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:phase2-ca-cert-password property.
     */
    phase2_ca_cert_password_flags: SettingSecretFlags
    /**
     * UTF-8 encoded path to a directory containing PEM or DER formatted
     * certificates to be added to the verification chain in addition to the
     * certificate specified in the #NMSetting8021x:phase2-ca-cert property.
     * 
     * If NMSetting8021x:system-ca-certs is enabled and the built-in CA
     * path is an existing directory, then this setting is ignored.
     */
    phase2_ca_path: string
    /**
     * Contains the "phase 2" client certificate if used by the EAP method
     * specified in the #NMSetting8021x:phase2-auth or
     * #NMSetting8021x:phase2-autheap properties.
     * 
     * Certificate data is specified using a "scheme"; two are currently
     * supported: blob and path. When using the blob scheme (which is backwards
     * compatible with NM 0.7.x) this property should be set to the
     * certificate's DER encoded data. When using the path scheme, this property
     * should be set to the full UTF-8 encoded path of the certificate, prefixed
     * with the string "file://" and ending with a terminating NUL byte. This
     * property can be unset even if the EAP method supports CA certificates,
     * but this allows man-in-the-middle attacks and is NOT recommended.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_phase2_client_cert() function instead.
     */
    phase2_client_cert: GLib.Bytes
    /**
     * The password used to access the "phase2" client certificate stored in
     * #NMSetting8021x:phase2-client-cert property. Only makes sense if the certificate
     * is stored on a PKCS#<!-- -->11 token that requires a login.
     */
    phase2_client_cert_password: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:phase2-client-cert-password property.
     */
    phase2_client_cert_password_flags: SettingSecretFlags
    /**
     * Constraint for server domain name. If set, this list of FQDNs is used as
     * a match requirement for dNSName element(s) of the certificate presented
     * by the authentication server during the inner "phase 2" authentication.
     * If a matching dNSName is found, this constraint is met.  If no dNSName
     * values are present, this constraint is matched against SubjectName CN
     * using the same comparison.
     * Multiple valid FQDNs can be passed as a ";" delimited list.
     */
    phase2_domain_match: string
    /**
     * Constraint for server domain name. If set, this FQDN is used as a suffix
     * match requirement for dNSName element(s) of the certificate presented by
     * the authentication server during the inner "phase 2" authentication.  If
     * a matching dNSName is found, this constraint is met.  If no dNSName
     * values are present, this constraint is matched against SubjectName CN
     * using same suffix match comparison.
     * Since version 1.24, multiple valid FQDNs can be passed as a ";" delimited
     * list.
     */
    phase2_domain_suffix_match: string
    /**
     * Contains the "phase 2" inner private key when the
     * #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap property is
     * set to "tls".
     * 
     * Key data is specified using a "scheme"; two are currently supported: blob
     * and path. When using the blob scheme and private keys, this property
     * should be set to the key's encrypted PEM encoded data. When using private
     * keys with the path scheme, this property should be set to the full UTF-8
     * encoded path of the key, prefixed with the string "file://" and ending
     * with a terminating NUL byte. When using PKCS#<!-- -->12 format private
     * keys and the blob scheme, this property should be set to the
     * PKCS#<!-- -->12 data and the #NMSetting8021x:phase2-private-key-password
     * property must be set to password used to decrypt the PKCS#<!-- -->12
     * certificate and key. When using PKCS#<!-- -->12 files and the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * key, prefixed with the string "file://" and ending with a terminating
     * NUL byte, and as with the blob scheme the
     * #NMSetting8021x:phase2-private-key-password property must be set to the
     * password used to decode the PKCS#<!-- -->12 private key and certificate.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_phase2_private_key() function instead.
     */
    phase2_private_key: GLib.Bytes
    /**
     * The password used to decrypt the "phase 2" private key specified in the
     * #NMSetting8021x:phase2-private-key property when the private key either
     * uses the path scheme, or is a PKCS#<!-- -->12 format key.  Setting this
     * property directly is not generally necessary except when returning
     * secrets to NetworkManager; it is generally set automatically when setting
     * the private key by the nm_setting_802_1x_set_phase2_private_key()
     * function.
     */
    phase2_private_key_password: string
    /**
     * Flags indicating how to handle the
     * #NMSetting8021x:phase2-private-key-password property.
     */
    phase2_private_key_password_flags: SettingSecretFlags
    /**
     * Substring to be matched against the subject of the certificate presented
     * by the authentication server during the inner "phase 2"
     * authentication. When unset, no verification of the authentication server
     * certificate's subject is performed.  This property provides little security,
     * if any, and its use is deprecated in favor of
     * NMSetting8021x:phase2-domain-suffix-match.
     */
    phase2_subject_match: string
    /**
     * PIN used for EAP authentication methods.
     */
    pin: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:pin property.
     */
    pin_flags: SettingSecretFlags
    /**
     * Contains the private key when the #NMSetting8021x:eap property is set to
     * "tls".
     * 
     * Key data is specified using a "scheme"; two are currently supported: blob
     * and path. When using the blob scheme and private keys, this property
     * should be set to the key's encrypted PEM encoded data. When using private
     * keys with the path scheme, this property should be set to the full UTF-8
     * encoded path of the key, prefixed with the string "file://" and ending
     * with a terminating NUL byte. When using PKCS#<!-- -->12 format private
     * keys and the blob scheme, this property should be set to the
     * PKCS#<!-- -->12 data and the #NMSetting8021x:private-key-password
     * property must be set to password used to decrypt the PKCS#<!-- -->12
     * certificate and key. When using PKCS#<!-- -->12 files and the path
     * scheme, this property should be set to the full UTF-8 encoded path of the
     * key, prefixed with the string "file://" and ending with a terminating
     * NUL byte, and as with the blob scheme the "private-key-password" property
     * must be set to the password used to decode the PKCS#<!-- -->12 private
     * key and certificate.
     * 
     * Setting this property directly is discouraged; use the
     * nm_setting_802_1x_set_private_key() function instead.
     * 
     * WARNING: #NMSetting8021x:private-key is not a "secret" property, and thus
     * unencrypted private key data using the BLOB scheme may be readable by
     * unprivileged users.  Private keys should always be encrypted with a
     * private key password to prevent unauthorized access to unencrypted
     * private key data.
     */
    private_key: GLib.Bytes
    /**
     * The password used to decrypt the private key specified in the
     * #NMSetting8021x:private-key property when the private key either uses the
     * path scheme, or if the private key is a PKCS#<!-- -->12 format key.  Setting this
     * property directly is not generally necessary except when returning
     * secrets to NetworkManager; it is generally set automatically when setting
     * the private key by the nm_setting_802_1x_set_private_key() function.
     */
    private_key_password: string
    /**
     * Flags indicating how to handle the #NMSetting8021x:private-key-password
     * property.
     */
    private_key_password_flags: SettingSecretFlags
    /**
     * Substring to be matched against the subject of the certificate presented
     * by the authentication server. When unset, no verification of the
     * authentication server certificate's subject is performed.  This property
     * provides little security, if any, and its use is deprecated in favor of
     * NMSetting8021x:domain-suffix-match.
     */
    subject_match: string
    /**
     * When %TRUE, overrides the #NMSetting8021x:ca-path and
     * #NMSetting8021x:phase2-ca-path properties using the system CA directory
     * specified at configure time with the --system-ca-path switch.  The
     * certificates in this directory are added to the verification chain in
     * addition to any certificates specified by the #NMSetting8021x:ca-cert and
     * #NMSetting8021x:phase2-ca-cert properties. If the path provided with
     * --system-ca-path is rather a file name (bundle of trusted CA certificates),
     * it overrides #NMSetting8021x:ca-cert and #NMSetting8021x:phase2-ca-cert
     * properties instead (sets ca_cert/ca_cert2 options for wpa_supplicant).
     */
    system_ca_certs: boolean
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Setting8021x */
    /**
     * Adds an allowed alternate subject name match.  Until at least one
     * match is added, the altSubjectName of the remote authentication
     * server is not verified.
     */
    add_altsubject_match(altsubject_match: string): boolean
    /**
     * Adds an allowed EAP method.  The setting is not valid until at least one
     * EAP method has been added.  See #NMSetting8021x:eap property for a list of
     * allowed EAP methods.
     */
    add_eap_method(eap: string): boolean
    /**
     * Adds an allowed alternate subject name match for "phase 2".  Until
     * at least one match is added, the altSubjectName of the "phase 2"
     * remote authentication server is not verified.
     */
    add_phase2_altsubject_match(phase2_altsubject_match: string): boolean
    /**
     * Clears all altSubjectName matches.
     */
    clear_altsubject_matches(): void
    /**
     * Clears all allowed EAP methods.
     */
    clear_eap_methods(): void
    /**
     * Clears all "phase 2" altSubjectName matches.
     */
    clear_phase2_altsubject_matches(): void
    /**
     * Returns the altSubjectName match at index `i`.
     */
    get_altsubject_match(i: number): string
    /**
     * Returns the anonymous identifier used by some EAP methods (like TTLS) to
     * authenticate the user in the outer unencrypted "phase 1" authentication.  The
     * inner "phase 2" authentication will use the #NMSetting8021x:identity in
     * a secure form, if applicable for that EAP method.
     */
    get_anonymous_identity(): string
    /**
     * Returns the value contained in the #NMSetting8021x:auth-timeout property.
     */
    get_auth_timeout(): number
    /**
     * Returns the CA certificate blob if the CA certificate is stored using the
     * %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use a
     * CA certificate (LEAP for example), and those that can take advantage of the
     * CA certificate allow it to be unset.  Note that lack of a CA certificate
     * reduces security by allowing man-in-the-middle attacks, because the identity
     * of the network cannot be confirmed by the client.
     */
    get_ca_cert_blob(): GLib.Bytes
    get_ca_cert_password(): string
    get_ca_cert_password_flags(): SettingSecretFlags
    /**
     * Returns the CA certificate path if the CA certificate is stored using the
     * %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use a
     * CA certificate (LEAP for example), and those that can take advantage of the
     * CA certificate allow it to be unset.  Note that lack of a CA certificate
     * reduces security by allowing man-in-the-middle attacks, because the identity
     * of the network cannot be confirmed by the client.
     */
    get_ca_cert_path(): string
    /**
     * Returns the scheme used to store the CA certificate.  If the returned scheme
     * is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_ca_cert_blob();
     * if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_ca_cert_path();
     * if %NM_SETTING_802_1X_CK_SCHEME_PKCS11, use nm_setting_802_1x_get_ca_cert_uri().
     */
    get_ca_cert_scheme(): Setting8021xCKScheme
    /**
     * Returns the CA certificate URI analogously to
     * nm_setting_802_1x_get_ca_cert_blob() and
     * nm_setting_802_1x_get_ca_cert_path().
     * 
     * Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
     * 7512), but may be extended to other schemes in future (such as 'file' URIs
     * for local files and 'data' URIs for inline certificate data).
     */
    get_ca_cert_uri(): string
    /**
     * Returns the path of the CA certificate directory if previously set.  Systems
     * will often have a directory that contains multiple individual CA certificates
     * which the supplicant can then add to the verification chain.  This may be
     * used in addition to the #NMSetting8021x:ca-cert property to add more CA
     * certificates for verifying the network to client.
     */
    get_ca_path(): string
    /**
     * Client certificates are used to identify the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    get_client_cert_blob(): GLib.Bytes
    get_client_cert_password(): string
    get_client_cert_password_flags(): SettingSecretFlags
    /**
     * Client certificates are used to identify the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    get_client_cert_path(): string
    /**
     * Returns the scheme used to store the client certificate.  If the returned scheme
     * is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_client_cert_blob();
     * if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_client_cert_path();
     * if %NM_SETTING_802_1X_CK_SCHEME_PKCS11, use nm_setting_802_1x_get_client_cert_uri().
     */
    get_client_cert_scheme(): Setting8021xCKScheme
    /**
     * Returns the client certificate URI analogously to
     * nm_setting_802_1x_get_client_cert_blob() and
     * nm_setting_802_1x_get_client_cert_path().
     * 
     * Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
     * 7512), but may be extended to other schemes in future (such as 'file' URIs
     * for local files and 'data' URIs for inline certificate data).
     */
    get_client_cert_uri(): string
    get_domain_match(): string
    get_domain_suffix_match(): string
    /**
     * Returns the name of the allowed EAP method at index `i`.
     */
    get_eap_method(i: number): string
    /**
     * Returns the identifier used by some EAP methods (like TLS) to
     * authenticate the user.  Often this is a username or login name.
     */
    get_identity(): string
    /**
     * Returns the number of entries in the
     * #NMSetting8021x:altsubject-matches property of this setting.
     */
    get_num_altsubject_matches(): number
    /**
     * Returns the number of eap methods allowed for use when connecting to the
     * network.  Generally only one EAP method is used.  Use the functions
     * nm_setting_802_1x_get_eap_method(), nm_setting_802_1x_add_eap_method(),
     * and nm_setting_802_1x_remove_eap_method() for adding, removing, and retrieving
     * allowed EAP methods.
     */
    get_num_eap_methods(): number
    /**
     * Returns the number of entries in the
     * #NMSetting8021x:phase2-altsubject-matches property of this setting.
     */
    get_num_phase2_altsubject_matches(): number
    /**
     * Returns the value contained in the #NMSetting8021x:optional property.
     */
    get_optional(): boolean
    /**
     * Returns the file containing PAC credentials used by EAP-FAST method.
     */
    get_pac_file(): string
    get_password(): string
    get_password_flags(): SettingSecretFlags
    get_password_raw(): GLib.Bytes
    get_password_raw_flags(): SettingSecretFlags
    get_phase1_auth_flags(): Setting8021xAuthFlags
    get_phase1_fast_provisioning(): string
    get_phase1_peaplabel(): string
    get_phase1_peapver(): string
    /**
     * Returns the "phase 2" altSubjectName match at index `i`.
     */
    get_phase2_altsubject_match(i: number): string
    get_phase2_auth(): string
    get_phase2_autheap(): string
    /**
     * Returns the "phase 2" CA certificate blob if the CA certificate is stored
     * using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use
     * a CA certificate (LEAP for example), and those that can take advantage of the
     * CA certificate allow it to be unset.  Note that lack of a CA certificate
     * reduces security by allowing man-in-the-middle attacks, because the identity
     * of the network cannot be confirmed by the client.
     */
    get_phase2_ca_cert_blob(): GLib.Bytes
    get_phase2_ca_cert_password(): string
    get_phase2_ca_cert_password_flags(): SettingSecretFlags
    /**
     * Returns the "phase 2" CA certificate path if the CA certificate is stored
     * using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use
     * a CA certificate (LEAP for example), and those that can take advantage of the
     * CA certificate allow it to be unset.  Note that lack of a CA certificate
     * reduces security by allowing man-in-the-middle attacks, because the identity
     * of the network cannot be confirmed by the client.
     */
    get_phase2_ca_cert_path(): string
    /**
     * Returns the scheme used to store the "phase 2" CA certificate.  If the
     * returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
     * nm_setting_802_1x_get_ca_cert_blob(); if %NM_SETTING_802_1X_CK_SCHEME_PATH,
     * use nm_setting_802_1x_get_ca_cert_path(); if %NM_SETTING_802_1X_CK_SCHEME_PKCS11,
     * use nm_setting_802_1x_get_ca_cert_uri().
     */
    get_phase2_ca_cert_scheme(): Setting8021xCKScheme
    /**
     * Returns the "phase 2" CA certificate URI analogously to
     * nm_setting_802_1x_get_phase2_ca_cert_blob() and
     * nm_setting_802_1x_get_phase2_ca_cert_path().
     * 
     * Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
     * 7512), but may be extended to other schemes in future (such as 'file' URIs
     * for local files and 'data' URIs for inline certificate data).
     */
    get_phase2_ca_cert_uri(): string
    /**
     * Returns the path of the "phase 2" CA certificate directory if previously set.
     * Systems will often have a directory that contains multiple individual CA
     * certificates which the supplicant can then add to the verification chain.
     * This may be used in addition to the #NMSetting8021x:phase2-ca-cert property
     * to add more CA certificates for verifying the network to client.
     */
    get_phase2_ca_path(): string
    /**
     * Client certificates are used to identify the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    get_phase2_client_cert_blob(): GLib.Bytes
    get_phase2_client_cert_password(): string
    get_phase2_client_cert_password_flags(): SettingSecretFlags
    /**
     * Client certificates are used to identify the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    get_phase2_client_cert_path(): string
    /**
     * Returns the scheme used to store the "phase 2" client certificate.  If the
     * returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
     * nm_setting_802_1x_get_client_cert_blob(); if
     * %NM_SETTING_802_1X_CK_SCHEME_PATH, use
     * nm_setting_802_1x_get_client_cert_path(); if
     * %NM_SETTING_802_1X_CK_SCHEME_PKCS11, use
     * nm_setting_802_1x_get_client_cert_uri().
     */
    get_phase2_client_cert_scheme(): Setting8021xCKScheme
    /**
     * Returns the "phase 2" client certificate URI analogously to
     * nm_setting_802_1x_get_phase2_ca_cert_blob() and
     * nm_setting_802_1x_get_phase2_ca_cert_path().
     * 
     * Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
     * 7512), but may be extended to other schemes in future (such as 'file' URIs
     * for local files and 'data' URIs for inline certificate data).
     */
    get_phase2_client_cert_uri(): string
    get_phase2_domain_match(): string
    get_phase2_domain_suffix_match(): string
    /**
     * Private keys are used to authenticate the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     * 
     * WARNING: the phase2 private key property is not a "secret" property, and thus
     * unencrypted private key data may be readable by unprivileged users.  Private
     * keys should always be encrypted with a private key password.
     */
    get_phase2_private_key_blob(): GLib.Bytes
    get_phase2_private_key_format(): Setting8021xCKFormat
    get_phase2_private_key_password(): string
    get_phase2_private_key_password_flags(): SettingSecretFlags
    /**
     * Private keys are used to authenticate the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    get_phase2_private_key_path(): string
    /**
     * Returns the scheme used to store the "phase 2" private key.  If the returned
     * scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
     * nm_setting_802_1x_get_client_cert_blob(); if
     * %NM_SETTING_802_1X_CK_SCHEME_PATH, use
     * nm_setting_802_1x_get_client_cert_path(); if
     * %NM_SETTING_802_1X_CK_SCHEME_PKCS11, use
     * nm_setting_802_1x_get_client_cert_uri().
     */
    get_phase2_private_key_scheme(): Setting8021xCKScheme
    /**
     * Returns the "phase 2" private key URI analogously to
     * nm_setting_802_1x_get_phase2_private_key_blob() and
     * nm_setting_802_1x_get_phase2_private_key_path().
     * 
     * Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
     * 7512), but may be extended to other schemes in future (such as 'file' URIs
     * for local files and 'data' URIs for inline certificate data).
     */
    get_phase2_private_key_uri(): string
    get_phase2_subject_match(): string
    get_pin(): string
    get_pin_flags(): SettingSecretFlags
    /**
     * Private keys are used to authenticate the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     * 
     * WARNING: the private key property is not a "secret" property, and thus
     * unencrypted private key data may be readable by unprivileged users.  Private
     * keys should always be encrypted with a private key password.
     */
    get_private_key_blob(): GLib.Bytes
    get_private_key_format(): Setting8021xCKFormat
    get_private_key_password(): string
    get_private_key_password_flags(): SettingSecretFlags
    /**
     * Private keys are used to authenticate the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    get_private_key_path(): string
    /**
     * Returns the scheme used to store the private key.  If the returned scheme is
     * %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
     * nm_setting_802_1x_get_client_cert_blob(); if
     * %NM_SETTING_802_1X_CK_SCHEME_PATH, use
     * nm_setting_802_1x_get_client_cert_path(); if
     * %NM_SETTING_802_1X_CK_SCHEME_PKCS11, use
     * nm_setting_802_1x_get_client_cert_uri().
     */
    get_private_key_scheme(): Setting8021xCKScheme
    /**
     * Returns the private key URI analogously to
     * nm_setting_802_1x_get_private_key_blob() and
     * nm_setting_802_1x_get_private_key_path().
     * 
     * Currently, it's limited to PKCS#11 URIs ('pkcs11' scheme as defined by RFC
     * 7512), but may be extended to other schemes in future (such as 'file' URIs
     * for local files and 'data' URIs for inline certificate data).
     */
    get_private_key_uri(): string
    get_subject_match(): string
    /**
     * Sets the #NMSetting8021x:system-ca-certs property. The
     * #NMSetting8021x:ca-path and #NMSetting8021x:phase2-ca-path
     * properties are ignored if the #NMSetting8021x:system-ca-certs property is
     * %TRUE, in which case a system-wide CA certificate directory specified at
     * compile time (using the --system-ca-path configure option) is used in place
     * of these properties.
     */
    get_system_ca_certs(): boolean
    /**
     * Removes the allowed altSubjectName at the specified index.
     */
    remove_altsubject_match(i: number): void
    /**
     * Removes the allowed altSubjectName `altsubject_match`.
     */
    remove_altsubject_match_by_value(altsubject_match: string): boolean
    /**
     * Removes the allowed EAP method at the specified index.
     */
    remove_eap_method(i: number): void
    /**
     * Removes the allowed EAP method `method`.
     */
    remove_eap_method_by_value(eap: string): boolean
    /**
     * Removes the allowed "phase 2" altSubjectName at the specified index.
     */
    remove_phase2_altsubject_match(i: number): void
    /**
     * Removes the allowed "phase 2" altSubjectName `phase2`_altsubject_match.
     */
    remove_phase2_altsubject_match_by_value(phase2_altsubject_match: string): boolean
    /**
     * Reads a certificate from disk and sets the #NMSetting8021x:ca-cert property
     * with the raw certificate data if using the %NM_SETTING_802_1X_CK_SCHEME_BLOB
     * scheme, or with the path to the certificate file if using the
     * %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.
     */
    set_ca_cert(value: string, scheme: Setting8021xCKScheme, out_format: Setting8021xCKFormat): boolean
    /**
     * Reads a certificate from disk and sets the #NMSetting8021x:client-cert
     * property with the raw certificate data if using the
     * %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
     * file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.
     * 
     * Client certificates are used to identify the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    set_client_cert(value: string, scheme: Setting8021xCKScheme, out_format: Setting8021xCKFormat): boolean
    /**
     * Reads a certificate from disk and sets the #NMSetting8021x:phase2-ca-cert
     * property with the raw certificate data if using the
     * %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
     * file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.
     */
    set_phase2_ca_cert(value: string, scheme: Setting8021xCKScheme, out_format: Setting8021xCKFormat): boolean
    /**
     * Reads a certificate from disk and sets the #NMSetting8021x:phase2-client-cert
     * property with the raw certificate data if using the
     * %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
     * file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.
     * 
     * Client certificates are used to identify the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     */
    set_phase2_client_cert(value: string, scheme: Setting8021xCKScheme, out_format: Setting8021xCKFormat): boolean
    /**
     * Private keys are used to authenticate the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     * 
     * This function reads a private key from disk and sets the
     * #NMSetting8021x:phase2-private-key property with the private key file data if
     * using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the
     * private key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.
     * 
     * If `password` is given, this function attempts to decrypt the private key to
     * verify that `password` is correct, and if it is, updates the
     * #NMSetting8021x:phase2-private-key-password property with the given
     * `password`.  If the decryption is unsuccessful, %FALSE is returned, `error` is
     * set, and no internal data is changed.  If no `password` is given, the private
     * key is assumed to be valid, no decryption is performed, and the password may
     * be set at a later time.
     * 
     * WARNING: the "phase2" private key property is not a "secret" property, and
     * thus unencrypted private key data using the BLOB scheme may be readable by
     * unprivileged users.  Private keys should always be encrypted with a private
     * key password to prevent unauthorized access to unencrypted private key data.
     */
    set_phase2_private_key(value: string, password: string, scheme: Setting8021xCKScheme, out_format: Setting8021xCKFormat): boolean
    /**
     * Private keys are used to authenticate the connecting client to the network
     * when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
     * authentication method.
     * 
     * This function reads a private key from disk and sets the
     * #NMSetting8021x:private-key property with the private key file data if using
     * the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the private
     * key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.
     * 
     * If `password` is given, this function attempts to decrypt the private key to
     * verify that `password` is correct, and if it is, updates the
     * #NMSetting8021x:private-key-password property with the given `password`.  If
     * the decryption is unsuccessful, %FALSE is returned, `error` is set, and no
     * internal data is changed.  If no `password` is given, the private key is
     * assumed to be valid, no decryption is performed, and the password may be set
     * at a later time.
     * 
     * WARNING: the private key property is not a "secret" property, and thus
     * unencrypted private key data using the BLOB scheme may be readable by
     * unprivileged users.  Private keys should always be encrypted with a private
     * key password to prevent unauthorized access to unencrypted private key data.
     */
    set_private_key(value: string, password: string, scheme: Setting8021xCKScheme, out_format: Setting8021xCKFormat): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::altsubject-matches", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::altsubject-matches", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::anonymous-identity", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::anonymous-identity", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auth-timeout", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auth-timeout", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ca-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ca-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ca-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ca-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ca-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ca-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ca-path", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ca-path", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::domain-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::domain-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::domain-suffix-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::domain-suffix-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::eap", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::eap", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::identity", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identity", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::optional", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::optional", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pac-file", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pac-file", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password-raw", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-raw", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password-raw-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-raw-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase1-auth-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase1-auth-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase1-fast-provisioning", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase1-fast-provisioning", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase1-peaplabel", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase1-peaplabel", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase1-peapver", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase1-peapver", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-altsubject-matches", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-altsubject-matches", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-auth", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-auth", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-autheap", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-autheap", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-ca-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-ca-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-ca-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-ca-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-ca-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-ca-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-ca-path", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-ca-path", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-client-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-client-cert", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-client-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-client-cert-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-client-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-client-cert-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-domain-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-domain-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-domain-suffix-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-domain-suffix-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-private-key", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-private-key", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-private-key-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-private-key-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-private-key-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-private-key-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::phase2-subject-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::phase2-subject-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pin", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pin", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pin-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pin-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::private-key", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::private-key-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key-password", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::private-key-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key-password-flags", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::subject-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject-match", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::system-ca-certs", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::system-ca-certs", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: Setting8021x, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: Setting8021x_ConstructProps)
    _init (config?: Setting8021x_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Setting8021x
    /**
     * Determines and verifies the blob type.
     * When setting certificate properties of NMSetting8021x
     * the blob must be not UNKNOWN (or NULL).
     */
    static check_cert_scheme(pdata: object | null, length: number): Setting8021xCKScheme
    static $gtype: GObject.Type
}
interface SettingAdsl_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingAdsl */
    /**
     * Encapsulation of ADSL connection.  Can be "vcmux" or "llc".
     */
    encapsulation?: string
    /**
     * Password used to authenticate with the ADSL service.
     */
    password?: string
    /**
     * Flags indicating how to handle the #NMSettingAdsl:password property.
     */
    password_flags?: SettingSecretFlags
    /**
     * ADSL connection protocol.  Can be "pppoa", "pppoe" or "ipoatm".
     */
    protocol?: string
    /**
     * Username used to authenticate with the ADSL service.
     */
    username?: string
    /**
     * VCI of ADSL connection
     */
    vci?: number
    /**
     * VPI of ADSL connection
     */
    vpi?: number
}
class SettingAdsl {
    /* Properties of NM-1.0.NM.SettingAdsl */
    /**
     * Encapsulation of ADSL connection.  Can be "vcmux" or "llc".
     */
    encapsulation: string
    /**
     * Password used to authenticate with the ADSL service.
     */
    password: string
    /**
     * Flags indicating how to handle the #NMSettingAdsl:password property.
     */
    password_flags: SettingSecretFlags
    /**
     * ADSL connection protocol.  Can be "pppoa", "pppoe" or "ipoatm".
     */
    protocol: string
    /**
     * Username used to authenticate with the ADSL service.
     */
    username: string
    /**
     * VCI of ADSL connection
     */
    vci: number
    /**
     * VPI of ADSL connection
     */
    vpi: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingAdsl */
    get_encapsulation(): string
    get_password(): string
    get_password_flags(): SettingSecretFlags
    get_protocol(): string
    get_username(): string
    get_vci(): number
    get_vpi(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::encapsulation", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::encapsulation", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password-flags", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-flags", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::protocol", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::username", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::username", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vci", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vci", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vpi", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vpi", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingAdsl, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingAdsl_ConstructProps)
    _init (config?: SettingAdsl_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingAdsl
    static $gtype: GObject.Type
}
interface SettingBluetooth_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingBluetooth */
    /**
     * The Bluetooth address of the device.
     */
    bdaddr?: string
    /**
     * Either "dun" for Dial-Up Networking connections or "panu" for Personal
     * Area Networking connections to devices supporting the NAP profile.
     */
    type?: string
}
class SettingBluetooth {
    /* Properties of NM-1.0.NM.SettingBluetooth */
    /**
     * The Bluetooth address of the device.
     */
    bdaddr: string
    /**
     * Either "dun" for Dial-Up Networking connections or "panu" for Personal
     * Area Networking connections to devices supporting the NAP profile.
     */
    type: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingBluetooth */
    /**
     * Gets the Bluetooth address of the remote device which this setting
     * describes a connection to.
     */
    get_bdaddr(): string
    /**
     * Returns the connection method for communicating with the remote device (i.e.
     * either DUN to a DUN-capable device or PANU to a NAP-capable device).
     */
    get_connection_type(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::bdaddr", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bdaddr", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::type", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingBluetooth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingBluetooth_ConstructProps)
    _init (config?: SettingBluetooth_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingBluetooth
    static $gtype: GObject.Type
}
interface SettingBond_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingBond */
    /**
     * Dictionary of key/value pairs of bonding options.  Both keys and values
     * must be strings. Option names must contain only alphanumeric characters
     * (ie, [a-zA-Z0-9]).
     */
    options?: GLib.HashTable
}
class SettingBond {
    /* Properties of NM-1.0.NM.SettingBond */
    /**
     * Dictionary of key/value pairs of bonding options.  Both keys and values
     * must be strings. Option names must contain only alphanumeric characters
     * (ie, [a-zA-Z0-9]).
     */
    options: GLib.HashTable
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingBond */
    /**
     * Add an option to the table. Adding a new name replaces any existing name/value pair
     * that may already exist.
     */
    add_option(name: string, value: string): boolean
    /**
     * Returns the number of options that should be set for this bond when it
     * is activated. This can be used to retrieve each option individually
     * using nm_setting_bond_get_option().
     */
    get_num_options(): number
    /**
     * Given an index, return the value of the bonding option at that index.  Indexes
     * are *not* guaranteed to be static across modifications to options done by
     * nm_setting_bond_add_option() and nm_setting_bond_remove_option(),
     * and should not be used to refer to options except for short periods of time
     * such as during option iteration.
     */
    get_option(idx: number): [ /* returnType */ boolean, /* out_name */ string, /* out_value */ string ]
    /**
     * Returns the value associated with the bonding option specified by
     * `name,` if it exists.
     */
    get_option_by_name(name: string): string
    get_option_default(name: string): string
    get_option_normalized(name: string): string
    /**
     * Returns a list of valid bond options.
     * 
     * The `setting` argument is unused and may be passed as %NULL.
     */
    get_valid_options(): string[]
    /**
     * Remove the bonding option referenced by `name` from the internal option
     * list.
     */
    remove_option(name: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingBond, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::options", callback: (($obj: SettingBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::options", callback: (($obj: SettingBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingBond, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingBond, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingBond_ConstructProps)
    _init (config?: SettingBond_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingBond
    /**
     * Checks whether `name` is a valid bond option and `value` is a valid value for
     * the `name`. If `value` is %NULL, the function only validates the option name.
     */
    static validate_option(name: string, value: string): boolean
    static $gtype: GObject.Type
}
interface SettingBondPort_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingBondPort */
    /**
     * The queue ID of this bond port. The maximum value of queue ID is
     * the number of TX queues currently active in device.
     */
    queue_id?: number
}
class SettingBondPort {
    /* Properties of NM-1.0.NM.SettingBondPort */
    /**
     * The queue ID of this bond port. The maximum value of queue ID is
     * the number of TX queues currently active in device.
     */
    queue_id: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingBondPort */
    get_queue_id(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingBondPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingBondPort, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::queue-id", callback: (($obj: SettingBondPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::queue-id", callback: (($obj: SettingBondPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingBondPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingBondPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingBondPort_ConstructProps)
    _init (config?: SettingBondPort_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingBondPort
    static $gtype: GObject.Type
}
interface SettingBridge_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingBridge */
    /**
     * The Ethernet MAC address aging time, in seconds.
     */
    ageing_time?: number
    /**
     * The Spanning Tree Protocol (STP) forwarding delay, in seconds.
     */
    forward_delay?: number
    /**
     * If specified, The MAC address of the multicast group this bridge uses for STP.
     * 
     * The address must be a link-local address in standard Ethernet MAC address format,
     * ie an address of the form 01:80:C2:00:00:0X, with X in [0, 4..F].
     * If not specified the default value is 01:80:C2:00:00:00.
     */
    group_address?: string
    /**
     * A mask of group addresses to forward. Usually, group addresses in
     * the range from 01:80:C2:00:00:00 to 01:80:C2:00:00:0F are not
     * forwarded according to standards. This property is a mask of 16 bits,
     * each corresponding to a group address in that range that must be
     * forwarded. The mask can't have bits 0, 1 or 2 set because they are
     * used for STP, MAC pause frames and LACP.
     */
    group_forward_mask?: number
    /**
     * The Spanning Tree Protocol (STP) hello time, in seconds.
     */
    hello_time?: number
    /**
     * If specified, the MAC address of bridge. When creating a new bridge, this
     * MAC address will be set.
     * 
     * If this field is left unspecified, the "ethernet.cloned-mac-address" is
     * referred instead to generate the initial MAC address. Note that setting
     * "ethernet.cloned-mac-address" anyway overwrites the MAC address of
     * the bridge later while activating the bridge. Hence, this property
     * is deprecated.
     */
    mac_address?: string
    /**
     * The Spanning Tree Protocol (STP) maximum message age, in seconds.
     */
    max_age?: number
    /**
     * Set maximum size of multicast hash table (value must be a power of 2).
     */
    multicast_hash_max?: number
    /**
     * Set the number of queries the bridge will send before
     * stopping forwarding a multicast group after a "leave"
     * message has been received.
     */
    multicast_last_member_count?: number
    /**
     * Set interval (in deciseconds) between queries to find remaining
     * members of a group, after a "leave" message is received.
     */
    multicast_last_member_interval?: number
    /**
     * Set delay (in deciseconds) after which the bridge will
     * leave a group, if no membership reports for this
     * group are received.
     */
    multicast_membership_interval?: number
    /**
     * Enable or disable sending of multicast queries by the bridge.
     * If not specified the option is disabled.
     */
    multicast_querier?: boolean
    /**
     * If no queries are seen after this delay (in deciseconds) has passed,
     * the bridge will start to send its own queries.
     */
    multicast_querier_interval?: number
    /**
     * Interval (in deciseconds) between queries sent
     * by the bridge after the end of the startup phase.
     */
    multicast_query_interval?: number
    /**
     * Set the Max Response Time/Max Response Delay
     * (in deciseconds) for IGMP/MLD queries sent by the bridge.
     */
    multicast_query_response_interval?: number
    /**
     * If enabled the bridge's own IP address is used as
     * the source address for IGMP queries otherwise
     * the default of 0.0.0.0 is used.
     */
    multicast_query_use_ifaddr?: boolean
    /**
     * Sets bridge's multicast router. Multicast-snooping must be enabled
     * for this option to work.
     * 
     * Supported values are: 'auto', 'disabled', 'enabled' to which kernel
     * assigns the numbers 1, 0, and 2, respectively.
     * If not specified the default value is 'auto' (1).
     */
    multicast_router?: string
    /**
     * Controls whether IGMP snooping is enabled for this bridge.
     * Note that if snooping was automatically disabled due to hash collisions,
     * the system may refuse to enable the feature until the collisions are
     * resolved.
     */
    multicast_snooping?: boolean
    /**
     * Set the number of IGMP queries to send during startup phase.
     */
    multicast_startup_query_count?: number
    /**
     * Sets the time (in deciseconds) between queries sent out
     * at startup to determine membership information.
     */
    multicast_startup_query_interval?: number
    /**
     * Sets the Spanning Tree Protocol (STP) priority for this bridge.  Lower
     * values are "better"; the lowest priority bridge will be elected the root
     * bridge.
     */
    priority?: number
    /**
     * Controls whether Spanning Tree Protocol (STP) is enabled for this bridge.
     */
    stp?: boolean
    /**
     * The default PVID for the ports of the bridge, that is the VLAN id
     * assigned to incoming untagged frames.
     */
    vlan_default_pvid?: number
    /**
     * Control whether VLAN filtering is enabled on the bridge.
     */
    vlan_filtering?: boolean
    /**
     * If specified, the protocol used for VLAN filtering.
     * 
     * Supported values are: '802.1Q', '802.1ad'.
     * If not specified the default value is '802.1Q'.
     */
    vlan_protocol?: string
    /**
     * Controls whether per-VLAN stats accounting is enabled.
     */
    vlan_stats_enabled?: boolean
    /**
     * Array of bridge VLAN objects. In addition to the VLANs
     * specified here, the bridge will also have the default-pvid
     * VLAN configured  by the bridge.vlan-default-pvid property.
     * 
     * In nmcli the VLAN list can be specified with the following
     * syntax:
     * 
     *  $vid [pvid] [untagged] [, $vid [pvid] [untagged]]...
     * 
     * where $vid is either a single id between 1 and 4094 or a
     * range, represented as a couple of ids separated by a dash.
     */
    vlans?: BridgeVlan[]
}
class SettingBridge {
    /* Properties of NM-1.0.NM.SettingBridge */
    /**
     * The Ethernet MAC address aging time, in seconds.
     */
    ageing_time: number
    /**
     * The Spanning Tree Protocol (STP) forwarding delay, in seconds.
     */
    forward_delay: number
    /**
     * If specified, The MAC address of the multicast group this bridge uses for STP.
     * 
     * The address must be a link-local address in standard Ethernet MAC address format,
     * ie an address of the form 01:80:C2:00:00:0X, with X in [0, 4..F].
     * If not specified the default value is 01:80:C2:00:00:00.
     */
    group_address: string
    /**
     * A mask of group addresses to forward. Usually, group addresses in
     * the range from 01:80:C2:00:00:00 to 01:80:C2:00:00:0F are not
     * forwarded according to standards. This property is a mask of 16 bits,
     * each corresponding to a group address in that range that must be
     * forwarded. The mask can't have bits 0, 1 or 2 set because they are
     * used for STP, MAC pause frames and LACP.
     */
    group_forward_mask: number
    /**
     * The Spanning Tree Protocol (STP) hello time, in seconds.
     */
    hello_time: number
    /**
     * If specified, the MAC address of bridge. When creating a new bridge, this
     * MAC address will be set.
     * 
     * If this field is left unspecified, the "ethernet.cloned-mac-address" is
     * referred instead to generate the initial MAC address. Note that setting
     * "ethernet.cloned-mac-address" anyway overwrites the MAC address of
     * the bridge later while activating the bridge. Hence, this property
     * is deprecated.
     */
    mac_address: string
    /**
     * The Spanning Tree Protocol (STP) maximum message age, in seconds.
     */
    max_age: number
    /**
     * Set maximum size of multicast hash table (value must be a power of 2).
     */
    multicast_hash_max: number
    /**
     * Set the number of queries the bridge will send before
     * stopping forwarding a multicast group after a "leave"
     * message has been received.
     */
    multicast_last_member_count: number
    /**
     * Set interval (in deciseconds) between queries to find remaining
     * members of a group, after a "leave" message is received.
     */
    multicast_last_member_interval: number
    /**
     * Set delay (in deciseconds) after which the bridge will
     * leave a group, if no membership reports for this
     * group are received.
     */
    multicast_membership_interval: number
    /**
     * Enable or disable sending of multicast queries by the bridge.
     * If not specified the option is disabled.
     */
    multicast_querier: boolean
    /**
     * If no queries are seen after this delay (in deciseconds) has passed,
     * the bridge will start to send its own queries.
     */
    multicast_querier_interval: number
    /**
     * Interval (in deciseconds) between queries sent
     * by the bridge after the end of the startup phase.
     */
    multicast_query_interval: number
    /**
     * Set the Max Response Time/Max Response Delay
     * (in deciseconds) for IGMP/MLD queries sent by the bridge.
     */
    multicast_query_response_interval: number
    /**
     * If enabled the bridge's own IP address is used as
     * the source address for IGMP queries otherwise
     * the default of 0.0.0.0 is used.
     */
    multicast_query_use_ifaddr: boolean
    /**
     * Sets bridge's multicast router. Multicast-snooping must be enabled
     * for this option to work.
     * 
     * Supported values are: 'auto', 'disabled', 'enabled' to which kernel
     * assigns the numbers 1, 0, and 2, respectively.
     * If not specified the default value is 'auto' (1).
     */
    multicast_router: string
    /**
     * Controls whether IGMP snooping is enabled for this bridge.
     * Note that if snooping was automatically disabled due to hash collisions,
     * the system may refuse to enable the feature until the collisions are
     * resolved.
     */
    multicast_snooping: boolean
    /**
     * Set the number of IGMP queries to send during startup phase.
     */
    multicast_startup_query_count: number
    /**
     * Sets the time (in deciseconds) between queries sent out
     * at startup to determine membership information.
     */
    multicast_startup_query_interval: number
    /**
     * Sets the Spanning Tree Protocol (STP) priority for this bridge.  Lower
     * values are "better"; the lowest priority bridge will be elected the root
     * bridge.
     */
    priority: number
    /**
     * Controls whether Spanning Tree Protocol (STP) is enabled for this bridge.
     */
    stp: boolean
    /**
     * The default PVID for the ports of the bridge, that is the VLAN id
     * assigned to incoming untagged frames.
     */
    vlan_default_pvid: number
    /**
     * Control whether VLAN filtering is enabled on the bridge.
     */
    vlan_filtering: boolean
    /**
     * If specified, the protocol used for VLAN filtering.
     * 
     * Supported values are: '802.1Q', '802.1ad'.
     * If not specified the default value is '802.1Q'.
     */
    vlan_protocol: string
    /**
     * Controls whether per-VLAN stats accounting is enabled.
     */
    vlan_stats_enabled: boolean
    /**
     * Array of bridge VLAN objects. In addition to the VLANs
     * specified here, the bridge will also have the default-pvid
     * VLAN configured  by the bridge.vlan-default-pvid property.
     * 
     * In nmcli the VLAN list can be specified with the following
     * syntax:
     * 
     *  $vid [pvid] [untagged] [, $vid [pvid] [untagged]]...
     * 
     * where $vid is either a single id between 1 and 4094 or a
     * range, represented as a couple of ids separated by a dash.
     */
    vlans: BridgeVlan[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingBridge */
    /**
     * Appends a new vlan and associated information to the setting.  The
     * given vlan gets sealed and a reference to it is added.
     */
    add_vlan(vlan: BridgeVlan): void
    /**
     * Removes all configured VLANs.
     */
    clear_vlans(): void
    get_ageing_time(): number
    get_forward_delay(): number
    get_group_address(): string
    get_group_forward_mask(): number
    get_hello_time(): number
    get_mac_address(): string
    get_max_age(): number
    get_multicast_hash_max(): number
    get_multicast_last_member_count(): number
    get_multicast_last_member_interval(): number
    get_multicast_membership_interval(): number
    get_multicast_querier(): boolean
    get_multicast_querier_interval(): number
    get_multicast_query_interval(): number
    get_multicast_query_response_interval(): number
    get_multicast_query_use_ifaddr(): boolean
    get_multicast_router(): string
    get_multicast_snooping(): boolean
    get_multicast_startup_query_count(): number
    get_multicast_startup_query_interval(): number
    get_num_vlans(): number
    get_priority(): number
    get_stp(): boolean
    get_vlan(idx: number): BridgeVlan
    get_vlan_default_pvid(): number
    get_vlan_filtering(): boolean
    get_vlan_protocol(): string
    get_vlan_stats_enabled(): boolean
    /**
     * Removes the vlan at index `idx`.
     */
    remove_vlan(idx: number): void
    /**
     * Remove the VLAN with range `vid_start` to `vid_end`.
     * If `vid_end` is zero, it is assumed to be equal to `vid_start`
     * and so the single-id VLAN with id `vid_start` is removed.
     */
    remove_vlan_by_vid(vid_start: number, vid_end: number): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::ageing-time", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ageing-time", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::forward-delay", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::forward-delay", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::group-address", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-address", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::group-forward-mask", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-forward-mask", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hello-time", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hello-time", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mac-address", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::max-age", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::max-age", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-hash-max", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-hash-max", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-last-member-count", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-last-member-count", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-last-member-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-last-member-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-membership-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-membership-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-querier", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-querier", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-querier-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-querier-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-query-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-query-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-query-response-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-query-response-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-query-use-ifaddr", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-query-use-ifaddr", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-router", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-router", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-snooping", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-snooping", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-startup-query-count", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-startup-query-count", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multicast-startup-query-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multicast-startup-query-interval", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::stp", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stp", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlan-default-pvid", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlan-default-pvid", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlan-filtering", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlan-filtering", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlan-protocol", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlan-protocol", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlan-stats-enabled", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlan-stats-enabled", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlans", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlans", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingBridge_ConstructProps)
    _init (config?: SettingBridge_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingBridge
    static $gtype: GObject.Type
}
interface SettingBridgePort_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingBridgePort */
    /**
     * Enables or disables "hairpin mode" for the port, which allows frames to
     * be sent back out through the port the frame was received on.
     */
    hairpin_mode?: boolean
    /**
     * The Spanning Tree Protocol (STP) port cost for destinations via this
     * port.
     */
    path_cost?: number
    /**
     * The Spanning Tree Protocol (STP) priority of this bridge port.
     */
    priority?: number
    /**
     * Array of bridge VLAN objects. In addition to the VLANs
     * specified here, the port will also have the default-pvid
     * VLAN configured on the bridge by the bridge.vlan-default-pvid
     * property.
     * 
     * In nmcli the VLAN list can be specified with the following
     * syntax:
     * 
     *  $vid [pvid] [untagged] [, $vid [pvid] [untagged]]...
     * 
     * where $vid is either a single id between 1 and 4094 or a
     * range, represented as a couple of ids separated by a dash.
     */
    vlans?: BridgeVlan[]
}
class SettingBridgePort {
    /* Properties of NM-1.0.NM.SettingBridgePort */
    /**
     * Enables or disables "hairpin mode" for the port, which allows frames to
     * be sent back out through the port the frame was received on.
     */
    hairpin_mode: boolean
    /**
     * The Spanning Tree Protocol (STP) port cost for destinations via this
     * port.
     */
    path_cost: number
    /**
     * The Spanning Tree Protocol (STP) priority of this bridge port.
     */
    priority: number
    /**
     * Array of bridge VLAN objects. In addition to the VLANs
     * specified here, the port will also have the default-pvid
     * VLAN configured on the bridge by the bridge.vlan-default-pvid
     * property.
     * 
     * In nmcli the VLAN list can be specified with the following
     * syntax:
     * 
     *  $vid [pvid] [untagged] [, $vid [pvid] [untagged]]...
     * 
     * where $vid is either a single id between 1 and 4094 or a
     * range, represented as a couple of ids separated by a dash.
     */
    vlans: BridgeVlan[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingBridgePort */
    /**
     * Appends a new vlan and associated information to the setting.  The
     * given vlan gets sealed and a reference to it is added.
     */
    add_vlan(vlan: BridgeVlan): void
    /**
     * Removes all configured VLANs.
     */
    clear_vlans(): void
    get_hairpin_mode(): boolean
    get_num_vlans(): number
    get_path_cost(): number
    get_priority(): number
    get_vlan(idx: number): BridgeVlan
    /**
     * Removes the vlan at index `idx`.
     */
    remove_vlan(idx: number): void
    /**
     * Remove the VLAN with range `vid_start` to `vid_end`.
     * If `vid_end` is zero, it is assumed to be equal to `vid_start`
     * and so the single-id VLAN with id `vid_start` is removed.
     */
    remove_vlan_by_vid(vid_start: number, vid_end: number): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::hairpin-mode", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hairpin-mode", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path-cost", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path-cost", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlans", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlans", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingBridgePort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingBridgePort_ConstructProps)
    _init (config?: SettingBridgePort_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingBridgePort
    static $gtype: GObject.Type
}
interface SettingCdma_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingCdma */
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple frames.
     */
    mtu?: number
    /**
     * The number to dial to establish the connection to the CDMA-based mobile
     * broadband network, if any.  If not specified, the default number (#777)
     * is used when required.
     */
    number?: string
    /**
     * The password used to authenticate with the network, if required.  Many
     * providers do not require a password, or accept any password.  But if a
     * password is required, it is specified here.
     */
    password?: string
    /**
     * Flags indicating how to handle the #NMSettingCdma:password property.
     */
    password_flags?: SettingSecretFlags
    /**
     * The username used to authenticate with the network, if required.  Many
     * providers do not require a username, or accept any username.  But if a
     * username is required, it is specified here.
     */
    username?: string
}
class SettingCdma {
    /* Properties of NM-1.0.NM.SettingCdma */
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple frames.
     */
    mtu: number
    /**
     * The number to dial to establish the connection to the CDMA-based mobile
     * broadband network, if any.  If not specified, the default number (#777)
     * is used when required.
     */
    number: string
    /**
     * The password used to authenticate with the network, if required.  Many
     * providers do not require a password, or accept any password.  But if a
     * password is required, it is specified here.
     */
    password: string
    /**
     * Flags indicating how to handle the #NMSettingCdma:password property.
     */
    password_flags: SettingSecretFlags
    /**
     * The username used to authenticate with the network, if required.  Many
     * providers do not require a username, or accept any username.  But if a
     * username is required, it is specified here.
     */
    username: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingCdma */
    get_mtu(): number
    get_number(): string
    get_password(): string
    get_password_flags(): SettingSecretFlags
    get_username(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::mtu", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::number", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::number", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password-flags", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-flags", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::username", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::username", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingCdma, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingCdma_ConstructProps)
    _init (config?: SettingCdma_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingCdma
    static $gtype: GObject.Type
}
interface SettingConnection_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingConnection */
    /**
     * The number of retries for the authentication. Zero means to try indefinitely; -1 means
     * to use a global default. If the global default is not set, the authentication
     * retries for 3 times before failing the connection.
     * 
     * Currently, this only applies to 802-1x authentication.
     */
    auth_retries?: number
    /**
     * Whether or not the connection should be automatically connected by
     * NetworkManager when the resources for the connection are available.
     * %TRUE to automatically activate the connection, %FALSE to require manual
     * intervention to activate the connection.
     * 
     * Autoconnect happens when the circumstances are suitable. That means for
     * example that the device is currently managed and not active. Autoconnect
     * thus never replaces or competes with an already active profile.
     * 
     * Note that autoconnect is not implemented for VPN profiles. See
     * #NMSettingConnection:secondaries as an alternative to automatically
     * connect VPN profiles.
     */
    autoconnect?: boolean
    /**
     * The autoconnect priority in range -999 to 999. If the connection is set
     * to autoconnect, connections with higher priority will be preferred.
     * The higher number means higher priority. Defaults to 0.
     * Note that this property only matters if there are more than one candidate
     * profile to select for autoconnect. In case of equal priority, the profile
     * used most recently is chosen.
     */
    autoconnect_priority?: number
    /**
     * The number of times a connection should be tried when autoactivating before
     * giving up. Zero means forever, -1 means the global default (4 times if not
     * overridden). Setting this to 1 means to try activation only once before
     * blocking autoconnect. Note that after a timeout, NetworkManager will try
     * to autoconnect again.
     */
    autoconnect_retries?: number
    /**
     * Whether or not slaves of this connection should be automatically brought up
     * when NetworkManager activates this connection. This only has a real effect
     * for master connections. The properties #NMSettingConnection:autoconnect,
     * #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
     * are unrelated to this setting.
     * The permitted values are: 0: leave slave connections untouched,
     * 1: activate all the slave connections with this connection, -1: default.
     * If -1 (default) is set, global connection.autoconnect-slaves is read to
     * determine the real value. If it is default as well, this fallbacks to 0.
     */
    autoconnect_slaves?: SettingConnectionAutoconnectSlaves
    /**
     * Whether DNSOverTls (dns-over-tls) is enabled for the connection.
     * DNSOverTls is a technology which uses TLS to encrypt dns traffic.
     * 
     * The permitted values are: "yes" (2) use DNSOverTls and disabled fallback,
     * "opportunistic" (1) use DNSOverTls but allow fallback to unencrypted resolution,
     * "no" (0) don't ever use DNSOverTls.
     * If unspecified "default" depends on the plugin used. Systemd-resolved
     * uses global setting.
     * 
     * This feature requires a plugin which supports DNSOverTls. Otherwise, the
     * setting has no effect. One such plugin is dns-systemd-resolved.
     */
    dns_over_tls?: number
    /**
     * If greater than zero, delay success of IP addressing until either the
     * timeout is reached, or an IP gateway replies to a ping.
     */
    gateway_ping_timeout?: number
    /**
     * A human readable unique identifier for the connection, like "Work Wi-Fi"
     * or "T-Mobile 3G".
     */
    id?: string
    /**
     * The name of the network interface this connection is bound to. If not
     * set, then the connection can be attached to any interface of the
     * appropriate type (subject to restrictions imposed by other settings).
     * 
     * For software devices this specifies the name of the created device.
     * 
     * For connection types where interface names cannot easily be made
     * persistent (e.g. mobile broadband or USB Ethernet), this property should
     * not be used. Setting this property restricts the interfaces a connection
     * can be used with, and if interface names change or are reordered the
     * connection may be applied to the wrong interface.
     */
    interface_name?: string
    /**
     * Whether LLDP is enabled for the connection.
     */
    lldp?: number
    /**
     * Whether Link-Local Multicast Name Resolution (LLMNR) is enabled
     * for the connection. LLMNR is a protocol based on the Domain Name
     * System (DNS) packet format that allows both IPv4 and IPv6 hosts
     * to perform name resolution for hosts on the same local link.
     * 
     * The permitted values are: "yes" (2) register hostname and resolving
     * for the connection, "no" (0) disable LLMNR for the interface, "resolve"
     * (1) do not register hostname but allow resolving of LLMNR host names
     * If unspecified, "default" ultimately depends on the DNS plugin (which
     * for systemd-resolved currently means "yes").
     * 
     * This feature requires a plugin which supports LLMNR. Otherwise, the
     * setting has no effect. One such plugin is dns-systemd-resolved.
     */
    llmnr?: number
    /**
     * Interface name of the master device or UUID of the master connection.
     */
    master?: string
    /**
     * Whether mDNS is enabled for the connection.
     * 
     * The permitted values are: "yes" (2) register hostname and resolving
     * for the connection, "no" (0) disable mDNS for the interface, "resolve"
     * (1) do not register hostname but allow resolving of mDNS host names
     * and "default" (-1) to allow lookup of a global default in NetworkManager.conf.
     * If unspecified, "default" ultimately depends on the DNS plugin (which
     * for systemd-resolved currently means "no").
     * 
     * This feature requires a plugin which supports mDNS. Otherwise, the
     * setting has no effect. One such plugin is dns-systemd-resolved.
     */
    mdns?: number
    /**
     * Whether the connection is metered.
     * 
     * When updating this property on a currently activated connection,
     * the change takes effect immediately.
     */
    metered?: Metered
    /**
     * If configured, set to a Manufacturer Usage Description (MUD) URL that points
     * to manufacturer-recommended network policies for IoT devices. It is transmitted
     * as a DHCPv4 or DHCPv6 option. The value must be a valid URL starting with "https://".
     * 
     * The special value "none" is allowed to indicate that no MUD URL is used.
     * 
     * If the per-profile value is unspecified (the default), a global connection default gets
     * consulted. If still unspecified, the ultimate default is "none".
     */
    mud_url?: string
    /**
     * Specifies whether the profile can be active multiple times at a particular
     * moment. The value is of type #NMConnectionMultiConnect.
     */
    multi_connect?: number
    /**
     * An array of strings defining what access a given user has to this
     * connection.  If this is %NULL or empty, all users are allowed to access
     * this connection; otherwise users are allowed if and only if they are in
     * this list.  When this is not empty, the connection can be active only when
     * one of the specified users is logged into an active session.  Each entry
     * is of the form "[type]:[id]:[reserved]"; for example, "user:dcbw:blah".
     * 
     * At this time only the "user" [type] is allowed.  Any other values are
     * ignored and reserved for future use.  [id] is the username that this
     * permission refers to, which may not contain the ":" character. Any
     * [reserved] information present must be ignored and is reserved for future
     * use.  All of [type], [id], and [reserved] must be valid UTF-8.
     */
    permissions?: string[]
    /**
     * %FALSE if the connection can be modified using the provided settings
     * service's D-Bus interface with the right privileges, or %TRUE if the
     * connection is read-only and cannot be modified.
     */
    read_only?: boolean
    /**
     * List of connection UUIDs that should be activated when the base
     * connection itself is activated. Currently, only VPN connections are
     * supported.
     */
    secondaries?: string[]
    /**
     * Setting name of the device type of this slave's master connection (eg,
     * %NM_SETTING_BOND_SETTING_NAME), or %NULL if this connection is not a
     * slave.
     */
    slave_type?: string
    /**
     * This represents the identity of the connection used for various purposes.
     * It allows to configure multiple profiles to share the identity. Also,
     * the stable-id can contain placeholders that are substituted dynamically and
     * deterministically depending on the context.
     * 
     * The stable-id is used for generating IPv6 stable private addresses
     * with ipv6.addr-gen-mode=stable-privacy. It is also used to seed the
     * generated cloned MAC address for ethernet.cloned-mac-address=stable
     * and wifi.cloned-mac-address=stable. It is also used as DHCP client
     * identifier with ipv4.dhcp-client-id=stable and to derive the DHCP
     * DUID with ipv6.dhcp-duid=stable-[llt,ll,uuid].
     * 
     * Note that depending on the context where it is used, other parameters are
     * also seeded into the generation algorithm. For example, a per-host key
     * is commonly also included, so that different systems end up generating
     * different IDs. Or with ipv6.addr-gen-mode=stable-privacy, also the device's
     * name is included, so that different interfaces yield different addresses.
     * The per-host key is the identity of your machine and stored in /var/lib/NetworkManager/secret-key.
     * 
     * The '$' character is treated special to perform dynamic substitutions
     * at runtime. Currently, supported are "${CONNECTION}", "${DEVICE}", "${MAC}",
     * "${BOOT}", "${RANDOM}".
     * These effectively create unique IDs per-connection, per-device, per-boot,
     * or every time. Note that "${DEVICE}" corresponds to the interface name of the
     * device and "${MAC}" is the permanent MAC address of the device.
     * Any unrecognized patterns following '$' are treated verbatim, however
     * are reserved for future use. You are thus advised to avoid '$' or
     * escape it as "$$".
     * For example, set it to "${CONNECTION}-${BOOT}-${DEVICE}" to create a unique id for
     * this connection that changes with every reboot and differs depending on the
     * interface where the profile activates.
     * 
     * If the value is unset, a global connection default is consulted. If the
     * value is still unset, the default is similar to "${CONNECTION}" and uses
     * a unique, fixed ID for the connection.
     */
    stable_id?: string
    /**
     * The time, in seconds since the Unix Epoch, that the connection was last
     * _successfully_ fully activated.
     * 
     * NetworkManager updates the connection timestamp periodically when the
     * connection is active to ensure that an active connection has the latest
     * timestamp. The property is only meant for reading (changes to this
     * property will not be preserved).
     */
    timestamp?: number
    /**
     * Base type of the connection. For hardware-dependent connections, should
     * contain the setting name of the hardware-type specific setting (ie,
     * "802-3-ethernet" or "802-11-wireless" or "bluetooth", etc), and for
     * non-hardware dependent connections like VPN or otherwise, should contain
     * the setting name of that setting type (ie, "vpn" or "bridge", etc).
     */
    type?: string
    /**
     * A universally unique identifier for the connection, for example generated
     * with libuuid.  It should be assigned when the connection is created, and
     * never changed as long as the connection still applies to the same
     * network.  For example, it should not be changed when the
     * #NMSettingConnection:id property or #NMSettingIP4Config changes, but
     * might need to be re-created when the Wi-Fi SSID, mobile broadband network
     * provider, or #NMSettingConnection:type property changes.
     * 
     * The UUID must be in the format "2815492f-7e56-435e-b2e9-246bd7cdc664"
     * (ie, contains only hexadecimal characters and "-").  A suitable UUID may
     * be generated by nm_utils_uuid_generate() or
     * nm_uuid_generate_from_string_str().
     */
    uuid?: string
    /**
     * Timeout in milliseconds to wait for device at startup.
     * During boot, devices may take a while to be detected by the driver.
     * This property will cause to delay NetworkManager-wait-online.service
     * and nm-online to give the device a chance to appear. This works by
     * waiting for the given timeout until a compatible device for the
     * profile is available and managed.
     * 
     * The value 0 means no wait time. The default value is -1, which
     * currently has the same meaning as no wait time.
     */
    wait_device_timeout?: number
    /**
     * The trust level of a the connection.  Free form case-insensitive string
     * (for example "Home", "Work", "Public").  %NULL or unspecified zone means
     * the connection will be placed in the default zone as defined by the
     * firewall.
     * 
     * When updating this property on a currently activated connection,
     * the change takes effect immediately.
     */
    zone?: string
}
class SettingConnection {
    /* Properties of NM-1.0.NM.SettingConnection */
    /**
     * The number of retries for the authentication. Zero means to try indefinitely; -1 means
     * to use a global default. If the global default is not set, the authentication
     * retries for 3 times before failing the connection.
     * 
     * Currently, this only applies to 802-1x authentication.
     */
    auth_retries: number
    /**
     * Whether or not the connection should be automatically connected by
     * NetworkManager when the resources for the connection are available.
     * %TRUE to automatically activate the connection, %FALSE to require manual
     * intervention to activate the connection.
     * 
     * Autoconnect happens when the circumstances are suitable. That means for
     * example that the device is currently managed and not active. Autoconnect
     * thus never replaces or competes with an already active profile.
     * 
     * Note that autoconnect is not implemented for VPN profiles. See
     * #NMSettingConnection:secondaries as an alternative to automatically
     * connect VPN profiles.
     */
    autoconnect: boolean
    /**
     * The autoconnect priority in range -999 to 999. If the connection is set
     * to autoconnect, connections with higher priority will be preferred.
     * The higher number means higher priority. Defaults to 0.
     * Note that this property only matters if there are more than one candidate
     * profile to select for autoconnect. In case of equal priority, the profile
     * used most recently is chosen.
     */
    autoconnect_priority: number
    /**
     * The number of times a connection should be tried when autoactivating before
     * giving up. Zero means forever, -1 means the global default (4 times if not
     * overridden). Setting this to 1 means to try activation only once before
     * blocking autoconnect. Note that after a timeout, NetworkManager will try
     * to autoconnect again.
     */
    autoconnect_retries: number
    /**
     * Whether or not slaves of this connection should be automatically brought up
     * when NetworkManager activates this connection. This only has a real effect
     * for master connections. The properties #NMSettingConnection:autoconnect,
     * #NMSettingConnection:autoconnect-priority and #NMSettingConnection:autoconnect-retries
     * are unrelated to this setting.
     * The permitted values are: 0: leave slave connections untouched,
     * 1: activate all the slave connections with this connection, -1: default.
     * If -1 (default) is set, global connection.autoconnect-slaves is read to
     * determine the real value. If it is default as well, this fallbacks to 0.
     */
    autoconnect_slaves: SettingConnectionAutoconnectSlaves
    /**
     * Whether DNSOverTls (dns-over-tls) is enabled for the connection.
     * DNSOverTls is a technology which uses TLS to encrypt dns traffic.
     * 
     * The permitted values are: "yes" (2) use DNSOverTls and disabled fallback,
     * "opportunistic" (1) use DNSOverTls but allow fallback to unencrypted resolution,
     * "no" (0) don't ever use DNSOverTls.
     * If unspecified "default" depends on the plugin used. Systemd-resolved
     * uses global setting.
     * 
     * This feature requires a plugin which supports DNSOverTls. Otherwise, the
     * setting has no effect. One such plugin is dns-systemd-resolved.
     */
    dns_over_tls: number
    /**
     * If greater than zero, delay success of IP addressing until either the
     * timeout is reached, or an IP gateway replies to a ping.
     */
    gateway_ping_timeout: number
    /**
     * A human readable unique identifier for the connection, like "Work Wi-Fi"
     * or "T-Mobile 3G".
     */
    id: string
    /**
     * The name of the network interface this connection is bound to. If not
     * set, then the connection can be attached to any interface of the
     * appropriate type (subject to restrictions imposed by other settings).
     * 
     * For software devices this specifies the name of the created device.
     * 
     * For connection types where interface names cannot easily be made
     * persistent (e.g. mobile broadband or USB Ethernet), this property should
     * not be used. Setting this property restricts the interfaces a connection
     * can be used with, and if interface names change or are reordered the
     * connection may be applied to the wrong interface.
     */
    interface_name: string
    /**
     * Whether LLDP is enabled for the connection.
     */
    lldp: number
    /**
     * Whether Link-Local Multicast Name Resolution (LLMNR) is enabled
     * for the connection. LLMNR is a protocol based on the Domain Name
     * System (DNS) packet format that allows both IPv4 and IPv6 hosts
     * to perform name resolution for hosts on the same local link.
     * 
     * The permitted values are: "yes" (2) register hostname and resolving
     * for the connection, "no" (0) disable LLMNR for the interface, "resolve"
     * (1) do not register hostname but allow resolving of LLMNR host names
     * If unspecified, "default" ultimately depends on the DNS plugin (which
     * for systemd-resolved currently means "yes").
     * 
     * This feature requires a plugin which supports LLMNR. Otherwise, the
     * setting has no effect. One such plugin is dns-systemd-resolved.
     */
    llmnr: number
    /**
     * Interface name of the master device or UUID of the master connection.
     */
    master: string
    /**
     * Whether mDNS is enabled for the connection.
     * 
     * The permitted values are: "yes" (2) register hostname and resolving
     * for the connection, "no" (0) disable mDNS for the interface, "resolve"
     * (1) do not register hostname but allow resolving of mDNS host names
     * and "default" (-1) to allow lookup of a global default in NetworkManager.conf.
     * If unspecified, "default" ultimately depends on the DNS plugin (which
     * for systemd-resolved currently means "no").
     * 
     * This feature requires a plugin which supports mDNS. Otherwise, the
     * setting has no effect. One such plugin is dns-systemd-resolved.
     */
    mdns: number
    /**
     * Whether the connection is metered.
     * 
     * When updating this property on a currently activated connection,
     * the change takes effect immediately.
     */
    metered: Metered
    /**
     * If configured, set to a Manufacturer Usage Description (MUD) URL that points
     * to manufacturer-recommended network policies for IoT devices. It is transmitted
     * as a DHCPv4 or DHCPv6 option. The value must be a valid URL starting with "https://".
     * 
     * The special value "none" is allowed to indicate that no MUD URL is used.
     * 
     * If the per-profile value is unspecified (the default), a global connection default gets
     * consulted. If still unspecified, the ultimate default is "none".
     */
    mud_url: string
    /**
     * Specifies whether the profile can be active multiple times at a particular
     * moment. The value is of type #NMConnectionMultiConnect.
     */
    multi_connect: number
    /**
     * An array of strings defining what access a given user has to this
     * connection.  If this is %NULL or empty, all users are allowed to access
     * this connection; otherwise users are allowed if and only if they are in
     * this list.  When this is not empty, the connection can be active only when
     * one of the specified users is logged into an active session.  Each entry
     * is of the form "[type]:[id]:[reserved]"; for example, "user:dcbw:blah".
     * 
     * At this time only the "user" [type] is allowed.  Any other values are
     * ignored and reserved for future use.  [id] is the username that this
     * permission refers to, which may not contain the ":" character. Any
     * [reserved] information present must be ignored and is reserved for future
     * use.  All of [type], [id], and [reserved] must be valid UTF-8.
     */
    permissions: string[]
    /**
     * %FALSE if the connection can be modified using the provided settings
     * service's D-Bus interface with the right privileges, or %TRUE if the
     * connection is read-only and cannot be modified.
     */
    read_only: boolean
    /**
     * List of connection UUIDs that should be activated when the base
     * connection itself is activated. Currently, only VPN connections are
     * supported.
     */
    secondaries: string[]
    /**
     * Setting name of the device type of this slave's master connection (eg,
     * %NM_SETTING_BOND_SETTING_NAME), or %NULL if this connection is not a
     * slave.
     */
    slave_type: string
    /**
     * This represents the identity of the connection used for various purposes.
     * It allows to configure multiple profiles to share the identity. Also,
     * the stable-id can contain placeholders that are substituted dynamically and
     * deterministically depending on the context.
     * 
     * The stable-id is used for generating IPv6 stable private addresses
     * with ipv6.addr-gen-mode=stable-privacy. It is also used to seed the
     * generated cloned MAC address for ethernet.cloned-mac-address=stable
     * and wifi.cloned-mac-address=stable. It is also used as DHCP client
     * identifier with ipv4.dhcp-client-id=stable and to derive the DHCP
     * DUID with ipv6.dhcp-duid=stable-[llt,ll,uuid].
     * 
     * Note that depending on the context where it is used, other parameters are
     * also seeded into the generation algorithm. For example, a per-host key
     * is commonly also included, so that different systems end up generating
     * different IDs. Or with ipv6.addr-gen-mode=stable-privacy, also the device's
     * name is included, so that different interfaces yield different addresses.
     * The per-host key is the identity of your machine and stored in /var/lib/NetworkManager/secret-key.
     * 
     * The '$' character is treated special to perform dynamic substitutions
     * at runtime. Currently, supported are "${CONNECTION}", "${DEVICE}", "${MAC}",
     * "${BOOT}", "${RANDOM}".
     * These effectively create unique IDs per-connection, per-device, per-boot,
     * or every time. Note that "${DEVICE}" corresponds to the interface name of the
     * device and "${MAC}" is the permanent MAC address of the device.
     * Any unrecognized patterns following '$' are treated verbatim, however
     * are reserved for future use. You are thus advised to avoid '$' or
     * escape it as "$$".
     * For example, set it to "${CONNECTION}-${BOOT}-${DEVICE}" to create a unique id for
     * this connection that changes with every reboot and differs depending on the
     * interface where the profile activates.
     * 
     * If the value is unset, a global connection default is consulted. If the
     * value is still unset, the default is similar to "${CONNECTION}" and uses
     * a unique, fixed ID for the connection.
     */
    stable_id: string
    /**
     * The time, in seconds since the Unix Epoch, that the connection was last
     * _successfully_ fully activated.
     * 
     * NetworkManager updates the connection timestamp periodically when the
     * connection is active to ensure that an active connection has the latest
     * timestamp. The property is only meant for reading (changes to this
     * property will not be preserved).
     */
    timestamp: number
    /**
     * Base type of the connection. For hardware-dependent connections, should
     * contain the setting name of the hardware-type specific setting (ie,
     * "802-3-ethernet" or "802-11-wireless" or "bluetooth", etc), and for
     * non-hardware dependent connections like VPN or otherwise, should contain
     * the setting name of that setting type (ie, "vpn" or "bridge", etc).
     */
    type: string
    /**
     * A universally unique identifier for the connection, for example generated
     * with libuuid.  It should be assigned when the connection is created, and
     * never changed as long as the connection still applies to the same
     * network.  For example, it should not be changed when the
     * #NMSettingConnection:id property or #NMSettingIP4Config changes, but
     * might need to be re-created when the Wi-Fi SSID, mobile broadband network
     * provider, or #NMSettingConnection:type property changes.
     * 
     * The UUID must be in the format "2815492f-7e56-435e-b2e9-246bd7cdc664"
     * (ie, contains only hexadecimal characters and "-").  A suitable UUID may
     * be generated by nm_utils_uuid_generate() or
     * nm_uuid_generate_from_string_str().
     */
    uuid: string
    /**
     * Timeout in milliseconds to wait for device at startup.
     * During boot, devices may take a while to be detected by the driver.
     * This property will cause to delay NetworkManager-wait-online.service
     * and nm-online to give the device a chance to appear. This works by
     * waiting for the given timeout until a compatible device for the
     * profile is available and managed.
     * 
     * The value 0 means no wait time. The default value is -1, which
     * currently has the same meaning as no wait time.
     */
    wait_device_timeout: number
    /**
     * The trust level of a the connection.  Free form case-insensitive string
     * (for example "Home", "Work", "Public").  %NULL or unspecified zone means
     * the connection will be placed in the default zone as defined by the
     * firewall.
     * 
     * When updating this property on a currently activated connection,
     * the change takes effect immediately.
     */
    zone: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingConnection */
    /**
     * Adds a permission to the connection's permission list.  At this time, only
     * the "user" permission type is supported, and `pitem` must be a username. See
     * #NMSettingConnection:permissions: for more details.
     */
    add_permission(ptype: string, pitem: string, detail?: string | null): boolean
    /**
     * Adds a new secondary connection UUID to the setting.
     */
    add_secondary(sec_uuid: string): boolean
    /**
     * Returns the value contained in the #NMSettingConnection:auth-retries property.
     */
    get_auth_retries(): number
    /**
     * Returns the #NMSettingConnection:autoconnect property of the connection.
     */
    get_autoconnect(): boolean
    /**
     * Returns the #NMSettingConnection:autoconnect-priority property of the connection.
     * The higher number, the higher priority.
     */
    get_autoconnect_priority(): number
    /**
     * Returns the #NMSettingConnection:autoconnect-retries property of the connection.
     * Zero means infinite, -1 means the global default value.
     */
    get_autoconnect_retries(): number
    /**
     * Returns the #NMSettingConnection:autoconnect-slaves property of the connection.
     */
    get_autoconnect_slaves(): SettingConnectionAutoconnectSlaves
    /**
     * Returns the #NMSettingConnection:type property of the connection.
     */
    get_connection_type(): string
    get_dns_over_tls(): SettingConnectionDnsOverTls
    get_gateway_ping_timeout(): number
    /**
     * Returns the #NMSettingConnection:id property of the connection.
     */
    get_id(): string
    /**
     * Returns the #NMSettingConnection:interface-name property of the connection.
     */
    get_interface_name(): string
    /**
     * Returns the #NMSettingConnection:lldp property of the connection.
     */
    get_lldp(): SettingConnectionLldp
    get_llmnr(): SettingConnectionLlmnr
    /**
     * Returns the #NMSettingConnection:master property of the connection.
     */
    get_master(): string
    get_mdns(): SettingConnectionMdns
    get_metered(): Metered
    /**
     * Returns the value contained in the #NMSettingConnection:mud-url
     * property.
     */
    get_mud_url(): string
    get_multi_connect(): ConnectionMultiConnect
    /**
     * Returns the number of entries in the #NMSettingConnection:permissions
     * property of this setting.
     */
    get_num_permissions(): number
    get_num_secondaries(): number
    /**
     * Retrieve one of the entries of the #NMSettingConnection:permissions property
     * of this setting.
     */
    get_permission(idx: number, out_ptype: string, out_pitem: string, out_detail: string): boolean
    /**
     * Returns the #NMSettingConnection:read-only property of the connection.
     */
    get_read_only(): boolean
    get_secondary(idx: number): string
    /**
     * Returns the #NMSettingConnection:slave-type property of the connection.
     */
    get_slave_type(): string
    /**
     * Returns the #NMSettingConnection:stable_id property of the connection.
     */
    get_stable_id(): string
    /**
     * Returns the #NMSettingConnection:timestamp property of the connection.
     */
    get_timestamp(): number
    /**
     * Returns the #NMSettingConnection:uuid property of the connection.
     */
    get_uuid(): string
    get_wait_device_timeout(): number
    /**
     * Returns the #NMSettingConnection:zone property of the connection.
     */
    get_zone(): string
    is_slave_type(type: string): boolean
    /**
     * Checks whether the given username is allowed to view/access this connection.
     */
    permissions_user_allowed(uname: string): boolean
    /**
     * Removes the permission at index `idx` from the connection.
     */
    remove_permission(idx: number): void
    /**
     * Removes the permission from the connection.
     * At this time, only the "user" permission type is supported, and `pitem` must
     * be a username. See #NMSettingConnection:permissions: for more details.
     */
    remove_permission_by_value(ptype: string, pitem: string, detail?: string | null): boolean
    /**
     * Removes the secondary connection UUID at index `idx`.
     */
    remove_secondary(idx: number): void
    /**
     * Removes the secondary connection UUID `sec_uuid`.
     */
    remove_secondary_by_value(sec_uuid: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::auth-retries", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auth-retries", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect-priority", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect-priority", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect-retries", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect-retries", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::autoconnect-slaves", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoconnect-slaves", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-over-tls", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-over-tls", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::gateway-ping-timeout", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::gateway-ping-timeout", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-name", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-name", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lldp", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lldp", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::llmnr", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::llmnr", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::master", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::master", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mdns", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mdns", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::metered", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::metered", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mud-url", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mud-url", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multi-connect", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multi-connect", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::permissions", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::permissions", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::read-only", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::read-only", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::secondaries", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::secondaries", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::slave-type", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::slave-type", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::stable-id", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stable-id", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::timestamp", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timestamp", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::type", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::uuid", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uuid", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wait-device-timeout", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wait-device-timeout", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::zone", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::zone", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingConnection_ConstructProps)
    _init (config?: SettingConnection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingConnection
    static $gtype: GObject.Type
}
interface SettingDcb_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingDcb */
    /**
     * Specifies the #NMSettingDcbFlags for the DCB FCoE application.  Flags may
     * be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    app_fcoe_flags?: SettingDcbFlags
    /**
     * The FCoE controller mode; either %NM_SETTING_DCB_FCOE_MODE_FABRIC
     * or %NM_SETTING_DCB_FCOE_MODE_VN2VN.
     * 
     * Since 1.34, %NULL is the default and means %NM_SETTING_DCB_FCOE_MODE_FABRIC.
     * Before 1.34, %NULL was rejected as invalid and the default was %NM_SETTING_DCB_FCOE_MODE_FABRIC.
     */
    app_fcoe_mode?: string
    /**
     * The highest User Priority (0 - 7) which FCoE frames should use, or -1 for
     * default priority.  Only used when the #NMSettingDcb:app-fcoe-flags
     * property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    app_fcoe_priority?: number
    /**
     * Specifies the #NMSettingDcbFlags for the DCB FIP application.  Flags may
     * be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    app_fip_flags?: SettingDcbFlags
    /**
     * The highest User Priority (0 - 7) which FIP frames should use, or -1 for
     * default priority.  Only used when the #NMSettingDcb:app-fip-flags
     * property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    app_fip_priority?: number
    /**
     * Specifies the #NMSettingDcbFlags for the DCB iSCSI application.  Flags
     * may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    app_iscsi_flags?: SettingDcbFlags
    /**
     * The highest User Priority (0 - 7) which iSCSI frames should use, or -1
     * for default priority. Only used when the #NMSettingDcb:app-iscsi-flags
     * property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    app_iscsi_priority?: number
    /**
     * An array of 8 uint values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates the percentage of bandwidth of
     * the priority's assigned group that the priority may use.  The sum of all
     * percentages for priorities which belong to the same group must total 100
     * percents.
     */
    priority_bandwidth?: number[]
    /**
     * An array of 8 boolean values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates whether or not the corresponding
     * priority should transmit priority pause.
     */
    priority_flow_control?: boolean[]
    /**
     * Specifies the #NMSettingDcbFlags for DCB Priority Flow Control (PFC).
     * Flags may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    priority_flow_control_flags?: SettingDcbFlags
    /**
     * An array of 8 uint values, where the array index corresponds to the
     * Priority Group ID (0 - 7) and the value indicates the percentage of link
     * bandwidth allocated to that group.  Allowed values are 0 - 100, and the
     * sum of all values must total 100 percents.
     */
    priority_group_bandwidth?: number[]
    /**
     * Specifies the #NMSettingDcbFlags for DCB Priority Groups.  Flags may be
     * any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    priority_group_flags?: SettingDcbFlags
    /**
     * An array of 8 uint values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates the Priority Group ID.  Allowed
     * Priority Group ID values are 0 - 7 or 15 for the unrestricted group.
     */
    priority_group_id?: number[]
    /**
     * An array of 8 boolean values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates whether or not the priority may
     * use all of the bandwidth allocated to its assigned group.
     */
    priority_strict_bandwidth?: boolean[]
    /**
     * An array of 8 uint values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates the traffic class (0 - 7) to
     * which the priority is mapped.
     */
    priority_traffic_class?: number[]
}
class SettingDcb {
    /* Properties of NM-1.0.NM.SettingDcb */
    /**
     * Specifies the #NMSettingDcbFlags for the DCB FCoE application.  Flags may
     * be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    app_fcoe_flags: SettingDcbFlags
    /**
     * The FCoE controller mode; either %NM_SETTING_DCB_FCOE_MODE_FABRIC
     * or %NM_SETTING_DCB_FCOE_MODE_VN2VN.
     * 
     * Since 1.34, %NULL is the default and means %NM_SETTING_DCB_FCOE_MODE_FABRIC.
     * Before 1.34, %NULL was rejected as invalid and the default was %NM_SETTING_DCB_FCOE_MODE_FABRIC.
     */
    app_fcoe_mode: string
    /**
     * The highest User Priority (0 - 7) which FCoE frames should use, or -1 for
     * default priority.  Only used when the #NMSettingDcb:app-fcoe-flags
     * property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    app_fcoe_priority: number
    /**
     * Specifies the #NMSettingDcbFlags for the DCB FIP application.  Flags may
     * be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    app_fip_flags: SettingDcbFlags
    /**
     * The highest User Priority (0 - 7) which FIP frames should use, or -1 for
     * default priority.  Only used when the #NMSettingDcb:app-fip-flags
     * property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    app_fip_priority: number
    /**
     * Specifies the #NMSettingDcbFlags for the DCB iSCSI application.  Flags
     * may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    app_iscsi_flags: SettingDcbFlags
    /**
     * The highest User Priority (0 - 7) which iSCSI frames should use, or -1
     * for default priority. Only used when the #NMSettingDcb:app-iscsi-flags
     * property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    app_iscsi_priority: number
    /**
     * An array of 8 uint values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates the percentage of bandwidth of
     * the priority's assigned group that the priority may use.  The sum of all
     * percentages for priorities which belong to the same group must total 100
     * percents.
     */
    priority_bandwidth: number[]
    /**
     * An array of 8 boolean values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates whether or not the corresponding
     * priority should transmit priority pause.
     */
    priority_flow_control: boolean[]
    /**
     * Specifies the #NMSettingDcbFlags for DCB Priority Flow Control (PFC).
     * Flags may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    priority_flow_control_flags: SettingDcbFlags
    /**
     * An array of 8 uint values, where the array index corresponds to the
     * Priority Group ID (0 - 7) and the value indicates the percentage of link
     * bandwidth allocated to that group.  Allowed values are 0 - 100, and the
     * sum of all values must total 100 percents.
     */
    priority_group_bandwidth: number[]
    /**
     * Specifies the #NMSettingDcbFlags for DCB Priority Groups.  Flags may be
     * any combination of %NM_SETTING_DCB_FLAG_ENABLE,
     * %NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.
     */
    priority_group_flags: SettingDcbFlags
    /**
     * An array of 8 uint values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates the Priority Group ID.  Allowed
     * Priority Group ID values are 0 - 7 or 15 for the unrestricted group.
     */
    priority_group_id: number[]
    /**
     * An array of 8 boolean values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates whether or not the priority may
     * use all of the bandwidth allocated to its assigned group.
     */
    priority_strict_bandwidth: boolean[]
    /**
     * An array of 8 uint values, where the array index corresponds to the User
     * Priority (0 - 7) and the value indicates the traffic class (0 - 7) to
     * which the priority is mapped.
     */
    priority_traffic_class: number[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingDcb */
    get_app_fcoe_flags(): SettingDcbFlags
    get_app_fcoe_mode(): string
    get_app_fcoe_priority(): number
    get_app_fip_flags(): SettingDcbFlags
    get_app_fip_priority(): number
    get_app_iscsi_flags(): SettingDcbFlags
    get_app_iscsi_priority(): number
    get_priority_bandwidth(user_priority: number): number
    get_priority_flow_control(user_priority: number): boolean
    get_priority_flow_control_flags(): SettingDcbFlags
    get_priority_group_bandwidth(group_id: number): number
    get_priority_group_flags(): SettingDcbFlags
    get_priority_group_id(user_priority: number): number
    get_priority_strict_bandwidth(user_priority: number): boolean
    get_priority_traffic_class(user_priority: number): number
    /**
     * These values are only valid when #NMSettingDcb:priority-group-flags includes
     * the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    set_priority_bandwidth(user_priority: number, bandwidth_percent: number): void
    /**
     * These values are only valid when #NMSettingDcb:priority-flow-control includes
     * the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    set_priority_flow_control(user_priority: number, enabled: boolean): void
    /**
     * These values are only valid when #NMSettingDcb:priority-group-flags includes
     * the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    set_priority_group_bandwidth(group_id: number, bandwidth_percent: number): void
    /**
     * These values are only valid when #NMSettingDcb:priority-group-flags includes
     * the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    set_priority_group_id(user_priority: number, group_id: number): void
    /**
     * These values are only valid when #NMSettingDcb:priority-group-flags includes
     * the %NM_SETTING_DCB_FLAG_ENABLE flag.
     */
    set_priority_strict_bandwidth(user_priority: number, strict: boolean): void
    set_priority_traffic_class(user_priority: number, traffic_class: number): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::app-fcoe-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::app-fcoe-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::app-fcoe-mode", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::app-fcoe-mode", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::app-fcoe-priority", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::app-fcoe-priority", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::app-fip-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::app-fip-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::app-fip-priority", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::app-fip-priority", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::app-iscsi-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::app-iscsi-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::app-iscsi-priority", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::app-iscsi-priority", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-bandwidth", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-bandwidth", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-flow-control", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-flow-control", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-flow-control-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-flow-control-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-group-bandwidth", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-group-bandwidth", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-group-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-group-flags", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-group-id", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-group-id", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-strict-bandwidth", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-strict-bandwidth", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority-traffic-class", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority-traffic-class", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingDcb, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingDcb_ConstructProps)
    _init (config?: SettingDcb_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingDcb
    static $gtype: GObject.Type
}
interface SettingDummy_ConstructProps extends Setting_ConstructProps {
}
class SettingDummy {
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingDummy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: SettingDummy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingDummy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingDummy_ConstructProps)
    _init (config?: SettingDummy_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingDummy
    static $gtype: GObject.Type
}
interface SettingEthtool_ConstructProps extends Setting_ConstructProps {
}
class SettingEthtool {
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingEthtool */
    /**
     * Clears all offload features settings
     */
    clear_features(): void
    /**
     * Gets and offload feature setting. Returns %NM_TERNARY_DEFAULT if the
     * feature is not set.
     * 
     * Note that `optname` must be a valid name for a feature, according to
     * nm_ethtool_optname_is_feature().
     */
    get_feature(optname: string): Ternary
    /**
     * This returns all options names that are set. This includes the feature names
     * like %NM_ETHTOOL_OPTNAME_FEATURE_GRO. See nm_ethtool_optname_is_feature() to
     * check whether the option name is valid for offload features.
     */
    get_optnames(): [ /* returnType */ string[], /* out_length */ number | null ]
    /**
     * Sets and offload feature setting.
     * 
     * Note that `optname` must be a valid name for a feature, according to
     * nm_ethtool_optname_is_feature().
     */
    set_feature(optname: string, value: Ternary): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingEthtool, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingEthtool, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: SettingEthtool, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingEthtool, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingEthtool_ConstructProps)
    _init (config?: SettingEthtool_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingEthtool
    static $gtype: GObject.Type
}
interface SettingGeneric_ConstructProps extends Setting_ConstructProps {
}
class SettingGeneric {
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingGeneric, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: SettingGeneric, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingGeneric, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingGeneric_ConstructProps)
    _init (config?: SettingGeneric_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingGeneric
    static $gtype: GObject.Type
}
interface SettingGsm_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingGsm */
    /**
     * The GPRS Access Point Name specifying the APN used when establishing a
     * data session with the GSM-based network.  The APN often determines how
     * the user will be billed for their network usage and whether the user has
     * access to the Internet or just a provider-specific walled-garden, so it
     * is important to use the correct APN for the user's mobile broadband plan.
     * The APN may only be composed of the characters a-z, 0-9, ., and - per GSM
     * 03.60 Section 14.9.
     */
    apn?: string
    /**
     * When %TRUE, the settings such as APN, username, or password will
     * default to values that match the network the modem will register
     * to in the Mobile Broadband Provider database.
     */
    auto_config?: boolean
    /**
     * The device unique identifier (as given by the WWAN management service)
     * which this connection applies to.  If given, the connection will only
     * apply to the specified device.
     */
    device_id?: string
    /**
     * When %TRUE, only connections to the home network will be allowed.
     * Connections to roaming networks will not be made.
     */
    home_only?: boolean
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple frames.
     */
    mtu?: number
    /**
     * The Network ID (GSM LAI format, ie MCC-MNC) to force specific network
     * registration.  If the Network ID is specified, NetworkManager will
     * attempt to force the device to register only on the specified network.
     * This can be used to ensure that the device does not roam when direct
     * roaming control of the device is not otherwise possible.
     */
    network_id?: string
    /**
     * Legacy setting that used to help establishing PPP data sessions for
     * GSM-based modems.
     */
    number?: string
    /**
     * The password used to authenticate with the network, if required.  Many
     * providers do not require a password, or accept any password.  But if a
     * password is required, it is specified here.
     */
    password?: string
    /**
     * Flags indicating how to handle the #NMSettingGsm:password property.
     */
    password_flags?: SettingSecretFlags
    /**
     * If the SIM is locked with a PIN it must be unlocked before any other
     * operations are requested.  Specify the PIN here to allow operation of the
     * device.
     */
    pin?: string
    /**
     * Flags indicating how to handle the #NMSettingGsm:pin property.
     */
    pin_flags?: SettingSecretFlags
    /**
     * The SIM card unique identifier (as given by the WWAN management service)
     * which this connection applies to.  If given, the connection will apply
     * to any device also allowed by #NMSettingGsm:device-id which contains a
     * SIM card matching the given identifier.
     */
    sim_id?: string
    /**
     * A MCC/MNC string like "310260" or "21601" identifying the specific
     * mobile network operator which this connection applies to.  If given,
     * the connection will apply to any device also allowed by
     * #NMSettingGsm:device-id and #NMSettingGsm:sim-id which contains a SIM
     * card provisioned by the given operator.
     */
    sim_operator_id?: string
    /**
     * The username used to authenticate with the network, if required.  Many
     * providers do not require a username, or accept any username.  But if a
     * username is required, it is specified here.
     */
    username?: string
}
class SettingGsm {
    /* Properties of NM-1.0.NM.SettingGsm */
    /**
     * The GPRS Access Point Name specifying the APN used when establishing a
     * data session with the GSM-based network.  The APN often determines how
     * the user will be billed for their network usage and whether the user has
     * access to the Internet or just a provider-specific walled-garden, so it
     * is important to use the correct APN for the user's mobile broadband plan.
     * The APN may only be composed of the characters a-z, 0-9, ., and - per GSM
     * 03.60 Section 14.9.
     */
    apn: string
    /**
     * When %TRUE, the settings such as APN, username, or password will
     * default to values that match the network the modem will register
     * to in the Mobile Broadband Provider database.
     */
    auto_config: boolean
    /**
     * The device unique identifier (as given by the WWAN management service)
     * which this connection applies to.  If given, the connection will only
     * apply to the specified device.
     */
    device_id: string
    /**
     * When %TRUE, only connections to the home network will be allowed.
     * Connections to roaming networks will not be made.
     */
    home_only: boolean
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple frames.
     */
    mtu: number
    /**
     * The Network ID (GSM LAI format, ie MCC-MNC) to force specific network
     * registration.  If the Network ID is specified, NetworkManager will
     * attempt to force the device to register only on the specified network.
     * This can be used to ensure that the device does not roam when direct
     * roaming control of the device is not otherwise possible.
     */
    network_id: string
    /**
     * Legacy setting that used to help establishing PPP data sessions for
     * GSM-based modems.
     */
    number: string
    /**
     * The password used to authenticate with the network, if required.  Many
     * providers do not require a password, or accept any password.  But if a
     * password is required, it is specified here.
     */
    password: string
    /**
     * Flags indicating how to handle the #NMSettingGsm:password property.
     */
    password_flags: SettingSecretFlags
    /**
     * If the SIM is locked with a PIN it must be unlocked before any other
     * operations are requested.  Specify the PIN here to allow operation of the
     * device.
     */
    pin: string
    /**
     * Flags indicating how to handle the #NMSettingGsm:pin property.
     */
    pin_flags: SettingSecretFlags
    /**
     * The SIM card unique identifier (as given by the WWAN management service)
     * which this connection applies to.  If given, the connection will apply
     * to any device also allowed by #NMSettingGsm:device-id which contains a
     * SIM card matching the given identifier.
     */
    sim_id: string
    /**
     * A MCC/MNC string like "310260" or "21601" identifying the specific
     * mobile network operator which this connection applies to.  If given,
     * the connection will apply to any device also allowed by
     * #NMSettingGsm:device-id and #NMSettingGsm:sim-id which contains a SIM
     * card provisioned by the given operator.
     */
    sim_operator_id: string
    /**
     * The username used to authenticate with the network, if required.  Many
     * providers do not require a username, or accept any username.  But if a
     * username is required, it is specified here.
     */
    username: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingGsm */
    get_apn(): string
    get_auto_config(): boolean
    get_device_id(): string
    get_home_only(): boolean
    get_mtu(): number
    get_network_id(): string
    get_number(): string
    get_password(): string
    get_password_flags(): SettingSecretFlags
    get_pin(): string
    get_pin_flags(): SettingSecretFlags
    get_sim_id(): string
    get_sim_operator_id(): string
    get_username(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::apn", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::apn", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-config", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-config", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::device-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::device-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::home-only", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::home-only", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::network-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::network-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::number", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::number", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password-flags", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-flags", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pin", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pin", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pin-flags", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pin-flags", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::sim-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sim-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::sim-operator-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sim-operator-id", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::username", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::username", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingGsm, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingGsm_ConstructProps)
    _init (config?: SettingGsm_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingGsm
    static $gtype: GObject.Type
}
interface SettingHostname_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingHostname */
    /**
     * Whether the system hostname can be determined from DHCP on
     * this connection.
     * 
     * When set to %NM_TERNARY_DEFAULT, the value from global configuration
     * is used. If the property doesn't have a value in the global
     * configuration, NetworkManager assumes the value to be %NM_TERNARY_TRUE.
     */
    from_dhcp?: Ternary
    /**
     * Whether the system hostname can be determined from reverse
     * DNS lookup of addresses on this device.
     * 
     * When set to %NM_TERNARY_DEFAULT, the value from global configuration
     * is used. If the property doesn't have a value in the global
     * configuration, NetworkManager assumes the value to be %NM_TERNARY_TRUE.
     */
    from_dns_lookup?: Ternary
    /**
     * If set to %NM_TERNARY_TRUE, NetworkManager attempts to get
     * the hostname via DHCPv4/DHCPv6 or reverse DNS lookup on this
     * device only when the device has the default route for the given
     * address family (IPv4/IPv6).
     * 
     * If set to %NM_TERNARY_FALSE, the hostname can be set from this
     * device even if it doesn't have the default route.
     * 
     * When set to %NM_TERNARY_DEFAULT, the value from global configuration
     * is used. If the property doesn't have a value in the global
     * configuration, NetworkManager assumes the value to be %NM_TERNARY_FALSE.
     */
    only_from_default?: Ternary
    /**
     * The relative priority of this connection to determine the
     * system hostname. A lower numerical value is better (higher
     * priority).  A connection with higher priority is considered
     * before connections with lower priority.
     * 
     * If the value is zero, it can be overridden by a global value
     * from NetworkManager configuration. If the property doesn't have
     * a value in the global configuration, the value is assumed to be
     * 100.
     * 
     * Negative values have the special effect of excluding other
     * connections with a greater numerical priority value; so in
     * presence of at least one negative priority, only connections
     * with the lowest priority value will be used to determine the
     * hostname.
     */
    priority?: number
}
class SettingHostname {
    /* Properties of NM-1.0.NM.SettingHostname */
    /**
     * Whether the system hostname can be determined from DHCP on
     * this connection.
     * 
     * When set to %NM_TERNARY_DEFAULT, the value from global configuration
     * is used. If the property doesn't have a value in the global
     * configuration, NetworkManager assumes the value to be %NM_TERNARY_TRUE.
     */
    from_dhcp: Ternary
    /**
     * Whether the system hostname can be determined from reverse
     * DNS lookup of addresses on this device.
     * 
     * When set to %NM_TERNARY_DEFAULT, the value from global configuration
     * is used. If the property doesn't have a value in the global
     * configuration, NetworkManager assumes the value to be %NM_TERNARY_TRUE.
     */
    from_dns_lookup: Ternary
    /**
     * If set to %NM_TERNARY_TRUE, NetworkManager attempts to get
     * the hostname via DHCPv4/DHCPv6 or reverse DNS lookup on this
     * device only when the device has the default route for the given
     * address family (IPv4/IPv6).
     * 
     * If set to %NM_TERNARY_FALSE, the hostname can be set from this
     * device even if it doesn't have the default route.
     * 
     * When set to %NM_TERNARY_DEFAULT, the value from global configuration
     * is used. If the property doesn't have a value in the global
     * configuration, NetworkManager assumes the value to be %NM_TERNARY_FALSE.
     */
    only_from_default: Ternary
    /**
     * The relative priority of this connection to determine the
     * system hostname. A lower numerical value is better (higher
     * priority).  A connection with higher priority is considered
     * before connections with lower priority.
     * 
     * If the value is zero, it can be overridden by a global value
     * from NetworkManager configuration. If the property doesn't have
     * a value in the global configuration, the value is assumed to be
     * 100.
     * 
     * Negative values have the special effect of excluding other
     * connections with a greater numerical priority value; so in
     * presence of at least one negative priority, only connections
     * with the lowest priority value will be used to determine the
     * hostname.
     */
    priority: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingHostname */
    /**
     * Returns the value contained in the #NMSettingHostname:from-dhcp
     * property.
     */
    get_from_dhcp(): Ternary
    /**
     * Returns the value contained in the #NMSettingHostname:from-dns-lookup
     * property.
     */
    get_from_dns_lookup(): Ternary
    /**
     * Returns the value contained in the #NMSettingHostname:only-from-default
     * property.
     */
    get_only_from_default(): Ternary
    /**
     * Returns the value contained in the #NMSettingHostname:priority
     * property.
     */
    get_priority(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::from-dhcp", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::from-dhcp", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::from-dns-lookup", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::from-dns-lookup", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::only-from-default", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::only-from-default", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::priority", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::priority", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingHostname, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingHostname_ConstructProps)
    _init (config?: SettingHostname_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingHostname
    static $gtype: GObject.Type
}
interface SettingIP4Config_ConstructProps extends SettingIPConfig_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingIP4Config */
    /**
     * A string sent to the DHCP server to identify the local machine which the
     * DHCP server may use to customize the DHCP lease and options.
     * When the property is a hex string ('aa:bb:cc') it is interpreted as a
     * binary client ID, in which case the first byte is assumed to be the
     * 'type' field as per RFC 2132 section 9.14 and the remaining bytes may be
     * an hardware address (e.g. '01:xx:xx:xx:xx:xx:xx' where 1 is the Ethernet
     * ARP type and the rest is a MAC address).
     * If the property is not a hex string it is considered as a
     * non-hardware-address client ID and the 'type' field is set to 0.
     * 
     * The special values "mac" and "perm-mac" are supported, which use the
     * current or permanent MAC address of the device to generate a client identifier
     * with type ethernet (01). Currently, these options only work for ethernet
     * type of links.
     * 
     * The special value "ipv6-duid" uses the DUID from "ipv6.dhcp-duid" property as
     * an RFC4361-compliant client identifier. As IAID it uses "ipv4.dhcp-iaid"
     * and falls back to "ipv6.dhcp-iaid" if unset.
     * 
     * The special value "duid" generates a RFC4361-compliant client identifier based
     * on "ipv4.dhcp-iaid" and uses a DUID generated by hashing /etc/machine-id.
     * 
     * The special value "stable" is supported to generate a type 0 client identifier based
     * on the stable-id (see connection.stable-id) and a per-host key. If you set the
     * stable-id, you may want to include the "${DEVICE}" or "${MAC}" specifier to get a
     * per-device key.
     * 
     * If unset, a globally configured default is used. If still unset, the default
     * depends on the DHCP plugin.
     */
    dhcp_client_id?: string
    /**
     * If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
     * specified FQDN will be sent to the DHCP server when acquiring a lease. This
     * property and #NMSettingIPConfig:dhcp-hostname are mutually exclusive and
     * cannot be set at the same time.
     */
    dhcp_fqdn?: string
    /**
     * The Vendor Class Identifier DHCP option (60).
     * Special characters in the data string may be escaped using C-style escapes,
     * nevertheless this property cannot contain nul bytes.
     * If the per-profile value is unspecified (the default),
     * a global connection default gets consulted.
     * If still unspecified, the DHCP option is not sent to the server.
     * 
     * Since 1.28
     */
    dhcp_vendor_class_identifier?: string
}
class SettingIP4Config {
    /* Properties of NM-1.0.NM.SettingIP4Config */
    /**
     * A string sent to the DHCP server to identify the local machine which the
     * DHCP server may use to customize the DHCP lease and options.
     * When the property is a hex string ('aa:bb:cc') it is interpreted as a
     * binary client ID, in which case the first byte is assumed to be the
     * 'type' field as per RFC 2132 section 9.14 and the remaining bytes may be
     * an hardware address (e.g. '01:xx:xx:xx:xx:xx:xx' where 1 is the Ethernet
     * ARP type and the rest is a MAC address).
     * If the property is not a hex string it is considered as a
     * non-hardware-address client ID and the 'type' field is set to 0.
     * 
     * The special values "mac" and "perm-mac" are supported, which use the
     * current or permanent MAC address of the device to generate a client identifier
     * with type ethernet (01). Currently, these options only work for ethernet
     * type of links.
     * 
     * The special value "ipv6-duid" uses the DUID from "ipv6.dhcp-duid" property as
     * an RFC4361-compliant client identifier. As IAID it uses "ipv4.dhcp-iaid"
     * and falls back to "ipv6.dhcp-iaid" if unset.
     * 
     * The special value "duid" generates a RFC4361-compliant client identifier based
     * on "ipv4.dhcp-iaid" and uses a DUID generated by hashing /etc/machine-id.
     * 
     * The special value "stable" is supported to generate a type 0 client identifier based
     * on the stable-id (see connection.stable-id) and a per-host key. If you set the
     * stable-id, you may want to include the "${DEVICE}" or "${MAC}" specifier to get a
     * per-device key.
     * 
     * If unset, a globally configured default is used. If still unset, the default
     * depends on the DHCP plugin.
     */
    dhcp_client_id: string
    /**
     * If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
     * specified FQDN will be sent to the DHCP server when acquiring a lease. This
     * property and #NMSettingIPConfig:dhcp-hostname are mutually exclusive and
     * cannot be set at the same time.
     */
    dhcp_fqdn: string
    /**
     * The Vendor Class Identifier DHCP option (60).
     * Special characters in the data string may be escaped using C-style escapes,
     * nevertheless this property cannot contain nul bytes.
     * If the per-profile value is unspecified (the default),
     * a global connection default gets consulted.
     * If still unspecified, the DHCP option is not sent to the server.
     * 
     * Since 1.28
     */
    dhcp_vendor_class_identifier: string
    /* Properties of NM-1.0.NM.SettingIPConfig */
    /**
     * Array of IP addresses.
     */
    addresses: IPAddress[]
    /**
     * Timeout in milliseconds used to check for the presence of duplicate IP
     * addresses on the network.  If an address conflict is detected, the
     * activation will fail.  A zero value means that no duplicate address
     * detection is performed, -1 means the default value (either configuration
     * ipvx.dad-timeout override or zero).  A value greater than zero is a
     * timeout in milliseconds.
     * 
     * The property is currently implemented only for IPv4.
     */
    dad_timeout: number
    /**
     * If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
     * specified name will be sent to the DHCP server when acquiring a lease.
     * This property and #NMSettingIP4Config:dhcp-fqdn are mutually exclusive and
     * cannot be set at the same time.
     */
    dhcp_hostname: string
    /**
     * Flags for the DHCP hostname and FQDN.
     * 
     * Currently, this property only includes flags to control the FQDN flags
     * set in the DHCP FQDN option. Supported FQDN flags are
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE.  When no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is set, the DHCP FQDN option will
     * contain no flag. Otherwise, if no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is not set, the standard FQDN flags
     * are set in the request:
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED for IPv4 and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE for IPv6.
     * 
     * When this property is set to the default value %NM_DHCP_HOSTNAME_FLAG_NONE,
     * a global default is looked up in NetworkManager configuration. If that value
     * is unset or also %NM_DHCP_HOSTNAME_FLAG_NONE, then the standard FQDN flags
     * described above are sent in the DHCP requests.
     */
    dhcp_hostname_flags: number
    /**
     * A string containing the "Identity Association Identifier" (IAID) used
     * by the DHCP client. The property is a 32-bit decimal value or a
     * special value among "mac", "perm-mac", "ifname" and "stable". When
     * set to "mac" (or "perm-mac"), the last 4 bytes of the current (or
     * permanent) MAC address are used as IAID. When set to "ifname", the
     * IAID is computed by hashing the interface name. The special value
     * "stable" can be used to generate an IAID based on the stable-id (see
     * connection.stable-id), a per-host key and the interface name. When
     * the property is unset, the value from global configuration is used;
     * if no global default is set then the IAID is assumed to be
     * "ifname". Note that at the moment this property is ignored for IPv6
     * by dhclient, which always derives the IAID from the MAC address.
     */
    dhcp_iaid: string
    /**
     * Array of servers from which DHCP offers must be rejected. This property
     * is useful to avoid getting a lease from misconfigured or rogue servers.
     * 
     * For DHCPv4, each element must be an IPv4 address, optionally
     * followed by a slash and a prefix length (e.g. "192.168.122.0/24").
     * 
     * This property is currently not implemented for DHCPv6.
     */
    dhcp_reject_servers: string[]
    /**
     * If %TRUE, a hostname is sent to the DHCP server when acquiring a lease.
     * Some DHCP servers use this hostname to update DNS databases, essentially
     * providing a static hostname for the computer.  If the
     * #NMSettingIPConfig:dhcp-hostname property is %NULL and this property is
     * %TRUE, the current persistent hostname of the computer is sent.
     */
    dhcp_send_hostname: boolean
    /**
     * A timeout for a DHCP transaction in seconds. If zero (the default), a
     * globally configured default is used. If still unspecified, a device specific
     * timeout is used (usually 45 seconds).
     * 
     * Set to 2147483647 (MAXINT32) for infinity.
     */
    dhcp_timeout: number
    /**
     * Array of IP addresses of DNS servers.
     */
    dns: string[]
    /**
     * Array of DNS options as described in man 5 resolv.conf.
     * 
     * %NULL means that the options are unset and left at the default.
     * In this case NetworkManager will use default options. This is
     * distinct from an empty list of properties.
     * 
     * The currently supported options are "attempts", "debug", "edns0",
     * "inet6", "ip6-bytestring", "ip6-dotint", "ndots", "no-check-names",
     * "no-ip6-dotint", "no-reload", "no-tld-query", "rotate", "single-request",
     * "single-request-reopen", "timeout", "trust-ad", "use-vc".
     * 
     * The "trust-ad" setting is only honored if the profile contributes
     * name servers to resolv.conf, and if all contributing profiles have
     * "trust-ad" enabled.
     * 
     * When using a caching DNS plugin (dnsmasq or systemd-resolved in
     * NetworkManager.conf) then "edns0" and "trust-ad" are automatically
     * added.
     */
    dns_options: string[]
    /**
     * DNS servers priority.
     * 
     * The relative priority for DNS servers specified by this setting.  A lower
     * numerical value is better (higher priority).
     * 
     * Negative values have the special effect of excluding other configurations
     * with a greater numerical priority value; so in presence of at least one negative
     * priority, only DNS servers from connections with the lowest priority value will be used.
     * To avoid all DNS leaks, set the priority of the profile that should be used
     * to the most negative value of all active connections profiles.
     * 
     * Zero selects a globally configured default value. If the latter is missing
     * or zero too, it defaults to 50 for VPNs (including WireGuard) and 100 for
     * other connections.
     * 
     * Note that the priority is to order DNS settings for multiple active
     * connections.  It does not disambiguate multiple DNS servers within the
     * same connection profile.
     * 
     * When multiple devices have configurations with the same priority, VPNs will be
     * considered first, then devices with the best (lowest metric) default
     * route and then all other devices.
     * 
     * When using dns=default, servers with higher priority will be on top of
     * resolv.conf. To prioritize a given server over another one within the
     * same connection, just specify them in the desired order.
     * Note that commonly the resolver tries name servers in /etc/resolv.conf
     * in the order listed, proceeding with the next server in the list
     * on failure. See for example the "rotate" option of the dns-options setting.
     * If there are any negative DNS priorities, then only name servers from
     * the devices with that lowest priority will be considered.
     * 
     * When using a DNS resolver that supports Conditional Forwarding or
     * Split DNS (with dns=dnsmasq or dns=systemd-resolved settings), each connection
     * is used to query domains in its search list. The search domains determine which
     * name servers to ask, and the DNS priority is used to prioritize
     * name servers based on the domain.  Queries for domains not present in any
     * search list are routed through connections having the '~.' special wildcard
     * domain, which is added automatically to connections with the default route
     * (or can be added manually).  When multiple connections specify the same domain, the
     * one with the best priority (lowest numerical value) wins.  If a sub domain
     * is configured on another interface it will be accepted regardless the priority,
     * unless parent domain on the other interface has a negative priority, which causes
     * the sub domain to be shadowed.
     * With Split DNS one can avoid undesired DNS leaks by properly configuring
     * DNS priorities and the search domains, so that only name servers of the desired
     * interface are configured.
     */
    dns_priority: number
    /**
     * Array of DNS search domains. Domains starting with a tilde ('~')
     * are considered 'routing' domains and are used only to decide the
     * interface over which a query must be forwarded; they are not used
     * to complete unqualified host names.
     * 
     * When using a DNS plugin that supports Conditional Forwarding or
     * Split DNS, then the search domains specify which name servers to
     * query. This makes the behavior different from running with plain
     * /etc/resolv.conf. For more information see also the dns-priority setting.
     */
    dns_search: string[]
    /**
     * The gateway associated with this configuration. This is only meaningful
     * if #NMSettingIPConfig:addresses is also set.
     * 
     * The gateway's main purpose is to control the next hop of the standard default route on the device.
     * Hence, the gateway property conflicts with #NMSettingIPConfig:never-default and will be
     * automatically dropped if the IP configuration is set to never-default.
     * 
     * As an alternative to set the gateway, configure a static default route with /0 as prefix
     * length.
     */
    gateway: string
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured name servers and search domains are
     * ignored and only name servers and search domains specified in the
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:dns-search properties, if
     * any, are used.
     */
    ignore_auto_dns: boolean
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured routes are ignored and only routes
     * specified in the #NMSettingIPConfig:routes property, if any, are used.
     */
    ignore_auto_routes: boolean
    /**
     * If %TRUE, allow overall network configuration to proceed even if the
     * configuration specified by this property times out.  Note that at least
     * one IP configuration must succeed or overall network configuration will
     * still fail.  For example, in IPv6-only networks, setting this property to
     * %TRUE on the #NMSettingIP4Config allows the overall network configuration
     * to succeed if IPv4 configuration fails but IPv6 configuration completes
     * successfully.
     */
    may_fail: boolean
    /**
     * IP configuration method.
     * 
     * #NMSettingIP4Config and #NMSettingIP6Config both support "disabled",
     * "auto", "manual", and "link-local". See the subclass-specific
     * documentation for other values.
     * 
     * In general, for the "auto" method, properties such as
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:routes specify information
     * that is added on to the information returned from automatic
     * configuration.  The #NMSettingIPConfig:ignore-auto-routes and
     * #NMSettingIPConfig:ignore-auto-dns properties modify this behavior.
     * 
     * For methods that imply no upstream network, such as "shared" or
     * "link-local", these properties must be empty.
     * 
     * For IPv4 method "shared", the IP subnet can be configured by adding one
     * manual IPv4 address or otherwise 10.42.x.0/24 is chosen. Note that the
     * shared method must be configured on the interface which shares the internet
     * to a subnet, not on the uplink which is shared.
     */
    method: string
    /**
     * If %TRUE, this connection will never be the default connection for this
     * IP type, meaning it will never be assigned the default route by
     * NetworkManager.
     */
    never_default: boolean
    /**
     * The minimum time interval in milliseconds for which dynamic IP configuration
     * should be tried before the connection succeeds.
     * 
     * This property is useful for example if both IPv4 and IPv6 are enabled and
     * are allowed to fail. Normally the connection succeeds as soon as one of
     * the two address families completes; by setting a required timeout for
     * e.g. IPv4, one can ensure that even if IP6 succeeds earlier than IPv4,
     * NetworkManager waits some time for IPv4 before the connection becomes
     * active.
     * 
     * Note that if #NMSettingIPConfig:may-fail is FALSE for the same address
     * family, this property has no effect as NetworkManager needs to wait for
     * the full DHCP timeout.
     * 
     * A zero value means that no required timeout is present, -1 means the
     * default value (either configuration ipvx.required-timeout override or
     * zero).
     */
    required_timeout: number
    /**
     * The default metric for routes that don't explicitly specify a metric.
     * The default value -1 means that the metric is chosen automatically
     * based on the device type.
     * The metric applies to dynamic routes, manual (static) routes that
     * don't have an explicit metric setting, address prefix routes, and
     * the default route.
     * Note that for IPv6, the kernel accepts zero (0) but coerces it to
     * 1024 (user default). Hence, setting this property to zero effectively
     * mean setting it to 1024.
     * For IPv4, zero is a regular value for the metric.
     */
    route_metric: number
    /**
     * Enable policy routing (source routing) and set the routing table used when adding routes.
     * 
     * This affects all routes, including device-routes, IPv4LL, DHCP, SLAAC, default-routes
     * and static routes. But note that static routes can individually overwrite the setting
     * by explicitly specifying a non-zero routing table.
     * 
     * If the table setting is left at zero, it is eligible to be overwritten via global
     * configuration. If the property is zero even after applying the global configuration
     * value, policy routing is disabled for the address family of this connection.
     * 
     * Policy routing disabled means that NetworkManager will add all routes to the main
     * table (except static routes that explicitly configure a different table). Additionally,
     * NetworkManager will not delete any extraneous routes from tables except the main table.
     * This is to preserve backward compatibility for users who manage routing tables outside
     * of NetworkManager.
     */
    route_table: number
    /**
     * Array of IP routes.
     */
    routes: IPRoute[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingIP4Config */
    /**
     * Returns the value contained in the #NMSettingIP4Config:dhcp-client-id
     * property.
     */
    get_dhcp_client_id(): string
    /**
     * Returns the value contained in the #NMSettingIP4Config:dhcp-fqdn
     * property.
     */
    get_dhcp_fqdn(): string
    /**
     * Returns the value contained in the #NMSettingIP4Config:dhcp_vendor_class_identifier
     * property.
     */
    get_dhcp_vendor_class_identifier(): string
    /* Methods of NM-1.0.NM.SettingIPConfig */
    /**
     * Adds a new IP address and associated information to the setting.  The
     * given address is duplicated internally and is not changed by this function.
     */
    add_address(address: IPAddress): boolean
    /**
     * Adds a new DHCP reject server to the setting.
     */
    add_dhcp_reject_server(server: string): void
    /**
     * Adds a new DNS server to the setting.
     */
    add_dns(dns: string): boolean
    /**
     * Adds a new DNS option to the setting.
     */
    add_dns_option(dns_option: string): boolean
    /**
     * Adds a new DNS search domain to the setting.
     */
    add_dns_search(dns_search: string): boolean
    /**
     * Appends a new route and associated information to the setting.  The
     * given route is duplicated internally and is not changed by this function.
     * If an identical route (considering attributes as well) already exists, the
     * route is not added and the function returns %FALSE.
     * 
     * Note that before 1.10, this function would not consider route attributes
     * and not add a route that has an existing route with same dest/prefix,next_hop,metric
     * parameters.
     */
    add_route(route: IPRoute): boolean
    /**
     * Appends a new routing-rule and associated information to the setting. The
     * given routing rules gets sealed and the reference count is incremented.
     * The function does not check whether an identical rule already exists
     * and always appends the rule to the end of the list.
     */
    add_routing_rule(routing_rule: IPRoutingRule): void
    /**
     * Removes all configured addresses.
     */
    clear_addresses(): void
    /**
     * Removes all configured DHCP reject servers.
     */
    clear_dhcp_reject_servers(): void
    /**
     * Removes all configured DNS servers.
     */
    clear_dns(): void
    /**
     * Removes all configured DNS options.
     */
    clear_dns_options(is_set: boolean): void
    /**
     * Removes all configured DNS search domains.
     */
    clear_dns_searches(): void
    /**
     * Removes all configured routes.
     */
    clear_routes(): void
    /**
     * Removes all configured routing rules.
     */
    clear_routing_rules(): void
    get_address(idx: number): IPAddress
    get_dad_timeout(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-hostname
     * property.
     */
    get_dhcp_hostname(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-hostname-flags
     * property.
     */
    get_dhcp_hostname_flags(): DhcpHostnameFlags
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-iaid
     * property.
     */
    get_dhcp_iaid(): string
    get_dhcp_reject_servers(): string[]
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-send-hostname
     * property.
     */
    get_dhcp_send_hostname(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-timeout
     * property.
     */
    get_dhcp_timeout(): number
    get_dns(idx: number): string
    get_dns_option(idx: number): string
    get_dns_priority(): number
    get_dns_search(idx: number): string
    get_gateway(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:ignore-auto-dns
     * property.
     */
    get_ignore_auto_dns(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:ignore-auto-routes
     * property.
     */
    get_ignore_auto_routes(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:may-fail
     * property.
     */
    get_may_fail(): boolean
    get_method(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:never-default
     * property.
     */
    get_never_default(): boolean
    get_num_addresses(): number
    get_num_dns(): number
    get_num_dns_options(): number
    get_num_dns_searches(): number
    get_num_routes(): number
    get_num_routing_rules(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:required-timeout
     * property.
     */
    get_required_timeout(): number
    get_route(idx: number): IPRoute
    /**
     * Returns the value contained in the #NMSettingIPConfig:route-metric
     * property.
     */
    get_route_metric(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:route-table
     * property.
     */
    get_route_table(): number
    get_routing_rule(idx: number): IPRoutingRule
    /**
     * NMSettingIPConfig can have a list of dns-options. If the list
     * is empty, there are two similar (but differentiated) states.
     * Either the options are explicitly set to have no values,
     * or the options are left undefined. The latter means to use
     * a default configuration, while the former explicitly means "no-options".
     */
    has_dns_options(): boolean
    /**
     * Removes the address at index `idx`.
     */
    remove_address(idx: number): void
    /**
     * Removes the address `address`.
     */
    remove_address_by_value(address: IPAddress): boolean
    /**
     * Removes the DHCP reject server at index `idx`.
     */
    remove_dhcp_reject_server(idx: number): void
    /**
     * Removes the DNS server at index `idx`.
     */
    remove_dns(idx: number): void
    /**
     * Removes the DNS server `dns`.
     */
    remove_dns_by_value(dns: string): boolean
    /**
     * Removes the DNS option at index `idx`.
     */
    remove_dns_option(idx: number): void
    /**
     * Removes the DNS option `dns_option`.
     */
    remove_dns_option_by_value(dns_option: string): boolean
    /**
     * Removes the DNS search domain at index `idx`.
     */
    remove_dns_search(idx: number): void
    /**
     * Removes the DNS search domain `dns_search`.
     */
    remove_dns_search_by_value(dns_search: string): boolean
    /**
     * Removes the route at index `idx`.
     */
    remove_route(idx: number): void
    /**
     * Removes the first matching route that matches `route`.
     * Note that before 1.10, this function would only compare dest/prefix,next_hop,metric
     * and ignore route attributes. Now, `route` must match exactly.
     */
    remove_route_by_value(route: IPRoute): boolean
    /**
     * Removes the routing_rule at index `idx`.
     */
    remove_routing_rule(idx: number): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::dhcp-client-id", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-client-id", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-fqdn", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-fqdn", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-vendor-class-identifier", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-vendor-class-identifier", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::addresses", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addresses", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dad-timeout", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dad-timeout", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-hostname", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-hostname", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-hostname-flags", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-hostname-flags", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-iaid", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-iaid", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-reject-servers", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-reject-servers", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-send-hostname", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-send-hostname", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-timeout", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-timeout", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-options", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-options", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-priority", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-priority", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-search", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-search", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::gateway", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::gateway", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ignore-auto-dns", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ignore-auto-dns", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ignore-auto-routes", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ignore-auto-routes", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::may-fail", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::may-fail", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::method", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::method", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::never-default", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::never-default", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::required-timeout", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::required-timeout", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::route-metric", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::route-metric", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::route-table", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::route-table", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::routes", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::routes", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingIP4Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingIP4Config_ConstructProps)
    _init (config?: SettingIP4Config_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingIP4Config
    static $gtype: GObject.Type
}
interface SettingIP6Config_ConstructProps extends SettingIPConfig_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingIP6Config */
    /**
     * Configure method for creating the address for use with RFC4862 IPv6
     * Stateless Address Autoconfiguration. The permitted values are:
     * %NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64 or
     * %NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY.
     * 
     * If the property is set to EUI64, the addresses will be generated
     * using the interface tokens derived from hardware address. This makes
     * the host part of the address to stay constant, making it possible
     * to track host's presence when it changes networks. The address changes
     * when the interface hardware is replaced.
     * 
     * The value of stable-privacy enables use of cryptographically
     * secure hash of a secret host-specific key along with the connection's
     * stable-id and the network address as specified by RFC7217.
     * This makes it impossible to use the address track host's presence,
     * and makes the address stable when the network interface hardware is
     * replaced.
     * 
     * On D-Bus, the absence of an addr-gen-mode setting equals enabling
     * stable-privacy. For keyfile plugin, the absence of the setting
     * on disk means EUI64 so that the property doesn't change on upgrade
     * from older versions.
     * 
     * Note that this setting is distinct from the Privacy Extensions as
     * configured by "ip6-privacy" property and it does not affect the
     * temporary addresses configured with this option.
     */
    addr_gen_mode?: number
    /**
     * A string containing the DHCPv6 Unique Identifier (DUID) used by the dhcp
     * client to identify itself to DHCPv6 servers (RFC 3315). The DUID is carried
     * in the Client Identifier option.
     * If the property is a hex string ('aa:bb:cc') it is interpreted as a binary
     * DUID and filled as an opaque value in the Client Identifier option.
     * 
     * The special value "lease" will retrieve the DUID previously used from the
     * lease file belonging to the connection. If no DUID is found and "dhclient"
     * is the configured dhcp client, the DUID is searched in the system-wide
     * dhclient lease file. If still no DUID is found, or another dhcp client is
     * used, a global and permanent DUID-UUID (RFC 6355) will be generated based
     * on the machine-id.
     * 
     * The special values "llt" and "ll" will generate a DUID of type LLT or LL
     * (see RFC 3315) based on the current MAC address of the device. In order to
     * try providing a stable DUID-LLT, the time field will contain a constant
     * timestamp that is used globally (for all profiles) and persisted to disk.
     * 
     * The special values "stable-llt", "stable-ll" and "stable-uuid" will generate
     * a DUID of the corresponding type, derived from the connection's stable-id and
     * a per-host unique key. You may want to include the "${DEVICE}" or "${MAC}" specifier
     * in the stable-id, in case this profile gets activated on multiple devices.
     * So, the link-layer address of "stable-ll" and "stable-llt" will be a generated
     * address derived from the stable id. The DUID-LLT time value in the "stable-llt"
     * option will be picked among a static timespan of three years (the upper bound
     * of the interval is the same constant timestamp used in "llt").
     * 
     * When the property is unset, the global value provided for "ipv6.dhcp-duid" is
     * used. If no global value is provided, the default "lease" value is assumed.
     */
    dhcp_duid?: string
    /**
     * Configure IPv6 Privacy Extensions for SLAAC, described in RFC4941.  If
     * enabled, it makes the kernel generate a temporary IPv6 address in
     * addition to the public one generated from MAC address via modified
     * EUI-64.  This enhances privacy, but could cause problems in some
     * applications, on the other hand.  The permitted values are: -1: unknown,
     * 0: disabled, 1: enabled (prefer public address), 2: enabled (prefer temporary
     * addresses).
     * 
     * Having a per-connection setting set to "-1" (unknown) means fallback to
     * global configuration "ipv6.ip6-privacy".
     * 
     * If also global configuration is unspecified or set to "-1", fallback to read
     * "/proc/sys/net/ipv6/conf/default/use_tempaddr".
     * 
     * Note that this setting is distinct from the Stable Privacy addresses
     * that can be enabled with the "addr-gen-mode" property's "stable-privacy"
     * setting as another way of avoiding host tracking with IPv6 addresses.
     */
    ip6_privacy?: SettingIP6ConfigPrivacy
    /**
     * A timeout for waiting Router Advertisements in seconds. If zero (the default), a
     * globally configured default is used. If still unspecified, the timeout depends on the
     * sysctl settings of the device.
     * 
     * Set to 2147483647 (MAXINT32) for infinity.
     */
    ra_timeout?: number
    /**
     * Configure the token for draft-chown-6man-tokenised-ipv6-identifiers-02
     * IPv6 tokenized interface identifiers. Useful with eui64 addr-gen-mode.
     */
    token?: string
}
class SettingIP6Config {
    /* Properties of NM-1.0.NM.SettingIP6Config */
    /**
     * Configure method for creating the address for use with RFC4862 IPv6
     * Stateless Address Autoconfiguration. The permitted values are:
     * %NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64 or
     * %NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY.
     * 
     * If the property is set to EUI64, the addresses will be generated
     * using the interface tokens derived from hardware address. This makes
     * the host part of the address to stay constant, making it possible
     * to track host's presence when it changes networks. The address changes
     * when the interface hardware is replaced.
     * 
     * The value of stable-privacy enables use of cryptographically
     * secure hash of a secret host-specific key along with the connection's
     * stable-id and the network address as specified by RFC7217.
     * This makes it impossible to use the address track host's presence,
     * and makes the address stable when the network interface hardware is
     * replaced.
     * 
     * On D-Bus, the absence of an addr-gen-mode setting equals enabling
     * stable-privacy. For keyfile plugin, the absence of the setting
     * on disk means EUI64 so that the property doesn't change on upgrade
     * from older versions.
     * 
     * Note that this setting is distinct from the Privacy Extensions as
     * configured by "ip6-privacy" property and it does not affect the
     * temporary addresses configured with this option.
     */
    addr_gen_mode: number
    /**
     * A string containing the DHCPv6 Unique Identifier (DUID) used by the dhcp
     * client to identify itself to DHCPv6 servers (RFC 3315). The DUID is carried
     * in the Client Identifier option.
     * If the property is a hex string ('aa:bb:cc') it is interpreted as a binary
     * DUID and filled as an opaque value in the Client Identifier option.
     * 
     * The special value "lease" will retrieve the DUID previously used from the
     * lease file belonging to the connection. If no DUID is found and "dhclient"
     * is the configured dhcp client, the DUID is searched in the system-wide
     * dhclient lease file. If still no DUID is found, or another dhcp client is
     * used, a global and permanent DUID-UUID (RFC 6355) will be generated based
     * on the machine-id.
     * 
     * The special values "llt" and "ll" will generate a DUID of type LLT or LL
     * (see RFC 3315) based on the current MAC address of the device. In order to
     * try providing a stable DUID-LLT, the time field will contain a constant
     * timestamp that is used globally (for all profiles) and persisted to disk.
     * 
     * The special values "stable-llt", "stable-ll" and "stable-uuid" will generate
     * a DUID of the corresponding type, derived from the connection's stable-id and
     * a per-host unique key. You may want to include the "${DEVICE}" or "${MAC}" specifier
     * in the stable-id, in case this profile gets activated on multiple devices.
     * So, the link-layer address of "stable-ll" and "stable-llt" will be a generated
     * address derived from the stable id. The DUID-LLT time value in the "stable-llt"
     * option will be picked among a static timespan of three years (the upper bound
     * of the interval is the same constant timestamp used in "llt").
     * 
     * When the property is unset, the global value provided for "ipv6.dhcp-duid" is
     * used. If no global value is provided, the default "lease" value is assumed.
     */
    dhcp_duid: string
    /**
     * Configure IPv6 Privacy Extensions for SLAAC, described in RFC4941.  If
     * enabled, it makes the kernel generate a temporary IPv6 address in
     * addition to the public one generated from MAC address via modified
     * EUI-64.  This enhances privacy, but could cause problems in some
     * applications, on the other hand.  The permitted values are: -1: unknown,
     * 0: disabled, 1: enabled (prefer public address), 2: enabled (prefer temporary
     * addresses).
     * 
     * Having a per-connection setting set to "-1" (unknown) means fallback to
     * global configuration "ipv6.ip6-privacy".
     * 
     * If also global configuration is unspecified or set to "-1", fallback to read
     * "/proc/sys/net/ipv6/conf/default/use_tempaddr".
     * 
     * Note that this setting is distinct from the Stable Privacy addresses
     * that can be enabled with the "addr-gen-mode" property's "stable-privacy"
     * setting as another way of avoiding host tracking with IPv6 addresses.
     */
    ip6_privacy: SettingIP6ConfigPrivacy
    /**
     * A timeout for waiting Router Advertisements in seconds. If zero (the default), a
     * globally configured default is used. If still unspecified, the timeout depends on the
     * sysctl settings of the device.
     * 
     * Set to 2147483647 (MAXINT32) for infinity.
     */
    ra_timeout: number
    /**
     * Configure the token for draft-chown-6man-tokenised-ipv6-identifiers-02
     * IPv6 tokenized interface identifiers. Useful with eui64 addr-gen-mode.
     */
    token: string
    /* Properties of NM-1.0.NM.SettingIPConfig */
    /**
     * Array of IP addresses.
     */
    addresses: IPAddress[]
    /**
     * Timeout in milliseconds used to check for the presence of duplicate IP
     * addresses on the network.  If an address conflict is detected, the
     * activation will fail.  A zero value means that no duplicate address
     * detection is performed, -1 means the default value (either configuration
     * ipvx.dad-timeout override or zero).  A value greater than zero is a
     * timeout in milliseconds.
     * 
     * The property is currently implemented only for IPv4.
     */
    dad_timeout: number
    /**
     * If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
     * specified name will be sent to the DHCP server when acquiring a lease.
     * This property and #NMSettingIP4Config:dhcp-fqdn are mutually exclusive and
     * cannot be set at the same time.
     */
    dhcp_hostname: string
    /**
     * Flags for the DHCP hostname and FQDN.
     * 
     * Currently, this property only includes flags to control the FQDN flags
     * set in the DHCP FQDN option. Supported FQDN flags are
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE.  When no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is set, the DHCP FQDN option will
     * contain no flag. Otherwise, if no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is not set, the standard FQDN flags
     * are set in the request:
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED for IPv4 and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE for IPv6.
     * 
     * When this property is set to the default value %NM_DHCP_HOSTNAME_FLAG_NONE,
     * a global default is looked up in NetworkManager configuration. If that value
     * is unset or also %NM_DHCP_HOSTNAME_FLAG_NONE, then the standard FQDN flags
     * described above are sent in the DHCP requests.
     */
    dhcp_hostname_flags: number
    /**
     * A string containing the "Identity Association Identifier" (IAID) used
     * by the DHCP client. The property is a 32-bit decimal value or a
     * special value among "mac", "perm-mac", "ifname" and "stable". When
     * set to "mac" (or "perm-mac"), the last 4 bytes of the current (or
     * permanent) MAC address are used as IAID. When set to "ifname", the
     * IAID is computed by hashing the interface name. The special value
     * "stable" can be used to generate an IAID based on the stable-id (see
     * connection.stable-id), a per-host key and the interface name. When
     * the property is unset, the value from global configuration is used;
     * if no global default is set then the IAID is assumed to be
     * "ifname". Note that at the moment this property is ignored for IPv6
     * by dhclient, which always derives the IAID from the MAC address.
     */
    dhcp_iaid: string
    /**
     * Array of servers from which DHCP offers must be rejected. This property
     * is useful to avoid getting a lease from misconfigured or rogue servers.
     * 
     * For DHCPv4, each element must be an IPv4 address, optionally
     * followed by a slash and a prefix length (e.g. "192.168.122.0/24").
     * 
     * This property is currently not implemented for DHCPv6.
     */
    dhcp_reject_servers: string[]
    /**
     * If %TRUE, a hostname is sent to the DHCP server when acquiring a lease.
     * Some DHCP servers use this hostname to update DNS databases, essentially
     * providing a static hostname for the computer.  If the
     * #NMSettingIPConfig:dhcp-hostname property is %NULL and this property is
     * %TRUE, the current persistent hostname of the computer is sent.
     */
    dhcp_send_hostname: boolean
    /**
     * A timeout for a DHCP transaction in seconds. If zero (the default), a
     * globally configured default is used. If still unspecified, a device specific
     * timeout is used (usually 45 seconds).
     * 
     * Set to 2147483647 (MAXINT32) for infinity.
     */
    dhcp_timeout: number
    /**
     * Array of IP addresses of DNS servers.
     */
    dns: string[]
    /**
     * Array of DNS options as described in man 5 resolv.conf.
     * 
     * %NULL means that the options are unset and left at the default.
     * In this case NetworkManager will use default options. This is
     * distinct from an empty list of properties.
     * 
     * The currently supported options are "attempts", "debug", "edns0",
     * "inet6", "ip6-bytestring", "ip6-dotint", "ndots", "no-check-names",
     * "no-ip6-dotint", "no-reload", "no-tld-query", "rotate", "single-request",
     * "single-request-reopen", "timeout", "trust-ad", "use-vc".
     * 
     * The "trust-ad" setting is only honored if the profile contributes
     * name servers to resolv.conf, and if all contributing profiles have
     * "trust-ad" enabled.
     * 
     * When using a caching DNS plugin (dnsmasq or systemd-resolved in
     * NetworkManager.conf) then "edns0" and "trust-ad" are automatically
     * added.
     */
    dns_options: string[]
    /**
     * DNS servers priority.
     * 
     * The relative priority for DNS servers specified by this setting.  A lower
     * numerical value is better (higher priority).
     * 
     * Negative values have the special effect of excluding other configurations
     * with a greater numerical priority value; so in presence of at least one negative
     * priority, only DNS servers from connections with the lowest priority value will be used.
     * To avoid all DNS leaks, set the priority of the profile that should be used
     * to the most negative value of all active connections profiles.
     * 
     * Zero selects a globally configured default value. If the latter is missing
     * or zero too, it defaults to 50 for VPNs (including WireGuard) and 100 for
     * other connections.
     * 
     * Note that the priority is to order DNS settings for multiple active
     * connections.  It does not disambiguate multiple DNS servers within the
     * same connection profile.
     * 
     * When multiple devices have configurations with the same priority, VPNs will be
     * considered first, then devices with the best (lowest metric) default
     * route and then all other devices.
     * 
     * When using dns=default, servers with higher priority will be on top of
     * resolv.conf. To prioritize a given server over another one within the
     * same connection, just specify them in the desired order.
     * Note that commonly the resolver tries name servers in /etc/resolv.conf
     * in the order listed, proceeding with the next server in the list
     * on failure. See for example the "rotate" option of the dns-options setting.
     * If there are any negative DNS priorities, then only name servers from
     * the devices with that lowest priority will be considered.
     * 
     * When using a DNS resolver that supports Conditional Forwarding or
     * Split DNS (with dns=dnsmasq or dns=systemd-resolved settings), each connection
     * is used to query domains in its search list. The search domains determine which
     * name servers to ask, and the DNS priority is used to prioritize
     * name servers based on the domain.  Queries for domains not present in any
     * search list are routed through connections having the '~.' special wildcard
     * domain, which is added automatically to connections with the default route
     * (or can be added manually).  When multiple connections specify the same domain, the
     * one with the best priority (lowest numerical value) wins.  If a sub domain
     * is configured on another interface it will be accepted regardless the priority,
     * unless parent domain on the other interface has a negative priority, which causes
     * the sub domain to be shadowed.
     * With Split DNS one can avoid undesired DNS leaks by properly configuring
     * DNS priorities and the search domains, so that only name servers of the desired
     * interface are configured.
     */
    dns_priority: number
    /**
     * Array of DNS search domains. Domains starting with a tilde ('~')
     * are considered 'routing' domains and are used only to decide the
     * interface over which a query must be forwarded; they are not used
     * to complete unqualified host names.
     * 
     * When using a DNS plugin that supports Conditional Forwarding or
     * Split DNS, then the search domains specify which name servers to
     * query. This makes the behavior different from running with plain
     * /etc/resolv.conf. For more information see also the dns-priority setting.
     */
    dns_search: string[]
    /**
     * The gateway associated with this configuration. This is only meaningful
     * if #NMSettingIPConfig:addresses is also set.
     * 
     * The gateway's main purpose is to control the next hop of the standard default route on the device.
     * Hence, the gateway property conflicts with #NMSettingIPConfig:never-default and will be
     * automatically dropped if the IP configuration is set to never-default.
     * 
     * As an alternative to set the gateway, configure a static default route with /0 as prefix
     * length.
     */
    gateway: string
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured name servers and search domains are
     * ignored and only name servers and search domains specified in the
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:dns-search properties, if
     * any, are used.
     */
    ignore_auto_dns: boolean
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured routes are ignored and only routes
     * specified in the #NMSettingIPConfig:routes property, if any, are used.
     */
    ignore_auto_routes: boolean
    /**
     * If %TRUE, allow overall network configuration to proceed even if the
     * configuration specified by this property times out.  Note that at least
     * one IP configuration must succeed or overall network configuration will
     * still fail.  For example, in IPv6-only networks, setting this property to
     * %TRUE on the #NMSettingIP4Config allows the overall network configuration
     * to succeed if IPv4 configuration fails but IPv6 configuration completes
     * successfully.
     */
    may_fail: boolean
    /**
     * IP configuration method.
     * 
     * #NMSettingIP4Config and #NMSettingIP6Config both support "disabled",
     * "auto", "manual", and "link-local". See the subclass-specific
     * documentation for other values.
     * 
     * In general, for the "auto" method, properties such as
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:routes specify information
     * that is added on to the information returned from automatic
     * configuration.  The #NMSettingIPConfig:ignore-auto-routes and
     * #NMSettingIPConfig:ignore-auto-dns properties modify this behavior.
     * 
     * For methods that imply no upstream network, such as "shared" or
     * "link-local", these properties must be empty.
     * 
     * For IPv4 method "shared", the IP subnet can be configured by adding one
     * manual IPv4 address or otherwise 10.42.x.0/24 is chosen. Note that the
     * shared method must be configured on the interface which shares the internet
     * to a subnet, not on the uplink which is shared.
     */
    method: string
    /**
     * If %TRUE, this connection will never be the default connection for this
     * IP type, meaning it will never be assigned the default route by
     * NetworkManager.
     */
    never_default: boolean
    /**
     * The minimum time interval in milliseconds for which dynamic IP configuration
     * should be tried before the connection succeeds.
     * 
     * This property is useful for example if both IPv4 and IPv6 are enabled and
     * are allowed to fail. Normally the connection succeeds as soon as one of
     * the two address families completes; by setting a required timeout for
     * e.g. IPv4, one can ensure that even if IP6 succeeds earlier than IPv4,
     * NetworkManager waits some time for IPv4 before the connection becomes
     * active.
     * 
     * Note that if #NMSettingIPConfig:may-fail is FALSE for the same address
     * family, this property has no effect as NetworkManager needs to wait for
     * the full DHCP timeout.
     * 
     * A zero value means that no required timeout is present, -1 means the
     * default value (either configuration ipvx.required-timeout override or
     * zero).
     */
    required_timeout: number
    /**
     * The default metric for routes that don't explicitly specify a metric.
     * The default value -1 means that the metric is chosen automatically
     * based on the device type.
     * The metric applies to dynamic routes, manual (static) routes that
     * don't have an explicit metric setting, address prefix routes, and
     * the default route.
     * Note that for IPv6, the kernel accepts zero (0) but coerces it to
     * 1024 (user default). Hence, setting this property to zero effectively
     * mean setting it to 1024.
     * For IPv4, zero is a regular value for the metric.
     */
    route_metric: number
    /**
     * Enable policy routing (source routing) and set the routing table used when adding routes.
     * 
     * This affects all routes, including device-routes, IPv4LL, DHCP, SLAAC, default-routes
     * and static routes. But note that static routes can individually overwrite the setting
     * by explicitly specifying a non-zero routing table.
     * 
     * If the table setting is left at zero, it is eligible to be overwritten via global
     * configuration. If the property is zero even after applying the global configuration
     * value, policy routing is disabled for the address family of this connection.
     * 
     * Policy routing disabled means that NetworkManager will add all routes to the main
     * table (except static routes that explicitly configure a different table). Additionally,
     * NetworkManager will not delete any extraneous routes from tables except the main table.
     * This is to preserve backward compatibility for users who manage routing tables outside
     * of NetworkManager.
     */
    route_table: number
    /**
     * Array of IP routes.
     */
    routes: IPRoute[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingIP6Config */
    /**
     * Returns the value contained in the #NMSettingIP6Config:addr-gen-mode
     * property.
     */
    get_addr_gen_mode(): SettingIP6ConfigAddrGenMode
    /**
     * Returns the value contained in the #NMSettingIP6Config:dhcp-duid
     * property.
     */
    get_dhcp_duid(): string
    /**
     * Returns the value contained in the #NMSettingIP6Config:ip6-privacy
     * property.
     */
    get_ip6_privacy(): SettingIP6ConfigPrivacy
    get_ra_timeout(): number
    /**
     * Returns the value contained in the #NMSettingIP6Config:token
     * property.
     */
    get_token(): string
    /* Methods of NM-1.0.NM.SettingIPConfig */
    /**
     * Adds a new IP address and associated information to the setting.  The
     * given address is duplicated internally and is not changed by this function.
     */
    add_address(address: IPAddress): boolean
    /**
     * Adds a new DHCP reject server to the setting.
     */
    add_dhcp_reject_server(server: string): void
    /**
     * Adds a new DNS server to the setting.
     */
    add_dns(dns: string): boolean
    /**
     * Adds a new DNS option to the setting.
     */
    add_dns_option(dns_option: string): boolean
    /**
     * Adds a new DNS search domain to the setting.
     */
    add_dns_search(dns_search: string): boolean
    /**
     * Appends a new route and associated information to the setting.  The
     * given route is duplicated internally and is not changed by this function.
     * If an identical route (considering attributes as well) already exists, the
     * route is not added and the function returns %FALSE.
     * 
     * Note that before 1.10, this function would not consider route attributes
     * and not add a route that has an existing route with same dest/prefix,next_hop,metric
     * parameters.
     */
    add_route(route: IPRoute): boolean
    /**
     * Appends a new routing-rule and associated information to the setting. The
     * given routing rules gets sealed and the reference count is incremented.
     * The function does not check whether an identical rule already exists
     * and always appends the rule to the end of the list.
     */
    add_routing_rule(routing_rule: IPRoutingRule): void
    /**
     * Removes all configured addresses.
     */
    clear_addresses(): void
    /**
     * Removes all configured DHCP reject servers.
     */
    clear_dhcp_reject_servers(): void
    /**
     * Removes all configured DNS servers.
     */
    clear_dns(): void
    /**
     * Removes all configured DNS options.
     */
    clear_dns_options(is_set: boolean): void
    /**
     * Removes all configured DNS search domains.
     */
    clear_dns_searches(): void
    /**
     * Removes all configured routes.
     */
    clear_routes(): void
    /**
     * Removes all configured routing rules.
     */
    clear_routing_rules(): void
    get_address(idx: number): IPAddress
    get_dad_timeout(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-hostname
     * property.
     */
    get_dhcp_hostname(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-hostname-flags
     * property.
     */
    get_dhcp_hostname_flags(): DhcpHostnameFlags
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-iaid
     * property.
     */
    get_dhcp_iaid(): string
    get_dhcp_reject_servers(): string[]
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-send-hostname
     * property.
     */
    get_dhcp_send_hostname(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-timeout
     * property.
     */
    get_dhcp_timeout(): number
    get_dns(idx: number): string
    get_dns_option(idx: number): string
    get_dns_priority(): number
    get_dns_search(idx: number): string
    get_gateway(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:ignore-auto-dns
     * property.
     */
    get_ignore_auto_dns(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:ignore-auto-routes
     * property.
     */
    get_ignore_auto_routes(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:may-fail
     * property.
     */
    get_may_fail(): boolean
    get_method(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:never-default
     * property.
     */
    get_never_default(): boolean
    get_num_addresses(): number
    get_num_dns(): number
    get_num_dns_options(): number
    get_num_dns_searches(): number
    get_num_routes(): number
    get_num_routing_rules(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:required-timeout
     * property.
     */
    get_required_timeout(): number
    get_route(idx: number): IPRoute
    /**
     * Returns the value contained in the #NMSettingIPConfig:route-metric
     * property.
     */
    get_route_metric(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:route-table
     * property.
     */
    get_route_table(): number
    get_routing_rule(idx: number): IPRoutingRule
    /**
     * NMSettingIPConfig can have a list of dns-options. If the list
     * is empty, there are two similar (but differentiated) states.
     * Either the options are explicitly set to have no values,
     * or the options are left undefined. The latter means to use
     * a default configuration, while the former explicitly means "no-options".
     */
    has_dns_options(): boolean
    /**
     * Removes the address at index `idx`.
     */
    remove_address(idx: number): void
    /**
     * Removes the address `address`.
     */
    remove_address_by_value(address: IPAddress): boolean
    /**
     * Removes the DHCP reject server at index `idx`.
     */
    remove_dhcp_reject_server(idx: number): void
    /**
     * Removes the DNS server at index `idx`.
     */
    remove_dns(idx: number): void
    /**
     * Removes the DNS server `dns`.
     */
    remove_dns_by_value(dns: string): boolean
    /**
     * Removes the DNS option at index `idx`.
     */
    remove_dns_option(idx: number): void
    /**
     * Removes the DNS option `dns_option`.
     */
    remove_dns_option_by_value(dns_option: string): boolean
    /**
     * Removes the DNS search domain at index `idx`.
     */
    remove_dns_search(idx: number): void
    /**
     * Removes the DNS search domain `dns_search`.
     */
    remove_dns_search_by_value(dns_search: string): boolean
    /**
     * Removes the route at index `idx`.
     */
    remove_route(idx: number): void
    /**
     * Removes the first matching route that matches `route`.
     * Note that before 1.10, this function would only compare dest/prefix,next_hop,metric
     * and ignore route attributes. Now, `route` must match exactly.
     */
    remove_route_by_value(route: IPRoute): boolean
    /**
     * Removes the routing_rule at index `idx`.
     */
    remove_routing_rule(idx: number): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::addr-gen-mode", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addr-gen-mode", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-duid", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-duid", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-privacy", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-privacy", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ra-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ra-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::token", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::token", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::addresses", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addresses", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dad-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dad-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-hostname", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-hostname", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-hostname-flags", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-hostname-flags", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-iaid", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-iaid", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-reject-servers", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-reject-servers", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-send-hostname", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-send-hostname", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-options", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-options", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-priority", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-priority", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-search", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-search", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::gateway", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::gateway", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ignore-auto-dns", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ignore-auto-dns", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ignore-auto-routes", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ignore-auto-routes", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::may-fail", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::may-fail", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::method", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::method", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::never-default", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::never-default", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::required-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::required-timeout", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::route-metric", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::route-metric", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::route-table", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::route-table", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::routes", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::routes", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingIP6Config, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingIP6Config_ConstructProps)
    _init (config?: SettingIP6Config_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingIP6Config
    static $gtype: GObject.Type
}
interface SettingIPConfig_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingIPConfig */
    /**
     * Array of IP addresses.
     */
    addresses?: IPAddress[]
    /**
     * Timeout in milliseconds used to check for the presence of duplicate IP
     * addresses on the network.  If an address conflict is detected, the
     * activation will fail.  A zero value means that no duplicate address
     * detection is performed, -1 means the default value (either configuration
     * ipvx.dad-timeout override or zero).  A value greater than zero is a
     * timeout in milliseconds.
     * 
     * The property is currently implemented only for IPv4.
     */
    dad_timeout?: number
    /**
     * If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
     * specified name will be sent to the DHCP server when acquiring a lease.
     * This property and #NMSettingIP4Config:dhcp-fqdn are mutually exclusive and
     * cannot be set at the same time.
     */
    dhcp_hostname?: string
    /**
     * Flags for the DHCP hostname and FQDN.
     * 
     * Currently, this property only includes flags to control the FQDN flags
     * set in the DHCP FQDN option. Supported FQDN flags are
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE.  When no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is set, the DHCP FQDN option will
     * contain no flag. Otherwise, if no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is not set, the standard FQDN flags
     * are set in the request:
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED for IPv4 and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE for IPv6.
     * 
     * When this property is set to the default value %NM_DHCP_HOSTNAME_FLAG_NONE,
     * a global default is looked up in NetworkManager configuration. If that value
     * is unset or also %NM_DHCP_HOSTNAME_FLAG_NONE, then the standard FQDN flags
     * described above are sent in the DHCP requests.
     */
    dhcp_hostname_flags?: number
    /**
     * A string containing the "Identity Association Identifier" (IAID) used
     * by the DHCP client. The property is a 32-bit decimal value or a
     * special value among "mac", "perm-mac", "ifname" and "stable". When
     * set to "mac" (or "perm-mac"), the last 4 bytes of the current (or
     * permanent) MAC address are used as IAID. When set to "ifname", the
     * IAID is computed by hashing the interface name. The special value
     * "stable" can be used to generate an IAID based on the stable-id (see
     * connection.stable-id), a per-host key and the interface name. When
     * the property is unset, the value from global configuration is used;
     * if no global default is set then the IAID is assumed to be
     * "ifname". Note that at the moment this property is ignored for IPv6
     * by dhclient, which always derives the IAID from the MAC address.
     */
    dhcp_iaid?: string
    /**
     * Array of servers from which DHCP offers must be rejected. This property
     * is useful to avoid getting a lease from misconfigured or rogue servers.
     * 
     * For DHCPv4, each element must be an IPv4 address, optionally
     * followed by a slash and a prefix length (e.g. "192.168.122.0/24").
     * 
     * This property is currently not implemented for DHCPv6.
     */
    dhcp_reject_servers?: string[]
    /**
     * If %TRUE, a hostname is sent to the DHCP server when acquiring a lease.
     * Some DHCP servers use this hostname to update DNS databases, essentially
     * providing a static hostname for the computer.  If the
     * #NMSettingIPConfig:dhcp-hostname property is %NULL and this property is
     * %TRUE, the current persistent hostname of the computer is sent.
     */
    dhcp_send_hostname?: boolean
    /**
     * A timeout for a DHCP transaction in seconds. If zero (the default), a
     * globally configured default is used. If still unspecified, a device specific
     * timeout is used (usually 45 seconds).
     * 
     * Set to 2147483647 (MAXINT32) for infinity.
     */
    dhcp_timeout?: number
    /**
     * Array of IP addresses of DNS servers.
     */
    dns?: string[]
    /**
     * Array of DNS options as described in man 5 resolv.conf.
     * 
     * %NULL means that the options are unset and left at the default.
     * In this case NetworkManager will use default options. This is
     * distinct from an empty list of properties.
     * 
     * The currently supported options are "attempts", "debug", "edns0",
     * "inet6", "ip6-bytestring", "ip6-dotint", "ndots", "no-check-names",
     * "no-ip6-dotint", "no-reload", "no-tld-query", "rotate", "single-request",
     * "single-request-reopen", "timeout", "trust-ad", "use-vc".
     * 
     * The "trust-ad" setting is only honored if the profile contributes
     * name servers to resolv.conf, and if all contributing profiles have
     * "trust-ad" enabled.
     * 
     * When using a caching DNS plugin (dnsmasq or systemd-resolved in
     * NetworkManager.conf) then "edns0" and "trust-ad" are automatically
     * added.
     */
    dns_options?: string[]
    /**
     * DNS servers priority.
     * 
     * The relative priority for DNS servers specified by this setting.  A lower
     * numerical value is better (higher priority).
     * 
     * Negative values have the special effect of excluding other configurations
     * with a greater numerical priority value; so in presence of at least one negative
     * priority, only DNS servers from connections with the lowest priority value will be used.
     * To avoid all DNS leaks, set the priority of the profile that should be used
     * to the most negative value of all active connections profiles.
     * 
     * Zero selects a globally configured default value. If the latter is missing
     * or zero too, it defaults to 50 for VPNs (including WireGuard) and 100 for
     * other connections.
     * 
     * Note that the priority is to order DNS settings for multiple active
     * connections.  It does not disambiguate multiple DNS servers within the
     * same connection profile.
     * 
     * When multiple devices have configurations with the same priority, VPNs will be
     * considered first, then devices with the best (lowest metric) default
     * route and then all other devices.
     * 
     * When using dns=default, servers with higher priority will be on top of
     * resolv.conf. To prioritize a given server over another one within the
     * same connection, just specify them in the desired order.
     * Note that commonly the resolver tries name servers in /etc/resolv.conf
     * in the order listed, proceeding with the next server in the list
     * on failure. See for example the "rotate" option of the dns-options setting.
     * If there are any negative DNS priorities, then only name servers from
     * the devices with that lowest priority will be considered.
     * 
     * When using a DNS resolver that supports Conditional Forwarding or
     * Split DNS (with dns=dnsmasq or dns=systemd-resolved settings), each connection
     * is used to query domains in its search list. The search domains determine which
     * name servers to ask, and the DNS priority is used to prioritize
     * name servers based on the domain.  Queries for domains not present in any
     * search list are routed through connections having the '~.' special wildcard
     * domain, which is added automatically to connections with the default route
     * (or can be added manually).  When multiple connections specify the same domain, the
     * one with the best priority (lowest numerical value) wins.  If a sub domain
     * is configured on another interface it will be accepted regardless the priority,
     * unless parent domain on the other interface has a negative priority, which causes
     * the sub domain to be shadowed.
     * With Split DNS one can avoid undesired DNS leaks by properly configuring
     * DNS priorities and the search domains, so that only name servers of the desired
     * interface are configured.
     */
    dns_priority?: number
    /**
     * Array of DNS search domains. Domains starting with a tilde ('~')
     * are considered 'routing' domains and are used only to decide the
     * interface over which a query must be forwarded; they are not used
     * to complete unqualified host names.
     * 
     * When using a DNS plugin that supports Conditional Forwarding or
     * Split DNS, then the search domains specify which name servers to
     * query. This makes the behavior different from running with plain
     * /etc/resolv.conf. For more information see also the dns-priority setting.
     */
    dns_search?: string[]
    /**
     * The gateway associated with this configuration. This is only meaningful
     * if #NMSettingIPConfig:addresses is also set.
     * 
     * The gateway's main purpose is to control the next hop of the standard default route on the device.
     * Hence, the gateway property conflicts with #NMSettingIPConfig:never-default and will be
     * automatically dropped if the IP configuration is set to never-default.
     * 
     * As an alternative to set the gateway, configure a static default route with /0 as prefix
     * length.
     */
    gateway?: string
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured name servers and search domains are
     * ignored and only name servers and search domains specified in the
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:dns-search properties, if
     * any, are used.
     */
    ignore_auto_dns?: boolean
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured routes are ignored and only routes
     * specified in the #NMSettingIPConfig:routes property, if any, are used.
     */
    ignore_auto_routes?: boolean
    /**
     * If %TRUE, allow overall network configuration to proceed even if the
     * configuration specified by this property times out.  Note that at least
     * one IP configuration must succeed or overall network configuration will
     * still fail.  For example, in IPv6-only networks, setting this property to
     * %TRUE on the #NMSettingIP4Config allows the overall network configuration
     * to succeed if IPv4 configuration fails but IPv6 configuration completes
     * successfully.
     */
    may_fail?: boolean
    /**
     * IP configuration method.
     * 
     * #NMSettingIP4Config and #NMSettingIP6Config both support "disabled",
     * "auto", "manual", and "link-local". See the subclass-specific
     * documentation for other values.
     * 
     * In general, for the "auto" method, properties such as
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:routes specify information
     * that is added on to the information returned from automatic
     * configuration.  The #NMSettingIPConfig:ignore-auto-routes and
     * #NMSettingIPConfig:ignore-auto-dns properties modify this behavior.
     * 
     * For methods that imply no upstream network, such as "shared" or
     * "link-local", these properties must be empty.
     * 
     * For IPv4 method "shared", the IP subnet can be configured by adding one
     * manual IPv4 address or otherwise 10.42.x.0/24 is chosen. Note that the
     * shared method must be configured on the interface which shares the internet
     * to a subnet, not on the uplink which is shared.
     */
    method?: string
    /**
     * If %TRUE, this connection will never be the default connection for this
     * IP type, meaning it will never be assigned the default route by
     * NetworkManager.
     */
    never_default?: boolean
    /**
     * The minimum time interval in milliseconds for which dynamic IP configuration
     * should be tried before the connection succeeds.
     * 
     * This property is useful for example if both IPv4 and IPv6 are enabled and
     * are allowed to fail. Normally the connection succeeds as soon as one of
     * the two address families completes; by setting a required timeout for
     * e.g. IPv4, one can ensure that even if IP6 succeeds earlier than IPv4,
     * NetworkManager waits some time for IPv4 before the connection becomes
     * active.
     * 
     * Note that if #NMSettingIPConfig:may-fail is FALSE for the same address
     * family, this property has no effect as NetworkManager needs to wait for
     * the full DHCP timeout.
     * 
     * A zero value means that no required timeout is present, -1 means the
     * default value (either configuration ipvx.required-timeout override or
     * zero).
     */
    required_timeout?: number
    /**
     * The default metric for routes that don't explicitly specify a metric.
     * The default value -1 means that the metric is chosen automatically
     * based on the device type.
     * The metric applies to dynamic routes, manual (static) routes that
     * don't have an explicit metric setting, address prefix routes, and
     * the default route.
     * Note that for IPv6, the kernel accepts zero (0) but coerces it to
     * 1024 (user default). Hence, setting this property to zero effectively
     * mean setting it to 1024.
     * For IPv4, zero is a regular value for the metric.
     */
    route_metric?: number
    /**
     * Enable policy routing (source routing) and set the routing table used when adding routes.
     * 
     * This affects all routes, including device-routes, IPv4LL, DHCP, SLAAC, default-routes
     * and static routes. But note that static routes can individually overwrite the setting
     * by explicitly specifying a non-zero routing table.
     * 
     * If the table setting is left at zero, it is eligible to be overwritten via global
     * configuration. If the property is zero even after applying the global configuration
     * value, policy routing is disabled for the address family of this connection.
     * 
     * Policy routing disabled means that NetworkManager will add all routes to the main
     * table (except static routes that explicitly configure a different table). Additionally,
     * NetworkManager will not delete any extraneous routes from tables except the main table.
     * This is to preserve backward compatibility for users who manage routing tables outside
     * of NetworkManager.
     */
    route_table?: number
    /**
     * Array of IP routes.
     */
    routes?: IPRoute[]
}
class SettingIPConfig {
    /* Properties of NM-1.0.NM.SettingIPConfig */
    /**
     * Array of IP addresses.
     */
    addresses: IPAddress[]
    /**
     * Timeout in milliseconds used to check for the presence of duplicate IP
     * addresses on the network.  If an address conflict is detected, the
     * activation will fail.  A zero value means that no duplicate address
     * detection is performed, -1 means the default value (either configuration
     * ipvx.dad-timeout override or zero).  A value greater than zero is a
     * timeout in milliseconds.
     * 
     * The property is currently implemented only for IPv4.
     */
    dad_timeout: number
    /**
     * If the #NMSettingIPConfig:dhcp-send-hostname property is %TRUE, then the
     * specified name will be sent to the DHCP server when acquiring a lease.
     * This property and #NMSettingIP4Config:dhcp-fqdn are mutually exclusive and
     * cannot be set at the same time.
     */
    dhcp_hostname: string
    /**
     * Flags for the DHCP hostname and FQDN.
     * 
     * Currently, this property only includes flags to control the FQDN flags
     * set in the DHCP FQDN option. Supported FQDN flags are
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_NO_UPDATE.  When no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is set, the DHCP FQDN option will
     * contain no flag. Otherwise, if no FQDN flag is set and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_CLEAR_FLAGS is not set, the standard FQDN flags
     * are set in the request:
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE,
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_ENCODED for IPv4 and
     * %NM_DHCP_HOSTNAME_FLAG_FQDN_SERV_UPDATE for IPv6.
     * 
     * When this property is set to the default value %NM_DHCP_HOSTNAME_FLAG_NONE,
     * a global default is looked up in NetworkManager configuration. If that value
     * is unset or also %NM_DHCP_HOSTNAME_FLAG_NONE, then the standard FQDN flags
     * described above are sent in the DHCP requests.
     */
    dhcp_hostname_flags: number
    /**
     * A string containing the "Identity Association Identifier" (IAID) used
     * by the DHCP client. The property is a 32-bit decimal value or a
     * special value among "mac", "perm-mac", "ifname" and "stable". When
     * set to "mac" (or "perm-mac"), the last 4 bytes of the current (or
     * permanent) MAC address are used as IAID. When set to "ifname", the
     * IAID is computed by hashing the interface name. The special value
     * "stable" can be used to generate an IAID based on the stable-id (see
     * connection.stable-id), a per-host key and the interface name. When
     * the property is unset, the value from global configuration is used;
     * if no global default is set then the IAID is assumed to be
     * "ifname". Note that at the moment this property is ignored for IPv6
     * by dhclient, which always derives the IAID from the MAC address.
     */
    dhcp_iaid: string
    /**
     * Array of servers from which DHCP offers must be rejected. This property
     * is useful to avoid getting a lease from misconfigured or rogue servers.
     * 
     * For DHCPv4, each element must be an IPv4 address, optionally
     * followed by a slash and a prefix length (e.g. "192.168.122.0/24").
     * 
     * This property is currently not implemented for DHCPv6.
     */
    dhcp_reject_servers: string[]
    /**
     * If %TRUE, a hostname is sent to the DHCP server when acquiring a lease.
     * Some DHCP servers use this hostname to update DNS databases, essentially
     * providing a static hostname for the computer.  If the
     * #NMSettingIPConfig:dhcp-hostname property is %NULL and this property is
     * %TRUE, the current persistent hostname of the computer is sent.
     */
    dhcp_send_hostname: boolean
    /**
     * A timeout for a DHCP transaction in seconds. If zero (the default), a
     * globally configured default is used. If still unspecified, a device specific
     * timeout is used (usually 45 seconds).
     * 
     * Set to 2147483647 (MAXINT32) for infinity.
     */
    dhcp_timeout: number
    /**
     * Array of IP addresses of DNS servers.
     */
    dns: string[]
    /**
     * Array of DNS options as described in man 5 resolv.conf.
     * 
     * %NULL means that the options are unset and left at the default.
     * In this case NetworkManager will use default options. This is
     * distinct from an empty list of properties.
     * 
     * The currently supported options are "attempts", "debug", "edns0",
     * "inet6", "ip6-bytestring", "ip6-dotint", "ndots", "no-check-names",
     * "no-ip6-dotint", "no-reload", "no-tld-query", "rotate", "single-request",
     * "single-request-reopen", "timeout", "trust-ad", "use-vc".
     * 
     * The "trust-ad" setting is only honored if the profile contributes
     * name servers to resolv.conf, and if all contributing profiles have
     * "trust-ad" enabled.
     * 
     * When using a caching DNS plugin (dnsmasq or systemd-resolved in
     * NetworkManager.conf) then "edns0" and "trust-ad" are automatically
     * added.
     */
    dns_options: string[]
    /**
     * DNS servers priority.
     * 
     * The relative priority for DNS servers specified by this setting.  A lower
     * numerical value is better (higher priority).
     * 
     * Negative values have the special effect of excluding other configurations
     * with a greater numerical priority value; so in presence of at least one negative
     * priority, only DNS servers from connections with the lowest priority value will be used.
     * To avoid all DNS leaks, set the priority of the profile that should be used
     * to the most negative value of all active connections profiles.
     * 
     * Zero selects a globally configured default value. If the latter is missing
     * or zero too, it defaults to 50 for VPNs (including WireGuard) and 100 for
     * other connections.
     * 
     * Note that the priority is to order DNS settings for multiple active
     * connections.  It does not disambiguate multiple DNS servers within the
     * same connection profile.
     * 
     * When multiple devices have configurations with the same priority, VPNs will be
     * considered first, then devices with the best (lowest metric) default
     * route and then all other devices.
     * 
     * When using dns=default, servers with higher priority will be on top of
     * resolv.conf. To prioritize a given server over another one within the
     * same connection, just specify them in the desired order.
     * Note that commonly the resolver tries name servers in /etc/resolv.conf
     * in the order listed, proceeding with the next server in the list
     * on failure. See for example the "rotate" option of the dns-options setting.
     * If there are any negative DNS priorities, then only name servers from
     * the devices with that lowest priority will be considered.
     * 
     * When using a DNS resolver that supports Conditional Forwarding or
     * Split DNS (with dns=dnsmasq or dns=systemd-resolved settings), each connection
     * is used to query domains in its search list. The search domains determine which
     * name servers to ask, and the DNS priority is used to prioritize
     * name servers based on the domain.  Queries for domains not present in any
     * search list are routed through connections having the '~.' special wildcard
     * domain, which is added automatically to connections with the default route
     * (or can be added manually).  When multiple connections specify the same domain, the
     * one with the best priority (lowest numerical value) wins.  If a sub domain
     * is configured on another interface it will be accepted regardless the priority,
     * unless parent domain on the other interface has a negative priority, which causes
     * the sub domain to be shadowed.
     * With Split DNS one can avoid undesired DNS leaks by properly configuring
     * DNS priorities and the search domains, so that only name servers of the desired
     * interface are configured.
     */
    dns_priority: number
    /**
     * Array of DNS search domains. Domains starting with a tilde ('~')
     * are considered 'routing' domains and are used only to decide the
     * interface over which a query must be forwarded; they are not used
     * to complete unqualified host names.
     * 
     * When using a DNS plugin that supports Conditional Forwarding or
     * Split DNS, then the search domains specify which name servers to
     * query. This makes the behavior different from running with plain
     * /etc/resolv.conf. For more information see also the dns-priority setting.
     */
    dns_search: string[]
    /**
     * The gateway associated with this configuration. This is only meaningful
     * if #NMSettingIPConfig:addresses is also set.
     * 
     * The gateway's main purpose is to control the next hop of the standard default route on the device.
     * Hence, the gateway property conflicts with #NMSettingIPConfig:never-default and will be
     * automatically dropped if the IP configuration is set to never-default.
     * 
     * As an alternative to set the gateway, configure a static default route with /0 as prefix
     * length.
     */
    gateway: string
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured name servers and search domains are
     * ignored and only name servers and search domains specified in the
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:dns-search properties, if
     * any, are used.
     */
    ignore_auto_dns: boolean
    /**
     * When #NMSettingIPConfig:method is set to "auto" and this property to
     * %TRUE, automatically configured routes are ignored and only routes
     * specified in the #NMSettingIPConfig:routes property, if any, are used.
     */
    ignore_auto_routes: boolean
    /**
     * If %TRUE, allow overall network configuration to proceed even if the
     * configuration specified by this property times out.  Note that at least
     * one IP configuration must succeed or overall network configuration will
     * still fail.  For example, in IPv6-only networks, setting this property to
     * %TRUE on the #NMSettingIP4Config allows the overall network configuration
     * to succeed if IPv4 configuration fails but IPv6 configuration completes
     * successfully.
     */
    may_fail: boolean
    /**
     * IP configuration method.
     * 
     * #NMSettingIP4Config and #NMSettingIP6Config both support "disabled",
     * "auto", "manual", and "link-local". See the subclass-specific
     * documentation for other values.
     * 
     * In general, for the "auto" method, properties such as
     * #NMSettingIPConfig:dns and #NMSettingIPConfig:routes specify information
     * that is added on to the information returned from automatic
     * configuration.  The #NMSettingIPConfig:ignore-auto-routes and
     * #NMSettingIPConfig:ignore-auto-dns properties modify this behavior.
     * 
     * For methods that imply no upstream network, such as "shared" or
     * "link-local", these properties must be empty.
     * 
     * For IPv4 method "shared", the IP subnet can be configured by adding one
     * manual IPv4 address or otherwise 10.42.x.0/24 is chosen. Note that the
     * shared method must be configured on the interface which shares the internet
     * to a subnet, not on the uplink which is shared.
     */
    method: string
    /**
     * If %TRUE, this connection will never be the default connection for this
     * IP type, meaning it will never be assigned the default route by
     * NetworkManager.
     */
    never_default: boolean
    /**
     * The minimum time interval in milliseconds for which dynamic IP configuration
     * should be tried before the connection succeeds.
     * 
     * This property is useful for example if both IPv4 and IPv6 are enabled and
     * are allowed to fail. Normally the connection succeeds as soon as one of
     * the two address families completes; by setting a required timeout for
     * e.g. IPv4, one can ensure that even if IP6 succeeds earlier than IPv4,
     * NetworkManager waits some time for IPv4 before the connection becomes
     * active.
     * 
     * Note that if #NMSettingIPConfig:may-fail is FALSE for the same address
     * family, this property has no effect as NetworkManager needs to wait for
     * the full DHCP timeout.
     * 
     * A zero value means that no required timeout is present, -1 means the
     * default value (either configuration ipvx.required-timeout override or
     * zero).
     */
    required_timeout: number
    /**
     * The default metric for routes that don't explicitly specify a metric.
     * The default value -1 means that the metric is chosen automatically
     * based on the device type.
     * The metric applies to dynamic routes, manual (static) routes that
     * don't have an explicit metric setting, address prefix routes, and
     * the default route.
     * Note that for IPv6, the kernel accepts zero (0) but coerces it to
     * 1024 (user default). Hence, setting this property to zero effectively
     * mean setting it to 1024.
     * For IPv4, zero is a regular value for the metric.
     */
    route_metric: number
    /**
     * Enable policy routing (source routing) and set the routing table used when adding routes.
     * 
     * This affects all routes, including device-routes, IPv4LL, DHCP, SLAAC, default-routes
     * and static routes. But note that static routes can individually overwrite the setting
     * by explicitly specifying a non-zero routing table.
     * 
     * If the table setting is left at zero, it is eligible to be overwritten via global
     * configuration. If the property is zero even after applying the global configuration
     * value, policy routing is disabled for the address family of this connection.
     * 
     * Policy routing disabled means that NetworkManager will add all routes to the main
     * table (except static routes that explicitly configure a different table). Additionally,
     * NetworkManager will not delete any extraneous routes from tables except the main table.
     * This is to preserve backward compatibility for users who manage routing tables outside
     * of NetworkManager.
     */
    route_table: number
    /**
     * Array of IP routes.
     */
    routes: IPRoute[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingIPConfig */
    /**
     * Adds a new IP address and associated information to the setting.  The
     * given address is duplicated internally and is not changed by this function.
     */
    add_address(address: IPAddress): boolean
    /**
     * Adds a new DHCP reject server to the setting.
     */
    add_dhcp_reject_server(server: string): void
    /**
     * Adds a new DNS server to the setting.
     */
    add_dns(dns: string): boolean
    /**
     * Adds a new DNS option to the setting.
     */
    add_dns_option(dns_option: string): boolean
    /**
     * Adds a new DNS search domain to the setting.
     */
    add_dns_search(dns_search: string): boolean
    /**
     * Appends a new route and associated information to the setting.  The
     * given route is duplicated internally and is not changed by this function.
     * If an identical route (considering attributes as well) already exists, the
     * route is not added and the function returns %FALSE.
     * 
     * Note that before 1.10, this function would not consider route attributes
     * and not add a route that has an existing route with same dest/prefix,next_hop,metric
     * parameters.
     */
    add_route(route: IPRoute): boolean
    /**
     * Appends a new routing-rule and associated information to the setting. The
     * given routing rules gets sealed and the reference count is incremented.
     * The function does not check whether an identical rule already exists
     * and always appends the rule to the end of the list.
     */
    add_routing_rule(routing_rule: IPRoutingRule): void
    /**
     * Removes all configured addresses.
     */
    clear_addresses(): void
    /**
     * Removes all configured DHCP reject servers.
     */
    clear_dhcp_reject_servers(): void
    /**
     * Removes all configured DNS servers.
     */
    clear_dns(): void
    /**
     * Removes all configured DNS options.
     */
    clear_dns_options(is_set: boolean): void
    /**
     * Removes all configured DNS search domains.
     */
    clear_dns_searches(): void
    /**
     * Removes all configured routes.
     */
    clear_routes(): void
    /**
     * Removes all configured routing rules.
     */
    clear_routing_rules(): void
    get_address(idx: number): IPAddress
    get_dad_timeout(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-hostname
     * property.
     */
    get_dhcp_hostname(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-hostname-flags
     * property.
     */
    get_dhcp_hostname_flags(): DhcpHostnameFlags
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-iaid
     * property.
     */
    get_dhcp_iaid(): string
    get_dhcp_reject_servers(): string[]
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-send-hostname
     * property.
     */
    get_dhcp_send_hostname(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:dhcp-timeout
     * property.
     */
    get_dhcp_timeout(): number
    get_dns(idx: number): string
    get_dns_option(idx: number): string
    get_dns_priority(): number
    get_dns_search(idx: number): string
    get_gateway(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:ignore-auto-dns
     * property.
     */
    get_ignore_auto_dns(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:ignore-auto-routes
     * property.
     */
    get_ignore_auto_routes(): boolean
    /**
     * Returns the value contained in the #NMSettingIPConfig:may-fail
     * property.
     */
    get_may_fail(): boolean
    get_method(): string
    /**
     * Returns the value contained in the #NMSettingIPConfig:never-default
     * property.
     */
    get_never_default(): boolean
    get_num_addresses(): number
    get_num_dns(): number
    get_num_dns_options(): number
    get_num_dns_searches(): number
    get_num_routes(): number
    get_num_routing_rules(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:required-timeout
     * property.
     */
    get_required_timeout(): number
    get_route(idx: number): IPRoute
    /**
     * Returns the value contained in the #NMSettingIPConfig:route-metric
     * property.
     */
    get_route_metric(): number
    /**
     * Returns the value contained in the #NMSettingIPConfig:route-table
     * property.
     */
    get_route_table(): number
    get_routing_rule(idx: number): IPRoutingRule
    /**
     * NMSettingIPConfig can have a list of dns-options. If the list
     * is empty, there are two similar (but differentiated) states.
     * Either the options are explicitly set to have no values,
     * or the options are left undefined. The latter means to use
     * a default configuration, while the former explicitly means "no-options".
     */
    has_dns_options(): boolean
    /**
     * Removes the address at index `idx`.
     */
    remove_address(idx: number): void
    /**
     * Removes the address `address`.
     */
    remove_address_by_value(address: IPAddress): boolean
    /**
     * Removes the DHCP reject server at index `idx`.
     */
    remove_dhcp_reject_server(idx: number): void
    /**
     * Removes the DNS server at index `idx`.
     */
    remove_dns(idx: number): void
    /**
     * Removes the DNS server `dns`.
     */
    remove_dns_by_value(dns: string): boolean
    /**
     * Removes the DNS option at index `idx`.
     */
    remove_dns_option(idx: number): void
    /**
     * Removes the DNS option `dns_option`.
     */
    remove_dns_option_by_value(dns_option: string): boolean
    /**
     * Removes the DNS search domain at index `idx`.
     */
    remove_dns_search(idx: number): void
    /**
     * Removes the DNS search domain `dns_search`.
     */
    remove_dns_search_by_value(dns_search: string): boolean
    /**
     * Removes the route at index `idx`.
     */
    remove_route(idx: number): void
    /**
     * Removes the first matching route that matches `route`.
     * Note that before 1.10, this function would only compare dest/prefix,next_hop,metric
     * and ignore route attributes. Now, `route` must match exactly.
     */
    remove_route_by_value(route: IPRoute): boolean
    /**
     * Removes the routing_rule at index `idx`.
     */
    remove_routing_rule(idx: number): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::addresses", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addresses", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dad-timeout", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dad-timeout", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-hostname", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-hostname", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-hostname-flags", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-hostname-flags", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-iaid", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-iaid", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-reject-servers", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-reject-servers", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-send-hostname", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-send-hostname", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-timeout", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-timeout", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-options", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-options", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-priority", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-priority", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dns-search", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dns-search", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::gateway", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::gateway", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ignore-auto-dns", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ignore-auto-dns", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ignore-auto-routes", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ignore-auto-routes", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::may-fail", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::may-fail", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::method", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::method", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::never-default", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::never-default", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::required-timeout", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::required-timeout", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::route-metric", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::route-metric", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::route-table", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::route-table", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::routes", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::routes", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingIPConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingIPConfig_ConstructProps)
    _init (config?: SettingIPConfig_ConstructProps): void
    static $gtype: GObject.Type
}
interface SettingIPTunnel_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingIPTunnel */
    /**
     * How many additional levels of encapsulation are permitted to be prepended
     * to packets. This property applies only to IPv6 tunnels.
     */
    encapsulation_limit?: number
    /**
     * Tunnel flags. Currently, the following values are supported:
     * %NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT, %NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS,
     * %NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL, %NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV,
     * %NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY, %NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK.
     * They are valid only for IPv6 tunnels.
     */
    flags?: number
    /**
     * The flow label to assign to tunnel packets. This property applies only to
     * IPv6 tunnels.
     */
    flow_label?: number
    /**
     * The key used for tunnel input packets; the property is valid only for
     * certain tunnel modes (GRE, IP6GRE). If empty, no key is used.
     */
    input_key?: string
    /**
     * The local endpoint of the tunnel; the value can be empty, otherwise it
     * must contain an IPv4 or IPv6 address.
     */
    local?: string
    /**
     * The tunneling mode, for example %NM_IP_TUNNEL_MODE_IPIP or
     * %NM_IP_TUNNEL_MODE_GRE.
     */
    mode?: number
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple fragments.
     */
    mtu?: number
    /**
     * The key used for tunnel output packets; the property is valid only for
     * certain tunnel modes (GRE, IP6GRE). If empty, no key is used.
     */
    output_key?: string
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * the new device will be bound to so that tunneled packets will only be
     * routed via that interface.
     */
    parent?: string
    /**
     * Whether to enable Path MTU Discovery on this tunnel.
     */
    path_mtu_discovery?: boolean
    /**
     * The remote endpoint of the tunnel; the value must contain an IPv4 or IPv6
     * address.
     */
    remote?: string
    /**
     * The type of service (IPv4) or traffic class (IPv6) field to be set on
     * tunneled packets.
     */
    tos?: number
    /**
     * The TTL to assign to tunneled packets. 0 is a special value meaning that
     * packets inherit the TTL value.
     */
    ttl?: number
}
class SettingIPTunnel {
    /* Properties of NM-1.0.NM.SettingIPTunnel */
    /**
     * How many additional levels of encapsulation are permitted to be prepended
     * to packets. This property applies only to IPv6 tunnels.
     */
    encapsulation_limit: number
    /**
     * Tunnel flags. Currently, the following values are supported:
     * %NM_IP_TUNNEL_FLAG_IP6_IGN_ENCAP_LIMIT, %NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_TCLASS,
     * %NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FLOWLABEL, %NM_IP_TUNNEL_FLAG_IP6_MIP6_DEV,
     * %NM_IP_TUNNEL_FLAG_IP6_RCV_DSCP_COPY, %NM_IP_TUNNEL_FLAG_IP6_USE_ORIG_FWMARK.
     * They are valid only for IPv6 tunnels.
     */
    flags: number
    /**
     * The flow label to assign to tunnel packets. This property applies only to
     * IPv6 tunnels.
     */
    flow_label: number
    /**
     * The key used for tunnel input packets; the property is valid only for
     * certain tunnel modes (GRE, IP6GRE). If empty, no key is used.
     */
    input_key: string
    /**
     * The local endpoint of the tunnel; the value can be empty, otherwise it
     * must contain an IPv4 or IPv6 address.
     */
    local: string
    /**
     * The tunneling mode, for example %NM_IP_TUNNEL_MODE_IPIP or
     * %NM_IP_TUNNEL_MODE_GRE.
     */
    mode: number
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple fragments.
     */
    mtu: number
    /**
     * The key used for tunnel output packets; the property is valid only for
     * certain tunnel modes (GRE, IP6GRE). If empty, no key is used.
     */
    output_key: string
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * the new device will be bound to so that tunneled packets will only be
     * routed via that interface.
     */
    parent: string
    /**
     * Whether to enable Path MTU Discovery on this tunnel.
     */
    path_mtu_discovery: boolean
    /**
     * The remote endpoint of the tunnel; the value must contain an IPv4 or IPv6
     * address.
     */
    remote: string
    /**
     * The type of service (IPv4) or traffic class (IPv6) field to be set on
     * tunneled packets.
     */
    tos: number
    /**
     * The TTL to assign to tunneled packets. 0 is a special value meaning that
     * packets inherit the TTL value.
     */
    ttl: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingIPTunnel */
    /**
     * Returns the #NMSettingIPTunnel:encapsulation-limit property of the setting.
     */
    get_encapsulation_limit(): number
    get_flags(): IPTunnelFlags
    /**
     * Returns the #NMSettingIPTunnel:flow-label property of the setting.
     */
    get_flow_label(): number
    /**
     * Returns the #NMSettingIPTunnel:input-key property of the setting.
     */
    get_input_key(): string
    /**
     * Returns the #NMSettingIPTunnel:local property of the setting.
     */
    get_local(): string
    /**
     * Returns the #NMSettingIPTunnel:mode property of the setting.
     */
    get_mode(): IPTunnelMode
    /**
     * Returns the #NMSettingIPTunnel:mtu property of the setting.
     */
    get_mtu(): number
    /**
     * Returns the #NMSettingIPTunnel:output-key property of the setting.
     */
    get_output_key(): string
    /**
     * Returns the #NMSettingIPTunnel:parent property of the setting
     */
    get_parent(): string
    /**
     * Returns the #NMSettingIPTunnel:path-mtu-discovery property of the setting.
     */
    get_path_mtu_discovery(): boolean
    /**
     * Returns the #NMSettingIPTunnel:remote property of the setting.
     */
    get_remote(): string
    /**
     * Returns the #NMSettingIPTunnel:tos property of the setting.
     */
    get_tos(): number
    /**
     * Returns the #NMSettingIPTunnel:ttl property of the setting.
     */
    get_ttl(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::encapsulation-limit", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::encapsulation-limit", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::flags", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::flow-label", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flow-label", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::input-key", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::input-key", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::local", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::output-key", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::output-key", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path-mtu-discovery", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path-mtu-discovery", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::remote", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remote", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tos", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tos", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ttl", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ttl", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingIPTunnel, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingIPTunnel_ConstructProps)
    _init (config?: SettingIPTunnel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingIPTunnel
    static $gtype: GObject.Type
}
interface SettingInfiniband_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingInfiniband */
    /**
     * If specified, this connection will only apply to the IPoIB device whose
     * permanent MAC address matches. This property does not change the MAC
     * address of the device (i.e. MAC spoofing).
     */
    mac_address?: string
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple frames.
     */
    mtu?: number
    /**
     * The InfiniBand P_Key to use for this device. A value of -1 means to use
     * the default P_Key (aka "the P_Key at index 0"). Otherwise, it is a 16-bit
     * unsigned integer, whose high bit is set if it is a "full membership"
     * P_Key.
     */
    p_key?: number
    /**
     * The interface name of the parent device of this device. Normally %NULL,
     * but if the #NMSettingInfiniband:p_key property is set, then you must
     * specify the base device by setting either this property or
     * #NMSettingInfiniband:mac-address.
     */
    parent?: string
    /**
     * The IP-over-InfiniBand transport mode. Either "datagram" or
     * "connected".
     */
    transport_mode?: string
}
class SettingInfiniband {
    /* Properties of NM-1.0.NM.SettingInfiniband */
    /**
     * If specified, this connection will only apply to the IPoIB device whose
     * permanent MAC address matches. This property does not change the MAC
     * address of the device (i.e. MAC spoofing).
     */
    mac_address: string
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple frames.
     */
    mtu: number
    /**
     * The InfiniBand P_Key to use for this device. A value of -1 means to use
     * the default P_Key (aka "the P_Key at index 0"). Otherwise, it is a 16-bit
     * unsigned integer, whose high bit is set if it is a "full membership"
     * P_Key.
     */
    p_key: number
    /**
     * The interface name of the parent device of this device. Normally %NULL,
     * but if the #NMSettingInfiniband:p_key property is set, then you must
     * specify the base device by setting either this property or
     * #NMSettingInfiniband:mac-address.
     */
    parent: string
    /**
     * The IP-over-InfiniBand transport mode. Either "datagram" or
     * "connected".
     */
    transport_mode: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingInfiniband */
    get_mac_address(): string
    get_mtu(): number
    /**
     * Returns the P_Key to use for this device. A value of -1 means to
     * use the default P_Key (aka "the P_Key at index 0"). Otherwise, it is
     * a 16-bit unsigned integer.
     */
    get_p_key(): number
    /**
     * Returns the parent interface name for this device, if set.
     */
    get_parent(): string
    /**
     * Returns the transport mode for this device. Either 'datagram' or
     * 'connected'.
     */
    get_transport_mode(): string
    /**
     * Returns the interface name created by combining #NMSettingInfiniband:parent
     * and #NMSettingInfiniband:p-key. (If either property is unset, this will
     * return %NULL.)
     */
    get_virtual_interface_name(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::mac-address", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::p-key", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::p-key", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::transport-mode", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transport-mode", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingInfiniband, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingInfiniband_ConstructProps)
    _init (config?: SettingInfiniband_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingInfiniband
    static $gtype: GObject.Type
}
interface SettingMacsec_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingMacsec */
    /**
     * Whether the transmitted traffic must be encrypted.
     */
    encrypt?: boolean
    /**
     * The pre-shared CAK (Connectivity Association Key) for MACsec
     * Key Agreement.
     */
    mka_cak?: string
    /**
     * Flags indicating how to handle the #NMSettingMacsec:mka-cak
     * property.
     */
    mka_cak_flags?: SettingSecretFlags
    /**
     * The pre-shared CKN (Connectivity-association Key Name) for
     * MACsec Key Agreement.
     */
    mka_ckn?: string
    /**
     * Specifies how the CAK (Connectivity Association Key) for MKA (MACsec Key
     * Agreement) is obtained.
     */
    mode?: number
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this MACSEC interface should be created.  If this property is
     * not specified, the connection must contain an #NMSettingWired setting
     * with a #NMSettingWired:mac-address property.
     */
    parent?: string
    /**
     * The port component of the SCI (Secure Channel Identifier), between 1 and 65534.
     */
    port?: number
    /**
     * Specifies whether the SCI (Secure Channel Identifier) is included
     * in every packet.
     */
    send_sci?: boolean
    /**
     * Specifies the validation mode for incoming frames.
     */
    validation?: number
}
class SettingMacsec {
    /* Properties of NM-1.0.NM.SettingMacsec */
    /**
     * Whether the transmitted traffic must be encrypted.
     */
    encrypt: boolean
    /**
     * The pre-shared CAK (Connectivity Association Key) for MACsec
     * Key Agreement.
     */
    mka_cak: string
    /**
     * Flags indicating how to handle the #NMSettingMacsec:mka-cak
     * property.
     */
    mka_cak_flags: SettingSecretFlags
    /**
     * The pre-shared CKN (Connectivity-association Key Name) for
     * MACsec Key Agreement.
     */
    mka_ckn: string
    /**
     * Specifies how the CAK (Connectivity Association Key) for MKA (MACsec Key
     * Agreement) is obtained.
     */
    mode: number
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this MACSEC interface should be created.  If this property is
     * not specified, the connection must contain an #NMSettingWired setting
     * with a #NMSettingWired:mac-address property.
     */
    parent: string
    /**
     * The port component of the SCI (Secure Channel Identifier), between 1 and 65534.
     */
    port: number
    /**
     * Specifies whether the SCI (Secure Channel Identifier) is included
     * in every packet.
     */
    send_sci: boolean
    /**
     * Specifies the validation mode for incoming frames.
     */
    validation: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingMacsec */
    get_encrypt(): boolean
    get_mka_cak(): string
    get_mka_cak_flags(): SettingSecretFlags
    get_mka_ckn(): string
    get_mode(): SettingMacsecMode
    get_parent(): string
    get_port(): number
    get_send_sci(): boolean
    get_validation(): SettingMacsecValidation
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::encrypt", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::encrypt", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mka-cak", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mka-cak", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mka-cak-flags", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mka-cak-flags", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mka-ckn", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mka-ckn", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::port", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::port", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::send-sci", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::send-sci", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::validation", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::validation", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingMacsec, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingMacsec_ConstructProps)
    _init (config?: SettingMacsec_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingMacsec
    static $gtype: GObject.Type
}
interface SettingMacvlan_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingMacvlan */
    /**
     * The macvlan mode, which specifies the communication mechanism between multiple
     * macvlans on the same lower device.
     */
    mode?: number
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this MAC-VLAN interface should be created.  If this property is
     * not specified, the connection must contain an #NMSettingWired setting
     * with a #NMSettingWired:mac-address property.
     */
    parent?: string
    /**
     * Whether the interface should be put in promiscuous mode.
     */
    promiscuous?: boolean
    /**
     * Whether the interface should be a MACVTAP.
     */
    tap?: boolean
}
class SettingMacvlan {
    /* Properties of NM-1.0.NM.SettingMacvlan */
    /**
     * The macvlan mode, which specifies the communication mechanism between multiple
     * macvlans on the same lower device.
     */
    mode: number
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this MAC-VLAN interface should be created.  If this property is
     * not specified, the connection must contain an #NMSettingWired setting
     * with a #NMSettingWired:mac-address property.
     */
    parent: string
    /**
     * Whether the interface should be put in promiscuous mode.
     */
    promiscuous: boolean
    /**
     * Whether the interface should be a MACVTAP.
     */
    tap: boolean
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingMacvlan */
    get_mode(): SettingMacvlanMode
    get_parent(): string
    get_promiscuous(): boolean
    get_tap(): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::mode", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::promiscuous", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::promiscuous", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tap", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tap", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingMacvlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingMacvlan_ConstructProps)
    _init (config?: SettingMacvlan_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingMacvlan
    static $gtype: GObject.Type
}
interface SettingMatch_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingMatch */
    /**
     * A list of driver names to match. Each element is a shell wildcard pattern.
     * 
     * See NMSettingMatch:interface-name for how special characters '|', '&',
     * '!' and '\\' are used for optional and mandatory matches and inverting the
     * pattern.
     */
    driver?: string[]
    /**
     * A list of interface names to match. Each element is a shell wildcard
     * pattern.
     * 
     * An element can be prefixed with a pipe symbol (|) or an ampersand (&).
     * The former means that the element is optional and the latter means that
     * it is mandatory. If there are any optional elements, than the match
     * evaluates to true if at least one of the optional element matches
     * (logical OR). If there are any mandatory elements, then they all
     * must match (logical AND). By default, an element is optional. This means
     * that an element "foo" behaves the same as "|foo". An element can also be inverted
     * with exclamation mark (!) between the pipe symbol (or the ampersand) and before
     * the pattern. Note that "!foo" is a shortcut for the mandatory match "&!foo". Finally,
     * a backslash can be used at the beginning of the element (after the optional special characters)
     * to escape the start of the pattern. For example, "&\\!a" is an mandatory match for literally "!a".
     */
    interface_name?: string[]
    /**
     * A list of kernel command line arguments to match. This may be used to check
     * whether a specific kernel command line option is set (or unset, if prefixed with
     * the exclamation mark). The argument must either be a single word, or
     * an assignment (i.e. two words, joined by "="). In the former case the kernel
     * command line is searched for the word appearing as is, or as left hand side
     * of an assignment. In the latter case, the exact assignment is looked for
     * with right and left hand side matching. Wildcard patterns are not supported.
     * 
     * See NMSettingMatch:interface-name for how special characters '|', '&',
     * '!' and '\\' are used for optional and mandatory matches and inverting the
     * match.
     */
    kernel_command_line?: string[]
    /**
     * A list of paths to match against the ID_PATH udev property of
     * devices. ID_PATH represents the topological persistent path of a
     * device. It typically contains a subsystem string (pci, usb, platform,
     * etc.) and a subsystem-specific identifier.
     * 
     * For PCI devices the path has the form
     * "pci-$domain:$bus:$device.$function", where each variable is an
     * hexadecimal value; for example "pci-0000:0a:00.0".
     * 
     * The path of a device can be obtained with "udevadm info
     * /sys/class/net/$dev | grep ID_PATH=" or by looking at the "path"
     * property exported by NetworkManager ("nmcli -f general.path device
     * show $dev").
     * 
     * Each element of the list is a shell wildcard pattern.
     * 
     * See NMSettingMatch:interface-name for how special characters '|', '&',
     * '!' and '\\' are used for optional and mandatory matches and inverting the
     * pattern.
     */
    path?: string[]
}
class SettingMatch {
    /* Properties of NM-1.0.NM.SettingMatch */
    /**
     * A list of driver names to match. Each element is a shell wildcard pattern.
     * 
     * See NMSettingMatch:interface-name for how special characters '|', '&',
     * '!' and '\\' are used for optional and mandatory matches and inverting the
     * pattern.
     */
    driver: string[]
    /**
     * A list of interface names to match. Each element is a shell wildcard
     * pattern.
     * 
     * An element can be prefixed with a pipe symbol (|) or an ampersand (&).
     * The former means that the element is optional and the latter means that
     * it is mandatory. If there are any optional elements, than the match
     * evaluates to true if at least one of the optional element matches
     * (logical OR). If there are any mandatory elements, then they all
     * must match (logical AND). By default, an element is optional. This means
     * that an element "foo" behaves the same as "|foo". An element can also be inverted
     * with exclamation mark (!) between the pipe symbol (or the ampersand) and before
     * the pattern. Note that "!foo" is a shortcut for the mandatory match "&!foo". Finally,
     * a backslash can be used at the beginning of the element (after the optional special characters)
     * to escape the start of the pattern. For example, "&\\!a" is an mandatory match for literally "!a".
     */
    interface_name: string[]
    /**
     * A list of kernel command line arguments to match. This may be used to check
     * whether a specific kernel command line option is set (or unset, if prefixed with
     * the exclamation mark). The argument must either be a single word, or
     * an assignment (i.e. two words, joined by "="). In the former case the kernel
     * command line is searched for the word appearing as is, or as left hand side
     * of an assignment. In the latter case, the exact assignment is looked for
     * with right and left hand side matching. Wildcard patterns are not supported.
     * 
     * See NMSettingMatch:interface-name for how special characters '|', '&',
     * '!' and '\\' are used for optional and mandatory matches and inverting the
     * match.
     */
    kernel_command_line: string[]
    /**
     * A list of paths to match against the ID_PATH udev property of
     * devices. ID_PATH represents the topological persistent path of a
     * device. It typically contains a subsystem string (pci, usb, platform,
     * etc.) and a subsystem-specific identifier.
     * 
     * For PCI devices the path has the form
     * "pci-$domain:$bus:$device.$function", where each variable is an
     * hexadecimal value; for example "pci-0000:0a:00.0".
     * 
     * The path of a device can be obtained with "udevadm info
     * /sys/class/net/$dev | grep ID_PATH=" or by looking at the "path"
     * property exported by NetworkManager ("nmcli -f general.path device
     * show $dev").
     * 
     * Each element of the list is a shell wildcard pattern.
     * 
     * See NMSettingMatch:interface-name for how special characters '|', '&',
     * '!' and '\\' are used for optional and mandatory matches and inverting the
     * pattern.
     */
    path: string[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingMatch */
    /**
     * Adds a new driver to the setting.
     */
    add_driver(driver: string): void
    /**
     * Adds a new interface name to the setting.
     */
    add_interface_name(interface_name: string): void
    /**
     * Adds a new kernel command line argument to the setting.
     */
    add_kernel_command_line(kernel_command_line: string): void
    /**
     * Adds a new path to the setting.
     */
    add_path(path: string): void
    /**
     * Removes all configured drivers.
     */
    clear_drivers(): void
    /**
     * Removes all configured interface names.
     */
    clear_interface_names(): void
    /**
     * Removes all configured kernel command line arguments.
     */
    clear_kernel_command_lines(): void
    /**
     * Removes all configured paths.
     */
    clear_paths(): void
    get_driver(idx: number): string
    /**
     * Returns all the drivers.
     */
    get_drivers(): string[]
    get_interface_name(idx: number): string
    /**
     * Returns all the interface names.
     */
    get_interface_names(): string[]
    get_kernel_command_line(idx: number): string
    /**
     * Returns all the interface names.
     */
    get_kernel_command_lines(): string[]
    get_num_drivers(): number
    get_num_interface_names(): number
    get_num_kernel_command_lines(): number
    get_num_paths(): number
    get_path(idx: number): string
    /**
     * Returns all the paths.
     */
    get_paths(): string[]
    /**
     * Removes the driver at index `idx`.
     */
    remove_driver(idx: number): void
    /**
     * Removes `driver`.
     */
    remove_driver_by_value(driver: string): boolean
    /**
     * Removes the interface name at index `idx`.
     */
    remove_interface_name(idx: number): void
    /**
     * Removes `interface_name`.
     */
    remove_interface_name_by_value(interface_name: string): boolean
    /**
     * Removes the kernel command line argument at index `idx`.
     */
    remove_kernel_command_line(idx: number): void
    /**
     * Removes `kernel_command_line`.
     */
    remove_kernel_command_line_by_value(kernel_command_line: string): boolean
    /**
     * Removes the path at index `idx`.
     */
    remove_path(idx: number): void
    /**
     * Removes `path`.
     */
    remove_path_by_value(path: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::driver", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::driver", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::interface-name", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interface-name", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::kernel-command-line", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::kernel-command-line", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingMatch, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingMatch_ConstructProps)
    _init (config?: SettingMatch_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingMatch
    static $gtype: GObject.Type
}
interface SettingOlpcMesh_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingOlpcMesh */
    /**
     * Channel on which the mesh network to join is located.
     */
    channel?: number
    /**
     * Anycast DHCP MAC address used when requesting an IP address via DHCP.
     * The specific anycast address used determines which DHCP server class
     * answers the request.
     * 
     * This is currently only implemented by dhclient DHCP plugin.
     */
    dhcp_anycast_address?: string
    /**
     * SSID of the mesh network to join.
     */
    ssid?: GLib.Bytes
}
class SettingOlpcMesh {
    /* Properties of NM-1.0.NM.SettingOlpcMesh */
    /**
     * Channel on which the mesh network to join is located.
     */
    channel: number
    /**
     * Anycast DHCP MAC address used when requesting an IP address via DHCP.
     * The specific anycast address used determines which DHCP server class
     * answers the request.
     * 
     * This is currently only implemented by dhclient DHCP plugin.
     */
    dhcp_anycast_address: string
    /**
     * SSID of the mesh network to join.
     */
    ssid: GLib.Bytes
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingOlpcMesh */
    get_channel(): number
    get_dhcp_anycast_address(): string
    get_ssid(): GLib.Bytes
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp-anycast-address", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp-anycast-address", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ssid", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ssid", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingOlpcMesh, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingOlpcMesh_ConstructProps)
    _init (config?: SettingOlpcMesh_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingOlpcMesh
    static $gtype: GObject.Type
}
interface SettingOvsBridge_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingOvsBridge */
    /**
     * The data path type. One of "system", "netdev" or empty.
     */
    datapath_type?: string
    /**
     * The bridge failure mode. One of "secure", "standalone" or empty.
     */
    fail_mode?: string
    /**
     * Enable or disable multicast snooping.
     */
    mcast_snooping_enable?: boolean
    /**
     * Enable or disable RSTP.
     */
    rstp_enable?: boolean
    /**
     * Enable or disable STP.
     */
    stp_enable?: boolean
}
class SettingOvsBridge {
    /* Properties of NM-1.0.NM.SettingOvsBridge */
    /**
     * The data path type. One of "system", "netdev" or empty.
     */
    datapath_type: string
    /**
     * The bridge failure mode. One of "secure", "standalone" or empty.
     */
    fail_mode: string
    /**
     * Enable or disable multicast snooping.
     */
    mcast_snooping_enable: boolean
    /**
     * Enable or disable RSTP.
     */
    rstp_enable: boolean
    /**
     * Enable or disable STP.
     */
    stp_enable: boolean
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingOvsBridge */
    get_datapath_type(): string
    get_fail_mode(): string
    get_mcast_snooping_enable(): boolean
    get_rstp_enable(): boolean
    get_stp_enable(): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::datapath-type", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::datapath-type", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::fail-mode", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fail-mode", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mcast-snooping-enable", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mcast-snooping-enable", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::rstp-enable", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rstp-enable", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::stp-enable", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stp-enable", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingOvsBridge, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingOvsBridge_ConstructProps)
    _init (config?: SettingOvsBridge_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingOvsBridge
    static $gtype: GObject.Type
}
interface SettingOvsDpdk_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingOvsDpdk */
    /**
     * Open vSwitch DPDK device arguments.
     */
    devargs?: string
    /**
     * Open vSwitch DPDK number of rx queues.
     * Defaults to zero which means to leave the parameter in OVS unspecified
     * and effectively configures one queue.
     */
    n_rxq?: number
}
class SettingOvsDpdk {
    /* Properties of NM-1.0.NM.SettingOvsDpdk */
    /**
     * Open vSwitch DPDK device arguments.
     */
    devargs: string
    /**
     * Open vSwitch DPDK number of rx queues.
     * Defaults to zero which means to leave the parameter in OVS unspecified
     * and effectively configures one queue.
     */
    n_rxq: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingOvsDpdk */
    get_devargs(): string
    get_n_rxq(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::devargs", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::devargs", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::n-rxq", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::n-rxq", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingOvsDpdk, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingOvsDpdk_ConstructProps)
    _init (config?: SettingOvsDpdk_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingOvsDpdk
    static $gtype: GObject.Type
}
interface SettingOvsExternalIDs_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingOvsExternalIDs */
    /**
     * A dictionary of key/value pairs with exernal-ids for OVS.
     */
    data?: GLib.HashTable
}
class SettingOvsExternalIDs {
    /* Properties of NM-1.0.NM.SettingOvsExternalIDs */
    /**
     * A dictionary of key/value pairs with exernal-ids for OVS.
     */
    data: GLib.HashTable
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingOvsExternalIDs */
    get_data(key: string): string
    get_data_keys(): string[]
    set_data(key: string, val?: string | null): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingOvsExternalIDs, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingOvsExternalIDs, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::data", callback: (($obj: SettingOvsExternalIDs, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::data", callback: (($obj: SettingOvsExternalIDs, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingOvsExternalIDs, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingOvsExternalIDs, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingOvsExternalIDs_ConstructProps)
    _init (config?: SettingOvsExternalIDs_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingOvsExternalIDs
    /**
     * Checks whether `key` is a valid key for OVS' external-ids.
     * This means, the key cannot be %NULL, not too large and valid ASCII.
     * Also, only digits and numbers are allowed with a few special
     * characters. They key must also not start with "NM.".
     */
    static check_key(key?: string | null): boolean
    /**
     * Checks whether `val` is a valid user data value. This means,
     * value is not %NULL, not too large and valid UTF-8.
     */
    static check_val(val?: string | null): boolean
    static $gtype: GObject.Type
}
interface SettingOvsInterface_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingOvsInterface */
    /**
     * The interface type. Either "internal", "system", "patch", "dpdk", or empty.
     */
    type?: string
}
class SettingOvsInterface {
    /* Properties of NM-1.0.NM.SettingOvsInterface */
    /**
     * The interface type. Either "internal", "system", "patch", "dpdk", or empty.
     */
    type: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingOvsInterface */
    get_interface_type(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingOvsInterface, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::type", callback: (($obj: SettingOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: (($obj: SettingOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingOvsInterface, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingOvsInterface_ConstructProps)
    _init (config?: SettingOvsInterface_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingOvsInterface
    static $gtype: GObject.Type
}
interface SettingOvsPatch_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingOvsPatch */
    /**
     * Specifies the name of the interface for the other side of the patch.
     * The patch on the other side must also set this interface as peer.
     */
    peer?: string
}
class SettingOvsPatch {
    /* Properties of NM-1.0.NM.SettingOvsPatch */
    /**
     * Specifies the name of the interface for the other side of the patch.
     * The patch on the other side must also set this interface as peer.
     */
    peer: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingOvsPatch */
    get_peer(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingOvsPatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingOvsPatch, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::peer", callback: (($obj: SettingOvsPatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer", callback: (($obj: SettingOvsPatch, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingOvsPatch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingOvsPatch, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingOvsPatch_ConstructProps)
    _init (config?: SettingOvsPatch_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingOvsPatch
    static $gtype: GObject.Type
}
interface SettingOvsPort_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingOvsPort */
    /**
     * The time port must be inactive in order to be considered down.
     */
    bond_downdelay?: number
    /**
     * Bonding mode. One of "active-backup", "balance-slb", or "balance-tcp".
     */
    bond_mode?: string
    /**
     * The time port must be active before it starts forwarding traffic.
     */
    bond_updelay?: number
    /**
     * LACP mode. One of "active", "off", or "passive".
     */
    lacp?: string
    /**
     * The VLAN tag in the range 0-4095.
     */
    tag?: number
    /**
     * The VLAN mode. One of "access", "native-tagged", "native-untagged",
     * "trunk" or unset.
     */
    vlan_mode?: string
}
class SettingOvsPort {
    /* Properties of NM-1.0.NM.SettingOvsPort */
    /**
     * The time port must be inactive in order to be considered down.
     */
    bond_downdelay: number
    /**
     * Bonding mode. One of "active-backup", "balance-slb", or "balance-tcp".
     */
    bond_mode: string
    /**
     * The time port must be active before it starts forwarding traffic.
     */
    bond_updelay: number
    /**
     * LACP mode. One of "active", "off", or "passive".
     */
    lacp: string
    /**
     * The VLAN tag in the range 0-4095.
     */
    tag: number
    /**
     * The VLAN mode. One of "access", "native-tagged", "native-untagged",
     * "trunk" or unset.
     */
    vlan_mode: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingOvsPort */
    get_bond_downdelay(): number
    get_bond_mode(): string
    get_bond_updelay(): number
    get_lacp(): string
    get_tag(): number
    get_vlan_mode(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::bond-downdelay", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bond-downdelay", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::bond-mode", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bond-mode", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::bond-updelay", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bond-updelay", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lacp", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lacp", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tag", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tag", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vlan-mode", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vlan-mode", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingOvsPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingOvsPort_ConstructProps)
    _init (config?: SettingOvsPort_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingOvsPort
    static $gtype: GObject.Type
}
interface SettingPpp_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingPpp */
    /**
     * If non-zero, instruct pppd to set the serial port to the specified
     * baudrate.  This value should normally be left as 0 to automatically
     * choose the speed.
     */
    baud?: number
    /**
     * If %TRUE, specify that pppd should set the serial port to use hardware
     * flow control with RTS and CTS signals.  This value should normally be set
     * to %FALSE.
     */
    crtscts?: boolean
    /**
     * If non-zero, instruct pppd to presume the connection to the peer has
     * failed if the specified number of LCP echo-requests go unanswered by the
     * peer.  The "lcp-echo-interval" property must also be set to a non-zero
     * value if this property is used.
     */
    lcp_echo_failure?: number
    /**
     * If non-zero, instruct pppd to send an LCP echo-request frame to the peer
     * every n seconds (where n is the specified value).  Note that some PPP
     * peers will respond to echo requests and some will not, and it is not
     * possible to autodetect this.
     */
    lcp_echo_interval?: number
    /**
     * If %TRUE, stateful MPPE is used.  See pppd documentation for more
     * information on stateful MPPE.
     */
    mppe_stateful?: boolean
    /**
     * If non-zero, instruct pppd to request that the peer send packets no
     * larger than the specified size.  If non-zero, the MRU should be between
     * 128 and 16384.
     */
    mru?: number
    /**
     * If non-zero, instruct pppd to send packets no larger than the specified
     * size.
     */
    mtu?: number
    /**
     * If %TRUE, Van Jacobsen TCP header compression will not be requested.
     */
    no_vj_comp?: boolean
    /**
     * If %TRUE, do not require the other side (usually the PPP server) to
     * authenticate itself to the client.  If %FALSE, require authentication
     * from the remote side.  In almost all cases, this should be %TRUE.
     */
    noauth?: boolean
    /**
     * If %TRUE, BSD compression will not be requested.
     */
    nobsdcomp?: boolean
    /**
     * If %TRUE, "deflate" compression will not be requested.
     */
    nodeflate?: boolean
    /**
     * If %TRUE, the CHAP authentication method will not be used.
     */
    refuse_chap?: boolean
    /**
     * If %TRUE, the EAP authentication method will not be used.
     */
    refuse_eap?: boolean
    /**
     * If %TRUE, the MSCHAP authentication method will not be used.
     */
    refuse_mschap?: boolean
    /**
     * If %TRUE, the MSCHAPv2 authentication method will not be used.
     */
    refuse_mschapv2?: boolean
    /**
     * If %TRUE, the PAP authentication method will not be used.
     */
    refuse_pap?: boolean
    /**
     * If %TRUE, MPPE (Microsoft Point-to-Point Encryption) will be required for
     * the PPP session.  If either 64-bit or 128-bit MPPE is not available the
     * session will fail.  Note that MPPE is not used on mobile broadband
     * connections.
     */
    require_mppe?: boolean
    /**
     * If %TRUE, 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
     * required for the PPP session, and the "require-mppe" property must also
     * be set to %TRUE.  If 128-bit MPPE is not available the session will fail.
     */
    require_mppe_128?: boolean
}
class SettingPpp {
    /* Properties of NM-1.0.NM.SettingPpp */
    /**
     * If non-zero, instruct pppd to set the serial port to the specified
     * baudrate.  This value should normally be left as 0 to automatically
     * choose the speed.
     */
    baud: number
    /**
     * If %TRUE, specify that pppd should set the serial port to use hardware
     * flow control with RTS and CTS signals.  This value should normally be set
     * to %FALSE.
     */
    crtscts: boolean
    /**
     * If non-zero, instruct pppd to presume the connection to the peer has
     * failed if the specified number of LCP echo-requests go unanswered by the
     * peer.  The "lcp-echo-interval" property must also be set to a non-zero
     * value if this property is used.
     */
    lcp_echo_failure: number
    /**
     * If non-zero, instruct pppd to send an LCP echo-request frame to the peer
     * every n seconds (where n is the specified value).  Note that some PPP
     * peers will respond to echo requests and some will not, and it is not
     * possible to autodetect this.
     */
    lcp_echo_interval: number
    /**
     * If %TRUE, stateful MPPE is used.  See pppd documentation for more
     * information on stateful MPPE.
     */
    mppe_stateful: boolean
    /**
     * If non-zero, instruct pppd to request that the peer send packets no
     * larger than the specified size.  If non-zero, the MRU should be between
     * 128 and 16384.
     */
    mru: number
    /**
     * If non-zero, instruct pppd to send packets no larger than the specified
     * size.
     */
    mtu: number
    /**
     * If %TRUE, Van Jacobsen TCP header compression will not be requested.
     */
    no_vj_comp: boolean
    /**
     * If %TRUE, do not require the other side (usually the PPP server) to
     * authenticate itself to the client.  If %FALSE, require authentication
     * from the remote side.  In almost all cases, this should be %TRUE.
     */
    noauth: boolean
    /**
     * If %TRUE, BSD compression will not be requested.
     */
    nobsdcomp: boolean
    /**
     * If %TRUE, "deflate" compression will not be requested.
     */
    nodeflate: boolean
    /**
     * If %TRUE, the CHAP authentication method will not be used.
     */
    refuse_chap: boolean
    /**
     * If %TRUE, the EAP authentication method will not be used.
     */
    refuse_eap: boolean
    /**
     * If %TRUE, the MSCHAP authentication method will not be used.
     */
    refuse_mschap: boolean
    /**
     * If %TRUE, the MSCHAPv2 authentication method will not be used.
     */
    refuse_mschapv2: boolean
    /**
     * If %TRUE, the PAP authentication method will not be used.
     */
    refuse_pap: boolean
    /**
     * If %TRUE, MPPE (Microsoft Point-to-Point Encryption) will be required for
     * the PPP session.  If either 64-bit or 128-bit MPPE is not available the
     * session will fail.  Note that MPPE is not used on mobile broadband
     * connections.
     */
    require_mppe: boolean
    /**
     * If %TRUE, 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
     * required for the PPP session, and the "require-mppe" property must also
     * be set to %TRUE.  If 128-bit MPPE is not available the session will fail.
     */
    require_mppe_128: boolean
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingPpp */
    get_baud(): number
    get_crtscts(): boolean
    get_lcp_echo_failure(): number
    get_lcp_echo_interval(): number
    get_mppe_stateful(): boolean
    get_mru(): number
    get_mtu(): number
    get_no_vj_comp(): boolean
    get_noauth(): boolean
    get_nobsdcomp(): boolean
    get_nodeflate(): boolean
    get_refuse_chap(): boolean
    get_refuse_eap(): boolean
    get_refuse_mschap(): boolean
    get_refuse_mschapv2(): boolean
    get_refuse_pap(): boolean
    get_require_mppe(): boolean
    get_require_mppe_128(): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::baud", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::baud", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::crtscts", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::crtscts", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lcp-echo-failure", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lcp-echo-failure", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lcp-echo-interval", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lcp-echo-interval", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mppe-stateful", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mppe-stateful", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mru", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mru", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::no-vj-comp", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::no-vj-comp", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::noauth", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::noauth", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nobsdcomp", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nobsdcomp", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::nodeflate", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nodeflate", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::refuse-chap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::refuse-chap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::refuse-eap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::refuse-eap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::refuse-mschap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::refuse-mschap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::refuse-mschapv2", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::refuse-mschapv2", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::refuse-pap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::refuse-pap", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::require-mppe", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-mppe", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::require-mppe-128", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::require-mppe-128", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingPpp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingPpp_ConstructProps)
    _init (config?: SettingPpp_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingPpp
    static $gtype: GObject.Type
}
interface SettingPppoe_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingPppoe */
    /**
     * If given, specifies the parent interface name on which this PPPoE
     * connection should be created.  If this property is not specified,
     * the connection is activated on the interface specified in
     * #NMSettingConnection:interface-name of #NMSettingConnection.
     */
    parent?: string
    /**
     * Password used to authenticate with the PPPoE service.
     */
    password?: string
    /**
     * Flags indicating how to handle the #NMSettingPppoe:password property.
     */
    password_flags?: SettingSecretFlags
    /**
     * If specified, instruct PPPoE to only initiate sessions with access
     * concentrators that provide the specified service.  For most providers,
     * this should be left blank.  It is only required if there are multiple
     * access concentrators or a specific service is known to be required.
     */
    service?: string
    /**
     * Username used to authenticate with the PPPoE service.
     */
    username?: string
}
class SettingPppoe {
    /* Properties of NM-1.0.NM.SettingPppoe */
    /**
     * If given, specifies the parent interface name on which this PPPoE
     * connection should be created.  If this property is not specified,
     * the connection is activated on the interface specified in
     * #NMSettingConnection:interface-name of #NMSettingConnection.
     */
    parent: string
    /**
     * Password used to authenticate with the PPPoE service.
     */
    password: string
    /**
     * Flags indicating how to handle the #NMSettingPppoe:password property.
     */
    password_flags: SettingSecretFlags
    /**
     * If specified, instruct PPPoE to only initiate sessions with access
     * concentrators that provide the specified service.  For most providers,
     * this should be left blank.  It is only required if there are multiple
     * access concentrators or a specific service is known to be required.
     */
    service: string
    /**
     * Username used to authenticate with the PPPoE service.
     */
    username: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingPppoe */
    get_parent(): string
    get_password(): string
    get_password_flags(): SettingSecretFlags
    get_service(): string
    get_username(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parent", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::password-flags", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-flags", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::service", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::username", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::username", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingPppoe, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingPppoe_ConstructProps)
    _init (config?: SettingPppoe_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingPppoe
    static $gtype: GObject.Type
}
interface SettingProxy_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingProxy */
    /**
     * Whether the proxy configuration is for browser only.
     */
    browser_only?: boolean
    /**
     * Method for proxy configuration, Default is %NM_SETTING_PROXY_METHOD_NONE
     */
    method?: number
    /**
     * PAC script for the connection.
     */
    pac_script?: string
    /**
     * PAC URL for obtaining PAC file.
     */
    pac_url?: string
}
class SettingProxy {
    /* Properties of NM-1.0.NM.SettingProxy */
    /**
     * Whether the proxy configuration is for browser only.
     */
    browser_only: boolean
    /**
     * Method for proxy configuration, Default is %NM_SETTING_PROXY_METHOD_NONE
     */
    method: number
    /**
     * PAC script for the connection.
     */
    pac_script: string
    /**
     * PAC URL for obtaining PAC file.
     */
    pac_url: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingProxy */
    get_browser_only(): boolean
    /**
     * Returns the proxy configuration method. By default the value is %NM_SETTING_PROXY_METHOD_NONE.
     * %NM_SETTING_PROXY_METHOD_NONE should be selected for a connection intended for direct network
     * access.
     */
    get_method(): SettingProxyMethod
    get_pac_script(): string
    get_pac_url(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::browser-only", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::browser-only", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::method", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::method", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pac-script", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pac-script", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pac-url", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pac-url", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingProxy, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingProxy_ConstructProps)
    _init (config?: SettingProxy_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingProxy
    static $gtype: GObject.Type
}
interface SettingSerial_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingSerial */
    /**
     * Speed to use for communication over the serial port.  Note that this
     * value usually has no effect for mobile broadband modems as they generally
     * ignore speed settings and use the highest available speed.
     */
    baud?: number
    /**
     * Byte-width of the serial communication. The 8 in "8n1" for example.
     */
    bits?: number
    /**
     * Parity setting of the serial port.
     */
    parity?: SettingSerialParity
    /**
     * Time to delay between each byte sent to the modem, in microseconds.
     */
    send_delay?: number
    /**
     * Number of stop bits for communication on the serial port.  Either 1 or 2.
     * The 1 in "8n1" for example.
     */
    stopbits?: number
}
class SettingSerial {
    /* Properties of NM-1.0.NM.SettingSerial */
    /**
     * Speed to use for communication over the serial port.  Note that this
     * value usually has no effect for mobile broadband modems as they generally
     * ignore speed settings and use the highest available speed.
     */
    baud: number
    /**
     * Byte-width of the serial communication. The 8 in "8n1" for example.
     */
    bits: number
    /**
     * Parity setting of the serial port.
     */
    parity: SettingSerialParity
    /**
     * Time to delay between each byte sent to the modem, in microseconds.
     */
    send_delay: number
    /**
     * Number of stop bits for communication on the serial port.  Either 1 or 2.
     * The 1 in "8n1" for example.
     */
    stopbits: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingSerial */
    get_baud(): number
    get_bits(): number
    get_parity(): SettingSerialParity
    get_send_delay(): number
    get_stopbits(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::baud", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::baud", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::bits", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bits", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parity", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parity", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::send-delay", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::send-delay", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::stopbits", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::stopbits", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingSerial, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingSerial_ConstructProps)
    _init (config?: SettingSerial_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingSerial
    static $gtype: GObject.Type
}
interface SettingSriov_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingSriov */
    /**
     * Whether to autoprobe virtual functions by a compatible driver.
     * 
     * If set to %NM_TERNARY_TRUE, the kernel will try to bind VFs to
     * a compatible driver and if this succeeds a new network
     * interface will be instantiated for each VF.
     * 
     * If set to %NM_TERNARY_FALSE, VFs will not be claimed and no
     * network interfaces will be created for them.
     * 
     * When set to %NM_TERNARY_DEFAULT, the global default is used; in
     * case the global default is unspecified it is assumed to be
     * %NM_TERNARY_TRUE.
     */
    autoprobe_drivers?: Ternary
    /**
     * The total number of virtual functions to create.
     * 
     * Note that when the sriov setting is present NetworkManager
     * enforces the number of virtual functions on the interface
     * (also when it is zero) during activation and resets it
     * upon deactivation. To prevent any changes to SR-IOV
     * parameters don't add a sriov setting to the connection.
     */
    total_vfs?: number
    /**
     * Array of virtual function descriptors.
     * 
     * Each VF descriptor is a dictionary mapping attribute names
     * to GVariant values. The 'index' entry is mandatory for
     * each VF.
     * 
     * When represented as string a VF is in the form:
     * 
     *   "INDEX [ATTR=VALUE[ ATTR=VALUE]...]".
     * 
     * for example:
     * 
     *   "2 mac=00:11:22:33:44:55 spoof-check=true".
     * 
     * Multiple VFs can be specified using a comma as separator.
     * Currently, the following attributes are supported: mac,
     * spoof-check, trust, min-tx-rate, max-tx-rate, vlans.
     * 
     * The "vlans" attribute is represented as a semicolon-separated
     * list of VLAN descriptors, where each descriptor has the form
     * 
     *   "ID[.PRIORITY[.PROTO]]".
     * 
     * PROTO can be either 'q' for 802.1Q (the default) or 'ad' for
     * 802.1ad.
     */
    vfs?: SriovVF[]
}
class SettingSriov {
    /* Properties of NM-1.0.NM.SettingSriov */
    /**
     * Whether to autoprobe virtual functions by a compatible driver.
     * 
     * If set to %NM_TERNARY_TRUE, the kernel will try to bind VFs to
     * a compatible driver and if this succeeds a new network
     * interface will be instantiated for each VF.
     * 
     * If set to %NM_TERNARY_FALSE, VFs will not be claimed and no
     * network interfaces will be created for them.
     * 
     * When set to %NM_TERNARY_DEFAULT, the global default is used; in
     * case the global default is unspecified it is assumed to be
     * %NM_TERNARY_TRUE.
     */
    autoprobe_drivers: Ternary
    /**
     * The total number of virtual functions to create.
     * 
     * Note that when the sriov setting is present NetworkManager
     * enforces the number of virtual functions on the interface
     * (also when it is zero) during activation and resets it
     * upon deactivation. To prevent any changes to SR-IOV
     * parameters don't add a sriov setting to the connection.
     */
    total_vfs: number
    /**
     * Array of virtual function descriptors.
     * 
     * Each VF descriptor is a dictionary mapping attribute names
     * to GVariant values. The 'index' entry is mandatory for
     * each VF.
     * 
     * When represented as string a VF is in the form:
     * 
     *   "INDEX [ATTR=VALUE[ ATTR=VALUE]...]".
     * 
     * for example:
     * 
     *   "2 mac=00:11:22:33:44:55 spoof-check=true".
     * 
     * Multiple VFs can be specified using a comma as separator.
     * Currently, the following attributes are supported: mac,
     * spoof-check, trust, min-tx-rate, max-tx-rate, vlans.
     * 
     * The "vlans" attribute is represented as a semicolon-separated
     * list of VLAN descriptors, where each descriptor has the form
     * 
     *   "ID[.PRIORITY[.PROTO]]".
     * 
     * PROTO can be either 'q' for 802.1Q (the default) or 'ad' for
     * 802.1ad.
     */
    vfs: SriovVF[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingSriov */
    /**
     * Appends a new VF and associated information to the setting.  The
     * given VF is duplicated internally and is not changed by this function.
     */
    add_vf(vf: SriovVF): void
    /**
     * Removes all configured VFs.
     */
    clear_vfs(): void
    /**
     * Returns the value contained in the #NMSettingSriov:autoprobe-drivers
     * property.
     */
    get_autoprobe_drivers(): Ternary
    get_num_vfs(): number
    /**
     * Returns the value contained in the #NMSettingSriov:total-vfs
     * property.
     */
    get_total_vfs(): number
    get_vf(idx: number): SriovVF
    /**
     * Removes the VF at index `idx`.
     */
    remove_vf(idx: number): void
    /**
     * Removes the VF with VF index `index`.
     */
    remove_vf_by_index(index: number): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::autoprobe-drivers", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::autoprobe-drivers", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::total-vfs", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::total-vfs", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vfs", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vfs", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingSriov, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingSriov_ConstructProps)
    _init (config?: SettingSriov_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingSriov
    static $gtype: GObject.Type
}
interface SettingTCConfig_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingTCConfig */
    /**
     * Array of TC queueing disciplines.
     * 
     * When the #NMSettingTCConfig setting is present, qdiscs from this
     * property are applied upon activation. If the property is empty,
     * all qdiscs are removed and the device will only
     * have the default qdisc assigned by kernel according to the
     * "net.core.default_qdisc" sysctl.
     * 
     * If the #NMSettingTCConfig setting is not present, NetworkManager
     * doesn't touch the qdiscs present on the interface.
     */
    qdiscs?: TCQdisc[]
    /**
     * Array of TC traffic filters.
     * 
     * When the #NMSettingTCConfig setting is present, filters from this
     * property are applied upon activation. If the property is empty,
     * NetworkManager removes all the filters.
     * 
     * If the #NMSettingTCConfig setting is not present, NetworkManager
     * doesn't touch the filters present on the interface.
     */
    tfilters?: TCTfilter[]
}
class SettingTCConfig {
    /* Properties of NM-1.0.NM.SettingTCConfig */
    /**
     * Array of TC queueing disciplines.
     * 
     * When the #NMSettingTCConfig setting is present, qdiscs from this
     * property are applied upon activation. If the property is empty,
     * all qdiscs are removed and the device will only
     * have the default qdisc assigned by kernel according to the
     * "net.core.default_qdisc" sysctl.
     * 
     * If the #NMSettingTCConfig setting is not present, NetworkManager
     * doesn't touch the qdiscs present on the interface.
     */
    qdiscs: TCQdisc[]
    /**
     * Array of TC traffic filters.
     * 
     * When the #NMSettingTCConfig setting is present, filters from this
     * property are applied upon activation. If the property is empty,
     * NetworkManager removes all the filters.
     * 
     * If the #NMSettingTCConfig setting is not present, NetworkManager
     * doesn't touch the filters present on the interface.
     */
    tfilters: TCTfilter[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingTCConfig */
    /**
     * Appends a new qdisc and associated information to the setting.  The
     * given qdisc is duplicated internally and is not changed by this function.
     * If an identical qdisc (considering attributes as well) already exists, the
     * qdisc is not added and the function returns %FALSE.
     */
    add_qdisc(qdisc: TCQdisc): boolean
    /**
     * Appends a new tfilter and associated information to the setting.  The
     * given tfilter is duplicated internally and is not changed by this function.
     * If an identical tfilter (considering attributes as well) already exists, the
     * tfilter is not added and the function returns %FALSE.
     */
    add_tfilter(tfilter: TCTfilter): boolean
    /**
     * Removes all configured queueing disciplines.
     */
    clear_qdiscs(): void
    /**
     * Removes all configured queueing disciplines.
     */
    clear_tfilters(): void
    get_num_qdiscs(): number
    get_num_tfilters(): number
    get_qdisc(idx: number): TCQdisc
    get_tfilter(idx: number): TCTfilter
    /**
     * Removes the qdisc at index `idx`.
     */
    remove_qdisc(idx: number): void
    /**
     * Removes the first matching qdisc that matches `qdisc`.
     */
    remove_qdisc_by_value(qdisc: TCQdisc): boolean
    /**
     * Removes the tfilter at index `idx`.
     */
    remove_tfilter(idx: number): void
    /**
     * Removes the first matching tfilter that matches `tfilter`.
     */
    remove_tfilter_by_value(tfilter: TCTfilter): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::qdiscs", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::qdiscs", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tfilters", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tfilters", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingTCConfig, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingTCConfig_ConstructProps)
    _init (config?: SettingTCConfig_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingTCConfig
    static $gtype: GObject.Type
}
interface SettingTeam_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingTeam */
    /**
     * The JSON configuration for the team network interface.  The property
     * should contain raw JSON configuration data suitable for teamd, because
     * the value is passed directly to teamd. If not specified, the default
     * configuration is used.  See man teamd.conf for the format details.
     */
    config?: string
    /**
     * Link watchers configuration for the connection: each link watcher is
     * defined by a dictionary, whose keys depend upon the selected link
     * watcher. Available link watchers are 'ethtool', 'nsna_ping' and
     * 'arp_ping' and it is specified in the dictionary with the key 'name'.
     * Available keys are:   ethtool: 'delay-up', 'delay-down', 'init-wait';
     * nsna_ping: 'init-wait', 'interval', 'missed-max', 'target-host';
     * arp_ping: all the ones in nsna_ping and 'source-host', 'validate-active',
     * 'validate-inactive', 'send-always'. See teamd.conf man for more details.
     */
    link_watchers?: TeamLinkWatcher[]
    /**
     * Corresponds to the teamd mcast_rejoin.count.
     */
    mcast_rejoin_count?: number
    /**
     * Corresponds to the teamd mcast_rejoin.interval.
     */
    mcast_rejoin_interval?: number
    /**
     * Corresponds to the teamd notify_peers.count.
     */
    notify_peers_count?: number
    /**
     * Corresponds to the teamd notify_peers.interval.
     */
    notify_peers_interval?: number
    /**
     * Corresponds to the teamd runner.name.
     * Permitted values are: "roundrobin", "broadcast", "activebackup",
     * "loadbalance", "lacp", "random".
     */
    runner?: string
    /**
     * Corresponds to the teamd runner.active.
     */
    runner_active?: boolean
    /**
     * Corresponds to the teamd runner.agg_select_policy.
     */
    runner_agg_select_policy?: string
    /**
     * Corresponds to the teamd runner.fast_rate.
     */
    runner_fast_rate?: boolean
    /**
     * Corresponds to the teamd runner.hwaddr_policy.
     */
    runner_hwaddr_policy?: string
    /**
     * Corresponds to the teamd runner.min_ports.
     */
    runner_min_ports?: number
    /**
     * Corresponds to the teamd runner.sys_prio.
     */
    runner_sys_prio?: number
    /**
     * Corresponds to the teamd runner.tx_balancer.name.
     */
    runner_tx_balancer?: string
    /**
     * Corresponds to the teamd runner.tx_balancer.interval.
     */
    runner_tx_balancer_interval?: number
    /**
     * Corresponds to the teamd runner.tx_hash.
     */
    runner_tx_hash?: string[]
}
class SettingTeam {
    /* Properties of NM-1.0.NM.SettingTeam */
    /**
     * The JSON configuration for the team network interface.  The property
     * should contain raw JSON configuration data suitable for teamd, because
     * the value is passed directly to teamd. If not specified, the default
     * configuration is used.  See man teamd.conf for the format details.
     */
    config: string
    /**
     * Link watchers configuration for the connection: each link watcher is
     * defined by a dictionary, whose keys depend upon the selected link
     * watcher. Available link watchers are 'ethtool', 'nsna_ping' and
     * 'arp_ping' and it is specified in the dictionary with the key 'name'.
     * Available keys are:   ethtool: 'delay-up', 'delay-down', 'init-wait';
     * nsna_ping: 'init-wait', 'interval', 'missed-max', 'target-host';
     * arp_ping: all the ones in nsna_ping and 'source-host', 'validate-active',
     * 'validate-inactive', 'send-always'. See teamd.conf man for more details.
     */
    link_watchers: TeamLinkWatcher[]
    /**
     * Corresponds to the teamd mcast_rejoin.count.
     */
    mcast_rejoin_count: number
    /**
     * Corresponds to the teamd mcast_rejoin.interval.
     */
    mcast_rejoin_interval: number
    /**
     * Corresponds to the teamd notify_peers.count.
     */
    notify_peers_count: number
    /**
     * Corresponds to the teamd notify_peers.interval.
     */
    notify_peers_interval: number
    /**
     * Corresponds to the teamd runner.name.
     * Permitted values are: "roundrobin", "broadcast", "activebackup",
     * "loadbalance", "lacp", "random".
     */
    runner: string
    /**
     * Corresponds to the teamd runner.active.
     */
    runner_active: boolean
    /**
     * Corresponds to the teamd runner.agg_select_policy.
     */
    runner_agg_select_policy: string
    /**
     * Corresponds to the teamd runner.fast_rate.
     */
    runner_fast_rate: boolean
    /**
     * Corresponds to the teamd runner.hwaddr_policy.
     */
    runner_hwaddr_policy: string
    /**
     * Corresponds to the teamd runner.min_ports.
     */
    runner_min_ports: number
    /**
     * Corresponds to the teamd runner.sys_prio.
     */
    runner_sys_prio: number
    /**
     * Corresponds to the teamd runner.tx_balancer.name.
     */
    runner_tx_balancer: string
    /**
     * Corresponds to the teamd runner.tx_balancer.interval.
     */
    runner_tx_balancer_interval: number
    /**
     * Corresponds to the teamd runner.tx_hash.
     */
    runner_tx_hash: string[]
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingTeam */
    /**
     * Appends a new link watcher to the setting.
     */
    add_link_watcher(link_watcher: TeamLinkWatcher): boolean
    /**
     * Adds a new txhash element to the setting.
     */
    add_runner_tx_hash(txhash: string): boolean
    /**
     * Removes all configured link watchers.
     */
    clear_link_watchers(): void
    get_config(): string
    get_link_watcher(idx: number): TeamLinkWatcher
    get_mcast_rejoin_count(): number
    get_mcast_rejoin_interval(): number
    get_notify_peers_count(): number
    get_notify_peers_interval(): number
    get_num_link_watchers(): number
    get_num_runner_tx_hash(): number
    get_runner(): string
    get_runner_active(): boolean
    get_runner_agg_select_policy(): string
    get_runner_fast_rate(): boolean
    get_runner_hwaddr_policy(): string
    get_runner_min_ports(): number
    get_runner_sys_prio(): number
    get_runner_tx_balancer(): string
    get_runner_tx_balancer_interval(): number
    get_runner_tx_hash(idx: number): string
    /**
     * Removes the link watcher at index #idx.
     */
    remove_link_watcher(idx: number): void
    /**
     * Removes the link watcher entry matching link_watcher.
     */
    remove_link_watcher_by_value(link_watcher: TeamLinkWatcher): boolean
    /**
     * Removes the txhash element at index `idx`.
     */
    remove_runner_tx_hash(idx: number): void
    /**
     * Removes the txhash element #txhash
     */
    remove_runner_tx_hash_by_value(txhash: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::config", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::config", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::link-watchers", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::link-watchers", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mcast-rejoin-count", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mcast-rejoin-count", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mcast-rejoin-interval", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mcast-rejoin-interval", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::notify-peers-count", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::notify-peers-count", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::notify-peers-interval", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::notify-peers-interval", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-active", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-active", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-agg-select-policy", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-agg-select-policy", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-fast-rate", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-fast-rate", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-hwaddr-policy", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-hwaddr-policy", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-min-ports", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-min-ports", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-sys-prio", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-sys-prio", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-tx-balancer", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-tx-balancer", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-tx-balancer-interval", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-tx-balancer-interval", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::runner-tx-hash", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::runner-tx-hash", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingTeam, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingTeam_ConstructProps)
    _init (config?: SettingTeam_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingTeam
    static $gtype: GObject.Type
}
interface SettingTeamPort_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingTeamPort */
    /**
     * The JSON configuration for the team port. The property should contain raw
     * JSON configuration data suitable for teamd, because the value is passed
     * directly to teamd. If not specified, the default configuration is
     * used. See man teamd.conf for the format details.
     */
    config?: string
    /**
     * Corresponds to the teamd ports.PORTIFNAME.lacp_key.
     */
    lacp_key?: number
    /**
     * Corresponds to the teamd ports.PORTIFNAME.lacp_prio.
     */
    lacp_prio?: number
    /**
     * Link watchers configuration for the connection: each link watcher is
     * defined by a dictionary, whose keys depend upon the selected link
     * watcher. Available link watchers are 'ethtool', 'nsna_ping' and
     * 'arp_ping' and it is specified in the dictionary with the key 'name'.
     * Available keys are:   ethtool: 'delay-up', 'delay-down', 'init-wait';
     * nsna_ping: 'init-wait', 'interval', 'missed-max', 'target-host';
     * arp_ping: all the ones in nsna_ping and 'source-host', 'validate-active',
     * 'validate-inactive', 'send-always'. See teamd.conf man for more details.
     */
    link_watchers?: TeamLinkWatcher[]
    /**
     * Corresponds to the teamd ports.PORTIFNAME.prio.
     */
    prio?: number
    /**
     * Corresponds to the teamd ports.PORTIFNAME.queue_id.
     * When set to -1 means the parameter is skipped from the json config.
     */
    queue_id?: number
    /**
     * Corresponds to the teamd ports.PORTIFNAME.sticky.
     */
    sticky?: boolean
}
class SettingTeamPort {
    /* Properties of NM-1.0.NM.SettingTeamPort */
    /**
     * The JSON configuration for the team port. The property should contain raw
     * JSON configuration data suitable for teamd, because the value is passed
     * directly to teamd. If not specified, the default configuration is
     * used. See man teamd.conf for the format details.
     */
    config: string
    /**
     * Corresponds to the teamd ports.PORTIFNAME.lacp_key.
     */
    lacp_key: number
    /**
     * Corresponds to the teamd ports.PORTIFNAME.lacp_prio.
     */
    lacp_prio: number
    /**
     * Link watchers configuration for the connection: each link watcher is
     * defined by a dictionary, whose keys depend upon the selected link
     * watcher. Available link watchers are 'ethtool', 'nsna_ping' and
     * 'arp_ping' and it is specified in the dictionary with the key 'name'.
     * Available keys are:   ethtool: 'delay-up', 'delay-down', 'init-wait';
     * nsna_ping: 'init-wait', 'interval', 'missed-max', 'target-host';
     * arp_ping: all the ones in nsna_ping and 'source-host', 'validate-active',
     * 'validate-inactive', 'send-always'. See teamd.conf man for more details.
     */
    link_watchers: TeamLinkWatcher[]
    /**
     * Corresponds to the teamd ports.PORTIFNAME.prio.
     */
    prio: number
    /**
     * Corresponds to the teamd ports.PORTIFNAME.queue_id.
     * When set to -1 means the parameter is skipped from the json config.
     */
    queue_id: number
    /**
     * Corresponds to the teamd ports.PORTIFNAME.sticky.
     */
    sticky: boolean
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingTeamPort */
    /**
     * Appends a new link watcher to the setting.
     */
    add_link_watcher(link_watcher: TeamLinkWatcher): boolean
    /**
     * Removes all configured link watchers.
     */
    clear_link_watchers(): void
    get_config(): string
    get_lacp_key(): number
    get_lacp_prio(): number
    get_link_watcher(idx: number): TeamLinkWatcher
    get_num_link_watchers(): number
    get_prio(): number
    get_queue_id(): number
    get_sticky(): boolean
    /**
     * Removes the link watcher at index #idx.
     */
    remove_link_watcher(idx: number): void
    /**
     * Removes the link watcher entry matching link_watcher.
     */
    remove_link_watcher_by_value(link_watcher: TeamLinkWatcher): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::config", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::config", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lacp-key", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lacp-key", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::lacp-prio", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::lacp-prio", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::link-watchers", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::link-watchers", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::prio", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prio", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::queue-id", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::queue-id", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::sticky", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sticky", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingTeamPort, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingTeamPort_ConstructProps)
    _init (config?: SettingTeamPort_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingTeamPort
    static $gtype: GObject.Type
}
interface SettingTun_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingTun */
    /**
     * The group ID which will own the device. If set to %NULL everyone
     * will be able to use the device.
     */
    group?: string
    /**
     * The operating mode of the virtual device. Allowed values are
     * %NM_SETTING_TUN_MODE_TUN to create a layer 3 device and
     * %NM_SETTING_TUN_MODE_TAP to create an Ethernet-like layer 2
     * one.
     */
    mode?: number
    /**
     * If the property is set to %TRUE, the interface will support
     * multiple file descriptors (queues) to parallelize packet
     * sending or receiving. Otherwise, the interface will only
     * support a single queue.
     */
    multi_queue?: boolean
    /**
     * The user ID which will own the device. If set to %NULL everyone
     * will be able to use the device.
     */
    owner?: string
    /**
     * If %TRUE the interface will prepend a 4 byte header describing the
     * physical interface to the packets.
     */
    pi?: boolean
    /**
     * If %TRUE the IFF_VNET_HDR the tunnel packets will include a virtio
     * network header.
     */
    vnet_hdr?: boolean
}
class SettingTun {
    /* Properties of NM-1.0.NM.SettingTun */
    /**
     * The group ID which will own the device. If set to %NULL everyone
     * will be able to use the device.
     */
    group: string
    /**
     * The operating mode of the virtual device. Allowed values are
     * %NM_SETTING_TUN_MODE_TUN to create a layer 3 device and
     * %NM_SETTING_TUN_MODE_TAP to create an Ethernet-like layer 2
     * one.
     */
    mode: number
    /**
     * If the property is set to %TRUE, the interface will support
     * multiple file descriptors (queues) to parallelize packet
     * sending or receiving. Otherwise, the interface will only
     * support a single queue.
     */
    multi_queue: boolean
    /**
     * The user ID which will own the device. If set to %NULL everyone
     * will be able to use the device.
     */
    owner: string
    /**
     * If %TRUE the interface will prepend a 4 byte header describing the
     * physical interface to the packets.
     */
    pi: boolean
    /**
     * If %TRUE the IFF_VNET_HDR the tunnel packets will include a virtio
     * network header.
     */
    vnet_hdr: boolean
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingTun */
    get_group(): string
    get_mode(): SettingTunMode
    get_multi_queue(): boolean
    get_owner(): string
    get_pi(): boolean
    get_vnet_hdr(): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::group", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::multi-queue", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::multi-queue", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::owner", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::owner", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pi", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pi", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vnet-hdr", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vnet-hdr", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingTun, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingTun_ConstructProps)
    _init (config?: SettingTun_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingTun
    static $gtype: GObject.Type
}
interface SettingUser_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingUser */
    /**
     * A dictionary of key/value pairs with user data. This data is ignored by NetworkManager
     * and can be used at the users discretion. The keys only support a strict ascii format,
     * but the values can be arbitrary UTF8 strings up to a certain length.
     */
    data?: GLib.HashTable
}
class SettingUser {
    /* Properties of NM-1.0.NM.SettingUser */
    /**
     * A dictionary of key/value pairs with user data. This data is ignored by NetworkManager
     * and can be used at the users discretion. The keys only support a strict ascii format,
     * but the values can be arbitrary UTF8 strings up to a certain length.
     */
    data: GLib.HashTable
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingUser */
    get_data(key: string): string
    get_keys(): string[]
    set_data(key: string, val?: string | null): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingUser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingUser, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::data", callback: (($obj: SettingUser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::data", callback: (($obj: SettingUser, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingUser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingUser, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingUser_ConstructProps)
    _init (config?: SettingUser_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingUser
    /**
     * Checks whether `key` is a valid user data key. This means,
     * key is not %NULL, not too large and valid ASCII. Also,
     * only digits and numbers are allowed with a few special
     * characters. The key must contain at least one '.' and
     * look like a fully qualified DNS name.
     */
    static check_key(key: string): boolean
    /**
     * Checks whether `val` is a valid user data value. This means,
     * value is not %NULL, not too large and valid UTF-8.
     */
    static check_val(val: string): boolean
    static $gtype: GObject.Type
}
interface SettingVeth_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingVeth */
    /**
     * This property specifies the peer interface name of the veth. This
     * property is mandatory.
     */
    peer?: string
}
class SettingVeth {
    /* Properties of NM-1.0.NM.SettingVeth */
    /**
     * This property specifies the peer interface name of the veth. This
     * property is mandatory.
     */
    peer: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingVeth */
    get_peer(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingVeth, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::peer", callback: (($obj: SettingVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer", callback: (($obj: SettingVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingVeth, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingVeth, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingVeth_ConstructProps)
    _init (config?: SettingVeth_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingVeth
    static $gtype: GObject.Type
}
interface SettingVlan_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingVlan */
    /**
     * For outgoing packets, a list of mappings from Linux SKB priorities to
     * 802.1p priorities.  The mapping is given in the format "from:to" where
     * both "from" and "to" are unsigned integers, ie "7:3".
     */
    egress_priority_map?: string[]
    /**
     * One or more flags which control the behavior and features of the VLAN
     * interface.  Flags include %NM_VLAN_FLAG_REORDER_HEADERS (reordering of
     * output packet headers), %NM_VLAN_FLAG_GVRP (use of the GVRP protocol),
     * and %NM_VLAN_FLAG_LOOSE_BINDING (loose binding of the interface to its
     * master device's operating state). %NM_VLAN_FLAG_MVRP (use of the MVRP
     * protocol).
     * 
     * The default value of this property is NM_VLAN_FLAG_REORDER_HEADERS,
     * but it used to be 0. To preserve backward compatibility, the default-value
     * in the D-Bus API continues to be 0 and a missing property on D-Bus
     * is still considered as 0.
     */
    flags?: VlanFlags
    /**
     * The VLAN identifier that the interface created by this connection should
     * be assigned. The valid range is from 0 to 4094, without the reserved id 4095.
     */
    id?: number
    /**
     * For incoming packets, a list of mappings from 802.1p priorities to Linux
     * SKB priorities.  The mapping is given in the format "from:to" where both
     * "from" and "to" are unsigned integers, ie "7:3".
     */
    ingress_priority_map?: string[]
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this VLAN interface should be created.  If this property is
     * not specified, the connection must contain an #NMSettingWired setting
     * with a #NMSettingWired:mac-address property.
     */
    parent?: string
}
class SettingVlan {
    /* Properties of NM-1.0.NM.SettingVlan */
    /**
     * For outgoing packets, a list of mappings from Linux SKB priorities to
     * 802.1p priorities.  The mapping is given in the format "from:to" where
     * both "from" and "to" are unsigned integers, ie "7:3".
     */
    egress_priority_map: string[]
    /**
     * One or more flags which control the behavior and features of the VLAN
     * interface.  Flags include %NM_VLAN_FLAG_REORDER_HEADERS (reordering of
     * output packet headers), %NM_VLAN_FLAG_GVRP (use of the GVRP protocol),
     * and %NM_VLAN_FLAG_LOOSE_BINDING (loose binding of the interface to its
     * master device's operating state). %NM_VLAN_FLAG_MVRP (use of the MVRP
     * protocol).
     * 
     * The default value of this property is NM_VLAN_FLAG_REORDER_HEADERS,
     * but it used to be 0. To preserve backward compatibility, the default-value
     * in the D-Bus API continues to be 0 and a missing property on D-Bus
     * is still considered as 0.
     */
    flags: VlanFlags
    /**
     * The VLAN identifier that the interface created by this connection should
     * be assigned. The valid range is from 0 to 4094, without the reserved id 4095.
     */
    id: number
    /**
     * For incoming packets, a list of mappings from 802.1p priorities to Linux
     * SKB priorities.  The mapping is given in the format "from:to" where both
     * "from" and "to" are unsigned integers, ie "7:3".
     */
    ingress_priority_map: string[]
    /**
     * If given, specifies the parent interface name or parent connection UUID
     * from which this VLAN interface should be created.  If this property is
     * not specified, the connection must contain an #NMSettingWired setting
     * with a #NMSettingWired:mac-address property.
     */
    parent: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingVlan */
    /**
     * Adds a priority mapping to the #NMSettingVlan:ingress_priority_map or
     * #NMSettingVlan:egress_priority_map properties of the setting. If `from` is
     * already in the given priority map, this function will overwrite the
     * existing entry with the new `to`.
     * 
     * If `map` is #NM_VLAN_INGRESS_MAP then `from` is the incoming 802.1q VLAN
     * Priority Code Point (PCP) value, and `to` is the Linux SKB priority value.
     * 
     * If `map` is #NM_VLAN_EGRESS_MAP then `from` is the Linux SKB priority value and
     * `to` is the outgoing 802.1q VLAN Priority Code Point (PCP) value.
     */
    add_priority(map: VlanPriorityMap, from: number, to: number): boolean
    /**
     * Adds a priority map entry into either the #NMSettingVlan:ingress_priority_map
     * or the #NMSettingVlan:egress_priority_map properties.  The priority map maps
     * the Linux SKB priorities to 802.1p priorities.
     */
    add_priority_str(map: VlanPriorityMap, str: string): boolean
    /**
     * Clear all the entries from #NMSettingVlan:ingress_priority_map or
     * #NMSettingVlan:egress_priority_map properties.
     */
    clear_priorities(map: VlanPriorityMap): void
    get_flags(): number
    get_id(): number
    /**
     * Returns the number of entries in the
     * #NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
     * properties of this setting.
     */
    get_num_priorities(map: VlanPriorityMap): number
    get_parent(): string
    /**
     * Retrieve one of the entries of the #NMSettingVlan:ingress_priority_map
     * or #NMSettingVlan:egress_priority_map properties of this setting.
     */
    get_priority(map: VlanPriorityMap, idx: number): [ /* returnType */ boolean, /* out_from */ number | null, /* out_to */ number | null ]
    /**
     * Removes the priority map at index `idx` from the
     * #NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
     * properties.
     */
    remove_priority(map: VlanPriorityMap, idx: number): void
    /**
     * Removes the priority map `form:``to` from the #NMSettingVlan:ingress_priority_map
     * or #NMSettingVlan:egress_priority_map (according to `map` argument)
     * properties.
     */
    remove_priority_by_value(map: VlanPriorityMap, from: number, to: number): boolean
    /**
     * Removes the priority map `str` from the #NMSettingVlan:ingress_priority_map
     * or #NMSettingVlan:egress_priority_map (according to `map` argument)
     * properties.
     */
    remove_priority_str_by_value(map: VlanPriorityMap, str: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::egress-priority-map", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::egress-priority-map", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::flags", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ingress-priority-map", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ingress-priority-map", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingVlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingVlan_ConstructProps)
    _init (config?: SettingVlan_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingVlan
    static $gtype: GObject.Type
}
interface SettingVpn_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingVpn */
    /**
     * Dictionary of key/value pairs of VPN plugin specific data.  Both keys and
     * values must be strings.
     */
    data?: GLib.HashTable
    /**
     * If the VPN service supports persistence, and this property is %TRUE,
     * the VPN will attempt to stay connected across link changes and outages,
     * until explicitly disconnected.
     */
    persistent?: boolean
    /**
     * Dictionary of key/value pairs of VPN plugin specific secrets like
     * passwords or private keys.  Both keys and values must be strings.
     */
    secrets?: GLib.HashTable
    /**
     * D-Bus service name of the VPN plugin that this setting uses to connect to
     * its network.  i.e. org.freedesktop.NetworkManager.vpnc for the vpnc
     * plugin.
     */
    service_type?: string
    /**
     * Timeout for the VPN service to establish the connection. Some services
     * may take quite a long time to connect.
     * Value of 0 means a default timeout, which is 60 seconds (unless overridden
     * by vpn.timeout in configuration file). Values greater than zero mean
     * timeout in seconds.
     */
    timeout?: number
    /**
     * If the VPN connection requires a user name for authentication, that name
     * should be provided here.  If the connection is available to more than one
     * user, and the VPN requires each user to supply a different name, then
     * leave this property empty.  If this property is empty, NetworkManager
     * will automatically supply the username of the user which requested the
     * VPN connection.
     */
    user_name?: string
}
class SettingVpn {
    /* Properties of NM-1.0.NM.SettingVpn */
    /**
     * Dictionary of key/value pairs of VPN plugin specific data.  Both keys and
     * values must be strings.
     */
    data: GLib.HashTable
    /**
     * If the VPN service supports persistence, and this property is %TRUE,
     * the VPN will attempt to stay connected across link changes and outages,
     * until explicitly disconnected.
     */
    persistent: boolean
    /**
     * Dictionary of key/value pairs of VPN plugin specific secrets like
     * passwords or private keys.  Both keys and values must be strings.
     */
    secrets: GLib.HashTable
    /**
     * D-Bus service name of the VPN plugin that this setting uses to connect to
     * its network.  i.e. org.freedesktop.NetworkManager.vpnc for the vpnc
     * plugin.
     */
    service_type: string
    /**
     * Timeout for the VPN service to establish the connection. Some services
     * may take quite a long time to connect.
     * Value of 0 means a default timeout, which is 60 seconds (unless overridden
     * by vpn.timeout in configuration file). Values greater than zero mean
     * timeout in seconds.
     */
    timeout: number
    /**
     * If the VPN connection requires a user name for authentication, that name
     * should be provided here.  If the connection is available to more than one
     * user, and the VPN requires each user to supply a different name, then
     * leave this property empty.  If this property is empty, NetworkManager
     * will automatically supply the username of the user which requested the
     * VPN connection.
     */
    user_name: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingVpn */
    /**
     * Establishes a relationship between `key` and `item` internally in the
     * setting which may be retrieved later.  Should not be used to store passwords
     * or other secrets, which is what nm_setting_vpn_add_secret() is for.
     * 
     * Before 1.24, `item` must not be %NULL and not an empty string. Since 1.24,
     * `item` can be set to an empty string. It can also be set to %NULL to unset
     * the key. In that case, the behavior is as if calling nm_setting_vpn_remove_data_item().
     */
    add_data_item(key: string, item?: string | null): void
    /**
     * Establishes a relationship between `key` and `secret` internally in the
     * setting which may be retrieved later.
     * 
     * Before 1.24, `secret` must not be %NULL and not an empty string. Since 1.24,
     * `secret` can be set to an empty string. It can also be set to %NULL to unset
     * the key. In that case, the behavior is as if calling nm_setting_vpn_remove_secret().
     */
    add_secret(key: string, secret?: string | null): void
    /**
     * Iterates all data items stored in this setting.  It is safe to add, remove,
     * and modify data items inside `func,` though any additions or removals made
     * during iteration will not be part of the iteration.
     */
    foreach_data_item(func: VpnIterFunc): void
    /**
     * Iterates all secrets stored in this setting.  It is safe to add, remove,
     * and modify secrets inside `func,` though any additions or removals made during
     * iteration will not be part of the iteration.
     */
    foreach_secret(func: VpnIterFunc): void
    /**
     * Retrieves the data item of a key/value relationship previously established
     * by nm_setting_vpn_add_data_item().
     */
    get_data_item(key: string): string
    /**
     * Retrieves every data key inside `setting,` as an array.
     */
    get_data_keys(): string[]
    /**
     * Gets number of key/value pairs of VPN configuration data.
     */
    get_num_data_items(): number
    /**
     * Gets number of VPN plugin specific secrets in the setting.
     */
    get_num_secrets(): number
    get_persistent(): boolean
    /**
     * Retrieves the secret of a key/value relationship previously established
     * by nm_setting_vpn_add_secret().
     */
    get_secret(key: string): string
    /**
     * Retrieves every secret key inside `setting,` as an array.
     */
    get_secret_keys(): string[]
    /**
     * Returns the service name of the VPN, which identifies the specific VPN
     * plugin that should be used to connect to this VPN.
     */
    get_service_type(): string
    get_timeout(): number
    get_user_name(): string
    /**
     * Deletes a key/value relationship previously established by
     * nm_setting_vpn_add_data_item().
     */
    remove_data_item(key: string): boolean
    /**
     * Deletes a key/value relationship previously established by
     * nm_setting_vpn_add_secret().
     */
    remove_secret(key: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::data", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::data", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::persistent", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::persistent", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::secrets", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::secrets", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::service-type", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service-type", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::timeout", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeout", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::user-name", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::user-name", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingVpn, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingVpn_ConstructProps)
    _init (config?: SettingVpn_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingVpn
    static $gtype: GObject.Type
}
interface SettingVrf_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingVrf */
    /**
     * The routing table for this VRF.
     */
    table?: number
}
class SettingVrf {
    /* Properties of NM-1.0.NM.SettingVrf */
    /**
     * The routing table for this VRF.
     */
    table: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingVrf */
    get_table(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingVrf, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::table", callback: (($obj: SettingVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::table", callback: (($obj: SettingVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingVrf, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingVrf, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingVrf_ConstructProps)
    _init (config?: SettingVrf_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingVrf
    static $gtype: GObject.Type
}
interface SettingVxlan_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingVxlan */
    /**
     * Specifies the lifetime in seconds of FDB entries learnt by the kernel.
     */
    ageing?: number
    /**
     * Specifies the UDP destination port to communicate to the remote VXLAN
     * tunnel endpoint.
     */
    destination_port?: number
    /**
     * Specifies the VXLAN Network Identifier (or VXLAN Segment Identifier) to
     * use.
     */
    id?: number
    /**
     * Specifies whether netlink LL ADDR miss notifications are generated.
     */
    l2_miss?: boolean
    /**
     * Specifies whether netlink IP ADDR miss notifications are generated.
     */
    l3_miss?: boolean
    /**
     * Specifies whether unknown source link layer addresses and IP addresses
     * are entered into the VXLAN device forwarding database.
     */
    learning?: boolean
    /**
     * Specifies the maximum number of FDB entries. A value of zero means that
     * the kernel will store unlimited entries.
     */
    limit?: number
    /**
     * If given, specifies the source IP address to use in outgoing packets.
     */
    local?: string
    /**
     * If given, specifies the parent interface name or parent connection UUID.
     */
    parent?: string
    /**
     * Specifies whether ARP proxy is turned on.
     */
    proxy?: boolean
    /**
     * Specifies the unicast destination IP address to use in outgoing packets
     * when the destination link layer address is not known in the VXLAN device
     * forwarding database, or the multicast IP address to join.
     */
    remote?: string
    /**
     * Specifies whether route short circuit is turned on.
     */
    rsc?: boolean
    /**
     * Specifies the maximum UDP source port to communicate to the remote VXLAN
     * tunnel endpoint.
     */
    source_port_max?: number
    /**
     * Specifies the minimum UDP source port to communicate to the remote VXLAN
     * tunnel endpoint.
     */
    source_port_min?: number
    /**
     * Specifies the TOS value to use in outgoing packets.
     */
    tos?: number
    /**
     * Specifies the time-to-live value to use in outgoing packets.
     */
    ttl?: number
}
class SettingVxlan {
    /* Properties of NM-1.0.NM.SettingVxlan */
    /**
     * Specifies the lifetime in seconds of FDB entries learnt by the kernel.
     */
    ageing: number
    /**
     * Specifies the UDP destination port to communicate to the remote VXLAN
     * tunnel endpoint.
     */
    destination_port: number
    /**
     * Specifies the VXLAN Network Identifier (or VXLAN Segment Identifier) to
     * use.
     */
    id: number
    /**
     * Specifies whether netlink LL ADDR miss notifications are generated.
     */
    l2_miss: boolean
    /**
     * Specifies whether netlink IP ADDR miss notifications are generated.
     */
    l3_miss: boolean
    /**
     * Specifies whether unknown source link layer addresses and IP addresses
     * are entered into the VXLAN device forwarding database.
     */
    learning: boolean
    /**
     * Specifies the maximum number of FDB entries. A value of zero means that
     * the kernel will store unlimited entries.
     */
    limit: number
    /**
     * If given, specifies the source IP address to use in outgoing packets.
     */
    local: string
    /**
     * If given, specifies the parent interface name or parent connection UUID.
     */
    parent: string
    /**
     * Specifies whether ARP proxy is turned on.
     */
    proxy: boolean
    /**
     * Specifies the unicast destination IP address to use in outgoing packets
     * when the destination link layer address is not known in the VXLAN device
     * forwarding database, or the multicast IP address to join.
     */
    remote: string
    /**
     * Specifies whether route short circuit is turned on.
     */
    rsc: boolean
    /**
     * Specifies the maximum UDP source port to communicate to the remote VXLAN
     * tunnel endpoint.
     */
    source_port_max: number
    /**
     * Specifies the minimum UDP source port to communicate to the remote VXLAN
     * tunnel endpoint.
     */
    source_port_min: number
    /**
     * Specifies the TOS value to use in outgoing packets.
     */
    tos: number
    /**
     * Specifies the time-to-live value to use in outgoing packets.
     */
    ttl: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingVxlan */
    get_ageing(): number
    get_destination_port(): number
    get_id(): number
    get_l2_miss(): boolean
    get_l3_miss(): boolean
    get_learning(): boolean
    get_limit(): number
    get_local(): string
    get_parent(): string
    get_proxy(): boolean
    get_remote(): string
    get_rsc(): boolean
    get_source_port_max(): number
    get_source_port_min(): number
    get_tos(): number
    get_ttl(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::ageing", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ageing", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::destination-port", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::destination-port", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::l2-miss", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::l2-miss", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::l3-miss", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::l3-miss", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::learning", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::learning", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::limit", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::limit", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::local", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::parent", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parent", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proxy", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proxy", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::remote", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::remote", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::rsc", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rsc", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::source-port-max", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source-port-max", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::source-port-min", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::source-port-min", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tos", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tos", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ttl", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ttl", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingVxlan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingVxlan_ConstructProps)
    _init (config?: SettingVxlan_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingVxlan
    static $gtype: GObject.Type
}
interface SettingWifiP2P_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingWifiP2P */
    /**
     * The P2P device that should be connected to. Currently, this is the only
     * way to create or join a group.
     */
    peer?: string
    /**
     * The Wi-Fi Display (WFD) Information Elements (IEs) to set.
     * 
     * Wi-Fi Display requires a protocol specific information element to be
     * set in certain Wi-Fi frames. These can be specified here for the
     * purpose of establishing a connection.
     * This setting is only useful when implementing a Wi-Fi Display client.
     */
    wfd_ies?: GLib.Bytes
    /**
     * Flags indicating which mode of WPS is to be used.
     * 
     * There's little point in changing the default setting as NetworkManager will
     * automatically determine the best method to use.
     */
    wps_method?: number
}
class SettingWifiP2P {
    /* Properties of NM-1.0.NM.SettingWifiP2P */
    /**
     * The P2P device that should be connected to. Currently, this is the only
     * way to create or join a group.
     */
    peer: string
    /**
     * The Wi-Fi Display (WFD) Information Elements (IEs) to set.
     * 
     * Wi-Fi Display requires a protocol specific information element to be
     * set in certain Wi-Fi frames. These can be specified here for the
     * purpose of establishing a connection.
     * This setting is only useful when implementing a Wi-Fi Display client.
     */
    wfd_ies: GLib.Bytes
    /**
     * Flags indicating which mode of WPS is to be used.
     * 
     * There's little point in changing the default setting as NetworkManager will
     * automatically determine the best method to use.
     */
    wps_method: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingWifiP2P */
    get_peer(): string
    get_wfd_ies(): GLib.Bytes
    get_wps_method(): SettingWirelessSecurityWpsMethod
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::peer", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wfd-ies", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wfd-ies", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wps-method", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wps-method", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingWifiP2P, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingWifiP2P_ConstructProps)
    _init (config?: SettingWifiP2P_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingWifiP2P
    static $gtype: GObject.Type
}
interface SettingWimax_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingWimax */
    /**
     * If specified, this connection will only apply to the WiMAX device whose
     * MAC address matches. This property does not change the MAC address of the
     * device (known as MAC spoofing).
     */
    mac_address?: string
    /**
     * Network Service Provider (NSP) name of the WiMAX network this connection
     * should use.
     */
    network_name?: string
}
class SettingWimax {
    /* Properties of NM-1.0.NM.SettingWimax */
    /**
     * If specified, this connection will only apply to the WiMAX device whose
     * MAC address matches. This property does not change the MAC address of the
     * device (known as MAC spoofing).
     */
    mac_address: string
    /**
     * Network Service Provider (NSP) name of the WiMAX network this connection
     * should use.
     */
    network_name: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingWimax */
    /**
     * Returns the MAC address of a WiMAX device which this connection is locked
     * to.
     */
    get_mac_address(): string
    /**
     * Returns the WiMAX NSP name (ex "Sprint" or "CLEAR") which identifies the
     * specific WiMAX network this setting describes a connection to.
     */
    get_network_name(): string
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::mac-address", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::network-name", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::network-name", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingWimax, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingWimax_ConstructProps)
    _init (config?: SettingWimax_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingWimax
    static $gtype: GObject.Type
}
interface SettingWireGuard_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingWireGuard */
    /**
     * The use of fwmark is optional and is by default off. Setting it to 0
     * disables it. Otherwise, it is a 32-bit fwmark for outgoing packets.
     * 
     * Note that "ip4-auto-default-route" or "ip6-auto-default-route" enabled,
     * implies to automatically choose a fwmark.
     */
    fwmark?: number
    /**
     * Whether to enable special handling of the IPv4 default route.
     * If enabled, the IPv4 default route from wireguard.peer-routes
     * will be placed to a dedicated routing-table and two policy routing rules
     * will be added. The fwmark number is also used as routing-table for the default-route,
     * and if fwmark is zero, an unused fwmark/table is chosen automatically.
     * This corresponds to what wg-quick does with Table=auto and what WireGuard
     * calls "Improved Rule-based Routing".
     * 
     * Note that for this automatism to work, you usually don't want to set
     * ipv4.gateway, because that will result in a conflicting default route.
     * 
     * Leaving this at the default will enable this option automatically
     * if ipv4.never-default is not set and there are any peers that use
     * a default-route as allowed-ips.
     */
    ip4_auto_default_route?: Ternary
    /**
     * Like ip4-auto-default-route, but for the IPv6 default route.
     */
    ip6_auto_default_route?: Ternary
    /**
     * The listen-port. If listen-port is not specified, the port will be chosen
     * randomly when the interface comes up.
     */
    listen_port?: number
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple fragments.
     * 
     * If zero a default MTU is used. Note that contrary to wg-quick's MTU
     * setting, this does not take into account the current routes at the
     * time of activation.
     */
    mtu?: number
    /**
     * Whether to automatically add routes for the AllowedIPs ranges
     * of the peers. If %TRUE (the default), NetworkManager will automatically
     * add routes in the routing tables according to ipv4.route-table and
     * ipv6.route-table. Usually you want this automatism enabled.
     * If %FALSE, no such routes are added automatically. In this case, the
     * user may want to configure static routes in ipv4.routes and ipv6.routes,
     * respectively.
     * 
     * Note that if the peer's AllowedIPs is "0.0.0.0/0" or "::/0" and the profile's
     * ipv4.never-default or ipv6.never-default setting is enabled, the peer route for
     * this peer won't be added automatically.
     */
    peer_routes?: boolean
    /**
     * The 256 bit private-key in base64 encoding.
     */
    private_key?: string
    /**
     * Flags indicating how to handle the #NMSettingWirelessSecurity:private-key
     * property.
     */
    private_key_flags?: SettingSecretFlags
}
class SettingWireGuard {
    /* Properties of NM-1.0.NM.SettingWireGuard */
    /**
     * The use of fwmark is optional and is by default off. Setting it to 0
     * disables it. Otherwise, it is a 32-bit fwmark for outgoing packets.
     * 
     * Note that "ip4-auto-default-route" or "ip6-auto-default-route" enabled,
     * implies to automatically choose a fwmark.
     */
    fwmark: number
    /**
     * Whether to enable special handling of the IPv4 default route.
     * If enabled, the IPv4 default route from wireguard.peer-routes
     * will be placed to a dedicated routing-table and two policy routing rules
     * will be added. The fwmark number is also used as routing-table for the default-route,
     * and if fwmark is zero, an unused fwmark/table is chosen automatically.
     * This corresponds to what wg-quick does with Table=auto and what WireGuard
     * calls "Improved Rule-based Routing".
     * 
     * Note that for this automatism to work, you usually don't want to set
     * ipv4.gateway, because that will result in a conflicting default route.
     * 
     * Leaving this at the default will enable this option automatically
     * if ipv4.never-default is not set and there are any peers that use
     * a default-route as allowed-ips.
     */
    ip4_auto_default_route: Ternary
    /**
     * Like ip4-auto-default-route, but for the IPv6 default route.
     */
    ip6_auto_default_route: Ternary
    /**
     * The listen-port. If listen-port is not specified, the port will be chosen
     * randomly when the interface comes up.
     */
    listen_port: number
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple fragments.
     * 
     * If zero a default MTU is used. Note that contrary to wg-quick's MTU
     * setting, this does not take into account the current routes at the
     * time of activation.
     */
    mtu: number
    /**
     * Whether to automatically add routes for the AllowedIPs ranges
     * of the peers. If %TRUE (the default), NetworkManager will automatically
     * add routes in the routing tables according to ipv4.route-table and
     * ipv6.route-table. Usually you want this automatism enabled.
     * If %FALSE, no such routes are added automatically. In this case, the
     * user may want to configure static routes in ipv4.routes and ipv6.routes,
     * respectively.
     * 
     * Note that if the peer's AllowedIPs is "0.0.0.0/0" or "::/0" and the profile's
     * ipv4.never-default or ipv6.never-default setting is enabled, the peer route for
     * this peer won't be added automatically.
     */
    peer_routes: boolean
    /**
     * The 256 bit private-key in base64 encoding.
     */
    private_key: string
    /**
     * Flags indicating how to handle the #NMSettingWirelessSecurity:private-key
     * property.
     */
    private_key_flags: SettingSecretFlags
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingWireGuard */
    /**
     * If a peer with the same public-key already exists, that
     * one is replaced by `peer`. The new `peer` is always appended
     * (or moved to) the end, so in case a peer is replaced, the
     * indexes are shifted and the number of peers stays unchanged.
     */
    append_peer(peer: WireGuardPeer): void
    clear_peers(): number
    get_fwmark(): number
    get_ip4_auto_default_route(): Ternary
    get_ip6_auto_default_route(): Ternary
    get_listen_port(): number
    get_mtu(): number
    get_peer(idx: number): WireGuardPeer
    get_peer_by_public_key(public_key: string): [ /* returnType */ WireGuardPeer, /* out_idx */ number | null ]
    get_peer_routes(): boolean
    get_peers_len(): number
    get_private_key(): string
    get_private_key_flags(): SettingSecretFlags
    remove_peer(idx: number): boolean
    /**
     * If `idx` is one past the last peer, the behavior is the same
     * as nm_setting_wireguard_append_peer().
     * Otherwise, the peer will be at `idx` and replace the peer
     * instance at that index. Note that if a peer with the same
     * public-key exists on another index, then that peer will also
     * be replaced. In that case, the number of peers will shrink
     * by one (because the one at `idx` got replace and then one
     * with the same public-key got removed). This also means,
     * that the resulting index afterwards may be one less than
     * `idx` (if another peer with a lower index was dropped).
     */
    set_peer(peer: WireGuardPeer, idx: number): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::fwmark", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fwmark", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-auto-default-route", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-auto-default-route", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-auto-default-route", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-auto-default-route", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::listen-port", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listen-port", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::peer-routes", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::peer-routes", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::private-key", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::private-key-flags", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key-flags", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingWireGuard, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingWireGuard_ConstructProps)
    _init (config?: SettingWireGuard_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingWireGuard
    static $gtype: GObject.Type
}
interface SettingWired_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingWired */
    /**
     * When %TRUE, setup the interface to accept packets for all MAC addresses.
     * This is enabling the kernel interface flag IFF_PROMISC.
     * When %FALSE, the interface will only accept the packets with the
     * interface destination mac address or broadcast.
     */
    accept_all_mac_addresses?: Ternary
    /**
     * When %TRUE, enforce auto-negotiation of speed and duplex mode.
     * If "speed" and "duplex" properties are both specified, only that
     * single mode will be advertised and accepted during the link
     * auto-negotiation process: this works only for BASE-T 802.3 specifications
     * and is useful for enforcing gigabits modes, as in these cases link
     * negotiation is mandatory.
     * When %FALSE, "speed" and "duplex" properties should be both set or
     * link configuration will be skipped.
     */
    auto_negotiate?: boolean
    /**
     * If specified, request that the device use this MAC address instead.
     * This is known as MAC cloning or spoofing.
     * 
     * Beside explicitly specifying a MAC address, the special values "preserve", "permanent",
     * "random" and "stable" are supported.
     * "preserve" means not to touch the MAC address on activation.
     * "permanent" means to use the permanent hardware address if the device
     * has one (otherwise this is treated as "preserve").
     * "random" creates a random MAC address on each connect.
     * "stable" creates a hashed MAC address based on connection.stable-id and a
     * machine dependent key.
     * 
     * If unspecified, the value can be overwritten via global defaults, see manual
     * of NetworkManager.conf. If still unspecified, it defaults to "preserve"
     * (older versions of NetworkManager may use a different default value).
     * 
     * On D-Bus, this field is expressed as "assigned-mac-address" or the deprecated
     * "cloned-mac-address".
     */
    cloned_mac_address?: string
    /**
     * When a value is set, either "half" or "full", configures the device
     * to use the specified duplex mode. If "auto-negotiate" is "yes" the
     * specified duplex mode will be the only one advertised during link
     * negotiation: this works only for BASE-T 802.3 specifications and is
     * useful for enforcing gigabits modes, as in these cases link negotiation
     * is mandatory.
     * If the value is unset (the default), the link configuration will be
     * either skipped (if "auto-negotiate" is "no", the default) or will
     * be auto-negotiated (if "auto-negotiate" is "yes") and the local device
     * will advertise all the supported duplex modes.
     * Must be set together with the "speed" property if specified.
     * Before specifying a duplex mode be sure your device supports it.
     */
    duplex?: string
    /**
     * With #NMSettingWired:cloned-mac-address setting "random" or "stable",
     * by default all bits of the MAC address are scrambled and a locally-administered,
     * unicast MAC address is created. This property allows to specify that certain bits
     * are fixed. Note that the least significant bit of the first MAC address will
     * always be unset to create a unicast MAC address.
     * 
     * If the property is %NULL, it is eligible to be overwritten by a default
     * connection setting. If the value is still %NULL or an empty string, the
     * default is to create a locally-administered, unicast MAC address.
     * 
     * If the value contains one MAC address, this address is used as mask. The set
     * bits of the mask are to be filled with the current MAC address of the device,
     * while the unset bits are subject to randomization.
     * Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
     * and only randomize the lower 3 bytes using the "random" or "stable" algorithm.
     * 
     * If the value contains one additional MAC address after the mask,
     * this address is used instead of the current MAC address to fill the bits
     * that shall not be randomized. For example, a value of
     * "FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
     * to 68:F7:28, while the lower bits are randomized. A value of
     * "02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
     * globally-administered, burned-in MAC address.
     * 
     * If the value contains more than one additional MAC addresses, one of
     * them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
     * will create a fully scrambled MAC address, randomly locally or globally
     * administered.
     */
    generate_mac_address_mask?: string
    /**
     * If specified, this connection will only apply to the Ethernet device
     * whose permanent MAC address matches. This property does not change the
     * MAC address of the device (i.e. MAC spoofing).
     */
    mac_address?: string
    /**
     * If specified, this connection will never apply to the Ethernet device
     * whose permanent MAC address matches an address in the list.  Each MAC
     * address is in the standard hex-digits-and-colons notation
     * (00:11:22:33:44:55).
     */
    mac_address_blacklist?: string[]
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple Ethernet frames.
     */
    mtu?: number
    /**
     * Specific port type to use if the device supports multiple
     * attachment methods.  One of "tp" (Twisted Pair), "aui" (Attachment Unit
     * Interface), "bnc" (Thin Ethernet) or "mii" (Media Independent Interface).
     * If the device supports only one port type, this setting is ignored.
     */
    port?: string
    /**
     * s390 network device type; one of "qeth", "lcs", or "ctc", representing
     * the different types of virtual network devices available on s390 systems.
     */
    s390_nettype?: string
    /**
     * Dictionary of key/value pairs of s390-specific device options.  Both keys
     * and values must be strings.  Allowed keys include "portno", "layer2",
     * "portname", "protocol", among others.  Key names must contain only
     * alphanumeric characters (ie, [a-zA-Z0-9]).
     * 
     * Currently, NetworkManager itself does nothing with this information.
     * However, s390utils ships a udev rule which parses this information
     * and applies it to the interface.
     */
    s390_options?: GLib.HashTable
    /**
     * Identifies specific subchannels that this network device uses for
     * communication with z/VM or s390 host.  Like the
     * #NMSettingWired:mac-address property for non-z/VM devices, this property
     * can be used to ensure this connection only applies to the network device
     * that uses these subchannels.  The list should contain exactly 3 strings,
     * and each string may only be composed of hexadecimal characters and the
     * period (.) character.
     */
    s390_subchannels?: string[]
    /**
     * When a value greater than 0 is set, configures the device to use
     * the specified speed. If "auto-negotiate" is "yes" the specified
     * speed will be the only one advertised during link negotiation:
     * this works only for BASE-T 802.3 specifications and is useful for
     * enforcing gigabit speeds, as in this case link negotiation is
     * mandatory.
     * If the value is unset (0, the default), the link configuration will be
     * either skipped (if "auto-negotiate" is "no", the default) or will
     * be auto-negotiated (if "auto-negotiate" is "yes") and the local device
     * will advertise all the supported speeds.
     * In Mbit/s, ie 100 == 100Mbit/s.
     * Must be set together with the "duplex" property when non-zero.
     * Before specifying a speed value be sure your device supports it.
     */
    speed?: number
    /**
     * The #NMSettingWiredWakeOnLan options to enable. Not all devices support all options.
     * May be any combination of %NM_SETTING_WIRED_WAKE_ON_LAN_PHY,
     * %NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST, %NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST,
     * %NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST, %NM_SETTING_WIRED_WAKE_ON_LAN_ARP,
     * %NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC or the special values
     * %NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT (to use global settings) and
     * %NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE (to disable management of Wake-on-LAN in
     * NetworkManager).
     */
    wake_on_lan?: number
    /**
     * If specified, the password used with magic-packet-based
     * Wake-on-LAN, represented as an Ethernet MAC address.  If %NULL,
     * no password will be required.
     */
    wake_on_lan_password?: string
}
class SettingWired {
    /* Properties of NM-1.0.NM.SettingWired */
    /**
     * When %TRUE, setup the interface to accept packets for all MAC addresses.
     * This is enabling the kernel interface flag IFF_PROMISC.
     * When %FALSE, the interface will only accept the packets with the
     * interface destination mac address or broadcast.
     */
    accept_all_mac_addresses: Ternary
    /**
     * When %TRUE, enforce auto-negotiation of speed and duplex mode.
     * If "speed" and "duplex" properties are both specified, only that
     * single mode will be advertised and accepted during the link
     * auto-negotiation process: this works only for BASE-T 802.3 specifications
     * and is useful for enforcing gigabits modes, as in these cases link
     * negotiation is mandatory.
     * When %FALSE, "speed" and "duplex" properties should be both set or
     * link configuration will be skipped.
     */
    auto_negotiate: boolean
    /**
     * If specified, request that the device use this MAC address instead.
     * This is known as MAC cloning or spoofing.
     * 
     * Beside explicitly specifying a MAC address, the special values "preserve", "permanent",
     * "random" and "stable" are supported.
     * "preserve" means not to touch the MAC address on activation.
     * "permanent" means to use the permanent hardware address if the device
     * has one (otherwise this is treated as "preserve").
     * "random" creates a random MAC address on each connect.
     * "stable" creates a hashed MAC address based on connection.stable-id and a
     * machine dependent key.
     * 
     * If unspecified, the value can be overwritten via global defaults, see manual
     * of NetworkManager.conf. If still unspecified, it defaults to "preserve"
     * (older versions of NetworkManager may use a different default value).
     * 
     * On D-Bus, this field is expressed as "assigned-mac-address" or the deprecated
     * "cloned-mac-address".
     */
    cloned_mac_address: string
    /**
     * When a value is set, either "half" or "full", configures the device
     * to use the specified duplex mode. If "auto-negotiate" is "yes" the
     * specified duplex mode will be the only one advertised during link
     * negotiation: this works only for BASE-T 802.3 specifications and is
     * useful for enforcing gigabits modes, as in these cases link negotiation
     * is mandatory.
     * If the value is unset (the default), the link configuration will be
     * either skipped (if "auto-negotiate" is "no", the default) or will
     * be auto-negotiated (if "auto-negotiate" is "yes") and the local device
     * will advertise all the supported duplex modes.
     * Must be set together with the "speed" property if specified.
     * Before specifying a duplex mode be sure your device supports it.
     */
    duplex: string
    /**
     * With #NMSettingWired:cloned-mac-address setting "random" or "stable",
     * by default all bits of the MAC address are scrambled and a locally-administered,
     * unicast MAC address is created. This property allows to specify that certain bits
     * are fixed. Note that the least significant bit of the first MAC address will
     * always be unset to create a unicast MAC address.
     * 
     * If the property is %NULL, it is eligible to be overwritten by a default
     * connection setting. If the value is still %NULL or an empty string, the
     * default is to create a locally-administered, unicast MAC address.
     * 
     * If the value contains one MAC address, this address is used as mask. The set
     * bits of the mask are to be filled with the current MAC address of the device,
     * while the unset bits are subject to randomization.
     * Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
     * and only randomize the lower 3 bytes using the "random" or "stable" algorithm.
     * 
     * If the value contains one additional MAC address after the mask,
     * this address is used instead of the current MAC address to fill the bits
     * that shall not be randomized. For example, a value of
     * "FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
     * to 68:F7:28, while the lower bits are randomized. A value of
     * "02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
     * globally-administered, burned-in MAC address.
     * 
     * If the value contains more than one additional MAC addresses, one of
     * them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
     * will create a fully scrambled MAC address, randomly locally or globally
     * administered.
     */
    generate_mac_address_mask: string
    /**
     * If specified, this connection will only apply to the Ethernet device
     * whose permanent MAC address matches. This property does not change the
     * MAC address of the device (i.e. MAC spoofing).
     */
    mac_address: string
    /**
     * If specified, this connection will never apply to the Ethernet device
     * whose permanent MAC address matches an address in the list.  Each MAC
     * address is in the standard hex-digits-and-colons notation
     * (00:11:22:33:44:55).
     */
    mac_address_blacklist: string[]
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple Ethernet frames.
     */
    mtu: number
    /**
     * Specific port type to use if the device supports multiple
     * attachment methods.  One of "tp" (Twisted Pair), "aui" (Attachment Unit
     * Interface), "bnc" (Thin Ethernet) or "mii" (Media Independent Interface).
     * If the device supports only one port type, this setting is ignored.
     */
    port: string
    /**
     * s390 network device type; one of "qeth", "lcs", or "ctc", representing
     * the different types of virtual network devices available on s390 systems.
     */
    s390_nettype: string
    /**
     * Dictionary of key/value pairs of s390-specific device options.  Both keys
     * and values must be strings.  Allowed keys include "portno", "layer2",
     * "portname", "protocol", among others.  Key names must contain only
     * alphanumeric characters (ie, [a-zA-Z0-9]).
     * 
     * Currently, NetworkManager itself does nothing with this information.
     * However, s390utils ships a udev rule which parses this information
     * and applies it to the interface.
     */
    s390_options: GLib.HashTable
    /**
     * Identifies specific subchannels that this network device uses for
     * communication with z/VM or s390 host.  Like the
     * #NMSettingWired:mac-address property for non-z/VM devices, this property
     * can be used to ensure this connection only applies to the network device
     * that uses these subchannels.  The list should contain exactly 3 strings,
     * and each string may only be composed of hexadecimal characters and the
     * period (.) character.
     */
    s390_subchannels: string[]
    /**
     * When a value greater than 0 is set, configures the device to use
     * the specified speed. If "auto-negotiate" is "yes" the specified
     * speed will be the only one advertised during link negotiation:
     * this works only for BASE-T 802.3 specifications and is useful for
     * enforcing gigabit speeds, as in this case link negotiation is
     * mandatory.
     * If the value is unset (0, the default), the link configuration will be
     * either skipped (if "auto-negotiate" is "no", the default) or will
     * be auto-negotiated (if "auto-negotiate" is "yes") and the local device
     * will advertise all the supported speeds.
     * In Mbit/s, ie 100 == 100Mbit/s.
     * Must be set together with the "duplex" property when non-zero.
     * Before specifying a speed value be sure your device supports it.
     */
    speed: number
    /**
     * The #NMSettingWiredWakeOnLan options to enable. Not all devices support all options.
     * May be any combination of %NM_SETTING_WIRED_WAKE_ON_LAN_PHY,
     * %NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST, %NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST,
     * %NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST, %NM_SETTING_WIRED_WAKE_ON_LAN_ARP,
     * %NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC or the special values
     * %NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT (to use global settings) and
     * %NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE (to disable management of Wake-on-LAN in
     * NetworkManager).
     */
    wake_on_lan: number
    /**
     * If specified, the password used with magic-packet-based
     * Wake-on-LAN, represented as an Ethernet MAC address.  If %NULL,
     * no password will be required.
     */
    wake_on_lan_password: string
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingWired */
    /**
     * Adds a new MAC address to the #NMSettingWired:mac-address-blacklist property.
     */
    add_mac_blacklist_item(mac: string): boolean
    /**
     * Add an option to the table. If the key already exists, the value gets
     * replaced.
     * 
     * Before 1.32, the function would assert that the key is valid. Since then,
     * an invalid key gets silently added but renders the profile as invalid.
     */
    add_s390_option(key: string, value: string): boolean
    /**
     * Removes all blacklisted MAC addresses.
     */
    clear_mac_blacklist_items(): void
    get_accept_all_mac_addresses(): Ternary
    get_auto_negotiate(): boolean
    get_cloned_mac_address(): string
    get_duplex(): string
    get_generate_mac_address_mask(): string
    get_mac_address(): string
    get_mac_address_blacklist(): string[]
    get_mac_blacklist_item(idx: number): string
    get_mtu(): number
    get_num_mac_blacklist_items(): number
    /**
     * Returns the number of s390-specific options that should be set for this
     * device when it is activated.  This can be used to retrieve each s390
     * option individually using nm_setting_wired_get_s390_option().
     */
    get_num_s390_options(): number
    get_port(): string
    /**
     * Returns the s390 device type this connection should apply to.  Will be one
     * of 'qeth', 'lcs', or 'ctc'.
     */
    get_s390_nettype(): string
    /**
     * Given an index, return the value of the s390 option at that index.  indexes
     * are *not* guaranteed to be static across modifications to options done by
     * nm_setting_wired_add_s390_option() and nm_setting_wired_remove_s390_option(),
     * and should not be used to refer to options except for short periods of time
     * such as during option iteration.
     */
    get_s390_option(idx: number): [ /* returnType */ boolean, /* out_key */ string | null, /* out_value */ string | null ]
    /**
     * Returns the value associated with the s390-specific option specified by
     * `key,` if it exists.
     */
    get_s390_option_by_key(key: string): string
    /**
     * Return the list of s390 subchannels that identify the device that this
     * connection is applicable to.  The connection should only be used in
     * conjunction with that device.
     */
    get_s390_subchannels(): string[]
    get_speed(): number
    /**
     * Returns a list of valid s390 options.
     * 
     * The `setting` argument is unused and %NULL may be passed instead.
     */
    get_valid_s390_options(): string[]
    /**
     * Returns the Wake-on-LAN options enabled for the connection
     */
    get_wake_on_lan(): SettingWiredWakeOnLan
    /**
     * Returns the Wake-on-LAN password. This only applies to
     * %NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC.
     */
    get_wake_on_lan_password(): string
    /**
     * Removes the MAC address at index `idx` from the blacklist.
     */
    remove_mac_blacklist_item(idx: number): void
    /**
     * Removes the MAC address `mac` from the blacklist.
     */
    remove_mac_blacklist_item_by_value(mac: string): boolean
    /**
     * Remove the s390-specific option referenced by `key` from the internal option
     * list.
     */
    remove_s390_option(key: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::accept-all-mac-addresses", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::accept-all-mac-addresses", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::auto-negotiate", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auto-negotiate", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::cloned-mac-address", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cloned-mac-address", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::duplex", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::duplex", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::generate-mac-address-mask", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::generate-mac-address-mask", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mac-address", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mac-address-blacklist", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address-blacklist", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::port", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::port", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::s390-nettype", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::s390-nettype", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::s390-options", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::s390-options", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::s390-subchannels", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::s390-subchannels", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::speed", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::speed", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wake-on-lan", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wake-on-lan", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wake-on-lan-password", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wake-on-lan-password", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingWired, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingWired_ConstructProps)
    _init (config?: SettingWired_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingWired
    static $gtype: GObject.Type
}
interface SettingWireless_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingWireless */
    /**
     * Configures AP isolation, which prevents communication between
     * wireless devices connected to this AP. This property can be set
     * to a value different from %NM_TERNARY_DEFAULT only when the
     * interface is configured in AP mode.
     * 
     * If set to %NM_TERNARY_TRUE, devices are not able to communicate
     * with each other. This increases security because it protects
     * devices against attacks from other clients in the network. At
     * the same time, it prevents devices to access resources on the
     * same wireless networks as file shares, printers, etc.
     * 
     * If set to %NM_TERNARY_FALSE, devices can talk to each other.
     * 
     * When set to %NM_TERNARY_DEFAULT, the global default is used; in
     * case the global default is unspecified it is assumed to be
     * %NM_TERNARY_FALSE.
     */
    ap_isolation?: Ternary
    /**
     * 802.11 frequency band of the network.  One of "a" for 5GHz 802.11a or
     * "bg" for 2.4GHz 802.11.  This will lock associations to the Wi-Fi network
     * to the specific band, i.e. if "a" is specified, the device will not
     * associate with the same network in the 2.4GHz band even if the network's
     * settings are compatible.  This setting depends on specific driver
     * capability and may not work with all drivers.
     */
    band?: string
    /**
     * If specified, directs the device to only associate with the given access
     * point.  This capability is highly driver dependent and not supported by
     * all devices.  Note: this property does not control the BSSID used when
     * creating an Ad-Hoc network and is unlikely to in the future.
     */
    bssid?: string
    /**
     * Wireless channel to use for the Wi-Fi connection.  The device will only
     * join (or create for Ad-Hoc networks) a Wi-Fi network on the specified
     * channel.  Because channel numbers overlap between bands, this property
     * also requires the "band" property to be set.
     */
    channel?: number
    /**
     * If specified, request that the device use this MAC address instead.
     * This is known as MAC cloning or spoofing.
     * 
     * Beside explicitly specifying a MAC address, the special values "preserve", "permanent",
     * "random" and "stable" are supported.
     * "preserve" means not to touch the MAC address on activation.
     * "permanent" means to use the permanent hardware address of the device.
     * "random" creates a random MAC address on each connect.
     * "stable" creates a hashed MAC address based on connection.stable-id and a
     * machine dependent key.
     * 
     * If unspecified, the value can be overwritten via global defaults, see manual
     * of NetworkManager.conf. If still unspecified, it defaults to "preserve"
     * (older versions of NetworkManager may use a different default value).
     * 
     * On D-Bus, this field is expressed as "assigned-mac-address" or the deprecated
     * "cloned-mac-address".
     */
    cloned_mac_address?: string
    /**
     * With #NMSettingWireless:cloned-mac-address setting "random" or "stable",
     * by default all bits of the MAC address are scrambled and a locally-administered,
     * unicast MAC address is created. This property allows to specify that certain bits
     * are fixed. Note that the least significant bit of the first MAC address will
     * always be unset to create a unicast MAC address.
     * 
     * If the property is %NULL, it is eligible to be overwritten by a default
     * connection setting. If the value is still %NULL or an empty string, the
     * default is to create a locally-administered, unicast MAC address.
     * 
     * If the value contains one MAC address, this address is used as mask. The set
     * bits of the mask are to be filled with the current MAC address of the device,
     * while the unset bits are subject to randomization.
     * Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
     * and only randomize the lower 3 bytes using the "random" or "stable" algorithm.
     * 
     * If the value contains one additional MAC address after the mask,
     * this address is used instead of the current MAC address to fill the bits
     * that shall not be randomized. For example, a value of
     * "FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
     * to 68:F7:28, while the lower bits are randomized. A value of
     * "02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
     * globally-administered, burned-in MAC address.
     * 
     * If the value contains more than one additional MAC addresses, one of
     * them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
     * will create a fully scrambled MAC address, randomly locally or globally
     * administered.
     */
    generate_mac_address_mask?: string
    /**
     * If %TRUE, indicates that the network is a non-broadcasting network that
     * hides its SSID. This works both in infrastructure and AP mode.
     * 
     * In infrastructure mode, various workarounds are used for a more reliable
     * discovery of hidden networks, such as probe-scanning the SSID.  However,
     * these workarounds expose inherent insecurities with hidden SSID networks,
     * and thus hidden SSID networks should be used with caution.
     * 
     * In AP mode, the created network does not broadcast its SSID.
     * 
     * Note that marking the network as hidden may be a privacy issue for you
     * (in infrastructure mode) or client stations (in AP mode), as the explicit
     * probe-scans are distinctly recognizable on the air.
     */
    hidden?: boolean
    /**
     * If specified, this connection will only apply to the Wi-Fi device whose
     * permanent MAC address matches. This property does not change the MAC
     * address of the device (i.e. MAC spoofing).
     */
    mac_address?: string
    /**
     * A list of permanent MAC addresses of Wi-Fi devices to which this
     * connection should never apply.  Each MAC address should be given in the
     * standard hex-digits-and-colons notation (eg "00:11:22:33:44:55").
     */
    mac_address_blacklist?: string[]
    /**
     * One of %NM_SETTING_MAC_RANDOMIZATION_DEFAULT (never randomize unless
     * the user has set a global default to randomize and the supplicant
     * supports randomization),  %NM_SETTING_MAC_RANDOMIZATION_NEVER (never
     * randomize the MAC address), or %NM_SETTING_MAC_RANDOMIZATION_ALWAYS
     * (always randomize the MAC address). This property is deprecated for
     * 'cloned-mac-address'.
     */
    mac_address_randomization?: number
    /**
     * Wi-Fi network mode; one of "infrastructure", "mesh", "adhoc" or "ap".  If blank,
     * infrastructure is assumed.
     */
    mode?: string
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple Ethernet frames.
     */
    mtu?: number
    /**
     * One of %NM_SETTING_WIRELESS_POWERSAVE_DISABLE (disable Wi-Fi power
     * saving), %NM_SETTING_WIRELESS_POWERSAVE_ENABLE (enable Wi-Fi power
     * saving), %NM_SETTING_WIRELESS_POWERSAVE_IGNORE (don't touch currently
     * configure setting) or %NM_SETTING_WIRELESS_POWERSAVE_DEFAULT (use the
     * globally configured value). All other values are reserved.
     */
    powersave?: number
    /**
     * If non-zero, directs the device to only use the specified bitrate for
     * communication with the access point.  Units are in Kb/s, ie 5500 = 5.5
     * Mbit/s.  This property is highly driver dependent and not all devices
     * support setting a static bitrate.
     */
    rate?: number
    /**
     * A list of BSSIDs (each BSSID formatted as a MAC address like
     * "00:11:22:33:44:55") that have been detected as part of the Wi-Fi
     * network.  NetworkManager internally tracks previously seen BSSIDs. The
     * property is only meant for reading and reflects the BSSID list of
     * NetworkManager. The changes you make to this property will not be
     * preserved.
     */
    seen_bssids?: string[]
    /**
     * SSID of the Wi-Fi network. Must be specified.
     */
    ssid?: GLib.Bytes
    /**
     * If non-zero, directs the device to use the specified transmit power.
     * Units are dBm.  This property is highly driver dependent and not all
     * devices support setting a static transmit power.
     */
    tx_power?: number
    /**
     * The #NMSettingWirelessWakeOnWLan options to enable. Not all devices support all options.
     * May be any combination of %NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP or the special values
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT (to use global settings) and
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE (to disable management of Wake-on-LAN in
     * NetworkManager).
     */
    wake_on_wlan?: number
}
class SettingWireless {
    /* Properties of NM-1.0.NM.SettingWireless */
    /**
     * Configures AP isolation, which prevents communication between
     * wireless devices connected to this AP. This property can be set
     * to a value different from %NM_TERNARY_DEFAULT only when the
     * interface is configured in AP mode.
     * 
     * If set to %NM_TERNARY_TRUE, devices are not able to communicate
     * with each other. This increases security because it protects
     * devices against attacks from other clients in the network. At
     * the same time, it prevents devices to access resources on the
     * same wireless networks as file shares, printers, etc.
     * 
     * If set to %NM_TERNARY_FALSE, devices can talk to each other.
     * 
     * When set to %NM_TERNARY_DEFAULT, the global default is used; in
     * case the global default is unspecified it is assumed to be
     * %NM_TERNARY_FALSE.
     */
    ap_isolation: Ternary
    /**
     * 802.11 frequency band of the network.  One of "a" for 5GHz 802.11a or
     * "bg" for 2.4GHz 802.11.  This will lock associations to the Wi-Fi network
     * to the specific band, i.e. if "a" is specified, the device will not
     * associate with the same network in the 2.4GHz band even if the network's
     * settings are compatible.  This setting depends on specific driver
     * capability and may not work with all drivers.
     */
    band: string
    /**
     * If specified, directs the device to only associate with the given access
     * point.  This capability is highly driver dependent and not supported by
     * all devices.  Note: this property does not control the BSSID used when
     * creating an Ad-Hoc network and is unlikely to in the future.
     */
    bssid: string
    /**
     * Wireless channel to use for the Wi-Fi connection.  The device will only
     * join (or create for Ad-Hoc networks) a Wi-Fi network on the specified
     * channel.  Because channel numbers overlap between bands, this property
     * also requires the "band" property to be set.
     */
    channel: number
    /**
     * If specified, request that the device use this MAC address instead.
     * This is known as MAC cloning or spoofing.
     * 
     * Beside explicitly specifying a MAC address, the special values "preserve", "permanent",
     * "random" and "stable" are supported.
     * "preserve" means not to touch the MAC address on activation.
     * "permanent" means to use the permanent hardware address of the device.
     * "random" creates a random MAC address on each connect.
     * "stable" creates a hashed MAC address based on connection.stable-id and a
     * machine dependent key.
     * 
     * If unspecified, the value can be overwritten via global defaults, see manual
     * of NetworkManager.conf. If still unspecified, it defaults to "preserve"
     * (older versions of NetworkManager may use a different default value).
     * 
     * On D-Bus, this field is expressed as "assigned-mac-address" or the deprecated
     * "cloned-mac-address".
     */
    cloned_mac_address: string
    /**
     * With #NMSettingWireless:cloned-mac-address setting "random" or "stable",
     * by default all bits of the MAC address are scrambled and a locally-administered,
     * unicast MAC address is created. This property allows to specify that certain bits
     * are fixed. Note that the least significant bit of the first MAC address will
     * always be unset to create a unicast MAC address.
     * 
     * If the property is %NULL, it is eligible to be overwritten by a default
     * connection setting. If the value is still %NULL or an empty string, the
     * default is to create a locally-administered, unicast MAC address.
     * 
     * If the value contains one MAC address, this address is used as mask. The set
     * bits of the mask are to be filled with the current MAC address of the device,
     * while the unset bits are subject to randomization.
     * Setting "FE:FF:FF:00:00:00" means to preserve the OUI of the current MAC address
     * and only randomize the lower 3 bytes using the "random" or "stable" algorithm.
     * 
     * If the value contains one additional MAC address after the mask,
     * this address is used instead of the current MAC address to fill the bits
     * that shall not be randomized. For example, a value of
     * "FE:FF:FF:00:00:00 68:F7:28:00:00:00" will set the OUI of the MAC address
     * to 68:F7:28, while the lower bits are randomized. A value of
     * "02:00:00:00:00:00 00:00:00:00:00:00" will create a fully scrambled
     * globally-administered, burned-in MAC address.
     * 
     * If the value contains more than one additional MAC addresses, one of
     * them is chosen randomly. For example, "02:00:00:00:00:00 00:00:00:00:00:00 02:00:00:00:00:00"
     * will create a fully scrambled MAC address, randomly locally or globally
     * administered.
     */
    generate_mac_address_mask: string
    /**
     * If %TRUE, indicates that the network is a non-broadcasting network that
     * hides its SSID. This works both in infrastructure and AP mode.
     * 
     * In infrastructure mode, various workarounds are used for a more reliable
     * discovery of hidden networks, such as probe-scanning the SSID.  However,
     * these workarounds expose inherent insecurities with hidden SSID networks,
     * and thus hidden SSID networks should be used with caution.
     * 
     * In AP mode, the created network does not broadcast its SSID.
     * 
     * Note that marking the network as hidden may be a privacy issue for you
     * (in infrastructure mode) or client stations (in AP mode), as the explicit
     * probe-scans are distinctly recognizable on the air.
     */
    hidden: boolean
    /**
     * If specified, this connection will only apply to the Wi-Fi device whose
     * permanent MAC address matches. This property does not change the MAC
     * address of the device (i.e. MAC spoofing).
     */
    mac_address: string
    /**
     * A list of permanent MAC addresses of Wi-Fi devices to which this
     * connection should never apply.  Each MAC address should be given in the
     * standard hex-digits-and-colons notation (eg "00:11:22:33:44:55").
     */
    mac_address_blacklist: string[]
    /**
     * One of %NM_SETTING_MAC_RANDOMIZATION_DEFAULT (never randomize unless
     * the user has set a global default to randomize and the supplicant
     * supports randomization),  %NM_SETTING_MAC_RANDOMIZATION_NEVER (never
     * randomize the MAC address), or %NM_SETTING_MAC_RANDOMIZATION_ALWAYS
     * (always randomize the MAC address). This property is deprecated for
     * 'cloned-mac-address'.
     */
    mac_address_randomization: number
    /**
     * Wi-Fi network mode; one of "infrastructure", "mesh", "adhoc" or "ap".  If blank,
     * infrastructure is assumed.
     */
    mode: string
    /**
     * If non-zero, only transmit packets of the specified size or smaller,
     * breaking larger packets up into multiple Ethernet frames.
     */
    mtu: number
    /**
     * One of %NM_SETTING_WIRELESS_POWERSAVE_DISABLE (disable Wi-Fi power
     * saving), %NM_SETTING_WIRELESS_POWERSAVE_ENABLE (enable Wi-Fi power
     * saving), %NM_SETTING_WIRELESS_POWERSAVE_IGNORE (don't touch currently
     * configure setting) or %NM_SETTING_WIRELESS_POWERSAVE_DEFAULT (use the
     * globally configured value). All other values are reserved.
     */
    powersave: number
    /**
     * If non-zero, directs the device to only use the specified bitrate for
     * communication with the access point.  Units are in Kb/s, ie 5500 = 5.5
     * Mbit/s.  This property is highly driver dependent and not all devices
     * support setting a static bitrate.
     */
    rate: number
    /**
     * A list of BSSIDs (each BSSID formatted as a MAC address like
     * "00:11:22:33:44:55") that have been detected as part of the Wi-Fi
     * network.  NetworkManager internally tracks previously seen BSSIDs. The
     * property is only meant for reading and reflects the BSSID list of
     * NetworkManager. The changes you make to this property will not be
     * preserved.
     */
    seen_bssids: string[]
    /**
     * SSID of the Wi-Fi network. Must be specified.
     */
    ssid: GLib.Bytes
    /**
     * If non-zero, directs the device to use the specified transmit power.
     * Units are dBm.  This property is highly driver dependent and not all
     * devices support setting a static transmit power.
     */
    tx_power: number
    /**
     * The #NMSettingWirelessWakeOnWLan options to enable. Not all devices support all options.
     * May be any combination of %NM_SETTING_WIRELESS_WAKE_ON_WLAN_ANY,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_DISCONNECT,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_MAGIC,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_GTK_REKEY_FAILURE,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_EAP_IDENTITY_REQUEST,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_4WAY_HANDSHAKE,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_RFKILL_RELEASE,
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_TCP or the special values
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_DEFAULT (to use global settings) and
     * %NM_SETTING_WIRELESS_WAKE_ON_WLAN_IGNORE (to disable management of Wake-on-LAN in
     * NetworkManager).
     */
    wake_on_wlan: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingWireless */
    /**
     * Adds a new MAC address to the #NMSettingWireless:mac-address-blacklist property.
     */
    add_mac_blacklist_item(mac: string): boolean
    /**
     * Adds a new Wi-Fi AP's BSSID to the previously seen BSSID list of the setting.
     * NetworkManager now tracks previously seen BSSIDs internally so this function
     * no longer has much use. Actually, changes you make using this function will
     * not be preserved.
     */
    add_seen_bssid(bssid: string): boolean
    /**
     * Given a #NMSettingWireless and an optional #NMSettingWirelessSecurity,
     * determine if the configuration given by the settings is compatible with
     * the security of an access point using that access point's capability flags
     * and mode.  Useful for clients that wish to filter a set of connections
     * against a set of access points and determine which connections are
     * compatible with which access points.
     */
    ap_security_compatible(s_wireless_sec: SettingWirelessSecurity, ap_flags: TODO_80211ApFlags, ap_wpa: TODO_80211ApSecurityFlags, ap_rsn: TODO_80211ApSecurityFlags, ap_mode: TODO_80211Mode): boolean
    /**
     * Removes all blacklisted MAC addresses.
     */
    clear_mac_blacklist_items(): void
    get_ap_isolation(): Ternary
    get_band(): string
    get_bssid(): string
    get_channel(): number
    get_cloned_mac_address(): string
    get_generate_mac_address_mask(): string
    get_hidden(): boolean
    get_mac_address(): string
    get_mac_address_blacklist(): string[]
    get_mac_address_randomization(): SettingMacRandomization
    get_mac_blacklist_item(idx: number): string
    get_mode(): string
    get_mtu(): number
    get_num_mac_blacklist_items(): number
    get_num_seen_bssids(): number
    get_powersave(): number
    get_rate(): number
    get_seen_bssid(i: number): string
    get_ssid(): GLib.Bytes
    get_tx_power(): number
    /**
     * Returns the Wake-on-WLAN options enabled for the connection
     */
    get_wake_on_wlan(): SettingWirelessWakeOnWLan
    /**
     * Removes the MAC address at index `idx` from the blacklist.
     */
    remove_mac_blacklist_item(idx: number): void
    /**
     * Removes the MAC address `mac` from the blacklist.
     */
    remove_mac_blacklist_item_by_value(mac: string): boolean
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::ap-isolation", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ap-isolation", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::band", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::band", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::bssid", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bssid", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::channel", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::cloned-mac-address", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cloned-mac-address", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::generate-mac-address-mask", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::generate-mac-address-mask", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hidden", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hidden", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mac-address", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mac-address-blacklist", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address-blacklist", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mac-address-randomization", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address-randomization", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mode", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mode", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mtu", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mtu", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::powersave", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::powersave", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::rate", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::rate", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::seen-bssids", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::seen-bssids", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ssid", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ssid", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::tx-power", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::tx-power", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wake-on-wlan", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wake-on-wlan", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingWireless, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingWireless_ConstructProps)
    _init (config?: SettingWireless_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingWireless
    static $gtype: GObject.Type
}
interface SettingWirelessSecurity_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingWirelessSecurity */
    /**
     * When WEP is used (ie, key-mgmt = "none" or "ieee8021x") indicate the
     * 802.11 authentication algorithm required by the AP here.  One of "open"
     * for Open System, "shared" for Shared Key, or "leap" for Cisco LEAP.  When
     * using Cisco LEAP (ie, key-mgmt = "ieee8021x" and auth-alg = "leap") the
     * "leap-username" and "leap-password" properties must be specified.
     */
    auth_alg?: string
    /**
     * Indicates whether Fast Initial Link Setup (802.11ai) must be enabled for
     * the connection.  One of %NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT (use
     * global default value), %NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE
     * (disable FILS), %NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL (enable FILS
     * if the supplicant and the access point support it) or
     * %NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED (enable FILS and fail if not
     * supported).  When set to %NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT and
     * no global default is set, FILS will be optionally enabled.
     */
    fils?: number
    /**
     * A list of group/broadcast encryption algorithms which prevents
     * connections to Wi-Fi networks that do not utilize one of the algorithms
     * in the list.  For maximum compatibility leave this property empty.  Each
     * list element may be one of "wep40", "wep104", "tkip", or "ccmp".
     */
    group?: string[]
    /**
     * Key management used for the connection. One of "none" (WEP or no
     * password protection), "ieee8021x" (Dynamic WEP), "owe" (Opportunistic
     * Wireless Encryption), "wpa-psk" (WPA2 + WPA3 personal), "sae" (WPA3
     * personal only), "wpa-eap" (WPA2 + WPA3 enterprise) or
     * "wpa-eap-suite-b-192" (WPA3 enterprise only).
     * 
     * This property must be set for any Wi-Fi connection that uses security.
     */
    key_mgmt?: string
    /**
     * The login password for legacy LEAP connections (ie, key-mgmt =
     * "ieee8021x" and auth-alg = "leap").
     */
    leap_password?: string
    /**
     * Flags indicating how to handle the
     * #NMSettingWirelessSecurity:leap-password property.
     */
    leap_password_flags?: SettingSecretFlags
    /**
     * The login username for legacy LEAP connections (ie, key-mgmt =
     * "ieee8021x" and auth-alg = "leap").
     */
    leap_username?: string
    /**
     * A list of pairwise encryption algorithms which prevents connections to
     * Wi-Fi networks that do not utilize one of the algorithms in the list.
     * For maximum compatibility leave this property empty.  Each list element
     * may be one of "tkip" or "ccmp".
     */
    pairwise?: string[]
    /**
     * Indicates whether Protected Management Frames (802.11w) must be enabled
     * for the connection.  One of %NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT
     * (use global default value), %NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE
     * (disable PMF), %NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL (enable PMF if
     * the supplicant and the access point support it) or
     * %NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED (enable PMF and fail if not
     * supported).  When set to %NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT and no
     * global default is set, PMF will be optionally enabled.
     */
    pmf?: number
    /**
     * List of strings specifying the allowed WPA protocol versions to use.
     * Each element may be one "wpa" (allow WPA) or "rsn" (allow WPA2/RSN).  If
     * not specified, both WPA and RSN connections are allowed.
     */
    proto?: string[]
    /**
     * Pre-Shared-Key for WPA networks. For WPA-PSK, it's either an ASCII
     * passphrase of 8 to 63 characters that is (as specified in the 802.11i
     * standard) hashed to derive the actual key, or the key in form of 64
     * hexadecimal character. The WPA3-Personal networks use a passphrase
     * of any length for SAE authentication.
     */
    psk?: string
    /**
     * Flags indicating how to handle the #NMSettingWirelessSecurity:psk
     * property.
     */
    psk_flags?: SettingSecretFlags
    /**
     * Flags indicating how to handle the #NMSettingWirelessSecurity:wep-key0,
     * #NMSettingWirelessSecurity:wep-key1, #NMSettingWirelessSecurity:wep-key2,
     * and #NMSettingWirelessSecurity:wep-key3 properties.
     */
    wep_key_flags?: SettingSecretFlags
    /**
     * Controls the interpretation of WEP keys.  Allowed values are
     * %NM_WEP_KEY_TYPE_KEY, in which case the key is either a 10- or
     * 26-character hexadecimal string, or a 5- or 13-character ASCII password;
     * or %NM_WEP_KEY_TYPE_PASSPHRASE, in which case the passphrase is provided
     * as a string and will be hashed using the de-facto MD5 method to derive
     * the actual WEP key.
     */
    wep_key_type?: WepKeyType
    /**
     * Index 0 WEP key.  This is the WEP key used in most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key0?: string
    /**
     * Index 1 WEP key.  This WEP index is not used by most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key1?: string
    /**
     * Index 2 WEP key.  This WEP index is not used by most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key2?: string
    /**
     * Index 3 WEP key.  This WEP index is not used by most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key3?: string
    /**
     * When static WEP is used (ie, key-mgmt = "none") and a non-default WEP key
     * index is used by the AP, put that WEP key index here.  Valid values are 0
     * (default key) through 3.  Note that some consumer access points (like the
     * Linksys WRT54G) number the keys 1 - 4.
     */
    wep_tx_keyidx?: number
    /**
     * Flags indicating which mode of WPS is to be used if any.
     * 
     * There's little point in changing the default setting as NetworkManager will
     * automatically determine whether it's feasible to start WPS enrollment from
     * the Access Point capabilities.
     * 
     * WPS can be disabled by setting this property to a value of 1.
     */
    wps_method?: number
}
class SettingWirelessSecurity {
    /* Properties of NM-1.0.NM.SettingWirelessSecurity */
    /**
     * When WEP is used (ie, key-mgmt = "none" or "ieee8021x") indicate the
     * 802.11 authentication algorithm required by the AP here.  One of "open"
     * for Open System, "shared" for Shared Key, or "leap" for Cisco LEAP.  When
     * using Cisco LEAP (ie, key-mgmt = "ieee8021x" and auth-alg = "leap") the
     * "leap-username" and "leap-password" properties must be specified.
     */
    auth_alg: string
    /**
     * Indicates whether Fast Initial Link Setup (802.11ai) must be enabled for
     * the connection.  One of %NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT (use
     * global default value), %NM_SETTING_WIRELESS_SECURITY_FILS_DISABLE
     * (disable FILS), %NM_SETTING_WIRELESS_SECURITY_FILS_OPTIONAL (enable FILS
     * if the supplicant and the access point support it) or
     * %NM_SETTING_WIRELESS_SECURITY_FILS_REQUIRED (enable FILS and fail if not
     * supported).  When set to %NM_SETTING_WIRELESS_SECURITY_FILS_DEFAULT and
     * no global default is set, FILS will be optionally enabled.
     */
    fils: number
    /**
     * A list of group/broadcast encryption algorithms which prevents
     * connections to Wi-Fi networks that do not utilize one of the algorithms
     * in the list.  For maximum compatibility leave this property empty.  Each
     * list element may be one of "wep40", "wep104", "tkip", or "ccmp".
     */
    group: string[]
    /**
     * Key management used for the connection. One of "none" (WEP or no
     * password protection), "ieee8021x" (Dynamic WEP), "owe" (Opportunistic
     * Wireless Encryption), "wpa-psk" (WPA2 + WPA3 personal), "sae" (WPA3
     * personal only), "wpa-eap" (WPA2 + WPA3 enterprise) or
     * "wpa-eap-suite-b-192" (WPA3 enterprise only).
     * 
     * This property must be set for any Wi-Fi connection that uses security.
     */
    key_mgmt: string
    /**
     * The login password for legacy LEAP connections (ie, key-mgmt =
     * "ieee8021x" and auth-alg = "leap").
     */
    leap_password: string
    /**
     * Flags indicating how to handle the
     * #NMSettingWirelessSecurity:leap-password property.
     */
    leap_password_flags: SettingSecretFlags
    /**
     * The login username for legacy LEAP connections (ie, key-mgmt =
     * "ieee8021x" and auth-alg = "leap").
     */
    leap_username: string
    /**
     * A list of pairwise encryption algorithms which prevents connections to
     * Wi-Fi networks that do not utilize one of the algorithms in the list.
     * For maximum compatibility leave this property empty.  Each list element
     * may be one of "tkip" or "ccmp".
     */
    pairwise: string[]
    /**
     * Indicates whether Protected Management Frames (802.11w) must be enabled
     * for the connection.  One of %NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT
     * (use global default value), %NM_SETTING_WIRELESS_SECURITY_PMF_DISABLE
     * (disable PMF), %NM_SETTING_WIRELESS_SECURITY_PMF_OPTIONAL (enable PMF if
     * the supplicant and the access point support it) or
     * %NM_SETTING_WIRELESS_SECURITY_PMF_REQUIRED (enable PMF and fail if not
     * supported).  When set to %NM_SETTING_WIRELESS_SECURITY_PMF_DEFAULT and no
     * global default is set, PMF will be optionally enabled.
     */
    pmf: number
    /**
     * List of strings specifying the allowed WPA protocol versions to use.
     * Each element may be one "wpa" (allow WPA) or "rsn" (allow WPA2/RSN).  If
     * not specified, both WPA and RSN connections are allowed.
     */
    proto: string[]
    /**
     * Pre-Shared-Key for WPA networks. For WPA-PSK, it's either an ASCII
     * passphrase of 8 to 63 characters that is (as specified in the 802.11i
     * standard) hashed to derive the actual key, or the key in form of 64
     * hexadecimal character. The WPA3-Personal networks use a passphrase
     * of any length for SAE authentication.
     */
    psk: string
    /**
     * Flags indicating how to handle the #NMSettingWirelessSecurity:psk
     * property.
     */
    psk_flags: SettingSecretFlags
    /**
     * Flags indicating how to handle the #NMSettingWirelessSecurity:wep-key0,
     * #NMSettingWirelessSecurity:wep-key1, #NMSettingWirelessSecurity:wep-key2,
     * and #NMSettingWirelessSecurity:wep-key3 properties.
     */
    wep_key_flags: SettingSecretFlags
    /**
     * Controls the interpretation of WEP keys.  Allowed values are
     * %NM_WEP_KEY_TYPE_KEY, in which case the key is either a 10- or
     * 26-character hexadecimal string, or a 5- or 13-character ASCII password;
     * or %NM_WEP_KEY_TYPE_PASSPHRASE, in which case the passphrase is provided
     * as a string and will be hashed using the de-facto MD5 method to derive
     * the actual WEP key.
     */
    wep_key_type: WepKeyType
    /**
     * Index 0 WEP key.  This is the WEP key used in most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key0: string
    /**
     * Index 1 WEP key.  This WEP index is not used by most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key1: string
    /**
     * Index 2 WEP key.  This WEP index is not used by most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key2: string
    /**
     * Index 3 WEP key.  This WEP index is not used by most networks.  See the
     * "wep-key-type" property for a description of how this key is interpreted.
     */
    wep_key3: string
    /**
     * When static WEP is used (ie, key-mgmt = "none") and a non-default WEP key
     * index is used by the AP, put that WEP key index here.  Valid values are 0
     * (default key) through 3.  Note that some consumer access points (like the
     * Linksys WRT54G) number the keys 1 - 4.
     */
    wep_tx_keyidx: number
    /**
     * Flags indicating which mode of WPS is to be used if any.
     * 
     * There's little point in changing the default setting as NetworkManager will
     * automatically determine whether it's feasible to start WPS enrollment from
     * the Access Point capabilities.
     * 
     * WPS can be disabled by setting this property to a value of 1.
     */
    wps_method: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingWirelessSecurity */
    /**
     * Adds an encryption algorithm to the list of allowed groupwise encryption
     * algorithms.  If the list is not empty, then only access points that support
     * one or more of the encryption algorithms in the list will be considered
     * compatible with this connection.
     */
    add_group(group: string): boolean
    /**
     * Adds an encryption algorithm to the list of allowed pairwise encryption
     * algorithms.  If the list is not empty, then only access points that support
     * one or more of the encryption algorithms in the list will be considered
     * compatible with this connection.
     */
    add_pairwise(pairwise: string): boolean
    /**
     * Adds a Wi-Fi security protocol (one of "wpa" or "rsn") to the allowed list;
     * only protocols in this list will be used when finding and connecting to
     * the Wi-Fi network specified by this connection.  For example, if the
     * protocol list contains only "wpa" but the access point for the SSID specified
     * by this connection only supports WPA2/RSN, the connection cannot be used
     * with the access point.
     */
    add_proto(proto: string): boolean
    /**
     * Removes all algorithms from the allowed list.  If there are no algorithms
     * specified then all groupwise encryption algorithms are allowed.
     */
    clear_groups(): void
    /**
     * Removes all algorithms from the allowed list.  If there are no algorithms
     * specified then all pairwise encryption algorithms are allowed.
     */
    clear_pairwise(): void
    /**
     * Removes all protocols from the allowed list.  If there are no protocols
     * specified then all protocols are allowed.
     */
    clear_protos(): void
    get_auth_alg(): string
    get_fils(): SettingWirelessSecurityFils
    /**
     * Returns the allowed groupwise encryption algorithm from allowed algorithm
     * list.
     */
    get_group(i: number): string
    get_key_mgmt(): string
    get_leap_password(): string
    get_leap_password_flags(): SettingSecretFlags
    get_leap_username(): string
    get_num_groups(): number
    get_num_pairwise(): number
    get_num_protos(): number
    /**
     * Returns the allowed pairwise encryption algorithm from allowed algorithm
     * list.
     */
    get_pairwise(i: number): string
    get_pmf(): SettingWirelessSecurityPmf
    get_proto(i: number): string
    get_psk(): string
    get_psk_flags(): SettingSecretFlags
    get_wep_key(idx: number): string
    get_wep_key_flags(): SettingSecretFlags
    get_wep_key_type(): WepKeyType
    get_wep_tx_keyidx(): number
    get_wps_method(): SettingWirelessSecurityWpsMethod
    /**
     * Removes an encryption algorithm from the allowed groupwise encryption
     * algorithm list.
     */
    remove_group(i: number): void
    /**
     * Removes an encryption algorithm from the allowed groupwise encryption
     * algorithm list.
     */
    remove_group_by_value(group: string): boolean
    /**
     * Removes an encryption algorithm from the allowed pairwise encryption
     * algorithm list.
     */
    remove_pairwise(i: number): void
    /**
     * Removes an encryption algorithm from the allowed pairwise encryption
     * algorithm list.
     */
    remove_pairwise_by_value(pairwise: string): boolean
    /**
     * Removes a protocol from the allowed protocol list.
     */
    remove_proto(i: number): void
    /**
     * Removes a protocol from the allowed protocol list.
     */
    remove_proto_by_value(proto: string): boolean
    /**
     * Sets a WEP key in the given index.
     */
    set_wep_key(idx: number, key: string): void
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::auth-alg", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::auth-alg", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::fils", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fils", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::group", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::key-mgmt", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::key-mgmt", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::leap-password", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::leap-password", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::leap-password-flags", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::leap-password-flags", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::leap-username", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::leap-username", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pairwise", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pairwise", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pmf", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pmf", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::proto", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::proto", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::psk", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::psk", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::psk-flags", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::psk-flags", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wep-key-flags", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wep-key-flags", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wep-key-type", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wep-key-type", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wep-key0", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wep-key0", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wep-key1", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wep-key1", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wep-key2", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wep-key2", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wep-key3", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wep-key3", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wep-tx-keyidx", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wep-tx-keyidx", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wps-method", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wps-method", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingWirelessSecurity, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingWirelessSecurity_ConstructProps)
    _init (config?: SettingWirelessSecurity_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingWirelessSecurity
    static $gtype: GObject.Type
}
interface SettingWpan_ConstructProps extends Setting_ConstructProps {
    /* Constructor properties of NM-1.0.NM.SettingWpan */
    /**
     * IEEE 802.15.4 channel. A positive integer or -1, meaning "do not
     * set, use whatever the device is already set to".
     */
    channel?: number
    /**
     * If specified, this connection will only apply to the IEEE 802.15.4 (WPAN)
     * MAC layer device whose permanent MAC address matches.
     */
    mac_address?: string
    /**
     * IEEE 802.15.4 channel page. A positive integer or -1, meaning "do not
     * set, use whatever the device is already set to".
     */
    page?: number
    /**
     * IEEE 802.15.4 Personal Area Network (PAN) identifier.
     */
    pan_id?: number
    /**
     * Short IEEE 802.15.4 address to be used within a restricted environment.
     */
    short_address?: number
}
class SettingWpan {
    /* Properties of NM-1.0.NM.SettingWpan */
    /**
     * IEEE 802.15.4 channel. A positive integer or -1, meaning "do not
     * set, use whatever the device is already set to".
     */
    channel: number
    /**
     * If specified, this connection will only apply to the IEEE 802.15.4 (WPAN)
     * MAC layer device whose permanent MAC address matches.
     */
    mac_address: string
    /**
     * IEEE 802.15.4 channel page. A positive integer or -1, meaning "do not
     * set, use whatever the device is already set to".
     */
    page: number
    /**
     * IEEE 802.15.4 Personal Area Network (PAN) identifier.
     */
    pan_id: number
    /**
     * Short IEEE 802.15.4 address to be used within a restricted environment.
     */
    short_address: number
    /* Properties of NM-1.0.NM.Setting */
    /**
     * The setting's name, which uniquely identifies the setting within the
     * connection.  Each setting type has a name unique to that type, for
     * example "ppp" or "802-11-wireless" or "802-3-ethernet".
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.SettingWpan */
    get_channel(): number
    get_mac_address(): string
    get_page(): number
    get_pan_id(): number
    get_short_address(): number
    /* Methods of NM-1.0.NM.Setting */
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.
     */
    compare(b: Setting, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMSetting objects for similarity, with comparison behavior
     * modified by a set of flags.  See the documentation for #NMSettingCompareFlags
     * for a description of each flag's behavior.  If the settings differ, the keys
     * of each setting that differ from the other are added to `results,` mapped to
     * one or more #NMSettingDiffResult values.
     */
    diff(b: Setting, flags: SettingCompareFlags, invert_results: boolean, results: GLib.HashTable): [ /* returnType */ boolean, /* results */ GLib.HashTable ]
    /**
     * Duplicates a #NMSetting.
     */
    duplicate(): Setting
    /**
     * Iterates over each property of the #NMSetting object, calling the supplied
     * user function for each property.
     */
    enumerate_values(func: SettingValueIterFn): void
    /**
     * Gets the D-Bus marshalling type of a property. `property_name` is a D-Bus
     * property name, which may not necessarily be a #GObject property.
     */
    get_dbus_property_type(property_name: string): GLib.VariantType
    /**
     * Returns the type name of the #NMSetting object
     */
    get_name(): string
    /**
     * For a given secret, retrieves the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    get_secret_flags(secret_name: string, out_flags: SettingSecretFlags): boolean
    option_clear_by_name(predicate?: UtilsPredicateStr | null): void
    option_get(opt_name: string): GLib.Variant
    /**
     * Gives the name of all set options.
     */
    option_get_all_names(): string[]
    option_get_boolean(opt_name: string): [ /* returnType */ boolean, /* out_value */ boolean | null ]
    option_get_uint32(opt_name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * If `variant` is %NULL, this clears the option if it is set.
     * Otherwise, `variant` is set as the option. If `variant` is
     * a floating reference, it will be consumed.
     * 
     * Note that not all setting types support options. It is a bug
     * setting a variant to a setting that doesn't support it.
     * Currently, only #NMSettingEthtool supports it.
     */
    option_set(opt_name: string, variant?: GLib.Variant | null): void
    /**
     * Like nm_setting_option_set() to set a boolean GVariant.
     */
    option_set_boolean(opt_name: string, value: boolean): void
    /**
     * Like nm_setting_option_set() to set a uint32 GVariant.
     */
    option_set_uint32(opt_name: string, value: number): void
    /**
     * For a given secret, stores the #NMSettingSecretFlags describing how to
     * handle that secret.
     */
    set_secret_flags(secret_name: string, flags: SettingSecretFlags): boolean
    /**
     * Convert the setting (including secrets!) into a string. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    to_string(): string
    /**
     * Validates the setting.  Each setting's properties have allowed values, and
     * some are dependent on other values (hence the need for `connection)`.  The
     * returned #GError contains information about which property of the setting
     * failed validation, and in what way that property failed validation.
     */
    verify(connection?: Connection | null): boolean
    /**
     * Verifies the secrets in the setting.
     * The returned #GError contains information about which secret of the setting
     * failed validation, and in what way that secret failed validation.
     * The secret validation is done separately from main setting validation, because
     * in some cases connection failure is not desired just for the secrets.
     */
    verify_secrets(connection?: Connection | null): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::mac-address", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mac-address", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::page", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::page", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::pan-id", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::pan-id", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::short-address", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::short-address", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: SettingWpan, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SettingWpan_ConstructProps)
    _init (config?: SettingWpan_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SettingWpan
    static $gtype: GObject.Type
}
interface SimpleConnection_ConstructProps extends GObject.Object_ConstructProps {
}
class SimpleConnection {
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of NM-1.0.NM.Connection */
    /**
     * Adds a #NMSetting to the connection, replacing any previous #NMSetting of the
     * same name which has previously been added to the #NMConnection.  The
     * connection takes ownership of the #NMSetting object and does not increase
     * the setting object's reference count.
     */
    add_setting(setting: Setting): void
    /**
     * Clears and frees any secrets that may be stored in the connection, to avoid
     * keeping secret data in memory when not needed.
     */
    clear_secrets(): void
    /**
     * Clears and frees secrets determined by `func`.
     */
    clear_secrets_with_flags(func?: SettingClearSecretsWithFlagsFn | null): void
    /**
     * Deletes all of `connection'`s settings.
     */
    clear_settings(): void
    /**
     * Compares two #NMConnection objects for similarity, with comparison behavior
     * modified by a set of flags.  See nm_setting_compare() for a description of
     * each flag's behavior.
     */
    compare(b: Connection, flags: SettingCompareFlags): boolean
    /**
     * Compares two #NMConnection objects for similarity, with comparison behavior
     * modified by a set of flags.  See nm_setting_compare() for a description of
     * each flag's behavior.  If the connections differ, settings and keys within
     * each setting that differ are added to the returned `out_settings` hash table.
     * No values are returned, only key names.
     */
    diff(b: Connection, flags: SettingCompareFlags, out_settings: GLib.HashTable): boolean
    /**
     * Print the connection (including secrets!) to stdout. For debugging
     * purposes ONLY, should NOT be used for serialization of the setting,
     * or machine-parsed in any way. The output format is not guaranteed to
     * be stable and may change at any time.
     */
    dump(): void
    /**
     * Iterates over the properties of each #NMSetting object in the #NMConnection,
     * calling the supplied user function for each property.
     */
    for_each_setting_value(func: SettingValueIterFn): void
    /**
     * A shortcut to return the type from the connection's #NMSettingConnection.
     */
    get_connection_type(): string
    /**
     * A shortcut to return the ID from the connection's #NMSettingConnection.
     */
    get_id(): string
    /**
     * Returns the interface name as stored in NMSettingConnection:interface_name.
     * If the connection contains no NMSettingConnection, it will return %NULL.
     * 
     * For hardware devices and software devices created outside of NetworkManager,
     * this name is used to match the device. for software devices created by
     * NetworkManager, this is the name of the created interface.
     */
    get_interface_name(): string
    /**
     * Returns the connection's D-Bus path.
     */
    get_path(): string
    /**
     * Gets the #NMSetting with the given #GType, if one has been previously added
     * to the #NMConnection.
     */
    get_setting(setting_type: GObject.Type): Setting
    /**
     * A shortcut to return any #NMSetting8021x the connection might contain.
     */
    get_setting_802_1x(): Setting8021x
    /**
     * A shortcut to return any #NMSettingAdsl the connection might contain.
     */
    get_setting_adsl(): SettingAdsl
    /**
     * A shortcut to return any #NMSettingBluetooth the connection might contain.
     */
    get_setting_bluetooth(): SettingBluetooth
    /**
     * A shortcut to return any #NMSettingBond the connection might contain.
     */
    get_setting_bond(): SettingBond
    /**
     * A shortcut to return any #NMSettingBridge the connection might contain.
     */
    get_setting_bridge(): SettingBridge
    /**
     * A shortcut to return any #NMSettingBridgePort the connection might contain.
     */
    get_setting_bridge_port(): SettingBridgePort
    /**
     * Gets the #NMSetting with the given name, if one has been previously added
     * the #NMConnection.
     */
    get_setting_by_name(name: string): Setting
    /**
     * A shortcut to return any #NMSettingCdma the connection might contain.
     */
    get_setting_cdma(): SettingCdma
    /**
     * A shortcut to return any #NMSettingConnection the connection might contain.
     */
    get_setting_connection(): SettingConnection
    /**
     * A shortcut to return any #NMSettingDcb the connection might contain.
     */
    get_setting_dcb(): SettingDcb
    /**
     * A shortcut to return any #NMSettingDummy the connection might contain.
     */
    get_setting_dummy(): SettingDummy
    /**
     * A shortcut to return any #NMSettingGeneric the connection might contain.
     */
    get_setting_generic(): SettingGeneric
    /**
     * A shortcut to return any #NMSettingGsm the connection might contain.
     */
    get_setting_gsm(): SettingGsm
    /**
     * A shortcut to return any #NMSettingInfiniband the connection might contain.
     */
    get_setting_infiniband(): SettingInfiniband
    /**
     * A shortcut to return any #NMSettingIP4Config the connection might contain.
     * 
     * Note that it returns the value as type #NMSettingIPConfig, since the vast
     * majority of IPv4-setting-related methods are on that type, not
     * #NMSettingIP4Config.
     */
    get_setting_ip4_config(): SettingIP4Config
    /**
     * A shortcut to return any #NMSettingIP6Config the connection might contain.
     * 
     * Note that it returns the value as type #NMSettingIPConfig, since the vast
     * majority of IPv6-setting-related methods are on that type, not
     * #NMSettingIP6Config.
     */
    get_setting_ip6_config(): SettingIP6Config
    /**
     * A shortcut to return any #NMSettingIPTunnel the connection might contain.
     */
    get_setting_ip_tunnel(): SettingIPTunnel
    /**
     * A shortcut to return any #NMSettingMacsec the connection might contain.
     */
    get_setting_macsec(): SettingMacsec
    /**
     * A shortcut to return any #NMSettingMacvlan the connection might contain.
     */
    get_setting_macvlan(): SettingMacvlan
    /**
     * A shortcut to return any #NMSettingOlpcMesh the connection might contain.
     */
    get_setting_olpc_mesh(): SettingOlpcMesh
    /**
     * A shortcut to return any #NMSettingOvsBridge the connection might contain.
     */
    get_setting_ovs_bridge(): SettingOvsBridge
    /**
     * A shortcut to return any #NMSettingOvsInterface the connection might contain.
     */
    get_setting_ovs_interface(): SettingOvsInterface
    /**
     * A shortcut to return any #NMSettingOvsPatch the connection might contain.
     */
    get_setting_ovs_patch(): SettingOvsPatch
    /**
     * A shortcut to return any #NMSettingOvsPort the connection might contain.
     */
    get_setting_ovs_port(): SettingOvsPort
    /**
     * A shortcut to return any #NMSettingPpp the connection might contain.
     */
    get_setting_ppp(): SettingPpp
    /**
     * A shortcut to return any #NMSettingPppoe the connection might contain.
     */
    get_setting_pppoe(): SettingPppoe
    /**
     * A shortcut to return any #NMSettingProxy the connection might contain.
     */
    get_setting_proxy(): SettingProxy
    /**
     * A shortcut to return any #NMSettingSerial the connection might contain.
     */
    get_setting_serial(): SettingSerial
    /**
     * A shortcut to return any #NMSettingTCConfig the connection might contain.
     */
    get_setting_tc_config(): SettingTCConfig
    /**
     * A shortcut to return any #NMSettingTeam the connection might contain.
     */
    get_setting_team(): SettingTeam
    /**
     * A shortcut to return any #NMSettingTeamPort the connection might contain.
     */
    get_setting_team_port(): SettingTeamPort
    /**
     * A shortcut to return any #NMSettingTun the connection might contain.
     */
    get_setting_tun(): SettingTun
    /**
     * A shortcut to return any #NMSettingVlan the connection might contain.
     */
    get_setting_vlan(): SettingVlan
    /**
     * A shortcut to return any #NMSettingVpn the connection might contain.
     */
    get_setting_vpn(): SettingVpn
    /**
     * A shortcut to return any #NMSettingVxlan the connection might contain.
     */
    get_setting_vxlan(): SettingVxlan
    /**
     * A shortcut to return any #NMSettingWimax the connection might contain.
     */
    get_setting_wimax(): SettingWimax
    /**
     * A shortcut to return any #NMSettingWired the connection might contain.
     */
    get_setting_wired(): SettingWired
    /**
     * A shortcut to return any #NMSettingWireless the connection might contain.
     */
    get_setting_wireless(): SettingWireless
    /**
     * A shortcut to return any #NMSettingWirelessSecurity the connection might contain.
     */
    get_setting_wireless_security(): SettingWirelessSecurity
    /**
     * Retrieves the settings in `connection`.
     * 
     * The returned array is %NULL-terminated.
     */
    get_settings(): Setting[]
    /**
     * A shortcut to return the UUID from the connection's #NMSettingConnection.
     */
    get_uuid(): string
    /**
     * Returns the name that nm_device_disambiguate_names() would
     * return for the virtual device that would be created for `connection`.
     * Eg, "VLAN (eth1.1)".
     */
    get_virtual_device_description(): string
    /**
     * A convenience function to check if the given `connection` is a particular
     * type (ie wired, Wi-Fi, ppp, etc). Checks the #NMSettingConnection:type
     * property of the connection and matches that against `type`.
     */
    is_type(type: string): boolean
    /**
     * Checks if `connection` refers to a virtual device (and thus can potentially be
     * activated even if the device it refers to doesn't exist).
     */
    is_virtual(): boolean
    /**
     * Returns the name of the first setting object in the connection which would
     * need secrets to make a successful connection.  The returned hints are only
     * intended as a guide to what secrets may be required, because in some
     * circumstances, there is no way to conclusively determine exactly which
     * secrets are needed.
     */
    need_secrets(): [ /* returnType */ string, /* hints */ string[] | null ]
    /**
     * Does some basic normalization and fixup of well known inconsistencies
     * and deprecated fields. If the connection was modified in any way,
     * the output parameter `modified` is set %TRUE.
     * 
     * Finally the connection will be verified and %TRUE returns if the connection
     * is valid. As this function only performs some specific normalization steps
     * it cannot repair all connections. If the connection has errors that
     * cannot be normalized, the connection will not be modified.
     */
    normalize(parameters?: GLib.HashTable | null): [ /* returnType */ boolean, /* modified */ boolean | null ]
    /**
     * Removes the #NMSetting with the given #GType from the #NMConnection.  This
     * operation dereferences the #NMSetting object.
     */
    remove_setting(setting_type: GObject.Type): void
    /**
     * Replaces `connection'`s settings with `new_settings` (which must be
     * syntactically valid, and describe a known type of connection, but does not
     * need to result in a connection that passes nm_connection_verify()).
     */
    replace_settings(new_settings: GLib.Variant): boolean
    /**
     * Deep-copies the settings of `new_connection` and replaces the settings of `connection`
     * with the copied settings.
     */
    replace_settings_from_connection(new_connection: Connection): void
    /**
     * Sets the D-Bus path of the connection.  This property is not serialized, and
     * is only for the reference of the caller.  Sets the #NMConnection:path
     * property.
     */
    set_path(path: string): void
    /**
     * Converts the #NMConnection into a #GVariant of type
     * %NM_VARIANT_TYPE_CONNECTION describing the connection, suitable for
     * marshalling over D-Bus or otherwise serializing.
     */
    to_dbus(flags: ConnectionSerializationFlags): GLib.Variant
    /**
     * Update the specified setting's secrets, given a dictionary of secrets
     * intended for that setting (deserialized from D-Bus for example).  Will also
     * extract the given setting's secrets hash if given a connection dictionary.
     * If `setting_name` is %NULL, expects a fully serialized #NMConnection as
     * returned by nm_connection_to_dbus() and will update all secrets from all
     * settings contained in `secrets`.
     */
    update_secrets(setting_name: string, secrets: GLib.Variant): boolean
    /**
     * Validates the connection and all its settings.  Each setting's properties
     * have allowed values, and some values are dependent on other values.  For
     * example, if a Wi-Fi connection is security enabled, the #NMSettingWireless
     * setting object's 'security' property must contain the setting name of the
     * #NMSettingWirelessSecurity object, which must also be present in the
     * connection for the connection to be valid.  As another example, the
     * #NMSettingWired object's 'mac-address' property must be a validly formatted
     * MAC address.  The returned #GError contains information about which
     * setting and which property failed validation, and how it failed validation.
     */
    verify(): boolean
    /**
     * Verifies the secrets in the connection.
     */
    verify_secrets(): boolean
    /* Virtual methods of NM-1.0.NM.SimpleConnection */
    vfunc_changed(): void
    vfunc_secrets_cleared(): void
    vfunc_secrets_updated(setting: string): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: SimpleConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: SimpleConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.Connection */
    /**
     * The ::changed signal is emitted when any property (including secrets)
     * of any setting of the connection is modified, or when settings are
     * added or removed.
     */
    connect(sigName: "changed", callback: (($obj: SimpleConnection) => void)): number
    connect_after(sigName: "changed", callback: (($obj: SimpleConnection) => void)): number
    emit(sigName: "changed"): void
    /**
     * The ::secrets-cleared signal is emitted when the secrets of a connection
     * are cleared.
     */
    connect(sigName: "secrets-cleared", callback: (($obj: SimpleConnection) => void)): number
    connect_after(sigName: "secrets-cleared", callback: (($obj: SimpleConnection) => void)): number
    emit(sigName: "secrets-cleared"): void
    /**
     * The ::secrets-updated signal is emitted when the secrets of a setting
     * have been changed.
     */
    connect(sigName: "secrets-updated", callback: (($obj: SimpleConnection, setting_name: string) => void)): number
    connect_after(sigName: "secrets-updated", callback: (($obj: SimpleConnection, setting_name: string) => void)): number
    emit(sigName: "secrets-updated", setting_name: string): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: SimpleConnection_ConstructProps)
    _init (config?: SimpleConnection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Clones an #NMConnection as an #NMSimpleConnection.
     */
    static new_clone(connection: Connection): Connection
    /**
     * Creates a new #NMSimpleConnection from a hash table describing the
     * connection and normalize the connection.  See nm_connection_to_dbus() for a
     * description of the expected hash table.
     */
    static new_from_dbus(dict: GLib.Variant): Connection
    static $gtype: GObject.Type
}
interface VpnConnection_ConstructProps extends ActiveConnection_ConstructProps {
}
class VpnConnection {
    /* Properties of NM-1.0.NM.VpnConnection */
    /**
     * The VPN login banner of the active VPN connection.
     */
    readonly banner: string
    /**
     * The VPN state of the active VPN connection.
     */
    readonly vpn_state: VpnConnectionState
    /* Properties of NM-1.0.NM.ActiveConnection */
    /**
     * The connection that this is an active instance of.
     */
    readonly connection: RemoteConnection
    /**
     * Whether the active connection is the default IPv4 one.
     */
    readonly "default": boolean
    /**
     * Whether the active connection is the default IPv6 one.
     */
    readonly default6: boolean
    /**
     * The devices of the active connection.
     */
    readonly devices: Device[]
    /**
     * The IPv4 #NMDhcpConfig of the connection.
     */
    readonly dhcp4_config: DhcpConfig
    /**
     * The IPv6 #NMDhcpConfig of the connection.
     */
    readonly dhcp6_config: DhcpConfig
    /**
     * The active connection's ID
     */
    readonly id: string
    /**
     * The IPv4 #NMIPConfig of the connection.
     */
    readonly ip4_config: IPConfig
    /**
     * The IPv6 #NMIPConfig of the connection.
     */
    readonly ip6_config: IPConfig
    /**
     * The master device if one exists.
     */
    readonly master: Device
    /**
     * The path to the "specific object" of the active connection; see
     * nm_active_connection_get_specific_object_path() for more details.
     */
    readonly specific_object_path: string
    /**
     * The state of the active connection.
     */
    readonly state: ActiveConnectionState
    /**
     * The state flags of the active connection.
     */
    readonly state_flags: number
    /**
     * The active connection's type
     */
    readonly type: string
    /**
     * The active connection's UUID
     */
    readonly uuid: string
    /**
     * Whether the active connection is a VPN connection.
     */
    readonly vpn: boolean
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.VpnConnection */
    /**
     * Gets the VPN login banner of the active #NMVpnConnection.
     */
    get_banner(): string
    /**
     * Gets the current #NMVpnConnection state.
     */
    get_vpn_state(): VpnConnectionState
    /* Methods of NM-1.0.NM.ActiveConnection */
    /**
     * Gets the #NMRemoteConnection associated with `connection`.
     */
    get_connection(): RemoteConnection
    /**
     * Gets the #NMConnection's type.
     */
    get_connection_type(): string
    /**
     * Whether the active connection is the default IPv4 one (that is, is used for
     * the default IPv4 route and DNS information).
     */
    get_default(): boolean
    /**
     * Whether the active connection is the default IPv6 one (that is, is used for
     * the default IPv6 route and DNS information).
     */
    get_default6(): boolean
    /**
     * Gets the #NMDevices used for the active connections.
     */
    get_devices(): Device[]
    /**
     * Gets the current IPv4 #NMDhcpConfig (if any) associated with the
     * #NMActiveConnection.
     */
    get_dhcp4_config(): DhcpConfig
    /**
     * Gets the current IPv6 #NMDhcpConfig (if any) associated with the
     * #NMActiveConnection.
     */
    get_dhcp6_config(): DhcpConfig
    /**
     * Gets the #NMConnection's ID.
     */
    get_id(): string
    /**
     * Gets the current IPv4 #NMIPConfig associated with the #NMActiveConnection.
     */
    get_ip4_config(): IPConfig
    /**
     * Gets the current IPv6 #NMIPConfig associated with the #NMActiveConnection.
     */
    get_ip6_config(): IPConfig
    /**
     * Gets the master #NMDevice of the connection.
     */
    get_master(): Device
    /**
     * Gets the path of the "specific object" used at activation.
     * 
     * Currently, there is no single method that will allow you to automatically turn
     * this into an appropriate #NMObject; you need to know what kind of object it
     * is based on other information. (Eg, if `connection` corresponds to a Wi-Fi
     * connection, then the specific object will be an #NMAccessPoint, and you can
     * resolve it with nm_device_wifi_get_access_point_by_path().)
     */
    get_specific_object_path(): string
    /**
     * Gets the active connection's state.
     */
    get_state(): ActiveConnectionState
    /**
     * Gets the active connection's state flags.
     */
    get_state_flags(): ActivationStateFlags
    /**
     * Gets the reason for active connection's state.
     */
    get_state_reason(): ActiveConnectionStateReason
    /**
     * Gets the #NMConnection's UUID.
     */
    get_uuid(): string
    /**
     * Whether the active connection is a VPN connection.
     */
    get_vpn(): boolean
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.VpnConnection */
    connect(sigName: "vpn-state-changed", callback: (($obj: VpnConnection, object: number, p0: number) => void)): number
    connect_after(sigName: "vpn-state-changed", callback: (($obj: VpnConnection, object: number, p0: number) => void)): number
    emit(sigName: "vpn-state-changed", object: number, p0: number): void
    /* Signals of NM-1.0.NM.ActiveConnection */
    connect(sigName: "state-changed", callback: (($obj: VpnConnection, state: number, reason: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: VpnConnection, state: number, reason: number) => void)): number
    emit(sigName: "state-changed", state: number, reason: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::banner", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::banner", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vpn-state", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vpn-state", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::connection", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::default", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::default", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::default6", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::default6", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::devices", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::devices", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp4-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp4-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::dhcp6-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::dhcp6-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::id", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::id", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip4-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip4-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::ip6-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::ip6-config", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::master", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::master", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::specific-object-path", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::specific-object-path", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::state-flags", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-flags", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::type", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::type", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::uuid", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uuid", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::vpn", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vpn", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: VpnConnection, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VpnConnection_ConstructProps)
    _init (config?: VpnConnection_ConstructProps): void
    static $gtype: GObject.Type
}
interface VpnPluginInfo_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of NM-1.0.NM.VpnPluginInfo */
    /**
     * The filename from which the info was loaded.
     * Can be %NULL if the instance was not loaded from
     * a file (i.e. the keyfile instance was passed to the
     * constructor).
     */
    filename?: string
    /**
     * Initialize the instance with a different keyfile instance.
     * When passing a keyfile instance, the constructor will not
     * try to read from filename.
     */
    keyfile?: GLib.KeyFile
}
class VpnPluginInfo {
    /* Properties of NM-1.0.NM.VpnPluginInfo */
    /**
     * The name of the VPN plugin.
     */
    readonly name: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.VpnPluginInfo */
    get_aliases(): string[]
    get_auth_dialog(): string
    get_editor_plugin(): VpnEditorPlugin
    get_filename(): string
    get_name(): string
    get_plugin(): string
    get_program(): string
    get_service(): string
    load_editor_plugin(): VpnEditorPlugin
    lookup_property(group: string, key: string): string
    /**
     * Set the internal plugin instance. If %NULL, only clear the previous instance.
     */
    set_editor_plugin(plugin?: VpnEditorPlugin | null): void
    supports_hints(): boolean
    supports_multiple(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of NM-1.0.NM.VpnPluginInfo */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VpnPluginInfo, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VpnPluginInfo, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: VpnPluginInfo, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: VpnPluginInfo, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VpnPluginInfo_ConstructProps)
    _init (config?: VpnPluginInfo_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new_from_file(filename: string): VpnPluginInfo
    static new_search_file(name?: string | null, service?: string | null): VpnPluginInfo
    static new_with_data(filename: string, keyfile: GLib.KeyFile): VpnPluginInfo
    static list_add(list: VpnPluginInfo[], plugin_info: VpnPluginInfo): boolean
    static list_find_by_filename(list: VpnPluginInfo[], filename: string): VpnPluginInfo
    static list_find_by_name(list: VpnPluginInfo[], name: string): VpnPluginInfo
    static list_find_by_service(list: VpnPluginInfo[], service: string): VpnPluginInfo
    /**
     * A VPN plugin provides one or several service-types, like org.freedesktop.NetworkManager.libreswan
     * Certain plugins provide more then one service type, via aliases (org.freedesktop.NetworkManager.openswan).
     * This function looks up a service-type (or an alias) based on a name.
     * 
     * Preferably, the name can be a full service-type/alias of an installed
     * plugin. Otherwise, it can be the name of a VPN plugin (in which case, the
     * primary, non-aliased service-type is returned). Otherwise, it can be
     * one of several well known short-names (which is a hard-coded list of
     * types in libnm). On success, this returns a full qualified service-type
     * (or an alias). It doesn't say, that such an plugin is actually available,
     * but it could be retrieved via nm_vpn_plugin_info_list_find_by_service().
     */
    static list_find_service_type(list: VpnPluginInfo[], name: string): string
    static list_get_service_types(list: VpnPluginInfo[], only_existing: boolean, with_abbreviations: boolean): string[]
    static list_load(): VpnPluginInfo[]
    /**
     * Remove `plugin_info` from `list`.
     */
    static list_remove(list: VpnPluginInfo[], plugin_info: VpnPluginInfo): boolean
    /**
     * Regular name files have a certain pattern. That basically means
     * they have the file extension "name". Check if `filename`
     * is valid according to that pattern.
     */
    static validate_filename(filename: string): boolean
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface VpnPluginOld_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of NM-1.0.NM.VpnPluginOld */
    /**
     * The D-Bus service name of this plugin.
     */
    service_name?: string
    /**
     * The state of the plugin.
     */
    state?: VpnServiceState
}
class VpnPluginOld {
    /* Properties of NM-1.0.NM.VpnPluginOld */
    /**
     * The state of the plugin.
     */
    state: VpnServiceState
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.VpnPluginOld */
    disconnect(): boolean
    failure(reason: VpnPluginFailure): void
    get_connection(): Gio.DBusConnection
    get_state(): VpnServiceState
    /**
     * Called by VPN plugin implementations to signal to NetworkManager that secrets
     * are required during the connection process.  This signal may be used to
     * request new secrets when the secrets originally provided by NetworkManager
     * are insufficient, or the VPN process indicates that it needs additional
     * information to complete the request.
     */
    secrets_required(message: string, hints: string): void
    set_config(config: GLib.Variant): void
    set_ip4_config(ip4_config: GLib.Variant): void
    set_ip6_config(ip6_config: GLib.Variant): void
    set_login_banner(banner: string): void
    set_state(state: VpnServiceState): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of NM-1.0.NM.VpnPluginOld */
    vfunc_config(config: GLib.Variant): void
    vfunc_connect(connection: Connection): boolean
    vfunc_connect_interactive(connection: Connection, details: GLib.Variant): boolean
    vfunc_disconnect(): boolean
    vfunc_failure(reason: VpnPluginFailure): void
    vfunc_ip4_config(ip4_config: GLib.Variant): void
    vfunc_ip6_config(config: GLib.Variant): void
    vfunc_login_banner(banner: string): void
    vfunc_need_secrets(connection: Connection, setting_name: string): boolean
    vfunc_new_secrets(connection: Connection): boolean
    vfunc_quit(): void
    vfunc_state_changed(state: VpnServiceState): void
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.VpnPluginOld */
    connect(sigName: "config", callback: (($obj: VpnPluginOld, object: GLib.Variant) => void)): number
    connect_after(sigName: "config", callback: (($obj: VpnPluginOld, object: GLib.Variant) => void)): number
    emit(sigName: "config", object: GLib.Variant): void
    connect(sigName: "failure", callback: (($obj: VpnPluginOld, object: number) => void)): number
    connect_after(sigName: "failure", callback: (($obj: VpnPluginOld, object: number) => void)): number
    emit(sigName: "failure", object: number): void
    connect(sigName: "ip4-config", callback: (($obj: VpnPluginOld, object: GLib.Variant) => void)): number
    connect_after(sigName: "ip4-config", callback: (($obj: VpnPluginOld, object: GLib.Variant) => void)): number
    emit(sigName: "ip4-config", object: GLib.Variant): void
    connect(sigName: "ip6-config", callback: (($obj: VpnPluginOld, object: GLib.Variant) => void)): number
    connect_after(sigName: "ip6-config", callback: (($obj: VpnPluginOld, object: GLib.Variant) => void)): number
    emit(sigName: "ip6-config", object: GLib.Variant): void
    connect(sigName: "login-banner", callback: (($obj: VpnPluginOld, object: string) => void)): number
    connect_after(sigName: "login-banner", callback: (($obj: VpnPluginOld, object: string) => void)): number
    emit(sigName: "login-banner", object: string): void
    connect(sigName: "quit", callback: (($obj: VpnPluginOld) => void)): number
    connect_after(sigName: "quit", callback: (($obj: VpnPluginOld) => void)): number
    emit(sigName: "quit"): void
    connect(sigName: "secrets-required", callback: (($obj: VpnPluginOld, object: string, p0: string[]) => void)): number
    connect_after(sigName: "secrets-required", callback: (($obj: VpnPluginOld, object: string, p0: string[]) => void)): number
    emit(sigName: "secrets-required", object: string, p0: string[]): void
    connect(sigName: "state-changed", callback: (($obj: VpnPluginOld, object: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: VpnPluginOld, object: number) => void)): number
    emit(sigName: "state-changed", object: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VpnPluginOld, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VpnPluginOld, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::state", callback: (($obj: VpnPluginOld, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: VpnPluginOld, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VpnPluginOld_ConstructProps)
    _init (config?: VpnPluginOld_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Given a VPN secret key name, attempts to find the corresponding flags data
     * item in `data`.  If found, converts the flags data item to
     * #NMSettingSecretFlags and returns it.
     */
    static get_secret_flags(data: GLib.HashTable, secret_name: string): [ /* returnType */ boolean, /* out_flags */ SettingSecretFlags ]
    /**
     * Parses key/value pairs from a file descriptor (normally stdin) passed by
     * an applet when the applet calls the authentication dialog of the VPN plugin.
     */
    static read_vpn_details(fd: number): [ /* returnType */ boolean, /* out_data */ GLib.HashTable, /* out_secrets */ GLib.HashTable ]
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface VpnServicePlugin_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of NM-1.0.NM.VpnServicePlugin */
    /**
     * The D-Bus service name of this plugin.
     */
    service_name?: string
    /**
     * The state of the plugin.
     */
    state?: VpnServiceState
    /**
     * Whether to watch for D-Bus peer's changes.
     */
    watch_peer?: boolean
}
class VpnServicePlugin {
    /* Properties of NM-1.0.NM.VpnServicePlugin */
    /**
     * The state of the plugin.
     */
    state: VpnServiceState
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.VpnServicePlugin */
    disconnect(): boolean
    failure(reason: VpnPluginFailure): void
    get_connection(): Gio.DBusConnection
    /**
     * Called by VPN plugin implementations to signal to NetworkManager that secrets
     * are required during the connection process.  This signal may be used to
     * request new secrets when the secrets originally provided by NetworkManager
     * are insufficient, or the VPN process indicates that it needs additional
     * information to complete the request.
     */
    secrets_required(message: string, hints: string): void
    set_config(config: GLib.Variant): void
    set_ip4_config(ip4_config: GLib.Variant): void
    set_ip6_config(ip6_config: GLib.Variant): void
    set_login_banner(banner: string): void
    /**
     * Shutdown the `plugin` and disconnect from D-Bus. After this,
     * the plugin instance is dead and should no longer be used.
     * It ensures to get no more requests from D-Bus. In principle,
     * you don't need to shutdown the plugin, disposing the instance
     * has the same effect. However, this gives a way to deactivate
     * the plugin before giving up the last reference.
     */
    shutdown(): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of NM-1.0.NM.VpnServicePlugin */
    vfunc_config(config: GLib.Variant): void
    vfunc_connect(connection: Connection): boolean
    vfunc_connect_interactive(connection: Connection, details: GLib.Variant): boolean
    vfunc_disconnect(): boolean
    vfunc_failure(reason: VpnPluginFailure): void
    vfunc_ip4_config(ip4_config: GLib.Variant): void
    vfunc_ip6_config(config: GLib.Variant): void
    vfunc_login_banner(banner: string): void
    vfunc_need_secrets(connection: Connection, setting_name: string): boolean
    vfunc_new_secrets(connection: Connection): boolean
    vfunc_quit(): void
    vfunc_state_changed(state: VpnServiceState): void
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    vfunc_init(cancellable?: Gio.Cancellable | null): boolean
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of NM-1.0.NM.VpnServicePlugin */
    connect(sigName: "config", callback: (($obj: VpnServicePlugin, object: GLib.Variant) => void)): number
    connect_after(sigName: "config", callback: (($obj: VpnServicePlugin, object: GLib.Variant) => void)): number
    emit(sigName: "config", object: GLib.Variant): void
    connect(sigName: "failure", callback: (($obj: VpnServicePlugin, object: number) => void)): number
    connect_after(sigName: "failure", callback: (($obj: VpnServicePlugin, object: number) => void)): number
    emit(sigName: "failure", object: number): void
    connect(sigName: "ip4-config", callback: (($obj: VpnServicePlugin, object: GLib.Variant) => void)): number
    connect_after(sigName: "ip4-config", callback: (($obj: VpnServicePlugin, object: GLib.Variant) => void)): number
    emit(sigName: "ip4-config", object: GLib.Variant): void
    connect(sigName: "ip6-config", callback: (($obj: VpnServicePlugin, object: GLib.Variant) => void)): number
    connect_after(sigName: "ip6-config", callback: (($obj: VpnServicePlugin, object: GLib.Variant) => void)): number
    emit(sigName: "ip6-config", object: GLib.Variant): void
    connect(sigName: "login-banner", callback: (($obj: VpnServicePlugin, object: string) => void)): number
    connect_after(sigName: "login-banner", callback: (($obj: VpnServicePlugin, object: string) => void)): number
    emit(sigName: "login-banner", object: string): void
    connect(sigName: "quit", callback: (($obj: VpnServicePlugin) => void)): number
    connect_after(sigName: "quit", callback: (($obj: VpnServicePlugin) => void)): number
    emit(sigName: "quit"): void
    connect(sigName: "secrets-required", callback: (($obj: VpnServicePlugin, object: string, p0: string[]) => void)): number
    connect_after(sigName: "secrets-required", callback: (($obj: VpnServicePlugin, object: string, p0: string[]) => void)): number
    emit(sigName: "secrets-required", object: string, p0: string[]): void
    connect(sigName: "state-changed", callback: (($obj: VpnServicePlugin, object: number) => void)): number
    connect_after(sigName: "state-changed", callback: (($obj: VpnServicePlugin, object: number) => void)): number
    emit(sigName: "state-changed", object: number): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: VpnServicePlugin, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: VpnServicePlugin, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::state", callback: (($obj: VpnServicePlugin, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: VpnServicePlugin, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: VpnServicePlugin_ConstructProps)
    _init (config?: VpnServicePlugin_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Given a VPN secret key name, attempts to find the corresponding flags data
     * item in `data`.  If found, converts the flags data item to
     * #NMSettingSecretFlags and returns it.
     */
    static get_secret_flags(data: GLib.HashTable, secret_name: string): [ /* returnType */ boolean, /* out_flags */ SettingSecretFlags ]
    /**
     * Parses key/value pairs from a file descriptor (normally stdin) passed by
     * an applet when the applet calls the authentication dialog of the VPN plugin.
     */
    static read_vpn_details(fd: number): [ /* returnType */ boolean, /* out_data */ GLib.HashTable, /* out_secrets */ GLib.HashTable ]
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(object_type: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface WifiP2PPeer_ConstructProps extends Object_ConstructProps {
}
class WifiP2PPeer {
    /* Properties of NM-1.0.NM.WifiP2PPeer */
    /**
     * The flags of the P2P peer.
     */
    readonly flags: TODO_80211ApFlags
    /**
     * The hardware address of the P2P peer.
     */
    readonly hw_address: string
    /**
     * The timestamp (in CLOCK_BOOTTIME seconds) for the last time the
     * P2P peer was found.  A value of -1 means the peer has never been seen.
     */
    readonly last_seen: number
    /**
     * The manufacturer of the P2P peer.
     */
    readonly manufacturer: string
    /**
     * The model of the P2P peer.
     */
    readonly model: string
    /**
     * The hardware address of the P2P peer.
     */
    readonly model_number: string
    /**
     * The name of the P2P peer.
     */
    readonly name: string
    /**
     * The serial number of the P2P peer.
     */
    readonly serial: string
    /**
     * The current signal strength of the P2P peer.
     */
    readonly strength: number
    /**
     * The WFD information elements of the P2P peer.
     */
    readonly wfd_ies: GLib.Bytes
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.WifiP2PPeer */
    /**
     * Validates a given connection against a given Wi-Fi P2P peer to ensure that
     * the connection may be activated with that peer. The connection must match the
     * `peer'`s address and in the future possibly other attributes.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Filters a given array of connections for a given #NMWifiP2PPeer object and
     * returns connections which may be activated with the P2P peer.  Any
     * returned connections will match the `peers'`s HW address and in the future
     * possibly other attributes.
     * 
     * To obtain the list of connections that are compatible with this P2P peer,
     * use nm_client_get_connections() and then filter the returned list for a given
     * #NMDevice using nm_device_filter_connections() and finally filter that list
     * with this function.
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the flags of the P2P peer.
     */
    get_flags(): TODO_80211ApFlags
    /**
     * Gets the hardware address of the P2P peer.
     */
    get_hw_address(): string
    /**
     * Returns the timestamp (in CLOCK_BOOTTIME seconds) for the last time the
     * P2P peer was seen.  A value of -1 means the P2P peer has never been seen.
     */
    get_last_seen(): number
    /**
     * Gets the manufacturer of the P2P peer.
     */
    get_manufacturer(): string
    /**
     * Gets the model of the P2P peer.
     */
    get_model(): string
    /**
     * Gets the model number of the P2P peer.
     */
    get_model_number(): string
    /**
     * Gets the name of the P2P peer.
     */
    get_name(): string
    /**
     * Gets the serial number of the P2P peer.
     */
    get_serial(): string
    /**
     * Gets the current signal strength of the P2P peer as a percentage.
     */
    get_strength(): number
    /**
     * Gets the WFD information elements of the P2P peer.
     */
    get_wfd_ies(): GLib.Bytes
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::flags", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::hw-address", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hw-address", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::last-seen", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::last-seen", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::manufacturer", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::manufacturer", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::model", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::model", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::model-number", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::model-number", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::name", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::serial", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::serial", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::strength", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::strength", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::wfd-ies", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::wfd-ies", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: WifiP2PPeer, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: WifiP2PPeer_ConstructProps)
    _init (config?: WifiP2PPeer_ConstructProps): void
    static $gtype: GObject.Type
}
interface WimaxNsp_ConstructProps extends Object_ConstructProps {
}
class WimaxNsp {
    /* Properties of NM-1.0.NM.WimaxNsp */
    /**
     * The name of the WiMAX NSP.
     */
    readonly name: string
    /**
     * The network type of the WiMAX NSP.
     */
    readonly network_type: WimaxNspNetworkType
    /**
     * The signal quality of the WiMAX NSP.
     */
    readonly signal_quality: number
    /* Properties of NM-1.0.NM.Object */
    /**
     * The NMClient instance as returned by nm_object_get_client().
     * 
     * When an NMObject gets removed from the NMClient cache,
     * the NMObject:path property stays unchanged, but this client
     * instance gets reset to %NULL. You can use this property to
     * track removal of the object from the cache.
     */
    readonly client: Client
    /**
     * The D-Bus object path.
     * 
     * The D-Bus path of an object instance never changes, even if the object
     * gets removed from the cache. To see whether the object is still in the
     * cache, check NMObject:client.
     */
    readonly path: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly g_type_instance: GObject.TypeInstance
    /* Methods of NM-1.0.NM.WimaxNsp */
    /**
     * Validates a given connection against a given WiMAX NSP to ensure that the
     * connection may be activated with that NSP.  The connection must match the
     * `nsp'`s network name and other attributes.
     */
    connection_valid(connection: Connection): boolean
    /**
     * Filters a given array of connections for a given #NMWimaxNsp object and
     * return connections which may be activated with the NSP.  Any returned
     * connections will match the `nsp'`s network name and other attributes.
     */
    filter_connections(connections: Connection[]): Connection[]
    /**
     * Gets the name of the wimax NSP
     */
    get_name(): string
    /**
     * Gets the network type of the wimax NSP.
     */
    get_network_type(): WimaxNspNetworkType
    /**
     * Gets the WPA signal quality of the wimax NSP.
     */
    get_signal_quality(): number
    /* Methods of NM-1.0.NM.Object */
    /**
     * Returns the #NMClient instance in which object is cached.
     * Also, if the object got removed from the client cached,
     * this returns %NULL. So it can be used to check whether the
     * object is still alive.
     */
    get_client(): Client
    /**
     * Gets the DBus path of the #NMObject.
     */
    get_path(): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bind_property(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bind_property_full(source_property: string, target: GObject.Object, target_property: string, flags: GObject.BindingFlags, transform_to: Function, transform_from: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    force_floating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freeze_notify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    get_data(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    get_property(property_name: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    get_qdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    is_floating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(property_name: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notify_by_pspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    ref_sink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    run_dispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    set_data(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    set_property(property_name: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    steal_data(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    steal_qdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thaw_notify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watch_closure(closure: Function): void
    /* Virtual methods of GObject-2.0.GObject.Object */
    vfunc_constructed(): void
    vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void
    vfunc_dispose(): void
    vfunc_finalize(): void
    vfunc_get_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    vfunc_notify(pspec: GObject.ParamSpec): void
    vfunc_set_property(property_id: number, value: any, pspec: GObject.ParamSpec): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesnt itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::name", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::network-type", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::network-type", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::signal-quality", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::signal-quality", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::client", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: "notify::path", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::path", callback: (($obj: WimaxNsp, pspec: GObject.ParamSpec) => void)): number
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    static name: string
    constructor (config?: WimaxNsp_ConstructProps)
    _init (config?: WimaxNsp_ConstructProps): void
    static $gtype: GObject.Type
}
abstract class AccessPointClass {
    static name: string
}
abstract class ActiveConnectionClass {
    static name: string
}
class BridgeVlan {
    /* Methods of NM-1.0.NM.BridgeVlan */
    /**
     * Compare two bridge VLAN objects.
     */
    cmp(b: BridgeVlan): number
    /**
     * Gets the VLAN id range.
     */
    get_vid_range(): [ /* returnType */ boolean, /* vid_start */ number, /* vid_end */ number ]
    /**
     * Returns whether the VLAN is the PVID for the port.
     */
    is_pvid(): boolean
    is_sealed(): boolean
    /**
     * Returns whether the VLAN is untagged.
     */
    is_untagged(): boolean
    new_clone(): BridgeVlan
    /**
     * Increases the reference count of the object.
     */
    ref(): BridgeVlan
    /**
     * Seal the #NMBridgeVlan instance. Afterwards, it is a bug
     * to call all functions that modify the instance (except ref/unref).
     * A sealed instance cannot be unsealed again, but you can create
     * an unsealed copy with nm_bridge_vlan_new_clone().
     */
    seal(): void
    /**
     * Change the value of the PVID property of the VLAN. It
     * is invalid to set the value to %TRUE for non-single-id
     * VLANs.
     */
    set_pvid(value: boolean): void
    /**
     * Change the value of the untagged property of the VLAN.
     */
    set_untagged(value: boolean): void
    /**
     * Convert a %NMBridgeVlan to a string.
     */
    to_str(): string
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero the object will be destroyed.
     */
    unref(): void
    static name: string
    static new(vid_start: number, vid_end: number): BridgeVlan
    constructor(vid_start: number, vid_end: number)
    /* Static methods and pseudo-constructors */
    static new(vid_start: number, vid_end: number): BridgeVlan
    /**
     * Parses the string representation of the queueing
     * discipline to a %NMBridgeVlan instance.
     */
    static from_str(str: string): BridgeVlan
}
abstract class CheckpointClass {
    static name: string
}
abstract class ClientClass {
    static name: string
}
abstract class ConnectionInterface {
    /* Fields of NM-1.0.NM.ConnectionInterface */
    /**
     * the parent interface struct
     */
    readonly parent: GObject.TypeInterface
    readonly secrets_updated: (connection: Connection, setting: string) => void
    readonly secrets_cleared: (connection: Connection) => void
    readonly changed: (connection: Connection) => void
    static name: string
}
abstract class Device6LowpanClass {
    static name: string
}
abstract class DeviceAdslClass {
    static name: string
}
abstract class DeviceBondClass {
    static name: string
}
abstract class DeviceBridgeClass {
    static name: string
}
abstract class DeviceBtClass {
    static name: string
}
abstract class DeviceClass {
    static name: string
}
abstract class DeviceDummyClass {
    static name: string
}
abstract class DeviceEthernetClass {
    static name: string
}
abstract class DeviceGenericClass {
    static name: string
}
abstract class DeviceIPTunnelClass {
    static name: string
}
abstract class DeviceInfinibandClass {
    static name: string
}
abstract class DeviceMacsecClass {
    static name: string
}
abstract class DeviceMacvlanClass {
    static name: string
}
abstract class DeviceModemClass {
    static name: string
}
abstract class DeviceOlpcMeshClass {
    static name: string
}
abstract class DeviceOvsBridgeClass {
    static name: string
}
abstract class DeviceOvsInterfaceClass {
    static name: string
}
abstract class DeviceOvsPortClass {
    static name: string
}
abstract class DevicePppClass {
    static name: string
}
abstract class DeviceTeamClass {
    static name: string
}
abstract class DeviceTunClass {
    static name: string
}
abstract class DeviceVethClass {
    static name: string
}
abstract class DeviceVlanClass {
    static name: string
}
abstract class DeviceVrfClass {
    static name: string
}
abstract class DeviceVxlanClass {
    static name: string
}
abstract class DeviceWifiClass {
    static name: string
}
abstract class DeviceWifiP2PClass {
    static name: string
}
abstract class DeviceWimaxClass {
    static name: string
}
abstract class DeviceWireGuardClass {
    static name: string
}
abstract class DeviceWpanClass {
    static name: string
}
abstract class DhcpConfigClass {
    static name: string
}
class DnsEntry {
    /* Methods of NM-1.0.NM.DnsEntry */
    /**
     * Gets the list of DNS domains.
     */
    get_domains(): string[]
    /**
     * Gets the interface on which name servers are contacted.
     */
    get_interface(): string
    /**
     * Gets the list of name servers for this entry.
     */
    get_nameservers(): string[]
    /**
     * Gets the priority of the entry
     */
    get_priority(): number
    /**
     * Gets whether the entry refers to VPN name servers.
     */
    get_vpn(): boolean
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
}
class IPAddress {
    /* Methods of NM-1.0.NM.IPAddress */
    /**
     * Note that with `cmp_flags` #NM_IP_ADDRESS_CMP_FLAGS_WITH_ATTRS, there
     * is no total order for comparing GVariant. That means, if the two addresses
     * only differ by their attributes, the sort order is undefined and the return
     * value only indicates equality.
     */
    cmp_full(b: IPAddress, cmp_flags: IPAddressCmpFlags): number
    /**
     * Creates a copy of `address`
     */
    dup(): IPAddress
    /**
     * Determines if two #NMIPAddress objects contain the same address and prefix
     * (attributes are not compared).
     */
    equal(other: IPAddress): boolean
    /**
     * Gets the IP address property of this address object.
     */
    get_address(): string
    /**
     * Gets the value of the attribute with name `name` on `address`
     */
    get_attribute(name: string): GLib.Variant
    /**
     * Gets an array of attribute names defined on `address`.
     */
    get_attribute_names(): string[]
    /**
     * Gets the IP address family (eg, AF_INET) property of this address
     * object.
     */
    get_family(): number
    /**
     * Gets the IP address prefix (ie "24" or "30" etc) property of this address
     * object.
     */
    get_prefix(): number
    /**
     * Increases the reference count of the object.
     */
    ref(): void
    /**
     * Sets the IP address property of this address object.
     * 
     * `addr` must be a valid address of `address'`s family. If you aren't sure you
     * have a valid address, use nm_utils_ipaddr_valid() to check it.
     */
    set_address(addr: string): void
    /**
     * Sets or clears the named attribute on `address` to the given value.
     */
    set_attribute(name: string, value?: GLib.Variant | null): void
    /**
     * Sets the IP address prefix property of this address object.
     */
    set_prefix(prefix: number): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
    static new(family: number, addr: string, prefix: number): IPAddress
    constructor(family: number, addr: string, prefix: number)
    /* Static methods and pseudo-constructors */
    static new(family: number, addr: string, prefix: number): IPAddress
    static new_binary(family: number, addr: object | null, prefix: number): IPAddress
}
abstract class IPConfigClass {
    static name: string
}
class IPRoute {
    /* Methods of NM-1.0.NM.IPRoute */
    /**
     * Creates a copy of `route`
     */
    dup(): IPRoute
    /**
     * Determines if two #NMIPRoute objects contain the same destination, prefix,
     * next hop, and metric. (Attributes are not compared.)
     */
    equal(other: IPRoute): boolean
    /**
     * Determines if two #NMIPRoute objects contain the same destination, prefix,
     * next hop, and metric.
     */
    equal_full(other: IPRoute, cmp_flags: number): boolean
    /**
     * Gets the value of the attribute with name `name` on `route`
     */
    get_attribute(name: string): GLib.Variant
    /**
     * Gets an array of attribute names defined on `route`.
     */
    get_attribute_names(): string[]
    /**
     * Gets the IP destination address property of this route object.
     */
    get_dest(): string
    /**
     * Gets the IP address family (eg, AF_INET) property of this route
     * object.
     */
    get_family(): number
    /**
     * Gets the route metric property of this route object; lower values
     * indicate "better" or more preferred routes; -1 indicates "default"
     * (meaning NetworkManager will set it appropriately).
     */
    get_metric(): number
    /**
     * Gets the IP address of the next hop of this route; this will be %NULL if the
     * route has no next hop.
     */
    get_next_hop(): string
    /**
     * Gets the IP prefix (ie "24" or "30" etc) of this route.
     */
    get_prefix(): number
    /**
     * Increases the reference count of the object.
     */
    ref(): void
    /**
     * Sets the named attribute on `route` to the given value.
     */
    set_attribute(name: string, value?: GLib.Variant | null): void
    /**
     * Sets the destination property of this route object.
     * 
     * `dest` must be a valid address of `route'`s family. If you aren't sure you
     * have a valid address, use nm_utils_ipaddr_is_valid() to check it.
     */
    set_dest(dest: string): void
    /**
     * Sets the metric property of this route object.
     */
    set_metric(metric: number): void
    /**
     * Sets the next-hop property of this route object.
     * 
     * `next_hop` (if non-%NULL) must be a valid address of `route'`s family. If you
     * aren't sure you have a valid address, use nm_utils_ipaddr_valid() to check
     * it.
     */
    set_next_hop(next_hop?: string | null): void
    /**
     * Sets the prefix property of this route object.
     */
    set_prefix(prefix: number): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
    static new(family: number, dest: string, prefix: number, next_hop: string | null, metric: number): IPRoute
    constructor(family: number, dest: string, prefix: number, next_hop: string | null, metric: number)
    /* Static methods and pseudo-constructors */
    static new(family: number, dest: string, prefix: number, next_hop: string | null, metric: number): IPRoute
    static new_binary(family: number, dest: object | null, prefix: number, next_hop: object | null, metric: number): IPRoute
    /**
     * Validates a route attribute, i.e. checks that the attribute is a known one
     * and the value is of the correct type and well-formed.
     */
    static attribute_validate(name: string, value: GLib.Variant, family: number): [ /* returnType */ boolean, /* known */ boolean ]
    static get_variant_attribute_spec(): VariantAttributeSpec
}
class IPRoutingRule {
    /* Methods of NM-1.0.NM.IPRoutingRule */
    cmp(other?: IPRoutingRule | null): number
    get_action(): number
    get_addr_family(): number
    get_destination_port_end(): number
    get_destination_port_start(): number
    get_from(): string
    get_from_len(): number
    get_fwmark(): number
    get_fwmask(): number
    get_iifname(): string
    get_invert(): boolean
    get_ipproto(): number
    get_oifname(): string
    get_priority(): number
    get_source_port_end(): number
    get_source_port_start(): number
    get_suppress_prefixlength(): number
    get_table(): number
    get_to(): string
    get_to_len(): number
    get_tos(): number
    get_uid_range(): [ /* returnType */ boolean, /* out_range_start */ number | null, /* out_range_end */ number | null ]
    is_sealed(): boolean
    new_clone(): IPRoutingRule
    /**
     * Increases the reference count of the instance.
     * This is not thread-safe.
     */
    ref(): IPRoutingRule
    /**
     * Seals the routing rule. Afterwards, the instance can no longer be
     * modified, and it is a bug to call any of the accessors that would
     * modify the rule. If `self` was already sealed, this has no effect.
     */
    seal(): void
    /**
     * Note that currently only certain actions are allowed. nm_ip_routing_rule_validate()
     * will reject unsupported actions as invalid.
     */
    set_action(action: number): void
    set_destination_port(start: number, end: number): void
    /**
     * Setting invalid values is accepted, but will later fail
     * during nm_ip_routing_rule_validate().
     */
    set_from(from: string | null, len: number): void
    set_fwmark(fwmark: number, fwmask: number): void
    /**
     * The name supports C backslash escaping for non-UTF-8 characters.
     * Note that nm_ip_routing_rule_from_string() too uses backslash
     * escaping when tokenizing the words by whitespace. So, in string
     * representation you'd get double backslashes.
     */
    set_iifname(iifname?: string | null): void
    set_invert(invert: boolean): void
    set_ipproto(ipproto: number): void
    /**
     * The name supports C backslash escaping for non-UTF-8 characters.
     * Note that nm_ip_routing_rule_from_string() too uses backslash
     * escaping when tokenizing the words by whitespace. So, in string
     * representation you'd get double backslashes.
     */
    set_oifname(oifname?: string | null): void
    /**
     * A valid priority ranges from 0 to %G_MAXUINT32. "-1" is also allowed
     * to reset the priority. It is a bug calling this function with any
     * other value.
     */
    set_priority(priority: number): void
    set_source_port(start: number, end: number): void
    set_suppress_prefixlength(suppress_prefixlength: number): void
    set_table(table: number): void
    /**
     * Setting invalid values is accepted, but will later fail
     * during nm_ip_routing_rule_validate().
     */
    set_to(to: string | null, len: number): void
    set_tos(tos: number): void
    /**
     * For a valid range, start must be less or equal to end.
     * If set to an invalid range, the range gets unset.
     */
    set_uid_range(uid_range_start: number, uid_range_end: number): void
    to_string(to_string_flags: IPRoutingRuleAsStringFlags, extra_args?: GLib.HashTable | null): string
    /**
     * Decreases the reference count of the instance and destroys
     * the instance if the reference count reaches zero.
     * This is not thread-safe.
     */
    unref(): void
    validate(): boolean
    static name: string
    static new(addr_family: number): IPRoutingRule
    constructor(addr_family: number)
    /* Static methods and pseudo-constructors */
    static new(addr_family: number): IPRoutingRule
    static from_string(str: string, to_string_flags: IPRoutingRuleAsStringFlags, extra_args?: GLib.HashTable | null): IPRoutingRule
}
class KeyfileHandlerData {
    /* Methods of NM-1.0.NM.KeyfileHandlerData */
    /**
     * Set the error for the handler. This lets the operation fail
     * with the provided error. You may only set the error once.
     * 
     * `src` must be non-%NULL.
     * 
     * Note that `src` is no longer valid after this call. If you want
     * to keep using the same GError*, you need to set it to %NULL
     * after calling this function on it.
     */
    fail_with_error(src: GLib.Error): void
    /**
     * Get context information of the current event. This function can be called
     * on all events, but the context information may be unset.
     */
    get_context(): [ /* out_kf_group_name */ string | null, /* out_kf_key_name */ string | null, /* out_cur_setting */ Setting | null, /* out_cur_property_name */ string | null ]
    warn_get(): [ /* out_message */ string | null, /* out_severity */ KeyfileWarnSeverity | null ]
    static name: string
}
class LldpNeighbor {
    /* Methods of NM-1.0.NM.LldpNeighbor */
    /**
     * Gets an array of attribute names available for `neighbor`.
     */
    get_attr_names(): string[]
    /**
     * Gets the string value of attribute with name `name` on `neighbor`
     */
    get_attr_string_value(name: string): [ /* returnType */ boolean, /* out_value */ string | null ]
    /**
     * Get the type of an attribute.
     */
    get_attr_type(name: string): GLib.VariantType
    /**
     * Gets the uint32 value of attribute with name `name` on `neighbor`
     */
    get_attr_uint_value(name: string): [ /* returnType */ boolean, /* out_value */ number | null ]
    /**
     * Gets the value (as a GVariant) of attribute with name `name` on `neighbor`
     */
    get_attr_value(name: string): GLib.Variant
    /**
     * Increases the reference count of the object.
     * 
     * Since 1.32, ref-counting of #NMLldpNeighbor is thread-safe.
     */
    ref(): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     * 
     * Since 1.32, ref-counting of #NMLldpNeighbor is thread-safe.
     */
    unref(): void
    static name: string
    static new(): LldpNeighbor
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): LldpNeighbor
}
abstract class ObjectClass {
    static name: string
}
abstract class RemoteConnectionClass {
    static name: string
}
abstract class SecretAgentOldClass {
    /* Fields of NM-1.0.NM.SecretAgentOldClass */
    readonly parent: GObject.ObjectClass
    readonly get_secrets: (self: SecretAgentOld, connection: Connection, connection_path: string, setting_name: string, hints: string[], flags: SecretAgentGetSecretsFlags, callback: SecretAgentOldGetSecretsFunc) => void
    readonly cancel_get_secrets: (self: SecretAgentOld, connection_path: string, setting_name: string) => void
    readonly save_secrets: (self: SecretAgentOld, connection: Connection, connection_path: string, callback: SecretAgentOldSaveSecretsFunc) => void
    readonly delete_secrets: (self: SecretAgentOld, connection: Connection, connection_path: string, callback: SecretAgentOldDeleteSecretsFunc) => void
    static name: string
}
abstract class Setting6LowpanClass {
    static name: string
}
abstract class Setting8021xClass {
    static name: string
}
abstract class SettingAdslClass {
    static name: string
}
abstract class SettingBluetoothClass {
    static name: string
}
abstract class SettingBondClass {
    static name: string
}
abstract class SettingBondPortClass {
    static name: string
}
abstract class SettingBridgeClass {
    static name: string
}
abstract class SettingBridgePortClass {
    static name: string
}
abstract class SettingCdmaClass {
    static name: string
}
abstract class SettingClass {
    static name: string
}
abstract class SettingConnectionClass {
    static name: string
}
abstract class SettingDcbClass {
    static name: string
}
abstract class SettingDummyClass {
    static name: string
}
abstract class SettingEthtoolClass {
    static name: string
}
abstract class SettingGenericClass {
    static name: string
}
abstract class SettingGsmClass {
    static name: string
}
abstract class SettingHostnameClass {
    static name: string
}
abstract class SettingIP4ConfigClass {
    static name: string
}
abstract class SettingIP6ConfigClass {
    static name: string
}
abstract class SettingIPConfigClass {
    static name: string
}
abstract class SettingIPTunnelClass {
    static name: string
}
abstract class SettingInfinibandClass {
    static name: string
}
abstract class SettingMacsecClass {
    static name: string
}
abstract class SettingMacvlanClass {
    static name: string
}
abstract class SettingMatchClass {
    static name: string
}
abstract class SettingOlpcMeshClass {
    static name: string
}
abstract class SettingOvsBridgeClass {
    static name: string
}
abstract class SettingOvsDpdkClass {
    static name: string
}
abstract class SettingOvsExternalIDsClass {
    static name: string
}
abstract class SettingOvsInterfaceClass {
    static name: string
}
abstract class SettingOvsPatchClass {
    static name: string
}
abstract class SettingOvsPortClass {
    static name: string
}
abstract class SettingPppClass {
    static name: string
}
abstract class SettingPppoeClass {
    static name: string
}
abstract class SettingProxyClass {
    static name: string
}
abstract class SettingSerialClass {
    static name: string
}
abstract class SettingSriovClass {
    static name: string
}
abstract class SettingTCConfigClass {
    static name: string
}
abstract class SettingTeamClass {
    static name: string
}
abstract class SettingTeamPortClass {
    static name: string
}
abstract class SettingTunClass {
    static name: string
}
abstract class SettingUserClass {
    static name: string
}
abstract class SettingVethClass {
    static name: string
}
abstract class SettingVlanClass {
    static name: string
}
abstract class SettingVpnClass {
    static name: string
}
abstract class SettingVrfClass {
    static name: string
}
abstract class SettingVxlanClass {
    static name: string
}
abstract class SettingWifiP2PClass {
    static name: string
}
abstract class SettingWimaxClass {
    static name: string
}
abstract class SettingWireGuardClass {
    static name: string
}
abstract class SettingWiredClass {
    static name: string
}
abstract class SettingWirelessClass {
    static name: string
}
abstract class SettingWirelessSecurityClass {
    static name: string
}
abstract class SettingWpanClass {
    static name: string
}
abstract class SimpleConnectionClass {
    static name: string
}
class SriovVF {
    /* Methods of NM-1.0.NM.SriovVF */
    /**
     * Adds a VLAN to the VF. Currently kernel only supports one VLAN per VF.
     */
    add_vlan(vlan_id: number): boolean
    /**
     * Creates a copy of `vf`.
     */
    dup(): SriovVF
    /**
     * Determines if two #NMSriovVF objects have the same index,
     * attributes and VLANs.
     */
    equal(other: SriovVF): boolean
    /**
     * Gets the value of the attribute with name `name` on `vf`
     */
    get_attribute(name: string): GLib.Variant
    /**
     * Gets an array of attribute names defined on `vf`.
     */
    get_attribute_names(): string[]
    /**
     * Gets the index property of this VF object.
     */
    get_index(): number
    /**
     * Returns the VLANs currently configured on the VF. Currently kernel only
     * supports one VLAN per VF.
     */
    get_vlan_ids(): number[]
    get_vlan_protocol(vlan_id: number): SriovVFVlanProtocol
    /**
     * Returns the QoS value for the given VLAN.
     */
    get_vlan_qos(vlan_id: number): number
    /**
     * Increases the reference count of the object.
     */
    ref(): void
    /**
     * Removes a VLAN from a VF.
     */
    remove_vlan(vlan_id: number): boolean
    /**
     * Sets the named attribute on `vf` to the given value.
     */
    set_attribute(name: string, value?: GLib.Variant | null): void
    /**
     * Sets the protocol for the given VLAN.
     */
    set_vlan_protocol(vlan_id: number, protocol: SriovVFVlanProtocol): void
    /**
     * Sets a QoS value for the given VLAN.
     */
    set_vlan_qos(vlan_id: number, qos: number): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
    static new(index: number): SriovVF
    constructor(index: number)
    /* Static methods and pseudo-constructors */
    static new(index: number): SriovVF
    /**
     * Validates a VF attribute, i.e. checks that the attribute is a known one,
     * the value is of the correct type and well-formed.
     */
    static attribute_validate(name: string, value: GLib.Variant): [ /* returnType */ boolean, /* known */ boolean ]
}
class TCAction {
    /* Methods of NM-1.0.NM.TCAction */
    /**
     * Creates a copy of `action`
     */
    dup(): TCAction
    /**
     * Determines if two #NMTCAction objects contain the same kind, family,
     * handle, parent and info.
     */
    equal(other: TCAction): boolean
    /**
     * Gets the value of the attribute with name `name` on `action`
     */
    get_attribute(name: string): GLib.Variant
    /**
     * Gets an array of attribute names defined on `action`.
     */
    get_attribute_names(): string[]
    get_kind(): string
    /**
     * Increases the reference count of the object.
     */
    ref(): void
    /**
     * Sets or clears the named attribute on `action` to the given value.
     */
    set_attribute(name: string, value?: GLib.Variant | null): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
    static new(kind: string): TCAction
    constructor(kind: string)
    /* Static methods and pseudo-constructors */
    static new(kind: string): TCAction
}
class TCQdisc {
    /* Methods of NM-1.0.NM.TCQdisc */
    /**
     * Creates a copy of `qdisc`
     */
    dup(): TCQdisc
    /**
     * Determines if two #NMTCQdisc objects contain the same kind, * handle
     * and parent.
     */
    equal(other: TCQdisc): boolean
    /**
     * Gets the value of the attribute with name `name` on `qdisc`
     */
    get_attribute(name: string): GLib.Variant
    /**
     * Gets an array of attribute names defined on `qdisc`.
     */
    get_attribute_names(): string[]
    get_handle(): number
    get_kind(): string
    get_parent(): number
    /**
     * Increases the reference count of the object.
     */
    ref(): void
    /**
     * Sets or clears the named attribute on `qdisc` to the given value.
     */
    set_attribute(name: string, value?: GLib.Variant | null): void
    /**
     * Sets the queueing discipline handle.
     */
    set_handle(handle: number): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
    static new(kind: string, parent: number): TCQdisc
    constructor(kind: string, parent: number)
    /* Static methods and pseudo-constructors */
    static new(kind: string, parent: number): TCQdisc
}
class TCTfilter {
    /* Methods of NM-1.0.NM.TCTfilter */
    /**
     * Creates a copy of `tfilter`
     */
    dup(): TCTfilter
    /**
     * Determines if two #NMTCTfilter objects contain the same kind, family,
     * handle, parent and info.
     */
    equal(other: TCTfilter): boolean
    get_action(): TCAction
    get_handle(): number
    get_kind(): string
    get_parent(): number
    /**
     * Increases the reference count of the object.
     */
    ref(): void
    /**
     * Sets the action associated with a traffic filter.
     */
    set_action(action: TCAction): void
    /**
     * Sets the queueing discipline handle.
     */
    set_handle(handle: number): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
    static new(kind: string, parent: number): TCTfilter
    constructor(kind: string, parent: number)
    /* Static methods and pseudo-constructors */
    static new(kind: string, parent: number): TCTfilter
}
class TeamLinkWatcher {
    /* Methods of NM-1.0.NM.TeamLinkWatcher */
    /**
     * Creates a copy of `watcher`
     */
    dup(): TeamLinkWatcher
    /**
     * Determines if two #NMTeamLinkWatcher objects contain the same values
     * in all the properties.
     */
    equal(other: TeamLinkWatcher): boolean
    /**
     * Gets the delay_down interval (in milliseconds) that elapses between the link
     * going down and the runner being notified about it.
     */
    get_delay_down(): number
    /**
     * Gets the delay_up interval (in milliseconds) that elapses between the link
     * coming up and the runner being notified about it.
     */
    get_delay_up(): number
    /**
     * Gets the arp ping watcher flags.
     */
    get_flags(): TeamLinkWatcherArpPingFlags
    /**
     * Gets the init_wait interval (in milliseconds) that the team slave should
     * wait before sending the first packet to the target host.
     */
    get_init_wait(): number
    /**
     * Gets the interval (in milliseconds) that the team slave should wait between
     * sending two check packets to the target host.
     */
    get_interval(): number
    /**
     * Gets the number of missed replies after which the link is considered down.
     */
    get_missed_max(): number
    /**
     * Gets the name of the link watcher to be used.
     */
    get_name(): string
    /**
     * Gets the ip address to be used as source for the link probing packets.
     */
    get_source_host(): string
    /**
     * Gets the host name/ip address to be used as destination for the link probing
     * packets.
     */
    get_target_host(): string
    /**
     * Gets the VLAN tag ID to be used to outgoing link probes
     */
    get_vlanid(): number
    /**
     * Increases the reference count of the object.
     */
    ref(): void
    /**
     * Decreases the reference count of the object.  If the reference count
     * reaches zero, the object will be destroyed.
     */
    unref(): void
    static name: string
    /* Static methods and pseudo-constructors */
    static new_arp_ping(init_wait: number, interval: number, missed_max: number, target_host: string, source_host: string, flags: TeamLinkWatcherArpPingFlags): TeamLinkWatcher
    static new_arp_ping2(init_wait: number, interval: number, missed_max: number, vlanid: number, target_host: string, source_host: string, flags: TeamLinkWatcherArpPingFlags): TeamLinkWatcher
    static new_ethtool(delay_up: number, delay_down: number): TeamLinkWatcher
    static new_nsna_ping(init_wait: number, interval: number, missed_max: number, target_host: string): TeamLinkWatcher
}
class VariantAttributeSpec {
    static name: string
}
abstract class VpnConnectionClass {
    static name: string
}
abstract class VpnEditorInterface {
    /* Fields of NM-1.0.NM.VpnEditorInterface */
    /**
     * the parent interface
     */
    readonly g_iface: GObject.TypeInterface
    readonly get_widget: (editor: VpnEditor) => GObject.Object
    readonly placeholder: () => void
    readonly update_connection: (editor: VpnEditor, connection: Connection) => boolean
    readonly changed: (editor: VpnEditor) => void
    static name: string
}
abstract class VpnEditorPluginInterface {
    /* Fields of NM-1.0.NM.VpnEditorPluginInterface */
    /**
     * the parent interface
     */
    readonly g_iface: GObject.TypeInterface
    readonly get_editor: (plugin: VpnEditorPlugin, connection: Connection) => VpnEditor
    readonly get_capabilities: (plugin: VpnEditorPlugin) => VpnEditorPluginCapability
    readonly export_to_file: (plugin: VpnEditorPlugin, path: string, connection: Connection) => boolean
    readonly get_suggested_filename: (plugin: VpnEditorPlugin, connection: Connection) => string
    readonly notify_plugin_info_set: (plugin: VpnEditorPlugin, plugin_info: VpnPluginInfo) => void
    readonly get_vt: (plugin: VpnEditorPlugin, out_vt_size: number) => VpnEditorPluginVT
    static name: string
}
class VpnEditorPluginVT {
    static name: string
}
abstract class VpnPluginInfoClass {
    static name: string
}
abstract class VpnPluginOldClass {
    /* Fields of NM-1.0.NM.VpnPluginOldClass */
    readonly parent: GObject.ObjectClass
    readonly state_changed: (plugin: VpnPluginOld, state: VpnServiceState) => void
    readonly ip4_config: (plugin: VpnPluginOld, ip4_config: GLib.Variant) => void
    readonly login_banner: (plugin: VpnPluginOld, banner: string) => void
    readonly failure: (plugin: VpnPluginOld, reason: VpnPluginFailure) => void
    readonly quit: (plugin: VpnPluginOld) => void
    readonly config: (plugin: VpnPluginOld, config: GLib.Variant) => void
    readonly ip6_config: (plugin: VpnPluginOld, config: GLib.Variant) => void
    readonly connect: (plugin: VpnPluginOld, connection: Connection) => boolean
    readonly need_secrets: (plugin: VpnPluginOld, connection: Connection, setting_name: string) => boolean
    readonly disconnect: (plugin: VpnPluginOld) => boolean
    readonly new_secrets: (plugin: VpnPluginOld, connection: Connection) => boolean
    readonly connect_interactive: (plugin: VpnPluginOld, connection: Connection, details: GLib.Variant) => boolean
    static name: string
}
abstract class VpnServicePluginClass {
    /* Fields of NM-1.0.NM.VpnServicePluginClass */
    readonly parent: GObject.ObjectClass
    readonly state_changed: (plugin: VpnServicePlugin, state: VpnServiceState) => void
    readonly ip4_config: (plugin: VpnServicePlugin, ip4_config: GLib.Variant) => void
    readonly login_banner: (plugin: VpnServicePlugin, banner: string) => void
    readonly failure: (plugin: VpnServicePlugin, reason: VpnPluginFailure) => void
    readonly quit: (plugin: VpnServicePlugin) => void
    readonly config: (plugin: VpnServicePlugin, config: GLib.Variant) => void
    readonly ip6_config: (plugin: VpnServicePlugin, config: GLib.Variant) => void
    readonly connect: (plugin: VpnServicePlugin, connection: Connection) => boolean
    readonly need_secrets: (plugin: VpnServicePlugin, connection: Connection, setting_name: string) => boolean
    readonly disconnect: (plugin: VpnServicePlugin) => boolean
    readonly new_secrets: (plugin: VpnServicePlugin, connection: Connection) => boolean
    readonly connect_interactive: (plugin: VpnServicePlugin, connection: Connection, details: GLib.Variant) => boolean
    static name: string
}
abstract class WifiP2PPeerClass {
    static name: string
}
abstract class WimaxNspClass {
    static name: string
}
class WireGuardPeer {
    /* Methods of NM-1.0.NM.WireGuardPeer */
    /**
     * Appends `allowed_ip` setting to the list. This does not check
     * for duplicates and always appends `allowed_ip` to the end of the
     * list. If `allowed_ip` is valid, it will be normalized and a modified
     * for might be appended. If `allowed_ip` is invalid, it will still be
     * appended, but later verification will fail.
     * 
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    append_allowed_ip(allowed_ip: string, accept_invalid: boolean): boolean
    /**
     * Removes all allowed-ip entries.
     * 
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    clear_allowed_ips(): void
    cmp(b: WireGuardPeer | null, compare_flags: SettingCompareFlags): number
    get_allowed_ip(idx: number, out_is_valid?: boolean | null): string
    get_allowed_ips_len(): number
    get_endpoint(): string
    get_persistent_keepalive(): number
    get_preshared_key(): string
    get_preshared_key_flags(): SettingSecretFlags
    get_public_key(): string
    is_sealed(): boolean
    is_valid(check_non_secrets: boolean, check_secrets: boolean): boolean
    new_clone(with_secrets: boolean): WireGuardPeer
    /**
     * This is not thread-safe.
     */
    ref(): WireGuardPeer
    /**
     * Removes the allowed-ip at the given `idx`. This shifts all
     * following entries one index down.
     * 
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    remove_allowed_ip(idx: number): boolean
    /**
     * Seal the #NMWireGuardPeer instance. Afterwards, it is a bug
     * to call all functions that modify the instance (except ref/unref).
     * A sealed instance cannot be unsealed again, but you can create
     * an unsealed copy with nm_wireguard_peer_new_clone().
     */
    seal(): void
    /**
     * Sets or clears the endpoint of `self`.
     * 
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    set_endpoint(endpoint: string, allow_invalid: boolean): boolean
    /**
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    set_persistent_keepalive(persistent_keepalive: number): void
    /**
     * Reset the preshared key. Note that if the preshared key is valid, it
     * will be normalized (which may or may not modify the set value).
     * 
     * Note that the preshared-key is a secret and consequently has corresponding
     * preshared-key-flags property. This is so that secrets can be optional
     * and requested on demand from a secret-agent. Also, an invalid  preshared-key
     * may optionally cause nm_wireguard_peer_is_valid() to fail or it may
     * be accepted.
     * 
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    set_preshared_key(preshared_key: string | null, accept_invalid: boolean): boolean
    /**
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    set_preshared_key_flags(preshared_key_flags: SettingSecretFlags): void
    /**
     * Reset the public key. Note that if the public key is valid, it
     * will be normalized (which may or may not modify the set value).
     * 
     * It is a bug trying to modify a sealed #NMWireGuardPeer instance.
     */
    set_public_key(public_key: string | null, accept_invalid: boolean): boolean
    /**
     * Drop a reference to `self`. If the last reference is dropped,
     * the instance is freed and all associate data released.
     * 
     * This is not thread-safe.
     */
    unref(): void
    static name: string
    static new(): WireGuardPeer
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): WireGuardPeer
}
}
export default NM;